<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Python 循环语句</title>
      <link href="/2025/10/27/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/"/>
      <url>/2025/10/27/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-循环语句"><a href="#Python-循环语句" class="headerlink" title="Python 循环语句"></a>Python 循环语句</h1><p>在前面的学习中，我们写的代码大多是一行接一行地顺序执行，就像我们一步一步地走路一样，做完一件事再做下一件</p><p>但是，如果我们需要做很多重复的事情，比如打印 100 遍 “Hello World”，或者计算 1 到 100 的总和，难道我们要把相同的代码写 100 遍吗？那会非常的麻烦！</p><p>但是，别担心，编程之所以强大，就是因为它能让计算机帮我们做重复的工作。<strong>循环语句</strong>就是实现这种重复的魔法</p><h2 id="什么是循环？"><a href="#什么是循环？" class="headerlink" title="什么是循环？"></a>什么是循环？</h2><p>简单说，<strong>循环就是让一部分代码按照我们设定的条件，重复执行多次的结构</strong>。</p><p>你可以这么设想：</p><ul><li>你想打印 5 遍 “我爱 Python！”。如果没有循环，你可能需要写 5 行 <code>print(&quot;我爱 Python！&quot;)</code>。有了循环，几句话就能搞定</li><li>游戏里角色的移动、敌人的刷新，背后都离不开循环的控制。</li></ul><h2 id="循环是如何工作的？"><a href="#循环是如何工作的？" class="headerlink" title="循环是如何工作的？"></a>循环是如何工作的？</h2><p>我们可以把循环看成一个<strong>检查点</strong>和一个<strong>执行区</strong>：</p><ol><li><strong>来到检查点</strong>：看看现在是不是该执行<strong>执行区</strong>里的代码。</li><li><strong>如果条件允许</strong>，比如：我还没打印够 5 遍，就进入<strong>执行区</strong>执行代码。</li><li><strong>执行完一次后</strong>，再次回到<strong>检查点</strong>。</li><li><strong>如果条件不允许了</strong>，比如：我已经打印够 5 遍了，就离开循环，继续执行循环后面的代码</li></ol><p>下面是一个简单的程序框图，展示了循环的一般工作流程：</p><div style="text-align:center">  <img src="/img_2/mermaid-1761627690264.png" alt="程序框图" style="width:50%;"></div><h2 id="Python-中的循环类型"><a href="#Python-中的循环类型" class="headerlink" title="Python 中的循环类型"></a>Python 中的循环类型</h2><p>Python 主要提供了两种类型的循环语句，让我们能应对不同的重复场景：</p><h3 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. <code>while</code> 循环</h3><ul><li><strong>特点</strong>：<strong>只要给定的条件为真（True），就会一直重复执行循环体里的代码</strong>。</li><li><strong>就像</strong>：“只要天还没黑，我就继续玩。” 这里“天还没黑”就是条件，“继续玩”就是循环体。</li></ul><h3 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a>2. <code>for</code> 循环</h3><ul><li><strong>特点</strong>：<strong>通常用于遍历序列中的每个元素，就比如列表和字符串，或者执行固定次数的循环</strong>。</li><li><strong>就像</strong>：“我有一个水果篮子，里面有苹果、香蕉、橘子，我要把它们一个一个拿出来吃掉。” 这里“水果篮子”就是一个序列，“一个一个拿出来吃掉”就是循环体。</li></ul><h3 id="3-嵌套循环"><a href="#3-嵌套循环" class="headerlink" title="3. 嵌套循环"></a>3. 嵌套循环</h3><ul><li><strong>特点</strong>：<strong>在一个循环的内部，再放一个循环</strong>。这就像俄罗斯套娃一样。</li><li><strong>用途</strong>：处理更复杂的重复任务，比如打印一个矩阵</li></ul><h2 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h2><p>有时候，我们不希望循环严格按照条件判断 -&gt; 执行的固定流程走。比如，我们可能想提前结束整个循环，或者跳过当前这次循环剩下的部分，直接开始下一次</p><p>Python 提供了几种<strong>循环控制语句</strong>来帮助我们更灵活地控制循环：</p><h3 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1. break 语句"></a>1. <code>break</code> 语句</h3><ul><li><strong>作用</strong>：<strong>立即终止当前的整个循环，并且跳出循环体，不再执行后续的循环迭代</strong>。</li><li><strong>就像</strong>：你在看书，突然电话响了，你不得不立刻停止看书，不管看到第几页，去接电话。</li></ul><h3 id="2-continue-语句"><a href="#2-continue-语句" class="headerlink" title="2. continue 语句"></a>2. <code>continue</code> 语句</h3><ul><li><strong>作用</strong>：<strong>立即终止当前这一次的循环迭代，跳过循环体中 <code>continue</code> 后面剩余的语句，直接进入下一次循环的条件判断</strong>。</li><li><strong>就像</strong>：你在吃一串葡萄，吃到一颗特别酸的，你会把这颗吐掉，然后继续吃下一颗，而不是把整串葡萄都扔了。</li></ul><h3 id="3-pass-语句"><a href="#3-pass-语句" class="headerlink" title="3. pass 语句"></a>3. <code>pass</code> 语句</h3><ul><li><strong>作用</strong>：**<code>pass</code> 是一个空语句，它什么也不做**。主要是为了在语法上需要一条语句，但我们暂时不想写具体代码的时候使用，用来保持程序结构的完整性。</li><li><strong>就像</strong>：你在日程本上写下“明天要学习循环”，但具体怎么学还没想好，先记下来占个位置。</li></ul><hr><p>好了，到这里，相信你已经对 Python 循环有了一个基本的概念性了解。接下来的内容，我会详细学习每一种循环和控制语句的具体用法</p><h2 id="Python-While-循环语句"><a href="#Python-While-循环语句" class="headerlink" title="Python While 循环语句"></a>Python While 循环语句</h2><p><code>while</code> 循环是 Python 中最简单也是最常用的循环类型之一。它的核心思想非常朴素：</p><p><strong>只要一个给定的条件成立（为真），就不断重复执行一段代码（循环体）。一旦条件不成立（为假），就停止循环，继续执行循环后面的代码。</strong></p><h3 id="1-1-while-循环的基本结构"><a href="#1-1-while-循环的基本结构" class="headerlink" title="1.1 while 循环的基本结构"></a>1.1 <code>while</code> 循环的基本结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    循环体语句 (当条件为 <span class="literal">True</span> 时执行)</span><br><span class="line">    ... (可以有多行语句)</span><br><span class="line"><span class="comment"># 循环结束后，执行这里的代码</span></span><br></pre></td></tr></table></figure><ul><li>**<code>while</code>**：这是 Python 的关键字，告诉 Python 接下来是一个 <code>while</code> 循环。</li><li><strong>条件表达式</strong>：一个会被计算为 <code>True</code> 或 <code>False</code> 的表达式。就像一个守门人，决定循环是否继续。</li><li>**冒号 <code>:</code>**：表示条件表达式的结束，以及循环体的开始。</li><li><strong>循环体语句</strong>：这部分是当条件为 <code>True</code> 时，会被重复执行的代码。<strong>循环体必须缩进</strong>（通常是 4 个空格），这是 Python 区分代码块的方式。</li></ul><h3 id="1-2-while-循环是如何工作的？"><a href="#1-2-while-循环是如何工作的？" class="headerlink" title="1.2 while 循环是如何工作的？"></a>1.2 <code>while</code> 循环是如何工作的？</h3><div style="text-align:center">  <img src="/img_2/mermaid-1761664530933.png" alt="程序框图" style="width:50%;"></div><p><strong>执行步骤</strong>：</p><ol><li>首先，检查 <code>while</code> 后面的“条件表达式”。</li><li>如果条件为 <code>True</code>：<ul><li>执行缩进的“循环体语句”。</li><li>执行完一遍循环体后，<strong>再次回到步骤 1 检查条件</strong>。</li></ul></li><li>如果条件为 <code>False</code>：<ul><li>跳过“循环体语句”，退出 <code>while</code> 循环。</li><li>继续执行 <code>while</code> 循环结构之后的代码。</li></ul></li></ol><h3 id="1-3-第一个-while-循环实例"><a href="#1-3-第一个-while-循环实例" class="headerlink" title="1.3 第一个 while 循环实例"></a>1.3 第一个 <code>while</code> 循环实例</h3><p>让我们看一个简单的例子，用 <code>while</code> 循环打印从 0 到 8 的数字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span>  <span class="comment"># 初始化一个计数器</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">9</span>:  <span class="comment"># 条件：只要 count 小于 9，就执行循环体</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;The count is:&quot;</span>, count)</span><br><span class="line">    count = count + <span class="number">1</span>  <span class="comment"># 计数器加 1，非常重要！否则条件永远为 True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)  <span class="comment"># 循环结束后执行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">The count is: 0</span><br><span class="line">The count is: 1</span><br><span class="line">The count is: 2</span><br><span class="line">The count is: 3</span><br><span class="line">The count is: 4</span><br><span class="line">The count is: 5</span><br><span class="line">The count is: 6</span><br><span class="line">The count is: 7</span><br><span class="line">The count is: 8</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p><strong>代码解析</strong>：</p><ul><li><code>count = 0</code>：我们先创建了一个变量 <code>count</code> 并初始化为 0，用作计数器。</li><li><code>while count &lt; 9:</code>：条件是 <code>count</code> 小于 9。一开始 <code>count</code> 是 0，条件为 <code>True</code>。</li><li><code>print(&quot;The count is:&quot;, count)</code>：打印当前的 <code>count</code> 值。</li><li><code>count = count + 1</code>：这是<strong>非常关键的一步</strong>！它让 <code>count</code> 的值每次增加 1。如果没有这一步，<code>count</code> 永远是 0，条件 <code>count &lt; 9</code> 永远为 <code>True</code>，循环就会永远执行下去，即无限循环</li><li>当 <code>count</code> 增加到 9 时，<code>count &lt; 9</code> 变为 <code>False</code>，循环停止。</li><li>最后打印 <code>&quot;Good bye!&quot;</code>。</li></ul><hr><h2 id="2-循环控制：break-和-continue"><a href="#2-循环控制：break-和-continue" class="headerlink" title="2. 循环控制：break 和 continue"></a>2. 循环控制：<code>break</code> 和 <code>continue</code></h2><p>有时候，我们希望在循环体内部根据某些条件来改变循环的正常流程。Python 提供了两个重要的关键字来实现这一点：<code>break</code> 和 <code>continue</code>。</p><h3 id="2-1-break-语句：立即终止循环，跳出！"><a href="#2-1-break-语句：立即终止循环，跳出！" class="headerlink" title="2.1 break 语句：立即终止循环，跳出！"></a>2.1 <code>break</code> 语句：立即终止循环，跳出！</h3><p><code>break</code> 语句的作用是：<strong>立即终止当前循环，并且跳出整个循环体，不再执行循环体中 <code>break</code> 后面的语句，也不再回到条件判断，直接执行循环后面的代码。</strong></p><p>设想一个场景，你在看书，突然火警响了，你会立刻停止看书，跑出房间</p><p><strong>实例：找到第一个偶数就停止</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果 i 是偶数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到第一个偶数:&quot;</span>, i)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 立即终止循环，跳出</span></span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">找到第一个偶数: 2</span><br><span class="line">循环结束</span><br></pre></td></tr></table></figure><p><strong>实例：从 1 数到 10，然后停止</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:  <span class="comment"># 条件永远是 True，理论上是无限循环</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">10</span>:  <span class="comment"># 当 i 大于 10 时</span></span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 跳出循环，终止无限循环</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数完了！&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">数完了！</span><br></pre></td></tr></table></figure><p>这里 <code>while True:</code> 会创建一个无限循环，但我们用 <code>break</code> 语句在适当的时候终止了它。</p><h3 id="2-2-continue-语句：跳过本次循环剩余部分，直接开始下一次循环"><a href="#2-2-continue-语句：跳过本次循环剩余部分，直接开始下一次循环" class="headerlink" title="2.2 continue 语句：跳过本次循环剩余部分，直接开始下一次循环"></a>2.2 <code>continue</code> 语句：跳过本次循环剩余部分，直接开始下一次循环</h3><p><code>continue</code> 语句的作用是：<strong>立即终止当前这一轮的循环，跳过循环体中 <code>continue</code> 后面剩余的语句，直接回到循环的条件判断处，准备开始下一次循环（如果条件仍然成立）。</strong></p><p>这就像你在吃葡萄，吃到一颗坏的，你会把这颗坏的吐掉，跳过它，<code>continue</code>，然后接着吃下一颗</p><p>**实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">10</span>:</span><br><span class="line">    i = i + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># 如果 i 是偶数</span></span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过下面的 print，直接进入下一次循环判断</span></span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 只有当 i 是奇数时才会执行到这里</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">3</span><br><span class="line">5</span><br><span class="line">7</span><br><span class="line">9</span><br></pre></td></tr></table></figure><p>解释：当 <code>i</code> 是偶数时，<code>continue</code> 语句让程序跳过了 <code>print(i)</code>，直接回到 <code>while</code> 条件判断。</p><hr><h2 id="3-无限循环：停不下来的循环"><a href="#3-无限循环：停不下来的循环" class="headerlink" title="3. 无限循环：停不下来的循环"></a>3. 无限循环：停不下来的循环</h2><p>如果 <code>while</code> 循环的条件表达式永远为 <code>True</code>，那么循环就会一直执行下去，永不停止，这就是<strong>无限循环</strong>。</p><p><strong>不小心写出无限循环是初学者常见的错误</strong>，通常是因为忘记在循环体中修改条件表达式里的变量（比如忘记 <code>count = count + 1</code>）。</p><h3 id="3-1-一个简单的无限循环例子"><a href="#3-1-一个简单的无限循环例子" class="headerlink" title="3.1 一个简单的无限循环例子"></a>3.1 一个简单的无限循环例子</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> var == <span class="number">1</span>:  <span class="comment"># var 永远是 1，条件永远为 True</span></span><br><span class="line">    num = <span class="built_in">input</span>(<span class="string">&quot;请输入一个数字 (输入 &#x27;q&#x27; 退出): &quot;</span>)  <span class="comment"># Python 3 使用 input()，Python 2 用 raw_input()</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 如果用户输入 &#x27;q&#x27;，就跳出循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;你输入的数字是:&quot;</span>, num)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>（示例）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">请输入一个数字 (输入 &#x27;q&#x27; 退出): 123</span><br><span class="line">你输入的数字是: 123</span><br><span class="line">请输入一个数字 (输入 &#x27;q&#x27; 退出): 456</span><br><span class="line">你输入的数字是: 456</span><br><span class="line">请输入一个数字 (输入 &#x27;q&#x27; 退出): q</span><br></pre></td></tr></table></figure><p>这个例子中，我们用 <code>break</code> 语句给了用户一个退出无限循环的途径。</p><h3 id="3-2-如何终止不小心写出的无限循环？"><a href="#3-2-如何终止不小心写出的无限循环？" class="headerlink" title="3.2 如何终止不小心写出的无限循环？"></a>3.2 如何终止不小心写出的无限循环？</h3><p>如果你的程序陷入了无限循环，可以：</p><ul><li>在大多数 Python IDE（如 PyCharm, VS Code）中，可以点击停止按钮。</li><li>在命令行或终端中运行时，可以按 <code>Ctrl + C</code> 组合键来强制终止程序。</li></ul><hr><h2 id="4-while-else-语句"><a href="#4-while-else-语句" class="headerlink" title="4. while ... else 语句"></a>4. <code>while ... else</code> 语句</h2><p>Python 的 <code>while</code> 循环还有一个特殊的语法：可以和 <code>else</code> 子句一起使用。</p><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式:</span><br><span class="line">    循环体语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    当条件表达式变为 <span class="literal">False</span>，且循环是正常结束，即，不是通过 <span class="string">&#x27;break&#x27;</span> 语句跳出，时执行的语句</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：<code>else</code> 子句中的代码块，会在 <code>while</code> 循环的条件变为 <code>False</code>，并且循环体是<strong>正常执行完毕</strong>.即不是因为执行了 <code>break</code> 语句而退出</p><p><strong>实例</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot;小于 5&quot;</span>)</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot;不再小于 5 (循环正常结束)&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0 小于 5</span><br><span class="line">1 小于 5</span><br><span class="line">2 小于 5</span><br><span class="line">3 小于 5</span><br><span class="line">4 小于 5</span><br><span class="line">5 不再小于 5 (循环正常结束)</span><br></pre></td></tr></table></figure><p><strong>如果循环中出现 break</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot;小于 5&quot;</span>)</span><br><span class="line">    count = count + <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 当 count 等于 3 时，强行跳出循环</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(count, <span class="string">&quot;不再小于 5 (循环正常结束)&quot;</span>)  <span class="comment"># 这行不会被执行！</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 小于 5</span><br><span class="line">1 小于 5</span><br><span class="line">2 小于 5</span><br></pre></td></tr></table></figure><p>可以看到，因为循环是通过 <code>break</code> 结束的，<code>else</code> 子句没有执行。</p><hr><h2 id="5-简单语句组"><a href="#5-简单语句组" class="headerlink" title="5. 简单语句组"></a>5. 简单语句组</h2><p>如果 <code>while</code> 循环的循环体中只有<strong>一条语句</strong>，你可以将这条语句与 <code>while</code> 写在同一行。这只是一种简写形式，不影响功能。</p><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件表达式: 一条语句</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flag = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> flag: <span class="built_in">print</span>(<span class="string">&quot; flag 为 True，循环继续...&quot;</span>)  <span class="comment"># 这是一个无限循环，因为 flag 始终为 1 (True)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意：按 Ctrl + C 停止</span></span><br></pre></td></tr></table></figure><p>但这种方式<strong>不推荐</strong>，虽然简洁，但如果循环体逻辑稍微复杂一点，这种写法会降低代码的可读性。对于初学者，建议还是使用标准的缩进形式</p><hr><h2 id="For-循环语句"><a href="#For-循环语句" class="headerlink" title="For 循环语句"></a>For 循环语句</h2><p><code>for</code> 循环是 Python 中另一种非常强大的循环结构。与 <code>while</code> 循环侧重于，当条件满足时就一直做不同，<code>for</code> 循环更侧重于<strong>对序列中的每个元素，都做一次</strong>。</p><p>简单说，<code>for</code> 循环最擅长的就是<strong>遍历</strong>——即依次访问序列中的每一个元素</p><h3 id="2-1-for-循环的基本结构"><a href="#2-1-for-循环的基本结构" class="headerlink" title="2.1 for 循环的基本结构"></a>2.1 <code>for</code> 循环的基本结构</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    循环体语句 (对序列中的每个元素执行)</span><br><span class="line">    ... (可以有多行语句)</span><br><span class="line"><span class="comment"># 循环结束后，执行这里的代码</span></span><br></pre></td></tr></table></figure><ul><li>**<code>for</code>**：Python 关键字，标记一个 <code>for</code> 循环的开始。</li><li><strong>变量</strong>：也叫“迭代变量”或“循环变量”。在每一次循环中，这个变量会被赋值为序列中的下一个元素。</li><li>**<code>in</code>**：Python 关键字，用于连接变量和序列，表示“在…之中”。</li><li><strong>序列</strong>：一个包含多个元素的对象，例如字符串、列表、元组等。<code>for</code> 循环会依次取出序列中的元素。</li><li>**冒号 <code>:</code>**：表示序列的结束，以及循环体的开始。</li><li><strong>循环体语句</strong>：对序列中的每个元素要执行的操作。<strong>循环体必须缩进</strong>（通常是 4 个空格）。</li></ul><h3 id="2-2-for-循环是如何工作的？"><a href="#2-2-for-循环是如何工作的？" class="headerlink" title="2.2 for 循环是如何工作的？"></a>2.2 <code>for</code> 循环是如何工作的？</h3><div style="text-align:center">  <img src="/img_2/mermaid_20251028_de5a65.png" alt="程序框图" style="width:50%"></div><p><strong>执行步骤</strong>：</p><ol><li>从序列中取出第一个元素。</li><li>如果序列中还有元素,即没有取完<ul><li>将取出的元素赋值给“变量”。</li><li>执行缩进的循环体语句（也就是使用当前变量的值）。</li><li>执行完一遍循环体后，<strong>回到步骤 1 取下一个元素</strong>。</li></ul></li><li>如果序列中没有元素了，即所有元素都已处理完毕<ul><li>退出 <code>for</code> 循环。</li><li>继续执行 <code>for</code> 循环后面的代码。</li></ul></li></ol><h3 id="2-3-实例1：遍历字符串"><a href="#2-3-实例1：遍历字符串" class="headerlink" title="2.3 实例1：遍历字符串"></a>2.3 实例1：遍历字符串</h3><p>字符串是字符的序列。我们可以用 <code>for</code> 循环遍历字符串中的每个字符。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例1：遍历字符串</span></span><br><span class="line">message = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> message:  <span class="comment"># char 依次是 &#x27;P&#x27;, &#x27;y&#x27;, &#x27;t&#x27;, &#x27;h&#x27;, &#x27;o&#x27;, &#x27;n&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前字母:&quot;</span>, char)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">当前字母: P</span><br><span class="line">当前字母: y</span><br><span class="line">当前字母: t</span><br><span class="line">当前字母: h</span><br><span class="line">当前字母: o</span><br><span class="line">当前字母: n</span><br><span class="line">循环结束!</span><br></pre></td></tr></table></figure><h3 id="2-4-实例2：遍历列表"><a href="#2-4-实例2：遍历列表" class="headerlink" title="2.4 实例2：遍历列表"></a>2.4 实例2：遍历列表</h3><p>列表是 Python 中最常用的序列类型之一，可以包含各种类型的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 实例2：遍历列表</span></span><br><span class="line">fruits = [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;芒果&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:  <span class="comment"># fruit 依次是 &#x27;香蕉&#x27;, &#x27;苹果&#x27;, &#x27;芒果&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前水果:&#x27;</span>, fruit)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;水果都吃完啦！&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前水果: 香蕉</span><br><span class="line">当前水果: 苹果</span><br><span class="line">当前水果: 芒果</span><br><span class="line">水果都吃完啦！</span><br></pre></td></tr></table></figure><hr><h3 id="2-5-通过序列索引进行遍历，配合-range-和-len"><a href="#2-5-通过序列索引进行遍历，配合-range-和-len" class="headerlink" title="2.5 通过序列索引进行遍历，配合 range() 和 len()"></a>2.5 通过序列索引进行遍历，配合 <code>range()</code> 和 <code>len()</code></h3><p>有时候，我们不仅需要元素的值，还需要知道元素在序列中的位置。这时，可以使用 <code>range()</code> 函数配合 <code>len()</code> 函数来生成索引序列，然后通过索引访问元素。</p><ul><li>**<code>len(序列)</code>**：返回序列的长度，即元素的个数。</li><li>**<code>range(stop)</code>**：生成一个从 <code>0</code> 开始，到 <code>stop-1</code> 结束的整数序列。例如 <code>range(5)</code> 生成 <code>0, 1, 2, 3, 4</code>。</li><li>**<code>range(start, stop)</code>**：生成从 <code>start</code> 开始，到 <code>stop-1</code> 结束的整数序列。</li></ul><p><strong>实例3：使用索引遍历列表</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;芒果&#x27;</span>]</span><br><span class="line"><span class="comment"># len(fruits) 是 3，range(len(fruits)) 生成 0, 1, 2</span></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fruits)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;索引:&#x27;</span>, index, <span class="string">&#x27;，水果:&#x27;</span>, fruits[index])  <span class="comment"># fruits[index] 通过索引访问元素</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">索引: 0 ，水果: 香蕉</span><br><span class="line">索引: 1 ，水果: 苹果</span><br><span class="line">索引: 2 ，水果: 芒果</span><br></pre></td></tr></table></figure><p>这种方式类似于其他语言中常见的 <code>for (i=0; i&lt;N; i++)</code> 形式。</p><hr><h3 id="2-6-for-循环中的-break-和-continue"><a href="#2-6-for-循环中的-break-和-continue" class="headerlink" title="2.6 for 循环中的 break 和 continue"></a>2.6 <code>for</code> 循环中的 <code>break</code> 和 <code>continue</code></h3><p>和 <code>while</code> 循环一样，<code>for</code> 循环也可以配合 <code>break</code> 和 <code>continue</code> 这两个控制语句来改变循环的执行流程。</p><ul><li>**<code>break</code>**：立即终止整个 <code>for</code> 循环，跳出循环体。</li><li>**<code>continue</code>**：跳过当前这次循环中 <code>continue</code> 后面的语句，直接开始下一次循环（取下一个元素）。</li></ul><p><strong>实例4：<code>break</code> 示例 - 找到 ‘苹果’ 就停止</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;芒果&#x27;</span>, <span class="string">&#x27;橘子&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="keyword">if</span> fruit == <span class="string">&#x27;苹果&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;找到了苹果！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 找到后立即退出循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前水果:&quot;</span>, fruit)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当前水果: 香蕉</span><br><span class="line">找到了苹果！</span><br></pre></td></tr></table></figure><p>芒果 和 橘子 没有被打印，因为循环已经被 <code>break</code> 终止了</p><p><strong>实例5：<code>continue</code> 示例 - 跳过 ‘苹果’</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;香蕉&#x27;</span>, <span class="string">&#x27;苹果&#x27;</span>, <span class="string">&#x27;芒果&#x27;</span>, <span class="string">&#x27;橘子&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    <span class="keyword">if</span> fruit == <span class="string">&#x27;苹果&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过当前水果，直接进行下一次循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;当前水果:&quot;</span>, fruit)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前水果: 香蕉</span><br><span class="line">当前水果: 芒果</span><br><span class="line">当前水果: 橘子</span><br></pre></td></tr></table></figure><p>（’苹果’ 被 <code>continue</code> 跳过了。）</p><hr><h3 id="2-7-for-else-语句：循环正常结束时执行的操作"><a href="#2-7-for-else-语句：循环正常结束时执行的操作" class="headerlink" title="2.7 for ... else 语句：循环正常结束时执行的操作"></a>2.7 <code>for ... else</code> 语句：循环正常结束时执行的操作</h3><p>与 <code>while ... else</code> 类似，<code>for</code> 循环也可以搭配 <code>else</code> 子句。</p><p><strong>语法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    循环体语句</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    当序列中的所有元素都被遍历完毕，且循环是正常结束，即，不是通过 <span class="string">&#x27;break&#x27;</span> 语句跳出时执行的语句</span><br></pre></td></tr></table></figure><p><strong>作用</strong>：<code>else</code> 子句中的代码块，会在 <code>for</code> 循环<strong>完整地遍历了序列中的所有元素</strong>，并且<strong>没有因为执行 <code>break</code> 语句而提前退出</strong>的情况下执行。</p><p><strong>实例6：判断列表中是否有负数，无 <code>break</code> 则 <code>else</code> 执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发现负数:&quot;</span>, num)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表中没有负数。&quot;</span>)  <span class="comment"># 因为没有 break，所以会执行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列表中没有负数。</span><br></pre></td></tr></table></figure><p><strong>实例7：判断列表中是否有负数，有 <code>break</code> 则 <code>else</code> 不执行</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, -<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;发现负数:&quot;</span>, num)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;列表中没有负数。&quot;</span>)  <span class="comment"># 因为有 break，所以不会执行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">发现负数: -3</span><br></pre></td></tr></table></figure><p><strong>经典应用：判断质数</strong></p><p>下面是一个更实用的例子，用 <code>for ... else</code> 结构判断一个数是否为质数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">17</span>  <span class="comment"># 我们要判断的数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num &lt;= <span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>(num, <span class="string">&quot;不是质数&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 检查从 2 到 num-1 的数是否能整除 num</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, num):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:  <span class="comment"># 如果能整除，说明不是质数</span></span><br><span class="line">            <span class="built_in">print</span>(num, <span class="string">&quot;等于&quot;</span>, i, <span class="string">&quot;*&quot;</span>, num//i)</span><br><span class="line">            <span class="built_in">print</span>(num, <span class="string">&quot;不是质数&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 如果上面的循环没有找到能整除的数（即没有执行 break）</span></span><br><span class="line">        <span class="built_in">print</span>(num, <span class="string">&quot;是一个质数&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">17 是一个质数</span><br></pre></td></tr></table></figure><p>如果把 <code>num</code> 改成 <code>15</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 等于 3 * 5</span><br><span class="line">15 不是质数</span><br></pre></td></tr></table></figure><hr><h3 id="2-8-更多实例：用-for-循环打印图案"><a href="#2-8-更多实例：用-for-循环打印图案" class="headerlink" title="2.8 更多实例：用 for 循环打印图案"></a>2.8 更多实例：用 <code>for</code> 循环打印图案</h3><p><code>for</code> 循环非常适合用来打印各种有规律的文本图案，比如三角形、矩形、菱形等。这通常会用到嵌套 <code>for</code> 循环。即，一个 <code>for</code> 循环里面再包含一个或多个 <code>for</code> 循环</p><p><strong>实例8：打印一个 5x5 的矩形星号 (<code>*</code>)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印矩形</span></span><br><span class="line">rows = <span class="number">5</span>  <span class="comment"># 行数</span></span><br><span class="line">cols = <span class="number">5</span>  <span class="comment"># 列数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(rows):          <span class="comment"># 外层循环控制行数</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(cols):      <span class="comment"># 内层循环控制每行的列数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot; &quot;</span>)    <span class="comment"># 打印一个星号和一个空格，end=&quot;&quot; 表示不换行</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 一行打印完后换行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">* * * * *</span><br><span class="line">* * * * *</span><br><span class="line">* * * * *</span><br><span class="line">* * * * *</span><br><span class="line">* * * * *</span><br></pre></td></tr></table></figure><p><strong>实例9：打印一个直角三角形</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印直角三角形 (靠右对齐)</span></span><br><span class="line">rows = <span class="number">5</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, rows + <span class="number">1</span>):  <span class="comment"># i 从 1 到 5 (行数)</span></span><br><span class="line">    <span class="comment"># 先打印 (rows - i) 个空格，再打印 i 个星号</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(rows - i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(i):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 换行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">        *</span><br><span class="line">      * *</span><br><span class="line">    * * *</span><br><span class="line">  * * * *</span><br><span class="line">* * * * *</span><br></pre></td></tr></table></figure><p>这些图案打印练习能很好地帮助你理解循环的控制流程，特别是嵌套循环。</p><hr><h2 id="嵌套循环"><a href="#嵌套循环" class="headerlink" title="嵌套循环"></a>嵌套循环</h2><h3 id="一、什么是循环嵌套？"><a href="#一、什么是循环嵌套？" class="headerlink" title="一、什么是循环嵌套？"></a>一、什么是循环嵌套？</h3><p>可以类比为，你要做多层嵌套的俄罗斯套娃，或者盖一栋有多层房间的楼房。在编程里，<strong>循环嵌套就是在一个循环的“身体里”再放进另一个循环</strong>。就像你写作业时，先按科目循环，比如先做数学、再做语文……每个科目里又按题目循环，第一题、第二题……</p><p>Python 里不管是 <code>for</code> 循环还是 <code>while</code> 循环，都能互相嵌套。比如：</p><ul><li><code>for</code> 里套 <code>for</code></li><li><code>for</code> 里套 <code>while</code></li><li><code>while</code> 里套 <code>for</code></li><li><code>while</code> 里套 <code>while</code></li></ul><h3 id="二、循环嵌套的基本语法"><a href="#二、循环嵌套的基本语法" class="headerlink" title="二、循环嵌套的基本语法"></a>二、循环嵌套的基本语法</h3><h4 id="（一）for-循环嵌套-for-循环"><a href="#（一）for-循环嵌套-for-循环" class="headerlink" title="（一）for 循环嵌套 for 循环"></a>（一）for 循环嵌套 for 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 外层变量 <span class="keyword">in</span> 外层序列:</span><br><span class="line">    <span class="comment"># 外层循环的操作</span></span><br><span class="line">    <span class="keyword">for</span> 内层变量 <span class="keyword">in</span> 内层序列:</span><br><span class="line">        <span class="comment"># 内层循环的操作</span></span><br><span class="line">    <span class="comment"># 外层循环后续操作（内层循环结束后执行）</span></span><br></pre></td></tr></table></figure><h4 id="（二）while-循环嵌套-while-循环"><a href="#（二）while-循环嵌套-while-循环" class="headerlink" title="（二）while 循环嵌套 while 循环"></a>（二）while 循环嵌套 while 循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">外层条件 = 初始值</span><br><span class="line"><span class="keyword">while</span> 外层条件 满足:</span><br><span class="line">    <span class="comment"># 外层循环的操作</span></span><br><span class="line">    内层条件 = 初始值</span><br><span class="line">    <span class="keyword">while</span> 内层条件 满足:</span><br><span class="line">        <span class="comment"># 内层循环的操作</span></span><br><span class="line">        内层条件 更新  <span class="comment"># 别忘更新，否则无限循环！</span></span><br><span class="line">    外层条件 更新  <span class="comment"># 别忘更新，否则无限循环！</span></span><br></pre></td></tr></table></figure><h4 id="（三）混合嵌套（比如-for-套-while，while-套-for）"><a href="#（三）混合嵌套（比如-for-套-while，while-套-for）" class="headerlink" title="（三）混合嵌套（比如 for 套 while，while 套 for）"></a>（三）混合嵌套（比如 for 套 while，while 套 for）</h4><p>原理和上面一样，只要记住<strong>内层循环要完全“包裹”在外层循环的缩进块里</strong>，Python 靠缩进来区分不同层级的循环体~</p><h3 id="三、循环嵌套如何执行？"><a href="#三、循环嵌套如何执行？" class="headerlink" title="三、循环嵌套如何执行？"></a>三、循环嵌套如何执行？</h3><p>看个简单例子：打印一个 3 行 4 列的星号矩形</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 行 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):  <span class="comment"># 外层循环控制“行”，执行 3 次（行号 0,1,2）</span></span><br><span class="line">    <span class="keyword">for</span> 列 <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):  <span class="comment"># 内层循环控制“列”，每行执行 4 次（列号 0,1,2,3）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;*&quot;</span>, end=<span class="string">&quot; &quot;</span>)  <span class="comment"># 打印星号，end=&quot; &quot; 表示不换行</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 内层循环结束后，换行准备下一行</span></span><br></pre></td></tr></table></figure><p><strong>执行流程拆解</strong>：</p><ol><li>外层循环第 1 次（行&#x3D;0）：<ul><li>进入内层循环，列从 0 到 3，依次打印 <code>* </code>，所以第一行是 <code>* * * * </code></li><li>内层循环结束后，执行 <code>print()</code> 换行</li></ul></li><li>外层循环第 2 次（行&#x3D;1）：<ul><li>内层循环再执行 4 次，打印第二行 <code>* * * * </code></li><li>换行</li></ul></li><li>外层循环第 3 次（行&#x3D;2）：<ul><li>内层循环再执行 4 次，打印第三行 <code>* * * * </code></li><li>换行<br>最终输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* * * * </span><br><span class="line">* * * * </span><br><span class="line">* * * * </span><br></pre></td></tr></table></figure></li></ul></li></ol><h3 id="四、实战：用嵌套循环找-2-100-的素数"><a href="#四、实战：用嵌套循环找-2-100-的素数" class="headerlink" title="四、实战：用嵌套循环找 2~100 的素数"></a>四、实战：用嵌套循环找 2~100 的素数</h3><p>素数（质数）是指<strong>只能被 1 和它本身整除的大于 1 的整数</strong>。比如 2、3、5、7 是素数，4（能被 2 整除）、6（能被 2 或 3 整除）不是</p><p><strong>先暂停一下，思考思考，再看下面的内容！！！</strong></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><ol><li>外层循环 <code>i</code> 从 2 遍历到 99（因为要找 2~100 的数）。</li><li>对每个 <code>i</code>，用内层循环 <code>j</code> 去试除：从 2 开始，直到 <code>j ≤ i/j</code>.这样可以减少计算次数，比如 i&#x3D;100 时，j 只需要试到 10 就行，因为 10*10&#x3D;100</li><li>如果 <code>i % j == 0</code>，说明 <code>i</code> 能被 <code>j</code> 整除，不是素数，立刻 <code>break</code> 内层循环。</li><li>如果内层循环跑完了都没找到能整除的 <code>j</code>.即,内层循环是自然结束，不是被 <code>break</code> 打断的），说明 <code>i</code> 是素数，打印出来</li></ol><h4 id="代码实现（while-套-while）："><a href="#代码实现（while-套-while）：" class="headerlink" title="代码实现（while 套 while）："></a>代码实现（while 套 while）：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> i &lt; <span class="number">100</span>:  <span class="comment"># 外层循环：i 从 2 到 99</span></span><br><span class="line">    j = <span class="number">2</span></span><br><span class="line">    <span class="comment"># 内层循环：j 从 2 开始，直到 j &gt; i/j（这样减少计算量）</span></span><br><span class="line">    <span class="keyword">while</span> j &lt;= (i / j):</span><br><span class="line">        <span class="keyword">if</span> i % j == <span class="number">0</span>:  <span class="comment"># 能整除，说明不是素数</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 跳出内层循环，不用再试了</span></span><br><span class="line">        j += <span class="number">1</span>  <span class="comment"># 试除的数 +1</span></span><br><span class="line">    <span class="comment"># 内层循环结束后，判断是“自然结束”还是被 break 打断</span></span><br><span class="line">    <span class="keyword">if</span> j &gt; (i / j):  <span class="comment"># 如果自然结束，说明没找到能整除的 j，是素数</span></span><br><span class="line">        <span class="built_in">print</span>(i, <span class="string">&quot;是素数&quot;</span>)</span><br><span class="line">    i += <span class="number">1</span>  <span class="comment"># 外层循环的 i +1，继续下一个数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="代码执行逻辑拆解："><a href="#代码执行逻辑拆解：" class="headerlink" title="代码执行逻辑拆解："></a>代码执行逻辑拆解：</h4><p>拿 <code>i=9</code> 举例：</p><ul><li>外层循环 <code>i=9</code>，进入内层循环 <code>j=2</code>。</li><li>检查 <code>j &lt;= 9/j</code> → 2 ≤ 4.5 → 成立。</li><li>检查 <code>9%2</code> → 余 1，不能整除，所以 <code>j +=1</code> → j&#x3D;3。</li><li>再检查 <code>j &lt;= 9/j</code> → 3 ≤ 3 → 成立。</li><li>检查 <code>9%3</code> → 余 0，能整除 → <code>break</code> 内层循环。</li><li>内层循环被 <code>break</code> 打断，所以不会执行 <code>if j &gt; i/j</code> 里的打印，<code>i=9</code> 不是素数。</li></ul><p>再拿 <code>i=7</code> 举例：</p><ul><li>外层循环 <code>i=7</code>，内层循环 <code>j=2</code>。</li><li><code>j &lt;=7/2</code> → 2 ≤ 3.5 → 成立。</li><li><code>7%2=1</code> → 不能整除，j&#x3D;3。</li><li>检查 <code>j &lt;=7/3</code> → 3 ≤ 2.333… → 不成立！所以内层循环“自然结束”。</li><li>此时 <code>j=3 &gt; 7/3≈2.333</code> → 满足条件，打印 <code>7 是素数</code>。</li></ul><h3 id="五、循环嵌套的注意事项"><a href="#五、循环嵌套的注意事项" class="headerlink" title="五、循环嵌套的注意事项"></a>五、循环嵌套的注意事项</h3><ol><li><strong>缩进要清晰</strong>：内层循环必须比外层循环多缩进（通常 4 个空格，这是第N次强调了），否则 Python 会分不清哪层是哪层。</li><li><strong>小心无限循环</strong>：内层和外层循环都要记得<strong>更新循环条件</strong>！比如外层 <code>while</code> 里的变量要递增，内层 <code>while</code> 里的变量也要递增，否则容易无限循环。</li><li><strong>性能问题</strong>：嵌套层数越多，执行次数呈指数级增长，比如 3 层循环，每层循环 10 次，总执行次数是 10×10×10&#x3D;1000 次。如果嵌套太多，程序可能会很慢，实际开发要谨慎</li></ol><h3 id="六、拓展练习：用-for-套-for-实现素数判断"><a href="#六、拓展练习：用-for-套-for-实现素数判断" class="headerlink" title="六、拓展练习：用 for 套 for 实现素数判断"></a>六、拓展练习：用 for 套 for 实现素数判断</h3><p>把上面的 <code>while</code> 套 <code>while</code> 改成 <code>for</code> 套 <code>for</code>，感受不同循环嵌套的写法。<strong>老规矩，先自己写，再看参考代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">100</span>):  <span class="comment"># 外层 for 循环，i 从 2 到 99</span></span><br><span class="line">    is_prime = <span class="literal">True</span>  <span class="comment"># 先假设 i 是素数</span></span><br><span class="line">    <span class="comment"># 内层 for 循环：j 从 2 到 int(i**0.5)（和 j &lt;= i/j 效果一样，更简洁）</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(i**<span class="number">0.5</span>) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> i % j == <span class="number">0</span>:  <span class="comment"># 能整除，不是素数</span></span><br><span class="line">            is_prime = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 跳出内层循环</span></span><br><span class="line">    <span class="keyword">if</span> is_prime:  <span class="comment"># 如果还是 True，说明是素数</span></span><br><span class="line">        <span class="built_in">print</span>(i, <span class="string">&quot;是素数&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这里用 <code>range(2, int(i**0.5)+1)</code> 代替了 <code>while j &lt;= i/j</code>，逻辑更简洁。原理是一样的，只要试除到平方根就够了</p><hr><h2 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h2><h3 id="一、break-是做什么的？"><a href="#一、break-是做什么的？" class="headerlink" title="一、break 是做什么的？"></a>一、break 是做什么的？</h3><p>就像你在玩闯关游戏，每一关是循环里的一次迭代。当你触发 <code>break</code>，比如，找到关键道具、触发特殊条件，<strong>不管循环有没有执行完，都会立刻终止当前所在的那一层循环</strong>，直接跳出循环体，去执行循环后面的代码</p><p>简单说，<code>break</code> 就是循环的<strong>紧急停止按钮</strong>，让循环提前结束</p><h3 id="二、break-的基本语法"><a href="#二、break-的基本语法" class="headerlink" title="二、break 的基本语法"></a>二、break 的基本语法</h3><p><code>break</code> 是 Python 的关键字，单独使用，不需要加括号或参数，写在循环体中</p><h4 id="（一）在-for-循环中用-break"><a href="#（一）在-for-循环中用-break" class="headerlink" title="（一）在 for 循环中用 break"></a>（一）在 for 循环中用 break</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 满足条件时，立刻终止整个 for 循环</span></span><br><span class="line">    代码块<span class="number">2</span></span><br><span class="line"><span class="comment"># 循环结束后，执行这里的代码</span></span><br></pre></td></tr></table></figure><h4 id="（二）在-while-循环中用-break"><a href="#（二）在-while-循环中用-break" class="headerlink" title="（二）在 while 循环中用 break"></a>（二）在 while 循环中用 break</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 满足条件时，立刻终止整个 while 循环</span></span><br><span class="line">    代码块<span class="number">2</span></span><br><span class="line">    <span class="comment"># 记得更新 while 的条件变量，否则容易无限循环！</span></span><br><span class="line"><span class="comment"># 循环结束后，执行这里的代码</span></span><br></pre></td></tr></table></figure><h3 id="三、break-如何工作？"><a href="#三、break-如何工作？" class="headerlink" title="三、break 如何工作？"></a>三、break 如何工作？</h3><p>以 <code>for</code> 循环为例：</p><div style="text-align:center">  <img src="/img_2/mermaid_20251028_708c4d.png" alt="程序框图" style="width:50%;"></div><h3 id="四、实例演示：break-在-for-和-while-中怎么用？"><a href="#四、实例演示：break-在-for-和-while-中怎么用？" class="headerlink" title="四、实例演示：break 在 for 和 while 中怎么用？"></a>四、实例演示：break 在 for 和 while 中怎么用？</h3><h4 id="（一）实例1：for-循环中遇到-‘h’-就停止"><a href="#（一）实例1：for-循环中遇到-‘h’-就停止" class="headerlink" title="（一）实例1：for 循环中遇到 ‘h’ 就停止"></a>（一）实例1：for 循环中遇到 ‘h’ 就停止</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 当字母是 &#x27;h&#x27; 时，终止整个 for 循环</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前字母:&#x27;</span>, letter)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束，继续执行后面的代码～&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当前字母: P</span><br><span class="line">当前字母: y</span><br><span class="line">当前字母: t</span><br><span class="line">循环结束，继续执行后面的代码～</span><br></pre></td></tr></table></figure><p>解释：<code>for</code> 循环原本要遍历 ‘P’,’y’,’t’,’h’,’o’,’n’，但当遍历到 ‘h’ 时，<code>break</code> 触发，循环直接终止，所以后面的 ‘o’、’n’ 没机会被处理。</p><h4 id="（二）实例2：while-循环中变量到-5-就停止"><a href="#（二）实例2：while-循环中变量到-5-就停止" class="headerlink" title="（二）实例2：while 循环中变量到 5 就停止"></a>（二）实例2：while 循环中变量到 5 就停止</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前变量值:&#x27;</span>, var)</span><br><span class="line">    var = var - <span class="number">1</span>  <span class="comment"># 变量递减</span></span><br><span class="line">    <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 当 var 减到 5 时，终止 while 循环</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前变量值: 10</span><br><span class="line">当前变量值: 9</span><br><span class="line">当前变量值: 8</span><br><span class="line">当前变量值: 7</span><br><span class="line">当前变量值: 6</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>解释：<code>while</code> 条件是 <code>var &gt; 0</code>，原本要从 10 减到 1。但当 <code>var</code> 减到 5 时，<code>break</code> 触发，循环终止，所以 4、3、2、1 不会被打印。</p><h3 id="五、break-在嵌套循环中的表现"><a href="#五、break-在嵌套循环中的表现" class="headerlink" title="五、break 在嵌套循环中的表现"></a>五、break 在嵌套循环中的表现</h3><p>如果是<strong>嵌套循环</strong>，比如 <code>for</code> 套 <code>for</code>，<code>while</code> 套 <code>while</code>，或者混合嵌套，<code>break</code> 只会终止<strong>它所在的那一层循环</strong>，不会影响外层循环</p><h4 id="实例3：嵌套-for-循环中，break-只终止内层循环"><a href="#实例3：嵌套-for-循环中，break-只终止内层循环" class="headerlink" title="实例3：嵌套 for 循环中，break 只终止内层循环"></a>实例3：嵌套 for 循环中，break 只终止内层循环</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层循环控制行</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 内层循环控制列</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> col == <span class="number">2</span>:  <span class="comment"># 当列数到 2 时，终止内层循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;row&#125;</span>,<span class="subst">&#123;col&#125;</span>) &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 内层循环结束后，换行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;外层循环也结束啦～&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(0,0) (0,1) </span><br><span class="line">(1,0) (1,1) </span><br><span class="line">(2,0) (2,1) </span><br><span class="line">外层循环也结束啦～</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>外层循环 <code>row</code> 从 0 到 2（共 3 行）。</li><li>内层循环 <code>col</code> 从 0 到 3，但每次到 <code>col=2</code> 时，<code>break</code> 终止<strong>当前这一层</strong>循环，所以每行只打印 <code>col=0</code> 和 <code>col=1</code>。</li><li>内层循环终止后，回到外层循环，继续下一行</li></ul><h3 id="六、break-的常见使用场景"><a href="#六、break-的常见使用场景" class="headerlink" title="六、break 的常见使用场景"></a>六、break 的常见使用场景</h3><ol><li><strong>提前终止循环</strong>：当已经找到目标结果，不需要再继续循环时，比如找列表中的某个元素，找到就停止</li><li><strong>避免无效计算</strong>：当循环中出现不可能满足条件的情况，及时终止节省性能，比如判断质数时，一旦找到能整除的数，立刻停止试除</li><li><strong>用户交互退出</strong>：比如写一个命令行程序，用户输入特定指令时，用 <code>break</code> 终止循环，退出程序</li></ol><h3 id="七、需要注意的地方"><a href="#七、需要注意的地方" class="headerlink" title="七、需要注意的地方"></a>七、需要注意的地方</h3><ul><li><code>break</code> 只能用在<strong>循环体</strong>（即，<code>for</code> 或 <code>while</code> 的缩进块）里，否则会报错（SyntaxError）。</li><li>在嵌套循环中，<code>break</code> 只影响当前所在的那一层循环，外层循环会继续执行。如果想同时终止多层循环，需要结合标志位（flag）或者其他逻辑</li></ul><hr><h2 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h2><h3 id="一、continue-是什么？和-break-有什么区别？"><a href="#一、continue-是什么？和-break-有什么区别？" class="headerlink" title="一、continue 是什么？和 break 有什么区别？"></a>一、continue 是什么？和 break 有什么区别？</h3><p>如果说 <code>break</code> 是循环的紧急停止按钮，那么 <code>continue</code> 就是循环的跳过当前按钮。<strong>它不会终止整个循环，只会跳过当前这次迭代中 <code>continue</code> 后面的代码，直接开始下一次循环</strong>。</p><p>简单来说：</p><ul><li><code>break</code> → <strong>彻底不干了</strong>。</li><li><code>continue</code> → <strong>这次不干了，下次继续</strong></li></ul><h3 id="二、continue-的基本语法"><a href="#二、continue-的基本语法" class="headerlink" title="二、continue 的基本语法"></a>二、continue 的基本语法</h3><p>和 <code>break</code> 一样，<code>continue</code> 也是 Python 关键字，单独使用，写在循环体的缩进块里，通常和 <code>if</code> 条件配合使用。</p><h4 id="（一）在-for-循环中用-continue"><a href="#（一）在-for-循环中用-continue" class="headerlink" title="（一）在 for 循环中用 continue"></a>（一）在 for 循环中用 continue</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 满足条件时，跳过当前迭代的剩余代码，直接开始下一次迭代</span></span><br><span class="line">    代码块<span class="number">2</span>  <span class="comment"># 如果触发 continue，这部分代码不会执行</span></span><br><span class="line"><span class="comment"># 循环结束后执行</span></span><br></pre></td></tr></table></figure><h4 id="（二）在-while-循环中用-continue"><a href="#（二）在-while-循环中用-continue" class="headerlink" title="（二）在 while 循环中用 continue"></a>（二）在 while 循环中用 continue</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    代码块<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> 条件:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 满足条件时，跳过当前迭代的剩余代码，直接开始下一次迭代（重新判断 while 条件）</span></span><br><span class="line">    代码块<span class="number">2</span>  <span class="comment"># 如果触发 continue，这部分代码不会执行</span></span><br><span class="line">    变量更新  <span class="comment"># ⚠️ 注意：在 while 中用 continue 时，一定要确保 continue 前更新了循环条件变量，否则可能无限循环！</span></span><br><span class="line"><span class="comment"># 循环结束后执行</span></span><br></pre></td></tr></table></figure><h3 id="三、continue-如何工作？"><a href="#三、continue-如何工作？" class="headerlink" title="三、continue 如何工作？"></a>三、continue 如何工作？</h3><p>以 <code>for</code> 循环为例：</p><div style="text-align:center">  <img src="/img_2/mermaid-1761667079887.png" alt="程序框图" style="width:50%;"></div><h3 id="四、实例演示：continue-在-for-和-while-中怎么用？"><a href="#四、实例演示：continue-在-for-和-while-中怎么用？" class="headerlink" title="四、实例演示：continue 在 for 和 while 中怎么用？"></a>四、实例演示：continue 在 for 和 while 中怎么用？</h3><h4 id="（一）实例1：for-循环中跳过-‘h’"><a href="#（一）实例1：for-循环中跳过-‘h’" class="headerlink" title="（一）实例1：for 循环中跳过 ‘h’"></a>（一）实例1：for 循环中跳过 ‘h’</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 当字母是 &#x27;h&#x27; 时，跳过当前迭代的剩余代码（即不打印 &#x27;h&#x27;）</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前字母:&#x27;</span>, letter)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;循环结束～&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当前字母: P</span><br><span class="line">当前字母: y</span><br><span class="line">当前字母: t</span><br><span class="line">当前字母: o</span><br><span class="line">当前字母: n</span><br><span class="line">循环结束～</span><br></pre></td></tr></table></figure><p>解释：<br><code>for</code> 循环遍历 ‘P’,’y’,’t’,’h’,’o’,’n’。当 <code>letter=&#39;h&#39;</code> 时，<code>continue</code> 触发，跳过 <code>print</code> 语句，直接开始下一次迭代（取下一个字母 ‘o’）。所以 ‘h’ 没有被打印，但循环没有终止，后面的 ‘o’ 和 ‘n’ 正常打印。</p><h4 id="（二）实例2：while-循环中跳过-5"><a href="#（二）实例2：while-循环中跳过-5" class="headerlink" title="（二）实例2：while 循环中跳过 5"></a>（二）实例2：while 循环中跳过 5</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:</span><br><span class="line">    var -= <span class="number">1</span>  <span class="comment"># ⚠️ 先减 1，再判断（避免 continue 跳过更新导致无限循环）</span></span><br><span class="line">    <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 当 var=5 时，跳过后面的 print</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前变量值:&#x27;</span>, var)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">当前变量值: 9</span><br><span class="line">当前变量值: 8</span><br><span class="line">当前变量值: 7</span><br><span class="line">当前变量值: 6</span><br><span class="line">当前变量值: 4</span><br><span class="line">当前变量值: 3</span><br><span class="line">当前变量值: 2</span><br><span class="line">当前变量值: 1</span><br><span class="line">当前变量值: 0</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>解释：</p><ul><li><code>var</code> 从 10 开始，每次循环先 <code>var -= 1</code>（更新变量）。</li><li>当 <code>var=5</code> 时，<code>continue</code> 触发，跳过 <code>print</code> 语句，直接开始下一次循环（<code>var</code> 继续减到 4，以此类推）。</li><li>注意：如果把 <code>var -= 1</code> 放在 <code>if var ==5: continue</code> 后面，当 <code>var=5</code> 时，<code>continue</code> 会跳过 <code>var -=1</code>，导致 <code>var</code> 永远是 5，进入<strong>无限循环</strong>！</li></ul><h3 id="五、continue-在嵌套循环中的表现"><a href="#五、continue-在嵌套循环中的表现" class="headerlink" title="五、continue 在嵌套循环中的表现"></a>五、continue 在嵌套循环中的表现</h3><p>和 <code>break</code> 类似，<code>continue</code> 也只影响<strong>它所在的那一层循环</strong>，不会影响外层循环。</p><h4 id="实例3：嵌套-for-循环中，continue-只跳过当前内层迭代"><a href="#实例3：嵌套-for-循环中，continue-只跳过当前内层迭代" class="headerlink" title="实例3：嵌套 for 循环中，continue 只跳过当前内层迭代"></a>实例3：嵌套 for 循环中，continue 只跳过当前内层迭代</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外层循环控制行（0,1,2）</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># 内层循环控制列（0,1,2,3）</span></span><br><span class="line">    <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> col == <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">continue</span>  <span class="comment"># 跳过当前列（col=2）的打印，直接开始下一列（col=3）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;(<span class="subst">&#123;row&#125;</span>,<span class="subst">&#123;col&#125;</span>) &quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 内层循环结束后换行</span></span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(0,0) (0,1) (0,3) </span><br><span class="line">(1,0) (1,1) (1,3) </span><br><span class="line">(2,0) (2,1) (2,3) </span><br></pre></td></tr></table></figure><p>解释：</p><ul><li>内层循环 <code>col</code> 从 0 到 3，当 <code>col=2</code> 时，<code>continue</code> 跳过当前列的 <code>print</code>，直接进入下一次内层循环（<code>col=3</code>）。</li><li>外层循环不受影响，正常执行 3 行。</li></ul><h3 id="六、continue-的常见使用场景"><a href="#六、continue-的常见使用场景" class="headerlink" title="六、continue 的常见使用场景"></a>六、continue 的常见使用场景</h3><ol><li><strong>过滤不需要的元素</strong>：遍历序列时，跳过不符合条件的元素，比如说，打印列表中所有偶数，跳过奇数</li><li><strong>跳过异常情况</strong>：处理数据时，遇到无效数据或错误格式，跳过当前处理，继续下一个</li></ol><h3 id="七、while-循环中使用-continue-的陷阱"><a href="#七、while-循环中使用-continue-的陷阱" class="headerlink" title="七、while 循环中使用 continue 的陷阱"></a>七、while 循环中使用 continue 的陷阱</h3><p>在 <code>while</code> 循环中使用 <code>continue</code> 时，<strong>一定一定要保证在 <code>continue</code> 语句执行前，已经更新了循环条件变量</strong>！否则可能导致变量永远不满足退出条件，陷入无限循环</p><p><strong>错误示例（无限循环）</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 当 var=5 时，跳过下面的 var -=1</span></span><br><span class="line">    <span class="built_in">print</span>(var)</span><br><span class="line">    var -= <span class="number">1</span>  <span class="comment"># ❌ 这行被跳过，var 永远是 5，while 条件永远成立！</span></span><br></pre></td></tr></table></figure><p>运行后会无限循环，永远停在 <code>var=5</code>。</p><p><strong>正确做法</strong>，先更新变量，再判断 <code>continue</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">10</span></span><br><span class="line"><span class="keyword">while</span> var &gt; <span class="number">0</span>:</span><br><span class="line">    var -= <span class="number">1</span>  <span class="comment"># ✅ 先减 1，再判断</span></span><br><span class="line">    <span class="keyword">if</span> var == <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(var)</span><br></pre></td></tr></table></figure><p>这样 <code>var</code> 会正常递减，不会无限循环</p><hr><h2 id="pass-语句"><a href="#pass-语句" class="headerlink" title="pass 语句"></a>pass 语句</h2><h3 id="一、pass-是做什么的？"><a href="#一、pass-是做什么的？" class="headerlink" title="一、pass 是做什么的？"></a>一、pass 是做什么的？</h3><p>假如，你在写作文大纲，先把框架列好，但某些部分还没想好具体内容。<code>pass</code> 就像大纲里的占位符，<strong>它什么实际操作都不做，但能让代码结构保持完整，避免语法错误</strong></p><p>简单说来说，<code>pass</code> 是 Python 的空语句，专门用来占位置，让代码能跑通，后续再填充逻辑</p><h3 id="二、pass-的基本语法"><a href="#二、pass-的基本语法" class="headerlink" title="二、pass 的基本语法"></a>二、pass 的基本语法</h3><p><code>pass</code> 是 Python 关键字，单独写一行，没有参数，也不需要括号。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单独使用 pass</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和 if、for、while 等语句配合（作为占位）</span></span><br><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 条件满足时，什么都不做</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 序列:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 遍历过程中，暂时什么都不做</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 循环过程中，暂时什么都不做</span></span><br></pre></td></tr></table></figure><h3 id="三、为什么需要-pass？"><a href="#三、为什么需要-pass？" class="headerlink" title="三、为什么需要 pass？"></a>三、为什么需要 pass？</h3><p>Python 是缩进敏感的语言，代码块<strong>必须有缩进的内容</strong>，否则会报错（SyntaxError🤣）</p><p>比如，你想先写个 <code>if</code> 结构，但暂时没想好 <code>if</code> 满足时做什么：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="comment"># 这里还没想好写什么</span></span><br><span class="line"><span class="comment"># 报错：IndentationError: expected an indented block</span></span><br></pre></td></tr></table></figure><p>这时候，<code>pass</code> 就能救场：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="keyword">if</span> age &gt;= <span class="number">18</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 先占个位置，代码结构完整，不报错</span></span><br></pre></td></tr></table></figure><h3 id="四、实例演示：pass-在不同场景的使用"><a href="#四、实例演示：pass-在不同场景的使用" class="headerlink" title="四、实例演示：pass 在不同场景的使用"></a>四、实例演示：pass 在不同场景的使用</h3><h4 id="（一）实例1：for-循环中用-pass-占位"><a href="#（一）实例1：for-循环中用-pass-占位" class="headerlink" title="（一）实例1：for 循环中用 pass 占位"></a>（一）实例1：for 循环中用 pass 占位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> letter <span class="keyword">in</span> <span class="string">&#x27;Python&#x27;</span>:</span><br><span class="line">    <span class="keyword">if</span> letter == <span class="string">&#x27;h&#x27;</span>:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 当字母是 &#x27;h&#x27; 时，什么都不做（但结构完整）</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;这是 pass 块&#x27;</span>)  <span class="comment"># 可以在 pass 后写其他逻辑</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;当前字母:&#x27;</span>, letter)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前字母: P</span><br><span class="line">当前字母: y</span><br><span class="line">当前字母: t</span><br><span class="line">这是 pass 块</span><br><span class="line">当前字母: h</span><br><span class="line">当前字母: o</span><br><span class="line">当前字母: n</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>解释：<br>当 <code>letter=&#39;h&#39;</code> 时，进入 <code>if</code> 分支，执行 <code>pass</code>（啥都不做），然后执行 <code>print(&#39;这是 pass 块&#39;)</code> 和 <code>print(&#39;当前字母: h&#39;)</code>。<code>pass</code> 只是占位置，不影响其他代码执行。</p><h4 id="（二）实例2：定义空函数时用-pass"><a href="#（二）实例2：定义空函数时用-pass" class="headerlink" title="（二）实例2：定义空函数时用 pass"></a>（二）实例2：定义空函数时用 pass</h4><p>如果想先定义一个函数，但还没写实现逻辑，可以用 <code>pass</code> 占位：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 函数体不能为空，用 pass 占位</span></span><br><span class="line"></span><br><span class="line">my_function()  <span class="comment"># 调用函数，不会报错（虽然函数里啥都没做）</span></span><br></pre></td></tr></table></figure><h4 id="（三）实例3：定义空类时用-pass"><a href="#（三）实例3：定义空类时用-pass" class="headerlink" title="（三）实例3：定义空类时用 pass"></a>（三）实例3：定义空类时用 pass</h4><p>同理，定义类但暂时不想写属性&#x2F;方法时：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 类体不能为空，用 pass 占位</span></span><br><span class="line"></span><br><span class="line">obj = MyClass()  <span class="comment"># 实例化类，不会报错</span></span><br></pre></td></tr></table></figure><h4 id="（四）实例4：if-else-结构中用-pass-占位"><a href="#（四）实例4：if-else-结构中用-pass-占位" class="headerlink" title="（四）实例4：if-else 结构中用 pass 占位"></a>（四）实例4：if-else 结构中用 pass 占位</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">85</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 暂时没想好“良好”要做什么，先占位置</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;加油&quot;</span>)</span><br></pre></td></tr></table></figure><p>执行后，当 <code>score=85</code> 时，进入 <code>elif</code> 分支，执行 <code>pass</code>（啥都不做），然后程序继续往下走。</p><h3 id="五、pass-和-注释-有什么区别？"><a href="#五、pass-和-注释-有什么区别？" class="headerlink" title="五、pass 和 注释 有什么区别？"></a>五、pass 和 注释 有什么区别？</h3><ul><li><strong>注释</strong>（<code>#</code> 开头）：是给人看的说明，Python 会直接忽略，不会占代码结构的位置。如果用注释代替 <code>pass</code> 放在代码块里，会因为代码块为空报错</li><li><strong>pass</strong>：是给 Python 看的空操作，会让代码块有内容，避免语法错误，同时不影响程序执行逻辑</li></ul><p>比如，错误示范（用注释代替 pass）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 这里暂时没内容</span></span><br><span class="line"><span class="comment"># 报错：IndentationError: expected an indented block</span></span><br></pre></td></tr></table></figure><p>正确示范（用 pass）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 占位，不报错</span></span><br></pre></td></tr></table></figure><h3 id="六、pass-的使用场景总结"><a href="#六、pass-的使用场景总结" class="headerlink" title="六、pass 的使用场景总结"></a>六、pass 的使用场景总结</h3><ol><li><strong>代码草稿阶段</strong>：先把结构，比如循环、分支、函数、类搭好，用 <code>pass</code> 占住每个代码块的位置，后续再填充逻辑</li><li><strong>临时占位</strong>：调试代码时，想跳过某段逻辑但又不想删除代码，用 <code>pass</code> 暂时替代，保留结构。</li><li><strong>满足语法要求</strong>：Python 规定代码块不能空，<code>pass</code> 用来充数，让语法合法。</li></ol><h3 id="七、pass-只占位置，不影响逻辑"><a href="#七、pass-只占位置，不影响逻辑" class="headerlink" title="七、pass 只占位置，不影响逻辑"></a>七、pass 只占位置，不影响逻辑</h3><p><code>pass</code> 什么都不做，所以不会改变程序执行流程。比如在循环里用 <code>pass</code>，循环会正常执行迭代，只是当前迭代里 <code>pass</code> 所在的代码块啥都没干。</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">pass</span>  <span class="comment"># 当 i=1 时，啥都不做</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br></pre></td></tr></table></figure><p><code>i=1</code> 时，<code>pass</code> 只是占位置，<code>print(i)</code> 依然会执行~</p><p>学会 <code>pass</code> ，代码结构也不会因为暂时没内容而报错啦 🛠️ 写代码时，先搭框架，再填细节，这样效率会高很多</p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="一、基础热身：循环语法与控制流"><a href="#一、基础热身：循环语法与控制流" class="headerlink" title="一、基础热身：循环语法与控制流"></a>一、基础热身：循环语法与控制流</h3><h4 id="练习1：打印1-10中的偶数（用-for-循环-continue）"><a href="#练习1：打印1-10中的偶数（用-for-循环-continue）" class="headerlink" title="练习1：打印1~10中的偶数（用 for 循环 + continue）"></a>练习1：打印1~10中的偶数（用 for 循环 + continue）</h4><p><strong>要求</strong>：遍历1到10，跳过奇数，打印所有偶数。<br><strong>提示</strong>：用 <code>range(1, 11)</code> 生成1~10，判断 <code>i % 2 != 0</code> 时用 <code>continue</code> 跳过。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>):</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">2</span> != <span class="number">0</span>:  <span class="comment"># 如果是奇数</span></span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出：2 4 6 8 10</span></span><br></pre></td></tr></table></figure></details><h4 id="练习2：计算1-100的和（用-while-循环-break）"><a href="#练习2：计算1-100的和（用-while-循环-break）" class="headerlink" title="练习2：计算1~100的和（用 while 循环 + break）"></a>练习2：计算1~100的和（用 while 循环 + break）</h4><p><strong>要求</strong>：从1开始累加，当和超过2000时停止，打印最终的和与此时的数字。<br><strong>提示</strong>：用 <code>while True</code> 无限循环，累加后判断是否超过2000，超过则 <code>break</code>。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">0</span></span><br><span class="line">num = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    total += num</span><br><span class="line">    <span class="keyword">if</span> total &gt; <span class="number">2000</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    num += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;和为<span class="subst">&#123;total&#125;</span>，此时数字是<span class="subst">&#123;num&#125;</span>&quot;</span>)  <span class="comment"># 输出：和为2016，此时数字是63</span></span><br></pre></td></tr></table></figure></details><h4 id="练习3：用-pass-完善代码框架"><a href="#练习3：用-pass-完善代码框架" class="headerlink" title="练习3：用 pass 完善代码框架"></a>练习3：用 pass 完善代码框架</h4><p><strong>要求</strong>：补全以下代码，当 <code>score &gt;= 60</code> 时打印“及格”，否则用 <code>pass</code> 占位（不做任何事）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">55</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;及格&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 此处用 pass 占位</span></span><br><span class="line">    ______  <span class="comment"># 请填空</span></span><br></pre></td></tr></table></figure><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">55</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;及格&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 占位，不执行任何操作</span></span><br></pre></td></tr></table></figure></details><h3 id="二、进阶实战：循环嵌套与逻辑综合"><a href="#二、进阶实战：循环嵌套与逻辑综合" class="headerlink" title="二、进阶实战：循环嵌套与逻辑综合"></a>二、进阶实战：循环嵌套与逻辑综合</h3><h4 id="练习4：打印99乘法表（嵌套-for-循环）"><a href="#练习4：打印99乘法表（嵌套-for-循环）" class="headerlink" title="练习4：打印99乘法表（嵌套 for 循环）"></a>练习4：打印99乘法表（嵌套 for 循环）</h4><p><strong>要求</strong>：用嵌套循环打印经典的99乘法表，格式如下（只打印到 <code>i*j</code>，不超过10）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1×1=1</span><br><span class="line">2×1=2  2×2=4</span><br><span class="line">3×1=3  3×2=6  3×3=9</span><br><span class="line">...</span><br><span class="line">9×1=9  ...  9×9=81</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：外层循环控制行数 <code>i</code>（1<del>9），内层循环控制列数 <code>j</code>（1</del>i）。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i+<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;i&#125;</span>×<span class="subst">&#123;j&#125;</span>=<span class="subst">&#123;i*j&#125;</span>&quot;</span>, end=<span class="string">&#x27;\t&#x27;</span>)  <span class="comment"># \t 制表符对齐</span></span><br><span class="line">    <span class="built_in">print</span>()  <span class="comment"># 换行</span></span><br></pre></td></tr></table></figure></details><h4 id="练习5：寻找100-200中的质数（break-优化）"><a href="#练习5：寻找100-200中的质数（break-优化）" class="headerlink" title="练习5：寻找100~200中的质数（break 优化）"></a>练习5：寻找100~200中的质数（break 优化）</h4><p><strong>要求</strong>：找出100到200之间的所有质数（只能被1和自身整除的数），并打印。<br><strong>提示</strong>：</p><ul><li>质数判断：对于 <code>num</code>，检查2到 <code>sqrt(num)</code> 之间是否有除数，有则不是质数，用 <code>break</code> 提前退出检查。</li><li>用 <code>math.sqrt()</code> 计算平方根（需 <code>import math</code>）。</li></ul><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>, <span class="number">201</span>):</span><br><span class="line">    is_prime = <span class="literal">True</span>  <span class="comment"># 假设是质数</span></span><br><span class="line">    <span class="comment"># 检查除数从2到sqrt(num)</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">int</span>(math.sqrt(num)) + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span>:</span><br><span class="line">            is_prime = <span class="literal">False</span></span><br><span class="line">            <span class="keyword">break</span>  <span class="comment"># 找到除数，提前退出内层循环</span></span><br><span class="line">    <span class="keyword">if</span> is_prime:</span><br><span class="line">        <span class="built_in">print</span>(num, end=<span class="string">&#x27; &#x27;</span>)  <span class="comment"># 输出：101 103 107 ... 199</span></span><br></pre></td></tr></table></figure></details><h4 id="练习6：猜数字游戏（while-break-条件判断）"><a href="#练习6：猜数字游戏（while-break-条件判断）" class="headerlink" title="练习6：猜数字游戏（while + break + 条件判断）"></a>练习6：猜数字游戏（while + break + 条件判断）</h4><p><strong>要求</strong>：程序随机生成1~100的整数，用户输入数字猜大小，直到猜对为止，统计猜的次数。<br><strong>提示</strong>：</p><ul><li>用 <code>random.randint(1, 100)</code> 生成随机数（需 <code>import random</code>）。</li><li>用 <code>while True</code> 循环，猜对时 <code>break</code>，否则提示“太大”或“太小”。</li></ul><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">secret = random.randint(<span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;猜数字游戏（1~100）：&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    guess = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的数字：&quot;</span>))</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> guess &gt; secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;太大了！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> guess &lt; secret:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;太小了！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;恭喜猜对了！共猜了<span class="subst">&#123;count&#125;</span>次&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 猜对后退出循环</span></span><br></pre></td></tr></table></figure></details><h3 id="三、综合挑战：循环与列表-字符串结合"><a href="#三、综合挑战：循环与列表-字符串结合" class="headerlink" title="三、综合挑战：循环与列表&#x2F;字符串结合"></a>三、综合挑战：循环与列表&#x2F;字符串结合</h3><h4 id="练习7：筛选列表中的特定元素（for-continue）"><a href="#练习7：筛选列表中的特定元素（for-continue）" class="headerlink" title="练习7：筛选列表中的特定元素（for + continue）"></a>练习7：筛选列表中的特定元素（for + continue）</h4><p><strong>要求</strong>：给定列表 <code>numbers = [1, -2, 3, -4, 5, -6, 7, -8, 9]</code>，筛选出所有正数并计算它们的平方和。<br><strong>提示</strong>：遍历列表，遇到负数用 <code>continue</code> 跳过，正数则累加平方。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">1</span>, -<span class="number">2</span>, <span class="number">3</span>, -<span class="number">4</span>, <span class="number">5</span>, -<span class="number">6</span>, <span class="number">7</span>, -<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">sum_squares = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> num <span class="keyword">in</span> numbers:</span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 跳过非正数</span></span><br><span class="line">    sum_squares += num ** <span class="number">2</span>  <span class="comment"># 累加平方</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;正数平方和：<span class="subst">&#123;sum_squares&#125;</span>&quot;</span>)  <span class="comment"># 输出：1+9+25+49+81=165</span></span><br></pre></td></tr></table></figure></details><h4 id="练习8：字符串去重与逆序（循环-条件判断）"><a href="#练习8：字符串去重与逆序（循环-条件判断）" class="headerlink" title="练习8：字符串去重与逆序（循环 + 条件判断）"></a>练习8：字符串去重与逆序（循环 + 条件判断）</h4><p><strong>要求</strong>：给定字符串 <code>s = &quot;abracadabra&quot;</code>，完成以下操作：</p><ol><li>去重：保留首次出现的字符，删除后续重复字符（结果为 <code>&quot;abrcd&quot;</code>）。</li><li>逆序：将去重后的字符串逆序输出（结果为 <code>&quot;dc rba&quot;</code>）。<br><strong>提示</strong>：</li></ol><ul><li>去重：用空列表记录已出现的字符，遍历字符串时判断是否在列表中，不在则添加。</li><li>逆序：用 <code>[::-1]</code> 或循环倒序拼接。</li></ul><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abracadabra&quot;</span></span><br><span class="line">unique_chars = []</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 去重：保留首次出现的字符</span></span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> s:</span><br><span class="line">    <span class="keyword">if</span> char <span class="keyword">not</span> <span class="keyword">in</span> unique_chars:</span><br><span class="line">        unique_chars.append(char)</span><br><span class="line">unique_str = <span class="string">&#x27;&#x27;</span>.join(unique_chars)  <span class="comment"># 结果：&quot;abrcd&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 逆序输出</span></span><br><span class="line">reversed_str = unique_str[::-<span class="number">1</span>]  <span class="comment"># 切片逆序，结果：&quot;dc rba&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;去重后：<span class="subst">&#123;unique_str&#125;</span>，逆序后：<span class="subst">&#123;reversed_str&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure></details><h3 id="四、思考题：深度理解循环控制"><a href="#四、思考题：深度理解循环控制" class="headerlink" title="四、思考题：深度理解循环控制"></a>四、思考题：深度理解循环控制</h3><h4 id="练习9：以下代码的输出是什么？为什么？"><a href="#练习9：以下代码的输出是什么？为什么？" class="headerlink" title="练习9：以下代码的输出是什么？为什么？"></a>练习9：以下代码的输出是什么？为什么？</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;循环正常结束&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：<code>for-else</code> 结构中，<code>else</code> 只在循环正常结束（未被 <code>break</code> 终止）时执行。</p><details><summary>答案与解析</summary><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p><strong>解析</strong>：</p><ul><li><code>i=0</code>：打印0；<code>i=1</code>：打印1；<code>i=2</code>：<code>continue</code> 跳过打印；<code>i=3</code>：打印3后 <code>break</code> 终止循环，<code>else</code> 不执行。</details></li></ul><h4 id="练习10：用-while-循环实现“斐波那契数列”前10项"><a href="#练习10：用-while-循环实现“斐波那契数列”前10项" class="headerlink" title="练习10：用 while 循环实现“斐波那契数列”前10项"></a>练习10：用 while 循环实现“斐波那契数列”前10项</h4><p><strong>斐波那契数列</strong>：1, 1, 2, 3, 5, 8…（从第3项起，每项是前两项之和）。<br><strong>要求</strong>：用 <code>while</code> 循环生成前10项并打印。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a, b = <span class="number">1</span>, <span class="number">1</span>  <span class="comment"># 前两项</span></span><br><span class="line">count = <span class="number">2</span>  <span class="comment"># 已生成2项</span></span><br><span class="line"><span class="built_in">print</span>(a, b, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">10</span>:</span><br><span class="line">    c = a + b</span><br><span class="line">    <span class="built_in">print</span>(c, end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    a, b = b, c  <span class="comment"># 更新前两项</span></span><br><span class="line">    count += <span class="number">1</span>  <span class="comment"># 计数+1</span></span><br></pre></td></tr></table></figure></details>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 条件语句</title>
      <link href="/2025/10/27/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/"/>
      <url>/2025/10/27/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-条件语句"><a href="#Python-条件语句" class="headerlink" title="Python 条件语句"></a>Python 条件语句</h1><p>你可能会好奇：“程序怎么知道什么时候该做什么呢？” 比如，一个游戏程序怎么知道你得分够高了，该进入下一关？或者一个聊天软件怎么知道你输入的密码对不对？这就需要用到<strong>条件语句</strong></p><p>条件语句就像生活中的“如果…就…”。比如：“<strong>如果</strong>明天下雨，<strong>就</strong>带伞。” 程序里的条件语句也是这个道理，它会先判断一个<strong>条件</strong>是不是成立，即，是真的还是假的，然后根据判断结果决定接下来执行哪段代码。</p><hr><h2 id="一、什么是“条件”？真和假是什么意思？"><a href="#一、什么是“条件”？真和假是什么意思？" class="headerlink" title="一、什么是“条件”？真和假是什么意思？"></a>一、什么是“条件”？真和假是什么意思？</h2><p>在Python里，条件语句会判断一个“条件”的结果是<strong>真</strong>（True）还是<strong>假</strong>（False）。</p><ul><li><strong>什么是“真”（True）？</strong><ul><li>数字里，除了0以外的任何数字（比如1, 3.14, -5）都是True。</li><li>文字里，除了空字符串（<code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>）以外的任何内容，比如”hello”, “123”等等都是True。</li><li>简单说：<strong>非0、非空的值，都被看作是True。</strong></li></ul></li><li><strong>什么是“假”（False）？</strong><ul><li>数字0（比如0, 0.0）。</li><li>空字符串（<code>&quot;&quot;</code> 或 <code>&#39;&#39;</code>）。</li><li>还有一个专门的关键字 <code>None</code>，表示什么都没有</li><li>简单说：<strong>0、空值、None，都被看作是False。</strong></li></ul></li></ul><hr><h2 id="二、最基本的条件语句：if-语句"><a href="#二、最基本的条件语句：if-语句" class="headerlink" title="二、最基本的条件语句：if 语句"></a>二、最基本的条件语句：<code>if</code> 语句</h2><p><code>if</code> 语句是最简单的条件语句，它的意思是：“<strong>如果</strong>某个条件成立（是True），<strong>就</strong>执行下面的代码。”</p><h3 id="1-if-语句的基本格式"><a href="#1-if-语句的基本格式" class="headerlink" title="1. if 语句的基本格式"></a>1. <code>if</code> 语句的基本格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line">    当条件为 <span class="literal">True</span> 时，执行这里的代码</span><br><span class="line">    这行代码也会执行，因为它和上一行对齐了，即缩进相同</span><br><span class="line"><span class="comment"># 这行代码不在 if 里面，不管条件真假都会执行，因为它没有缩进</span></span><br></pre></td></tr></table></figure><ul><li><strong>重要规则：</strong><ul><li><code>if</code> 后面的判断条件<strong>必须</strong>加冒号 <code>:</code>。</li><li><code>if</code> 条件成立后要执行的代码块，<strong>必须</strong>向右缩进，通常是按一下Tab键，或者4个空格。Python就是通过缩进来区分哪些代码属于这个条件的。</li></ul></li></ul><h3 id="2-举个例子"><a href="#2-举个例子" class="headerlink" title="2. 举个例子"></a>2. 举个例子</h3><p>设想一下，你写了一个简单的程序，想知道变量 <code>name</code> 是不是 “python”。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;luren&#x27;</span>  <span class="comment"># 给变量 name 赋值为 &#x27;luren&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;python&#x27;</span>:  <span class="comment"># 判断 name 的值是不是等于 &#x27;python&#x27;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;welcome boss&#x27;</span>)  <span class="comment"># 如果条件成立，就打印这句话</span></span><br><span class="line"><span class="comment"># 如果条件不成立，上面这行缩进的代码就跳过不执行</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束了&#x27;</span>)  <span class="comment"># 这行没有缩进，所以不管 if 条件怎么样，都会执行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果是什么呢？</strong><br>因为 <code>name</code> 是 ‘luren’，不等于 ‘python’，所以 <code>if</code> 里面的 <code>print(&#39;welcome boss&#39;)</code> 不会执行。最后只会打印：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">程序结束了</span><br></pre></td></tr></table></figure><p>如果我们把 <code>name = &#39;luren&#39;</code> 改成 <code>name = &#39;python&#39;</code>，那么 <code>if</code> 条件成立，运行结果就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome boss</span><br><span class="line">程序结束了</span><br></pre></td></tr></table></figure><h3 id="3-if-语句的执行过程"><a href="#3-if-语句的执行过程" class="headerlink" title="3. if 语句的执行过程"></a>3. <code>if</code> 语句的执行过程</h3><div style="text-align:center">  <img src="/img_2/mermaid-1761619909752.png" alt="程序框图" style="width:50%;"></div><h2 id="三、“如果…不满足，就…”：if-else-语句"><a href="#三、“如果…不满足，就…”：if-else-语句" class="headerlink" title="三、“如果…不满足，就…”：if-else 语句"></a>三、“如果…不满足，就…”：<code>if-else</code> 语句</h2><p>有时候，我们不仅想知道“条件成立时做什么”，还想知道“条件<strong>不</strong>成立时做什么”。这时候就需要 <code>else</code> 了。<code>else</code> 的意思是“否则”。</p><h3 id="1-if-else-语句的基本格式"><a href="#1-if-else-语句的基本格式" class="headerlink" title="1. if-else 语句的基本格式"></a>1. <code>if-else</code> 语句的基本格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件:</span><br><span class="line">    当条件为 <span class="literal">True</span> 时，执行这里的代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    当条件为 <span class="literal">False</span> 时，执行这里的代码块</span><br><span class="line"><span class="comment"># 这行代码在 if-else 外面，一定会执行</span></span><br></pre></td></tr></table></figure><ul><li><code>else</code> 后面也要加冒号 <code>:</code>。</li><li><code>else</code> 下面的代码块也要缩进。</li></ul><h3 id="2-举个例子-1"><a href="#2-举个例子-1" class="headerlink" title="2. 举个例子"></a>2. 举个例子</h3><p>还是上面的 <code>name</code> 例子，我们可以加上 <code>else</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&#x27;luren&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> name == <span class="string">&#x27;python&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;welcome boss&#x27;</span>)  <span class="comment"># 条件成立（True），执行这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(name)  <span class="comment"># 条件不成立（False），执行这个</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;程序结束了&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong><br>因为 <code>name</code> 是 ‘luren’，<code>if</code> 条件不成立，所以执行 <code>else</code> 里面的 <code>print(name)</code>，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">luren</span><br><span class="line">程序结束了</span><br></pre></td></tr></table></figure><p>如果 <code>name</code> 是 ‘python’，则输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">welcome boss</span><br><span class="line">程序结束了</span><br></pre></td></tr></table></figure><h3 id="3-if-else-的执行过程"><a href="#3-if-else-的执行过程" class="headerlink" title="3. if-else 的执行过程"></a>3. <code>if-else</code> 的执行过程</h3><div style="text-align:center">  <img src="/img_2/mermaid-1761620133851.png" alt="" style="width:50%;" ></div><hr><h2 id="四、“如果…就…；否则如果…就…；否则就…”：if-elif-else-语句"><a href="#四、“如果…就…；否则如果…就…；否则就…”：if-elif-else-语句" class="headerlink" title="四、“如果…就…；否则如果…就…；否则就…”：if-elif-else 语句"></a>四、“如果…就…；否则如果…就…；否则就…”：<code>if-elif-else</code> 语句</h2><p>生活中我们经常会遇到多种选择。比如：“<strong>如果</strong>考试得了90分以上，<strong>就</strong>奖励玩具；<strong>否则如果</strong>得了80分以上，<strong>就</strong>奖励零食；<strong>否则</strong>，就继续努力。”</p><p>在Python里，<code>elif</code> 就是“<strong>否则如果</strong>”的意思，可以帮我们处理多种条件判断。</p><h3 id="1-if-elif-else-语句的基本格式"><a href="#1-if-elif-else-语句的基本格式" class="headerlink" title="1. if-elif-else 语句的基本格式"></a>1. <code>if-elif-else</code> 语句的基本格式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    当条件<span class="number">1</span>为 <span class="literal">True</span> 时，执行这里的代码块</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    当条件<span class="number">1</span>为 <span class="literal">False</span>，但条件<span class="number">2</span>为 <span class="literal">True</span> 时，执行这里的代码块</span><br><span class="line"><span class="keyword">elif</span> 判断条件<span class="number">3</span>:</span><br><span class="line">    当条件<span class="number">1</span>和条件<span class="number">2</span>都为 <span class="literal">False</span>，但条件<span class="number">3</span>为 <span class="literal">True</span> 时，执行这里的代码块</span><br><span class="line"><span class="meta">... </span>(可以有更多的 <span class="keyword">elif</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    当所有前面的条件都为 <span class="literal">False</span> 时，执行这里的代码块</span><br></pre></td></tr></table></figure><ul><li><code>elif</code> 是 <code>else if</code> 的缩写。</li><li><code>elif</code> 后面也要加冒号 <code>:</code>，代码块也要缩进。</li><li><code>else</code> 是可选的，放在最后，表示所有条件都不满足时的情况。</li></ul><h3 id="2-举个例子-2"><a href="#2-举个例子-2" class="headerlink" title="2. 举个例子"></a>2. 举个例子</h3><p>假设我们根据数字 <code>num</code> 的值输出不同的身份：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">5</span>  <span class="comment"># 我们来看看 num=5 会输出什么</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> num == <span class="number">3</span>:          <span class="comment"># 判断 num 的值是不是3</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;boss&#x27;</span>)     <span class="comment"># 如果是3，打印 &#x27;boss&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">2</span>:        <span class="comment"># 如果不是3，再判断是不是2</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;user&#x27;</span>)     <span class="comment"># 如果是2，打印 &#x27;user&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> num == <span class="number">1</span>:        <span class="comment"># 如果不是2，再判断是不是1</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;worker&#x27;</span>)   <span class="comment"># 如果是1，打印 &#x27;worker&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> num &lt; <span class="number">0</span>:         <span class="comment"># 如果不是1，再判断是不是小于0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;error&#x27;</span>)    <span class="comment"># 如果小于0，打印 &#x27;error&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:                 <span class="comment"># 如果上面所有条件都不满足</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;roadman&#x27;</span>)  <span class="comment"># 就打印 &#x27;roadman&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>思考一下：</strong> <code>num</code> 是5。</p><ul><li><code>num ==3</code>? 不是（False）。</li><li><code>num ==2</code>? 不是（False）。</li><li><code>num ==1</code>? 不是（False）。</li><li><code>num &lt;0</code>? 不是（False）。</li><li>所以执行 <code>else</code>，输出：<code>roadman</code>。</li></ul><h3 id="3-if-else-else-的执行过程"><a href="#3-if-else-else-的执行过程" class="headerlink" title="3. if-else-else 的执行过程"></a>3. <code>if-else-else</code> 的执行过程</h3><div style="text-align:center">  <img src="/img_2/mermaid-1761620291553.png" alt="" style="width:50%;" ></div>---<h2 id="五、多个条件一起判断：and-和-or"><a href="#五、多个条件一起判断：and-和-or" class="headerlink" title="五、多个条件一起判断：and 和 or"></a>五、多个条件一起判断：<code>and</code> 和 <code>or</code></h2><p>有时候，我们的条件不是单一的，可能需要同时满足几个条件，或者满足其中一个条件就可以。这时候就要用到 <code>and</code>（表示并且&#x2F;与）和 <code>or</code>（表示或者&#x2F;或）。</p><h3 id="1-and（并且）：所有条件都为-True，结果才是-True"><a href="#1-and（并且）：所有条件都为-True，结果才是-True" class="headerlink" title="1. and（并且）：所有条件都为 True，结果才是 True"></a>1. <code>and</code>（并且）：所有条件都为 True，结果才是 True</h3><p>格式：<code>条件A and 条件B</code></p><ul><li>只有当 <strong>条件A为True，并且条件B也为True</strong> 时，整个表达式才是True。</li><li>只要有一个条件是False，整个表达式就是False。</li></ul><p><strong>例子：判断一个数字是否在0到10之间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">9</span></span><br><span class="line"><span class="keyword">if</span> num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">10</span>:  <span class="comment"># num 大于等于0 并且 num 小于等于10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 9满足条件，所以会打印 &#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="2-or（或者）：只要有一个条件为-True，结果就是-True"><a href="#2-or（或者）：只要有一个条件为-True，结果就是-True" class="headerlink" title="2. or（或者）：只要有一个条件为 True，结果就是 True"></a>2. <code>or</code>（或者）：只要有一个条件为 True，结果就是 True</h3><p>格式：<code>条件A or 条件B</code></p><ul><li>只要 <strong>条件A为True，或者条件B为True</strong>，或者两者都为True，整个表达式就是True。</li><li>只有当所有条件都为False时，整个表达式才是False。</li></ul><p><strong>例子：判断一个数字是否小于0或者大于10</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> num &lt; <span class="number">0</span> <span class="keyword">or</span> num &gt; <span class="number">10</span>:  <span class="comment"># num 小于0 或者 num 大于10</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;undefine&#x27;</span>)  <span class="comment"># 10不小于0，也不大于10，所以条件是False，执行else，打印 &#x27;undefine&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="3-更复杂的组合：使用括号"><a href="#3-更复杂的组合：使用括号" class="headerlink" title="3. 更复杂的组合：使用括号 ()"></a>3. 更复杂的组合：使用括号 <code>()</code></h3><p>如果条件更复杂，可以用括号 <code>()</code> 来改变判断的顺序，就像数学里先算括号里的一样。</p><p><strong>例子：判断一个数字是否在0<del>5之间，或者在10</del>15之间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="number">8</span></span><br><span class="line"><span class="keyword">if</span> (num &gt;= <span class="number">0</span> <span class="keyword">and</span> num &lt;= <span class="number">5</span>) <span class="keyword">or</span> (num &gt;= <span class="number">10</span> <span class="keyword">and</span> num &lt;= <span class="number">15</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;undefine&#x27;</span>)  <span class="comment"># 8不在0-5，也不在10-15，所以打印 &#x27;undefine&#x27;</span></span><br></pre></td></tr></table></figure><p>这里 <code>(num &gt;= 0 and num &lt;=5)</code> 是一个整体条件，<code>(num &gt;=10 and num &lt;=15)</code> 是另一个整体条件，用 <code>or</code> 连接，表示满足其中一个整体条件即可</p><hr><h2 id="六、简单的一行-if-语句（了解即可）"><a href="#六、简单的一行-if-语句（了解即可）" class="headerlink" title="六、简单的一行 if 语句（了解即可）"></a>六、简单的一行 <code>if</code> 语句（了解即可）</h2><p>如果 <code>if</code> 条件成立后要执行的代码非常简单，只有一行，Python允许我们把它和 <code>if</code> 写在同一行。</p><p><strong>例子：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var = <span class="number">100</span></span><br><span class="line"><span class="keyword">if</span> var == <span class="number">100</span>: <span class="built_in">print</span>(<span class="string">&quot;变量 var 的值为100&quot;</span>)  <span class="comment"># 如果 var 等于100，就打印这句话</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Good bye!&quot;</span>)  <span class="comment"># 这行总会执行</span></span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">变量 var 的值为100</span><br><span class="line">Good bye!</span><br></pre></td></tr></table></figure><p>这种写法虽然简洁，但如果代码多了就不推荐了，会影响可读性</p><hr><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="一、基础练习"><a href="#一、基础练习" class="headerlink" title="一、基础练习"></a>一、基础练习</h3><h4 id="练习1：判断奇偶数"><a href="#练习1：判断奇偶数" class="headerlink" title="练习1：判断奇偶数"></a>练习1：判断奇偶数</h4><p><strong>题目：</strong> 输入一个整数，判断它是奇数还是偶数。<br>（提示：一个数除以2如果余数为0就是偶数，否则是奇数。用 <code>%</code> 运算符求余数。）</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入一个整数: &quot;</span>))  <span class="comment"># input()获取用户输入，int()转换为整数</span></span><br><span class="line"><span class="keyword">if</span> num % <span class="number">2</span> == <span class="number">0</span>:  <span class="comment"># % 是取余运算符，如果除以2余数是0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> 是偶数&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;num&#125;</span> 是奇数&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ul><li>输入 4 → 4 是偶数</li><li>输入 7 → 7 是奇数</details></li></ul><h4 id="练习2：比较两个数的大小"><a href="#练习2：比较两个数的大小" class="headerlink" title="练习2：比较两个数的大小"></a>练习2：比较两个数的大小</h4><p><strong>题目：</strong> 输入两个整数，比较它们的大小，并输出较大的那个数。如果两个数相等，也提示。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第一个整数: &quot;</span>))</span><br><span class="line">b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入第二个整数: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> a &gt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span> 大于 <span class="subst">&#123;b&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> a &lt; b:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;b&#125;</span> 大于 <span class="subst">&#123;a&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;a&#125;</span> 和 <span class="subst">&#123;b&#125;</span> 相等&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ul><li>输入 5 和 3 → 5 大于 3</li><li>输入 2 和 7 → 7 大于 2</li><li>输入 4 和 4 → 4 和 4 相等</details></li></ul><h4 id="练习3：判断成绩等级"><a href="#练习3：判断成绩等级" class="headerlink" title="练习3：判断成绩等级"></a>练习3：判断成绩等级</h4><p><strong>题目：</strong> 输入一个学生的分数（0-100），根据分数判断等级：</p><ul><li>90-100分：A</li><li>80-89分：B</li><li>70-79分：C</li><li>60-69分：D</li><li>0-59分：F</li><li>如果分数不在0-100之间，提示“分数输入错误！”</li></ul><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="built_in">float</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入学生分数（0-100）: &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> score &lt; <span class="number">0</span> <span class="keyword">or</span> score &gt; <span class="number">100</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;分数输入错误！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：A&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:  <span class="comment"># 能到这里，说明分数 &lt;90</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：B&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">70</span>:  <span class="comment"># 能到这里，说明分数 &lt;80</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：C&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">60</span>:  <span class="comment"># 能到这里，说明分数 &lt;70</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：D&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># 能到这里，说明分数 &lt;60 且 &gt;=0 (因为前面排除了&lt;0的情况)</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;等级：F&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ul><li>输入 95 → 等级：A</li><li>输入 83 → 等级：B</li><li>输入 77 → 等级：C</li><li>输入 62 → 等级：D</li><li>输入 45 → 等级：F</li><li>输入 105 → 分数输入错误！</li><li>输入 -5 → 分数输入错误！</details></li></ul><hr><h3 id="二、综合练习"><a href="#二、综合练习" class="headerlink" title="二、综合练习"></a>二、综合练习</h3><h4 id="练习4：简单的登录验证"><a href="#练习4：简单的登录验证" class="headerlink" title="练习4：简单的登录验证"></a>练习4：简单的登录验证</h4><p><strong>题目：</strong> 假设系统中有一个预设的用户名 “admin” 和密码 “123456”。<br>请用户输入用户名和密码，如果两者都正确，打印“登录成功！”；<br>如果用户名错误，打印“用户名不存在！”；<br>如果用户名正确但密码错误，打印“密码错误！”。</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 预设的正确用户名和密码</span></span><br><span class="line">correct_username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">correct_password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取用户输入</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名: &quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断</span></span><br><span class="line"><span class="keyword">if</span> username != correct_username:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户名不存在！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 用户名正确了，再判断密码</span></span><br><span class="line">    <span class="keyword">if</span> password == correct_password:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;登录成功！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>或者，使用逻辑运算符合并条件：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">correct_username = <span class="string">&quot;admin&quot;</span></span><br><span class="line">correct_password = <span class="string">&quot;123456&quot;</span></span><br><span class="line"></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名: &quot;</span>)</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码: &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> username == correct_username <span class="keyword">and</span> password == correct_password:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登录成功！&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> username != correct_username:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用户名不存在！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:  <span class="comment"># username 正确，但 password 错误</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;密码错误！&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ul><li>用户名：admin，密码：123456 → 登录成功！</li><li>用户名：user，密码：123456 → 用户名不存在！</li><li>用户名：admin，密码：wrong → 密码错误！</details></li></ul><h4 id="练习5：电影票价计算"><a href="#练习5：电影票价计算" class="headerlink" title="练习5：电影票价计算"></a>练习5：电影票价计算</h4><p><strong>题目：</strong> 某电影院根据观众的年龄和是否为会员来决定票价：</p><ul><li>会员：<ul><li>年龄 &lt; 18岁：票价 30元</li><li>年龄 &gt;&#x3D; 18岁：票价 40元</li></ul></li><li>非会员：<ul><li>年龄 &lt; 18岁：票价 45元</li><li>年龄 &gt;&#x3D; 18岁：票价 55元<br>请用户输入年龄和是否为会员（输入 “y” 或 “Y” 表示会员，其他表示非会员），计算并输出票价。</li></ul></li></ul><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入您的年龄: &quot;</span>))</span><br><span class="line">is_member_input = <span class="built_in">input</span>(<span class="string">&quot;您是会员吗？(y/Y 表示是，其他表示否): &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为会员</span></span><br><span class="line">is_member = is_member_input.lower() == <span class="string">&#x27;y&#x27;</span>  <span class="comment"># lower() 把输入转为小写，再比较是否是 &#x27;y&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> is_member:</span><br><span class="line">    <span class="comment"># 会员逻辑</span></span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">        price = <span class="number">30</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        price = <span class="number">40</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 非会员逻辑</span></span><br><span class="line">    <span class="keyword">if</span> age &lt; <span class="number">18</span>:</span><br><span class="line">        price = <span class="number">45</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        price = <span class="number">55</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;您的电影票价是：<span class="subst">&#123;price&#125;</span>元&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>测试：</strong></p><ul><li>年龄15，输入y → 30元</li><li>年龄20，输入Y → 40元</li><li>年龄12，输入n → 45元</li><li>年龄30，输入m → 55元</details></li></ul><hr><h3 id="三、挑战练习（选做）"><a href="#三、挑战练习（选做）" class="headerlink" title="三、挑战练习（选做）"></a>三、挑战练习（选做）</h3><h4 id="练习6：石头剪刀布"><a href="#练习6：石头剪刀布" class="headerlink" title="练习6：石头剪刀布"></a>练习6：石头剪刀布</h4><p><strong>题目：</strong> 简单实现石头剪刀布游戏。</p><ol><li>程序随机选择石头、剪刀或布（用数字1代表石头，2代表剪刀，3代表布）。</li><li>用户输入自己的选择（1&#x2F;2&#x2F;3）。</li><li>判断胜负规则：<ul><li>石头(1) 胜 剪刀(2)</li><li>剪刀(2) 胜 布(3)</li><li>布(3) 胜 石头(1)</li><li>双方选择相同则平局。</li></ul></li><li>输出电脑的选择和比赛结果</li></ol><p>（提示：可以使用 <code>random.randint(1,3)</code> 来生成电脑的随机选择，需要先导入 random 模块：<code>import random</code>）</p><details><summary>参考答案</summary><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="comment"># 电脑随机选择 (1:石头, 2:剪刀, 3:布)</span></span><br><span class="line">computer_choice = random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户输入选择</span></span><br><span class="line">user_choice = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你的选择 (1:石头, 2:剪刀, 3:布): &quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 确保用户输入有效 (这一步可以省略，作为挑战可以先不考虑输入错误的情况)</span></span><br><span class="line"><span class="keyword">if</span> user_choice <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;输入错误！请输入1、2或3。&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 显示双方选择</span></span><br><span class="line">    choice_names = &#123;<span class="number">1</span>: <span class="string">&#x27;石头&#x27;</span>, <span class="number">2</span>: <span class="string">&#x27;剪刀&#x27;</span>, <span class="number">3</span>: <span class="string">&#x27;布&#x27;</span>&#125;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;电脑选择：<span class="subst">&#123;choice_names[computer_choice]&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;你的选择：<span class="subst">&#123;choice_names[user_choice]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断胜负</span></span><br><span class="line">    <span class="keyword">if</span> user_choice == computer_choice:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平局！&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> (user_choice == <span class="number">1</span> <span class="keyword">and</span> computer_choice == <span class="number">2</span>) <span class="keyword">or</span> \</span><br><span class="line">         (user_choice == <span class="number">2</span> <span class="keyword">and</span> computer_choice == <span class="number">3</span>) <span class="keyword">or</span> \</span><br><span class="line">         (user_choice == <span class="number">3</span> <span class="keyword">and</span> computer_choice == <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你赢了！&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;你输了！&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>游戏逻辑解释：</strong><br>当 <code>user_choice != computer_choice</code> 时，只有三种情况用户会赢：<br>(user_choice&#x3D;1 且 computer_choice&#x3D;2) OR (user_choice&#x3D;2 且 computer_choice&#x3D;3) OR (user_choice&#x3D;3 且 computer_choice&#x3D;1)。其他情况就是用户输了。</p><p><strong>测试（注意：每次运行结果可能不同，因为电脑是随机的）：</strong></p><ul><li>电脑选1，用户选1 → 平局</li><li>电脑选2，用户选1 → 你赢了</li><li>电脑选3，用户选1 → 你输了 (因为布赢石头)</li><li>电脑选1，用户选2 → 你输了 (因为石头赢剪刀)</li><li>电脑选2，用户选2 → 平局</li><li>电脑选3，用户选2 → 你赢了 (因为剪刀赢布)</li><li>电脑选1，用户选3 → 你赢了 (因为布赢石头)</li><li>电脑选2，用户选3 → 你输了 (因为剪刀赢布)</li><li>电脑选3，用户选3 → 平局</details></li></ul><hr><p>希望这些练习能帮助你更好地理解和掌握 Python 条件语句！<strong>一定要自己动手敲代码，不要只是看答案哦！</strong> 遇到问题多思考，多尝试修改代码，这样才能真正学会。加油！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 运算符</title>
      <link href="/2025/10/26/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/10/26/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="Python运算符"><a href="#Python运算符" class="headerlink" title="Python运算符"></a>Python运算符</h1><p>你可以把运算符看作成我们日常生活中做计算或者做比较时用到的那些小动作或小符号。它们帮助我们对数据进行各种操作。</p><h2 id="一、到底什么是运算符？"><a href="#一、到底什么是运算符？" class="headerlink" title="一、到底什么是运算符？"></a><strong>一、到底什么是运算符？</strong></h2><p>我们先从一个简单的数学题开始： <code>2 + 3 = 5</code>。</p><ul><li>在这个式子中，<code>2</code> 和 <code>3</code> 是我们要计算的<strong>数字</strong>，我们给它们起个专业点的名字叫 <strong>“操作数”</strong> (就像是被“操作”的数字)。</li><li>中间的 <code>+</code> 号，就是<strong>运算符</strong>！它告诉我们要对 <code>2</code> 和 <code>3</code> 做什么操作——这里是“相加”。</li><li>最后的 <code>5</code> 就是这个操作的<strong>结果</strong>。</li></ul><p>所以，<strong>运算符</strong> 就是用来对 <strong>操作数</strong> 进行某种运算处理的特殊符号。没有运算符，我们就没法让数字或其他数据进行互动</p><p>Python 语言支持以下类型的运算符：</p><ul><li><a href="#算术运算符">算术运算符</a></li><li><a href="#比较运算符">比较（关系）运算符</a></li><li><a href="#赋值运算符">赋值运算符</a></li><li><a href="#逻辑运算符">逻辑运算符</a></li><li><a href="#位运算符">位运算符</a></li><li><a href="#成员运算符">成员运算符</a></li><li><a href="#身份运算符">身份运算符</a></li><li><a href="#运算符优先级">运算符优先级</a></li></ul><p>接下里，我将一个个来介绍 Python 的运算符</p><h2 id="算术运算符">算术运算符</h2><p>Python 的算术运算符就像数学课本里的“+”、“-”、“×”、“÷”一样，用来对数字进行各种计算</p><p>假设我们现在有两个“盒子”（即上一部分内容中讲的变量），里面分别装着两个数字：</p><ul><li>变量 <code>a</code>，里面装着数字 <code>10</code></li><li>变量 <code>b</code>，里面装着数字 <code>20</code></li></ul><p>接下来，我们就用 <code>a</code> 和 <code>b</code> 作为例子，看看 Python 能帮我们做哪些数学运算。</p><hr><h3 id="一、最常用的加减乘除"><a href="#一、最常用的加减乘除" class="headerlink" title="一、最常用的加减乘除"></a>一、最常用的加减乘除</h3><h4 id="1-1-加法-：把两个数合起来"><a href="#1-1-加法-：把两个数合起来" class="headerlink" title="1.1 加法 +：把两个数合起来"></a>1.1 加法 <code>+</code>：把两个数合起来</h4><p><strong>🌰</strong>：就像你有 <code>a</code> 块糖，又得到 <code>b</code>  块糖，现在一共有多少块？</p><p><strong>写法</strong>：<code>a + b</code></p><h4 id="1-2-减法-：从一个数里去掉另一个数"><a href="#1-2-减法-：从一个数里去掉另一个数" class="headerlink" title="1.2 减法 -：从一个数里去掉另一个数"></a>1.2 减法 <code>-</code>：从一个数里去掉另一个数</h4><p><strong>🌰</strong>：你有 <code>a</code>  块糖，给了别人 <code>b</code>  块，还剩多少块？或者，<code>a</code> 比 <code>b</code> 少多少？</p><p><strong>写法</strong>：<code>a - b</code> </p><h4 id="1-3-乘法-：几个相同的数加起来"><a href="#1-3-乘法-：几个相同的数加起来" class="headerlink" title="1.3 乘法 *：几个相同的数加起来"></a>1.3 乘法 <code>*</code>：几个相同的数加起来</h4><p><strong>🌰</strong>：你每天吃 <code>a</code>  颗草莓，吃了 <code>b</code>  天，一共吃了多少颗？</p><p><strong>写法</strong>：<code>a * b</code> （注意，乘法符号是 <code>*</code> 星号，不是 <code>×</code>）</p><h4 id="1-4-除法-：把一个数平均分成几份"><a href="#1-4-除法-：把一个数平均分成几份" class="headerlink" title="1.4 除法 /：把一个数平均分成几份"></a>1.4 除法 <code>/</code>：把一个数平均分成几份</h4><p><strong>🌰</strong>：你有 <code>b</code> 颗糖，平均分给 <code>a</code>  个小朋友，每个小朋友能得到几颗？</p><p><strong>写法</strong>：<code>b / a</code> </p><p><strong>特别提醒</strong>：<br>在 Python 里，除法运算的结果通常是一个带小数点的数，我们叫它<strong>浮点数</strong>，比如 <code>5 / 2</code> 会得到 <code>2.5</code>。<br>但是！如果你的 Python 版本非常非常旧，比如 Python 2.x，两个整数相除（比如 <code>5 / 2</code>）可能会得到 <code>2</code>（只保留整数部分）。不过现在大家一般都用比较新的 Python 3 啦，所以放心用 <code>/</code> 即可</p><hr><h3 id="二、取余数和整除"><a href="#二、取余数和整除" class="headerlink" title="二、取余数和整除"></a>二、取余数和整除</h3><p>除了上面最基本的加减乘除，Python 还有两个在数学计算中也很常用的运算符。</p><h4 id="2-1-取模（即求余数）-：平均分完后还剩多少"><a href="#2-1-取模（即求余数）-：平均分完后还剩多少" class="headerlink" title="2.1 取模（即求余数） %：平均分完后还剩多少"></a>2.1 取模（即求余数） <code>%</code>：平均分完后还剩多少</h4><p><strong>🌰</strong>：你有 <code>b</code> 个苹果，每 <code>a</code>  个装一袋，能装满几袋？还会剩下几个苹果？<code>%</code> 就是帮我们求“剩下几个”的。</p><p><strong>写法</strong>：<code>b % a</code></p><p><strong>结论</strong>：<code>20 % 10</code> 的结果是 <code>0</code><br>再比如：<code>7 % 3</code>，<code>3*2=6</code>，<code>7-6=1</code>，所以结果是 <code>1</code>。</p><h4 id="2-2-取整除（地板除）-：平均分完后能装满几整份"><a href="#2-2-取整除（地板除）-：平均分完后能装满几整份" class="headerlink" title="2.2 取整除（地板除） //：平均分完后能装满几整份"></a>2.2 取整除（地板除） <code>//</code>：平均分完后能装满几整份</h4><p><strong>🌰</strong>：接着上面的例子，<code>b</code>  个苹果，每 <code>a</code>  个装一袋，能装满几袋？<code>//</code> 就是帮我们求“能装满几袋”的。只保留整数部分，而且是向下取整</p><p><strong>写法</strong>：<code>b // a</code></p><p><strong>结论</strong>：</p><ul><li><code>20 // 10</code> 的结果是 <code>2</code>。</li><li><code>9 // 2</code>：<code>2*4=8</code>，<code>9-8=1</code>，所以能装满 <code>4</code> 袋，结果是 <code>4</code>。</li><li>再看一个带负数的：<code>-9 // 2</code>。<code>2*(-5) = -10</code>，<code>-9</code> 比 <code>-10</code> 大一点，所以向下取整就是 <code>-5</code>。这个刚开始可能有点绕，多想想<strong>向下取整</strong></li></ul><hr><h3 id="三、乘方"><a href="#三、乘方" class="headerlink" title="三、乘方 **"></a>三、乘方 <code>**</code></h3><p><strong>🌰</strong>：计算一个数的几次方。比如 <code>a</code> 的 <code>b</code> 次方，就是 <code>b</code> 个 <code>a</code> 相乘。</p><p><strong>写法</strong>：<code>a ** b</code> （两个星号连在一起）</p><p><strong>结论</strong>：<code>a = 10</code>，<code>b = 20</code>，<code>a ** b</code> 就是 <code>10</code> 的 <code>20</code> 次方。<br><code>10**2</code> 是 <code>10*10=100</code>，<br><code>10**3</code> 是 <code>10*10*10=1000</code>，<br>那 <code>10**20</code> 就是 <code>1</code> 后面跟着 <code>20</code> 个 <code>0</code>，结果是 <code>100000000000000000000</code>。</p><h3 id="算术运算符表"><a href="#算术运算符表" class="headerlink" title="算术运算符表"></a>算术运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">叫什么名字</th><th align="left">是干嘛的</th><th align="left">简单例子 (x 和 y 是数字)</th></tr></thead><tbody><tr><td align="left"><code>+</code></td><td align="left">加号（加法）</td><td align="left">把 x 和 y 加起来</td><td align="left"><code>x + y</code></td></tr><tr><td align="left"><code>-</code></td><td align="left">减号（减法）</td><td align="left">用 x 减去 y</td><td align="left"><code>x - y</code></td></tr><tr><td align="left"><code>*</code></td><td align="left">星号（乘法）</td><td align="left">把 x 和 y 乘起来</td><td align="left"><code>x * y</code></td></tr><tr><td align="left"><code>/</code></td><td align="left">斜杠（除法）</td><td align="left">用 x 除以 y，结果是小数</td><td align="left"><code>x / y</code></td></tr><tr><td align="left"><code>%</code></td><td align="left">百分号（取模）</td><td align="left">用 x 除以 y，结果是剩下的余数</td><td align="left"><code>x % y</code></td></tr><tr><td align="left"><code>**</code></td><td align="left">双星号（乘方）</td><td align="left">x 的 y 次方，比如 <code>2**3</code> 是 8</td><td align="left"><code>x ** y</code></td></tr><tr><td align="left"><code>//</code></td><td align="left">双斜杠（取整除）</td><td align="left">用 x 除以 y，结果是商的整数部分（向下取整）</td><td align="left"><code>x // y</code></td></tr></tbody></table><hr><h2 id="比较运算符">比较（关系）运算符</h2><p>就像我们平时会比较两个苹果哪个大、两块糖哪个甜一样，在 Python 里，我们也可以比较两个数字大小、是否相等。</p><p>比较的结果只会有两种：<strong>是</strong> 或者 <strong>不是</strong>。在 Python 里，这两种结果用 <code>True</code>（真，表示“是”）和 <code>False</code>（假，表示“不是”）来表示</p><p>假设我们还是有两个变量：</p><ul><li>变量 <code>a</code>，里面装着数字 <code>10</code></li><li>变量 <code>b</code>，里面装着数字 <code>20</code></li></ul><p>我们就用 <code>a</code> 和 <code>b</code> 来看看能进行哪些比较。</p><hr><h3 id="一、判断“等于”和“不等于”"><a href="#一、判断“等于”和“不等于”" class="headerlink" title="一、判断“等于”和“不等于”"></a>一、判断“等于”和“不等于”</h3><h4 id="1-1-等于-：它们俩一样吗？"><a href="#1-1-等于-：它们俩一样吗？" class="headerlink" title="1.1 等于 ==：它们俩一样吗？"></a>1.1 等于 <code>==</code>：它们俩一样吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值和 <code>b</code> 的值是不是<strong>完全一样</strong>。<br><strong>重要</strong>：这里是两个连在一起的等号 <code>==</code>，而不是一个等号 <code>=</code>。一个等号是用来<strong>赋值</strong>的（即，把东西放进盒子），两个等号才是用来比较是否相等的（<strong>再次强调！！！</strong>）</p><p><strong>写法</strong>：<code>a == b</code></p><p><strong>🌰</strong>：<code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 和 <code>20</code> 一样吗？当然不一样！所以 <code>a == b</code> 的结果是 <code>False</code>。</p><p>如果 <code>a</code> 和 <code>b</code> 都是 <code>10</code>，那么 <code>a == b</code> 的结果就是 <code>True</code>。</p><h4 id="1-2-不等于-：它们俩不一样吗？"><a href="#1-2-不等于-：它们俩不一样吗？" class="headerlink" title="1.2 不等于 !=：它们俩不一样吗？"></a>1.2 不等于 <code>!=</code>：它们俩不一样吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值和 <code>b</code> 的值是不是<strong>不一样</strong>。</p><p><strong>写法</strong>：<code>a != b</code></p><p><strong>🌰</strong>：<code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 和 <code>20</code> 不一样吗？是的！所以 <code>a != b</code> 的结果是 <code>True</code>。</p><p>如果 <code>a</code> 和 <code>b</code> 都是 <code>10</code>，那么 <code>a != b</code> 的结果就是 <code>False</code>。</p><h4 id="了解即可，不用学"><a href="#了解即可，不用学" class="headerlink" title="&lt;&gt; (了解即可，不用学)"></a><code>&lt;&gt; </code>(了解即可，不用学)</h4><p>你可能会看到一个长的像 <code>&lt;&gt;</code> 的符号，它在很久很久以前的 Python 版本（比如 Python 2.x）里也是表示“不等于”，和 <code>!=</code> 一样。但是现在的 Python 3 版本已经不用它了，所以我们只需要记住 <code>!=</code> 即可</p><hr><h3 id="二、判断大小"><a href="#二、判断大小" class="headerlink" title="二、判断大小"></a>二、判断大小</h3><h4 id="2-1-大于-：左边的比右边的大吗？"><a href="#2-1-大于-：左边的比右边的大吗？" class="headerlink" title="2.1 大于 &gt;：左边的比右边的大吗？"></a>2.1 大于 <code>&gt;</code>：左边的比右边的大吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值是不是<strong>大于</strong> <code>b</code> 的值。</p><p><strong>写法</strong>：<code>a &gt; b</code></p><p><strong>🌰</strong>：<code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 大于 <code>20</code> 吗？<code>10 &gt; 20</code>？不是的！所以结果是 <code>False</code>。<br>反过来，如果问 <code>b &gt; a</code> （<code>20 &gt; 10</code>），那结果就是 <code>True</code>。</p><h4 id="2-2-小于"><a href="#2-2-小于" class="headerlink" title="2.2 小于 &lt;：左边的比右边的小吗？"></a>2.2 小于 <code>&lt;</code>：左边的比右边的小吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值是不是<strong>小于</strong> <code>b</code> 的值。</p><p><strong>写法</strong>：<code>a &lt; b</code></p><p><strong>🌰</strong>：<code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 小于 <code>20</code> 吗？<code>10 &lt; 20</code>？是的！所以结果是 <code>True</code>。<br>反过来，如果问 <code>b &lt; a</code> （<code>20 &lt; 10</code>），那结果就是 <code>False</code>。</p><h4 id="2-3-大于等于-：左边的比右边的大，或者一样大吗？"><a href="#2-3-大于等于-：左边的比右边的大，或者一样大吗？" class="headerlink" title="2.3 大于等于 &gt;=：左边的比右边的大，或者一样大吗？"></a>2.3 大于等于 <code>&gt;=</code>：左边的比右边的大，或者一样大吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值是不是<strong>大于或者等于</strong> <code>b</code> 的值。只要满足其中一个条件，结果就是 <code>True</code>。</p><p><strong>写法</strong>：<code>a &gt;= b</code></p><p><strong>🌰</strong>：</p><ul><li><code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 大于等于 <code>20</code> 吗？<code>10 &gt;= 20</code>？<code>10</code> 既不大于 <code>20</code>，也不等于 <code>20</code>，所以结果是 <code>False</code>。</li><li>如果 <code>a</code> 是 <code>20</code>，<code>b</code> 是 <code>20</code>。<code>20 &gt;= 20</code>？等于，所以结果是 <code>True</code>。</li><li>如果 <code>a</code> 是 <code>25</code>，<code>b</code> 是 <code>20</code>。<code>25 &gt;= 20</code>？大于，所以结果是 <code>True</code>。</li></ul><h4 id="2-4-小于等于"><a href="#2-4-小于等于" class="headerlink" title="2.4 小于等于 &lt;=：左边的比右边的小，或者一样小吗？"></a>2.4 小于等于 <code>&lt;=</code>：左边的比右边的小，或者一样小吗？</h4><p><strong>用处</strong>：判断 <code>a</code> 的值是不是<strong>小于或者等于</strong> <code>b</code> 的值。只要满足其中一个条件，结果就是 <code>True</code>。</p><p><strong>写法</strong>：<code>a &lt;= b</code></p><p><strong>🌰</strong>：</p><ul><li><code>a</code> 是 <code>10</code>，<code>b</code> 是 <code>20</code>。<code>10</code> 小于等于 <code>20</code> 吗？<code>10 &lt;= 20</code>？是的，<code>10</code> 小于 <code>20</code>，所以结果是 <code>True</code>。</li><li>如果 <code>a</code> 是 <code>20</code>，<code>b</code> 是 <code>20</code>。<code>20 &lt;= 20</code>？等于，所以结果是 <code>True</code>。</li><li>如果 <code>a</code> 是 <code>25</code>，<code>b</code> 是 <code>20</code>。<code>25 &lt;= 20</code>？<code>25</code> 比 <code>20</code> 大，所以结果是 <code>False</code>。</li></ul><hr><h3 id="比较运算符表"><a href="#比较运算符表" class="headerlink" title="比较运算符表"></a>比较运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">名字</th><th align="left">描述（以 <code>a</code> 和 <code>b</code> 为例）</th><th align="left">例子 (a&#x3D;10, b&#x3D;20)</th><th align="left">结果 (True&#x2F;False)</th></tr></thead><tbody><tr><td align="left"><code>==</code></td><td align="left">等于</td><td align="left"><code>a</code> 的值是否等于 <code>b</code> 的值？</td><td align="left"><code>10 == 20</code></td><td align="left"><code>False</code></td></tr><tr><td align="left"><code>!=</code></td><td align="left">不等于</td><td align="left"><code>a</code> 的值是否不等于 <code>b</code> 的值？</td><td align="left"><code>10 != 20</code></td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>&gt;</code></td><td align="left">大于</td><td align="left"><code>a</code> 的值是否大于 <code>b</code> 的值？</td><td align="left"><code>10 &gt; 20</code></td><td align="left"><code>False</code></td></tr><tr><td align="left"><code>&lt;</code></td><td align="left">小于</td><td align="left"><code>a</code> 的值是否小于 <code>b</code> 的值？</td><td align="left"><code>10 &lt; 20</code></td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>&gt;=</code></td><td align="left">大于等于</td><td align="left"><code>a</code> 的值是否大于或等于 <code>b</code> 的值？</td><td align="left"><code>10 &gt;= 20</code></td><td align="left"><code>False</code></td></tr><tr><td align="left"><code>&lt;=</code></td><td align="left">小于等于</td><td align="left"><code>a</code> 的值是否小于或等于 <code>b</code> 的值？</td><td align="left"><code>10 &lt;= 20</code></td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>&lt;&gt;</code></td><td align="left">不等于</td><td align="left">(旧写法，同 <code>!=</code>，Python 3 已弃用)</td><td align="left"><code>10 &lt;&gt; 20</code></td><td align="left"><code>True</code> (古老版本)</td></tr></tbody></table><hr><h2 id="赋值运算符">赋值运算符</h2><p><strong>赋值</strong> 听起来有点专业，其实很简单，就是 <strong>把一个值放到一个变量里</strong> 的过程。就像你把一颗糖放进标着自己名字的小盒子里一样</p><p>我们已经知道，<code>=</code> 这个等号就是最基本的赋值运算符。比如 <code>a = 10</code>，就是把数字 <code>10</code> 放进了叫做 <code>a</code> 的这个“盒子”里。</p><p>除了简单的 <code>=</code>，Python 还有一些<strong>复合赋值运算符</strong>，它们能把<strong>运算</strong>和<strong>赋值</strong>这两步操作合并成一步，写起来更简洁</p><p>我们还是用两个变量来举例（但是，具体的值会根据例子变化）：</p><ul><li>变量 <code>a</code></li><li>变量 <code>c</code> (以下内容，我们主要用 <code>c</code> 来演示各种赋值操作)</li></ul><hr><h3 id="一、最基本的赋值："><a href="#一、最基本的赋值：" class="headerlink" title="一、最基本的赋值：="></a>一、最基本的赋值：<code>=</code></h3><h4 id="1-1-：把右边的值，放到左边的变量里"><a href="#1-1-：把右边的值，放到左边的变量里" class="headerlink" title="1.1 =：把右边的值，放到左边的变量里"></a>1.1 <code>=</code>：把右边的值，放到左边的变量里</h4><p><strong>用处</strong>：这是最常用的赋值运算符。它的意思是：<strong>把等号右边计算得到的结果，存放到等号左边的变量里。</strong></p><p><strong>写法</strong>：<code>变量 = 表达式</code> 在这里，表达式可以是一个数字，或者一个计算式</p><p><strong>举例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>      <span class="comment"># 把数字 10 放进变量 a 这个盒子里。现在 a 里面是 10。</span></span><br><span class="line">b = <span class="number">20</span>      <span class="comment"># 把数字 20 放进变量 b 这个盒子里。现在 b 里面是 20。</span></span><br><span class="line">c = a + b   <span class="comment"># 先计算 a + b (10 + 20 = 30)，然后把结果 30 放进变量 c 这个盒子里。现在 c 里面是 30。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 打印 c，会显示 30。</span></span><br></pre></td></tr></table></figure><p><strong>记住</strong>：等号 <code>=</code> 在这里不是<strong>等于</strong>的意思（比较相等我们用 <code>==</code>），而是<strong>赋值</strong>。比如 <code>c = a + b</code>，读作“把 a 加 b 的结果赋值给 c”</p><hr><h3 id="二、复合赋值运算符"><a href="#二、复合赋值运算符" class="headerlink" title="二、复合赋值运算符"></a>二、复合赋值运算符</h3><p>假设现在变量 <code>c</code> 里面已经有一个值了。如果我们想对 <code>c</code> 里面的这个值进行一些运算，比如加、减、乘、除某个数，然后再把新的结果放回到 <code>c</code> 里面，该怎么做呢？</p><p>比如，<code>c</code> 现在是 <code>10</code>，我们想让 <code>c</code> 加上 <code>5</code>，然后还是存回 <code>c</code>。<br>普通写法是：<code>c = c + 5</code>。<br>用<strong>复合赋值运算符</strong>，可以写成：<code>c += 5</code>。是不是更简洁？</p><p>下面我们就来看看这些复合赋值运算符：</p><h4 id="2-1-：加法赋值-先加后存"><a href="#2-1-：加法赋值-先加后存" class="headerlink" title="2.1 +=：加法赋值 (先加后存)"></a>2.1 <code>+=</code>：加法赋值 (先加后存)</h4><p><strong>用处</strong>：<code>c += a</code> 等效于 <code>c = c + a</code>。<br>意思是：<strong>把变量 c 现在的值，加上 a 的值，然后把得到的新结果再存回 c 里。</strong></p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>31</code> ，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c += a   <span class="comment"># 相当于 c = c + a → c = 31 + 21 = 52</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 52</span></span><br></pre></td></tr></table></figure><h4 id="2-2-：减法赋值-先减后存"><a href="#2-2-：减法赋值-先减后存" class="headerlink" title="2.2 -=：减法赋值 (先减后存)"></a>2.2 <code>-=</code>：减法赋值 (先减后存)</h4><p><strong>用处</strong>：<code>c -= a</code> 等效于 <code>c = c - a</code>。<br>意思是：<strong>把变量 c 现在的值，减去 a 的值，然后把得到的新结果再存回 c 里。</strong></p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>52</code>，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c -= a   <span class="comment"># 相当于 c = c - a → c = 52 - 21 = 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 31</span></span><br></pre></td></tr></table></figure><h4 id="2-3-：乘法赋值-先乘后存"><a href="#2-3-：乘法赋值-先乘后存" class="headerlink" title="2.3 *=：乘法赋值 (先乘后存)"></a>2.3 <code>*=</code>：乘法赋值 (先乘后存)</h4><p><strong>用处</strong>：<code>c *= a</code> 等效于 <code>c = c * a</code>。<br>意思是：<strong>把变量 c 现在的值，乘以 a 的值，然后把得到的新结果再存回 c 里。</strong></p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>52</code> (接上面 <code>+=</code> 的例子)，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c *= a   <span class="comment"># 相当于 c = c * a → c = 52 * 21 = 1092</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 1092</span></span><br></pre></td></tr></table></figure><h4 id="2-4-：除法赋值-先除后存"><a href="#2-4-：除法赋值-先除后存" class="headerlink" title="2.4 /=：除法赋值 (先除后存)"></a>2.4 <code>/=</code>：除法赋值 (先除后存)</h4><p><strong>用处</strong>：<code>c /= a</code> 等效于 <code>c = c / a</code>。<br>意思是：<strong>把变量 c 现在的值，除以 a 的值，然后把得到的新结果再存回 c 里。</strong> (结果通常是默认为浮点数)</p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>1092</code> (接上面 <code>*=</code> 的例子)，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c /= a   <span class="comment"># 相当于 c = c / a → c = 1092 / 21 = 52.0 (在 Python 3 里会得到 52.0)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 52.0 (如果 a 和 c 是整数，结果可能带小数点)</span></span><br></pre></td></tr></table></figure><h4 id="2-5-：取模赋值-先取余后存"><a href="#2-5-：取模赋值-先取余后存" class="headerlink" title="2.5 %=：取模赋值 (先取余后存)"></a>2.5 <code>%=</code>：取模赋值 (先取余后存)</h4><p><strong>用处</strong>：<code>c %= a</code> 等效于 <code>c = c % a</code>。<br>意思是：<strong>把变量 c 现在的值，对 a 的值进行取模运算，然后把得到的新结果再存回 c 里。</strong></p><p><strong>举例</strong>：<br>现在，我们重新给 c 赋值， <code>c</code> 现在是 <code>2</code> ，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">2</span>    <span class="comment"># 现在 c 里面是 2</span></span><br><span class="line">c %= a   <span class="comment"># 相当于 c = c % a → c = 2 % 21。2 除以 21 商 0 余 2，所以结果是 2。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 2</span></span><br></pre></td></tr></table></figure><p>再比如：如果 <code>c = 25</code>，<code>a = 10</code>，那么 <code>c %= a</code> 就是 <code>25 % 10 = 5</code>，之后 <code>c</code> 就是 <code>5</code>。</p><h4 id="2-6-：幂赋值-先乘方后存"><a href="#2-6-：幂赋值-先乘方后存" class="headerlink" title="2.6 **=：幂赋值 (先乘方后存)"></a>2.6 <code>**=</code>：幂赋值 (先乘方后存)</h4><p><strong>用处</strong>：<code>c **= a</code> 等效于 <code>c = c** a</code>。<br>意思是：<strong>把变量 c 现在的值，作为底数，a 的值作为指数进行乘方运算，然后把得到的新结果再存回 c 里。</strong></p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>2</code>，<code>a</code> 是 <code>21</code> (哇，2 的 21 次方是个大数字！)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c = <span class="number">2</span>    <span class="comment"># 现在 c 里面是 2</span></span><br><span class="line">c **= a  <span class="comment"># 相当于 c = c **a → c = 2** 21。2 的 21 次方是 2097152。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 2097152</span></span><br></pre></td></tr></table></figure><h4 id="2-7-：取整除赋值-先整除后存"><a href="#2-7-：取整除赋值-先整除后存" class="headerlink" title="2.7 //=：取整除赋值 (先整除后存)"></a>2.7 <code>//=</code>：取整除赋值 (先整除后存)</h4><p><strong>用处</strong>：<code>c //= a</code> 等效于 <code>c = c // a</code>。<br>意思是：<strong>把变量 c 现在的值，除以 a 的值，然后对结果进行向下取整（取整除），再把得到的新结果存回 c 里。</strong></p><p><strong>举例</strong>：<br>假设 <code>c</code> 现在是 <code>2097152</code> (接上面 <code>**=</code> 的例子)，<code>a</code> 是 <code>21</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">c //= a   <span class="comment"># 相当于 c = c // a → c = 2097152 // 21</span></span><br><span class="line">          <span class="comment"># 21 * 99864 = 2097144，2097152 - 2097144 = 8，所以商是 99864。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;c 的值为：&quot;</span>, c)  <span class="comment"># 现在 c 是 99864</span></span><br></pre></td></tr></table></figure><hr><h3 id="赋值运算符表"><a href="#赋值运算符表" class="headerlink" title="赋值运算符表"></a>赋值运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">例子 (假设 c 初始值为 10, a&#x3D;5)</th><th align="left">等效于</th><th align="left">运算后 c 的值</th></tr></thead><tbody><tr><td align="left"><code>=</code></td><td align="left">赋值</td><td align="left"><code>c = a</code></td><td align="left"><code>c = a</code></td><td align="left">5</td></tr><tr><td align="left"><code>+=</code></td><td align="left">加法赋值</td><td align="left"><code>c += a</code></td><td align="left"><code>c = c + a</code></td><td align="left">10 + 5 &#x3D; 15</td></tr><tr><td align="left"><code>-=</code></td><td align="left">减法赋值</td><td align="left"><code>c -= a</code></td><td align="left"><code>c = c - a</code></td><td align="left">10 - 5 &#x3D; 5</td></tr><tr><td align="left"><code>*=</code></td><td align="left">乘法赋值</td><td align="left"><code>c *= a</code></td><td align="left"><code>c = c * a</code></td><td align="left">10 * 5 &#x3D; 50</td></tr><tr><td align="left"><code>/=</code></td><td align="left">除法赋值</td><td align="left"><code>c /= a</code></td><td align="left"><code>c = c / a</code></td><td align="left">10 &#x2F; 5 &#x3D; 2.0</td></tr><tr><td align="left"><code>%=</code></td><td align="left">取模赋值</td><td align="left"><code>c %= a</code></td><td align="left"><code>c = c % a</code></td><td align="left">10 % 5 &#x3D; 0</td></tr><tr><td align="left"><code>**=</code></td><td align="left">幂赋值</td><td align="left"><code>c **= a</code></td><td align="left"><code>c = c** a</code></td><td align="left">10^5 &#x3D; 100000</td></tr><tr><td align="left"><code>//=</code></td><td align="left">取整除赋值</td><td align="left"><code>c //= a</code></td><td align="left"><code>c = c // a</code></td><td align="left">10 &#x2F;&#x2F; 5 &#x3D; 2</td></tr></tbody></table><hr><h2 id="逻辑运算符">逻辑运算符</h2><p>现在设想一下，你和朋友约好周末出去玩，可能会有这样的对话：</p><ol><li>“如果明天<strong>天气好并且</strong>我作业写完了，我们就去公园。” → 两个条件都要满足才行！</li><li>“如果明天<strong>下雨或者</strong>我生病了，我们就不去了。” → 只要有一个条件满足就不去。</li><li>“<strong>不是</strong>因为我不想去，而是因为我有事。” → 否定一个条件。</li></ol><p>这些“并且”、“或者”、“不是”，在 Python 中就是逻辑运算符的作用！它们连接多个<strong>条件</strong>（通常是比较运算的结果，比如 <code>a &gt; b</code>，<code>x == 5</code> 等），最终得到一个 <code>True</code>（真）或 <code>False</code>（假）的结果。</p><p>Python 有三个逻辑运算符：<code>and</code>（与）、<code>or</code>（或）、<code>not</code>（非）。</p><hr><h3 id="一、and：并且（两个条件都要满足）"><a href="#一、and：并且（两个条件都要满足）" class="headerlink" title="一、and：并且（两个条件都要满足）"></a>一、<code>and</code>：并且（两个条件都要满足）</h3><h4 id="1-1-and-运算符（逻辑与）"><a href="#1-1-and-运算符（逻辑与）" class="headerlink" title="1.1 and 运算符（逻辑与）"></a>1.1 <code>and</code> 运算符（逻辑与）</h4><p><strong>逻辑表达式</strong>：<code>条件1 and 条件2</code></p><p><strong>描述</strong>：</p><ul><li>如果 <strong>条件1</strong> 是 <code>False</code>（假），那么整个表达式直接返回 <code>False</code>（因为，“并且”需要两个都真，一个假了整体就假了）。</li><li>如果 <strong>条件1</strong> 是 <code>True</code>（真），那么整个表达式的结果就取决于 <strong>条件2</strong>：条件2 是 <code>True</code> 就返回 <code>True</code>，条件2 是 <code>False</code> 就返回 <code>False</code>。</li></ul><p><strong>生活例子</strong>：</p><ul><li>你能玩游戏的条件：<code>(作业写完了) and (妈妈同意了)</code>。两个条件都满足才能玩。</li><li>如果作业没写完（条件1 <code>False</code>），不管妈妈同不同意，都不能玩（整体 <code>False</code>）。</li><li>如果作业写完了（条件1 <code>True</code>），那就看妈妈是否同意（条件2）：妈妈同意（<code>True</code>）→ 能玩；妈妈不同意（<code>False</code>）→ 不能玩。</li></ul><p><strong>Python 实例（用数字代替条件理解）</strong>：<br>在 Python 中，<code>0</code> 代表 <code>False</code>，非 <code>0</code> 数字代表 <code>True</code>。我们先看一个简单的例子，假设 <code>a = 10</code>（<code>True</code>），<code>b = 20</code>（<code>True</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>  <span class="comment"># 非0 → True</span></span><br><span class="line">b = <span class="number">20</span>  <span class="comment"># 非0 → True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (a and b)：因为 a 是 True，所以结果是 b 的值（20，代表 True）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a and b 的结果:&quot;</span>, a <span class="keyword">and</span> b)  <span class="comment"># 输出 20（实际逻辑结果是 True，但这里返回了 b 的值，后面会解释）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 a 是 0（False）：</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 and b 的结果:&quot;</span>, a <span class="keyword">and</span> b)  <span class="comment"># 输出 0（因为 a 是 False，整体直接返回 False，即 0）</span></span><br></pre></td></tr></table></figure><h4 id="1-2-在条件判断中使用-and（更常用！）"><a href="#1-2-在条件判断中使用-and（更常用！）" class="headerlink" title="1.2 在条件判断中使用 and（更常用！）"></a>1.2 在条件判断中使用 <code>and</code>（更常用！）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断 a 是否大于 5 并且 b 是否大于 15</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">and</span> b &gt; <span class="number">15</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 和 b 都满足条件（a&gt;5 并且 b&gt;15）&quot;</span>)  <span class="comment"># a&gt;5 (True), b&gt;15 (True) → 整体 True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 和 b 至少有一个不满足条件&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 a 为 3</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a &gt; <span class="number">5</span> <span class="keyword">and</span> b &gt; <span class="number">15</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 a 和 b 都满足条件&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 a 和 b 至少有一个不满足条件&quot;</span>)  <span class="comment"># a&gt;5 (False), 所以整体 False</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 - 变量 a 和 b 都满足条件（a&gt;5 并且 b&gt;15）</span><br><span class="line">2 - 变量 a 和 b 至少有一个不满足条件</span><br></pre></td></tr></table></figure><hr><h3 id="二、or：或者（满足一个条件就行）"><a href="#二、or：或者（满足一个条件就行）" class="headerlink" title="二、or：或者（满足一个条件就行）"></a>二、<code>or</code>：或者（满足一个条件就行）</h3><h4 id="2-1-or-运算符（逻辑或）"><a href="#2-1-or-运算符（逻辑或）" class="headerlink" title="2.1 or 运算符（逻辑或）"></a>2.1 <code>or</code> 运算符（逻辑或）</h4><p><strong>逻辑表达式</strong>：<code>条件1 or 条件2</code></p><p><strong>描述</strong>：</p><ul><li>如果 <strong>条件1</strong> 是 <code>True</code>（真），那么整个表达式直接返回 <code>True</code>（因为，“或者”只要有一个真就行）。</li><li>如果 <strong>条件1</strong> 是 <code>False</code>（假），那么整个表达式的结果就取决于 <strong>条件2</strong>：条件2 是 <code>True</code> 就返回 <code>True</code>，条件2 是 <code>False</code> 就返回 <code>False</code>。</li></ul><p><strong>实际例子</strong>：</p><ul><li>你不能上学的条件：<code>(生病了) or (下雨了)</code>。只要满足一个就不能上学。</li><li>如果你生病了（条件1 <code>True</code>），不管下不下雨，都不能上学（整体 <code>True</code>）。</li><li>如果你没生病（条件1 <code>False</code>），那就看是否下雨（条件2）：下雨（<code>True</code>）→ 不能上学；不下雨（<code>False</code>）→ 能上学。</li></ul><p><strong>Python 实例（用数字代替条件理解）</strong>：<br><code>a = 10</code>（<code>True</code>），<code>b = 20</code>（<code>True</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>  <span class="comment"># True</span></span><br><span class="line">b = <span class="number">20</span>  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># (a or b)：因为 a 是 True，所以结果是 a 的值（10，代表 True）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a or b 的结果:&quot;</span>, a <span class="keyword">or</span> b)  <span class="comment"># 输出 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 a 是 0（False）：</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;0 or b 的结果:&quot;</span>, a <span class="keyword">or</span> b)  <span class="comment"># 输出 20（因为 a 是 False，所以看 b，b 是 True，返回 b 的值）</span></span><br></pre></td></tr></table></figure><h4 id="2-2-在条件判断中使用-or（更常用！）"><a href="#2-2-在条件判断中使用-or（更常用！）" class="headerlink" title="2.2 在条件判断中使用 or（更常用！）"></a>2.2 在条件判断中使用 <code>or</code>（更常用！）</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断 a 是否小于 5 或者 b 是否小于 15</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">5</span> <span class="keyword">or</span> b &lt; <span class="number">15</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 和 b 至少有一个满足条件（a&lt;5 或者 b&lt;15）&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 和 b 都不满足条件&quot;</span>)  <span class="comment"># a&lt;5 (False), b&lt;15 (False) → 整体 False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 a 为 3</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line"><span class="keyword">if</span> a &lt; <span class="number">5</span> <span class="keyword">or</span> b &lt; <span class="number">15</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - 变量 a 和 b 至少有一个满足条件&quot;</span>)  <span class="comment"># a&lt;5 (True) → 整体 True</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - 变量 a 和 b 都不满足条件&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3 - 变量 a 和 b 都不满足条件</span><br><span class="line">4 - 变量 a 和 b 至少有一个满足条件</span><br></pre></td></tr></table></figure><hr><h3 id="三、not：不是（否定一个条件）"><a href="#三、not：不是（否定一个条件）" class="headerlink" title="三、not：不是（否定一个条件）"></a>三、<code>not</code>：不是（否定一个条件）</h3><h4 id="3-1-not-运算符（逻辑非）"><a href="#3-1-not-运算符（逻辑非）" class="headerlink" title="3.1 not 运算符（逻辑非）"></a>3.1 <code>not</code> 运算符（逻辑非）</h4><p><strong>逻辑表达式</strong>：<code>not 条件</code></p><p><strong>描述</strong>：</p><ul><li>如果 <strong>条件</strong> 是 <code>True</code>（真），那么 <code>not 条件</code> 就返回 <code>False</code>（假）。</li><li>如果 <strong>条件</strong> 是 <code>False</code>（假），那么 <code>not 条件</code> 就返回 <code>True</code>（真）。</li></ul><p><strong>生活例子</strong>：</p><ul><li>“今天<strong>不是</strong>晴天。” → 如果今天是晴天（<code>True</code>），那么这句话就是 <code>False</code>；如果今天不是晴天（<code>False</code>），这句话就是 <code>True</code>。</li><li>“我<strong>不是</strong>不想去。” → 如果“我不想去”是 <code>True</code>，那么这句话就是 <code>False</code>（其实我想去）。</li></ul><p><strong>Python 实例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span>  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># not a：a 是 True，所以 not a 是 False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not a 的结果:&quot;</span>, <span class="keyword">not</span> a)  <span class="comment"># 输出 False</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">0</span>  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;not b 的结果:&quot;</span>, <span class="keyword">not</span> b)  <span class="comment"># 输出 True（因为 b 是 False，not b 就是 True）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在条件判断中</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (a &gt; <span class="number">20</span>):  <span class="comment"># a&gt;20 是 False，not False 是 True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5 - a 不大于 20&quot;</span>)  <span class="comment"># 会执行这句</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5 - a 大于 20&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">not a 的结果: False</span><br><span class="line">not b 的结果: True</span><br><span class="line">5 - a 不大于 20</span><br></pre></td></tr></table></figure><hr><h3 id="四、综合实例"><a href="#四、综合实例" class="headerlink" title="四、综合实例"></a>四、综合实例</h3><p>现在我们来看你提供的完整示例代码，理解逻辑运算符在条件判断中的应用。</p><p><strong>已知</strong>：初始 <code>a = 10</code>（非0 → <code>True</code>），<code>b = 20</code>（非0 → <code>True</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 判断 a 和 b 是否都为 True（非0即True）</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b:  <span class="comment"># a 是 True，b 是 True → True and True = True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 和 b 都为 True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 和 b 有一个不为 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 判断 a 或 b 是否为 True</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b:  <span class="comment"># a 是 True → True or ... = True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 a 和 b 都为 True，或其中一个变量为 True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 a 和 b 都不为 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 a 的值为 0（0 代表 False）</span></span><br><span class="line">a = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 再次判断 a 和 b 是否都为 True</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">and</span> b:  <span class="comment"># a 是 False → False and ... = False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 和 b 都为 True&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 和 b 有一个不为 True&quot;</span>)  <span class="comment"># 执行这句</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 再次判断 a 或 b 是否为 True</span></span><br><span class="line"><span class="keyword">if</span> a <span class="keyword">or</span> b:  <span class="comment"># a 是 False，但 b 是 True → False or True = True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - 变量 a 和 b 都为 True，或其中一个变量为 True&quot;</span>)  <span class="comment"># 执行这句</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - 变量 a 和 b 都不为 True&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 判断 not (a and b) 的结果</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> (a <span class="keyword">and</span> b):  <span class="comment"># a and b 是 False → not False = True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5 - 变量 a 和 b 都为 False，或其中一个变量为 False&quot;</span>)  <span class="comment"># 执行这句</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;5 - 变量 a 和 b 都为 True&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>输出结果和示例完全一样</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1 - 变量 a 和 b 都为 True</span><br><span class="line">2 - 变量 a 和 b 都为 True，或其中一个变量为 True</span><br><span class="line">3 - 变量 a 和 b 有一个不为 True</span><br><span class="line">4 - 变量 a 和 b 都为 True，或其中一个变量为 True</span><br><span class="line">5 - 变量 a 和 b 都为 False，或其中一个变量为 False</span><br></pre></td></tr></table></figure><hr><h3 id="五、逻辑运算符的“短路特性”"><a href="#五、逻辑运算符的“短路特性”" class="headerlink" title="五、逻辑运算符的“短路特性”"></a>五、逻辑运算符的“短路特性”</h3><p>逻辑运算符有个有趣的“短路”特性，当然，只对 <code>and</code> 和 <code>or</code> 有效。但它可以帮助我们理解它们的执行过程：</p><h3 id="5-1-and-的短路："><a href="#5-1-and-的短路：" class="headerlink" title="5.1 and 的短路："></a>5.1 <code>and</code> 的短路：</h3><ul><li>如果第一个条件是 <code>False</code>，后面的条件<strong>不会执行</strong>（因为整体已经是 <code>False</code> 了，没必要看后面）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">0</span> <span class="keyword">and</span> (<span class="number">1</span>/<span class="number">0</span>))  <span class="comment"># 输出 0，不会报错！因为 0 是 False，后面的 1/0（除零错误）不会执行。</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-2-or-的短路："><a href="#5-2-or-的短路：" class="headerlink" title="5.2 or 的短路："></a>5.2 <code>or</code> 的短路：</h4><ul><li>如果第一个条件是 <code>True</code>，后面的条件<strong>不会执行</strong>（因为整体已经是 <code>True</code> 了，没必要看后面）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="number">10</span> <span class="keyword">or</span> (<span class="number">1</span>/<span class="number">0</span>))  <span class="comment"># 输出 10，不会报错！因为 10 是 True，后面的 1/0 不会执行。</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="逻辑运算符表"><a href="#逻辑运算符表" class="headerlink" title="逻辑运算符表"></a>逻辑运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">逻辑表达式</th><th align="left">描述（条件版）</th><th align="left">描述（数字版，0&#x3D;False，非0&#x3D;True）</th><th align="left">例子（a&#x3D;10, b&#x3D;20, c&#x3D;0）</th></tr></thead><tbody><tr><td align="left"><code>and</code></td><td align="left"><code>条件1 and 条件2</code></td><td align="left">两个条件都为 True，结果才为 True；否则 False。</td><td align="left">若第一个数是 0，返回 0；否则返回第二个数。</td><td align="left"><code>a and b → 20</code>，<code>c and a → 0</code></td></tr><tr><td align="left"><code>or</code></td><td align="left"><code>条件1 or 条件2</code></td><td align="left">至少一个条件为 True，结果就为 True；都为 False 才返回 False。</td><td align="left">若第一个数非0，返回第一个数；否则返回第二个数。</td><td align="left"><code>a or b → 10</code>，<code>c or a → 10</code></td></tr><tr><td align="left"><code>not</code></td><td align="left"><code>not 条件</code></td><td align="left">条件为 True，结果为 False；条件为 False，结果为 True。</td><td align="left">非0数返回 False；0 返回 True。</td><td align="left"><code>not a → False</code>，<code>not c → True</code></td></tr></tbody></table><p><strong>最重要的是理解并且、或者、不是的逻辑</strong>，在条件判断（<code>if</code> 语句）中非常常用！多结合生活例子想想，很快就能掌握啦！加油！</p><hr><h2 id="位运算符">位运算符</h2><p>在此之前，我们计算用的都是 <strong>十进制</strong>（0,1,2,…,9,10,11…）。而<strong>位运算</strong>，是直接对数字的<strong>二进制</strong>（0 和 1）形式进行操作的。就像我们拼积木，这次我们是一小块一小块（地拼</p><p>别担心，我会从最基础的二进制概念开始</p><hr><h3 id="预备知识：什么是二进制？"><a href="#预备知识：什么是二进制？" class="headerlink" title="预备知识：什么是二进制？"></a>预备知识：什么是二进制？</h3><p>我们日常用的是<strong>十进制</strong>，满 10 进 1。<br><strong>二进制</strong> 是计算机最喜欢的计数方式，因为它只有 0 和 1 两个数字，满 2 就进 1。</p><ul><li>十进制的 <code>1</code> → 二进制 <code>1</code></li><li>十进制的 <code>2</code> → 二进制 <code>10</code> (因为 1*2 + 0 &#x3D; 2)</li><li>十进制的 <code>3</code> → 二进制 <code>11</code> (1*2 + 1 &#x3D; 3)</li><li>十进制的 <code>4</code> → 二进制 <code>100</code> (1<em>4 + 0</em>2 + 0 &#x3D;4)</li><li>…以此类推。</li></ul><p><strong>我们今天的例子会用到：</strong></p><ul><li>变量 <code>a = 60</code> → 它的二进制是 <code>0011 1100</code> (为了方便看，我们写成 8 位)</li><li>变量 <code>b = 13</code> → 它的二进制是 <code>0000 1101</code></li></ul><hr><h3 id="一、按位与-AND-：全-1-才得-1，有-0-就为-0"><a href="#一、按位与-AND-：全-1-才得-1，有-0-就为-0" class="headerlink" title="一、按位与 &amp; (AND)：全 1 才得 1，有 0 就为 0"></a>一、按位与 <code>&amp;</code> (AND)：全 1 才得 1，有 0 就为 0</h3><h4 id="1-1-运算符：对二进制的每一位进行“与”操作"><a href="#1-1-运算符：对二进制的每一位进行“与”操作" class="headerlink" title="1.1 &amp; 运算符：对二进制的每一位进行“与”操作"></a>1.1 <code>&amp;</code> 运算符：对二进制的每一位进行“与”操作</h4><p><strong>规则</strong>（<strong>很重要，记下来！</strong>）：<br>当两个二进制位都为 <code>1</code> 时，结果位才是 <code>1</code>；否则，结果位就是 <code>0</code>。<br>可以想像成“并且”：两位都得是 1，结果才是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 &amp; 0 = 0</span><br><span class="line">0 &amp; 1 = 0</span><br><span class="line">1 &amp; 0 = 0</span><br><span class="line">1 &amp; 1 = 1  ✔️ 只有这个是 1</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：计算 <code>a &amp; b</code>，其中 <code>a=60</code> (<code>0011 1100</code>)，<code>b=13</code> (<code>0000 1101</code>)</p><p>我们把二进制上下对齐，逐位进行 <code>&amp;</code> 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    a:  0011 1100</span><br><span class="line">    b:  0000 1101</span><br><span class="line">  &amp;----------------</span><br><span class="line">结果:  0000 1100   (这就是二进制的 12)</span><br></pre></td></tr></table></figure><p><strong>所以</strong>：<code>a &amp; b = 12</code></p><hr><h3 id="二、按位或-OR-：有-1-就为-1，全-0-才得-0"><a href="#二、按位或-OR-：有-1-就为-1，全-0-才得-0" class="headerlink" title="二、按位或 | (OR)：有 1 就为 1，全 0 才得 0"></a>二、按位或 <code>|</code> (OR)：有 1 就为 1，全 0 才得 0</h3><h4 id="2-1-运算符：对二进制的每一位进行“或”操作"><a href="#2-1-运算符：对二进制的每一位进行“或”操作" class="headerlink" title="2.1 | 运算符：对二进制的每一位进行“或”操作"></a>2.1 <code>|</code> 运算符：对二进制的每一位进行“或”操作</h4><p><strong>规则</strong>（<strong>记下来！</strong>）：<br>当两个二进制位中有一个为 <code>1</code> 时，结果位就是 <code>1</code>；只有两个都为 <code>0</code>，结果位才是 <code>0</code>。<br>可以想像成“或者”：只要有一个是 1，结果就是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 | 0 = 0</span><br><span class="line">0 | 1 = 1  ✔️</span><br><span class="line">1 | 0 = 1  ✔️</span><br><span class="line">1 | 1 = 1  ✔️</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：计算 <code>a | b</code>，其中 <code>a=60</code> (<code>0011 1100</code>)，<code>b=13</code> (<code>0000 1101</code>)</p><p>逐位进行 <code>|</code> 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    a:  0011 1100</span><br><span class="line">    b:  0000 1101</span><br><span class="line">  |----------------</span><br><span class="line">结果:  0011 1101   (这就是二进制的 61)</span><br></pre></td></tr></table></figure><p><strong>所以</strong>：<code>a | b = 61</code></p><hr><h3 id="三、按位异或-XOR-：不同为-1，相同为-0"><a href="#三、按位异或-XOR-：不同为-1，相同为-0" class="headerlink" title="三、按位异或 ^ (XOR)：不同为 1，相同为 0"></a>三、按位异或 <code>^</code> (XOR)：不同为 1，相同为 0</h3><h4 id="3-1-运算符：对二进制的每一位进行“异或”操作"><a href="#3-1-运算符：对二进制的每一位进行“异或”操作" class="headerlink" title="3.1 ^ 运算符：对二进制的每一位进行“异或”操作"></a>3.1 <code>^</code> 运算符：对二进制的每一位进行“异或”操作</h4><p><strong>规则</strong>（记下来！）：<br>当两个二进制位<strong>不一样</strong>时（一个 0，一个 1），结果位就是 <code>1</code>；如果<strong>一样</strong>（都是 0 或都是 1），结果位就是 <code>0</code>。<br>可以理解为“找不同”：不一样才是 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 ^ 0 = 0  (相同)</span><br><span class="line">0 ^ 1 = 1  (不同) ✔️</span><br><span class="line">1 ^ 0 = 1  (不同) ✔️</span><br><span class="line">1 ^ 1 = 0  (相同)</span><br></pre></td></tr></table></figure><p><strong>实例</strong>：计算 <code>a ^ b</code>，其中 <code>a=60</code> (<code>0011 1100</code>)，<code>b=13</code> (<code>0000 1101</code>)</p><p>逐位进行 <code>^</code> 操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    a:  0011 1100</span><br><span class="line">    b:  0000 1101</span><br><span class="line">  ^----------------</span><br><span class="line">结果:  0011 0001   (这就是二进制的 49)</span><br></pre></td></tr></table></figure><p><strong>所以</strong>：<code>a ^ b = 49</code></p><hr><h3 id="四、按位取反-NOT-：0-变-1，1-变-0-也叫单目运算符"><a href="#四、按位取反-NOT-：0-变-1，1-变-0-也叫单目运算符" class="headerlink" title="四、按位取反 ~ (NOT)：0 变 1，1 变 0 (也叫单目运算符)"></a>四、按位取反 <code>~</code> (NOT)：0 变 1，1 变 0 (也叫单目运算符)</h3><h4 id="4-1-运算符：对二进制的每一位进行“取反”操作"><a href="#4-1-运算符：对二进制的每一位进行“取反”操作" class="headerlink" title="4.1 ~ 运算符：对二进制的每一位进行“取反”操作"></a>4.1 <code>~</code> 运算符：对二进制的每一位进行“取反”操作</h4><p><strong>规则</strong>（记下来！）：<br>把二进制位中的 <code>0</code> 变成 <code>1</code>，<code>1</code> 变成 <code>0</code>。<br>它只有一个操作数（不像 <code>&amp;</code> 需要两个数）。</p><p><strong>举例</strong>：<code>~a</code>，其中 <code>a=60</code> (<code>0011 1100</code>)</p><p>首先对 <code>a</code> 的每一位取反：<br><code>0011 1100</code> → 取反后 <code>1100 0011</code>。</p><p><strong>但这里有个难点</strong>：在计算机中，数字通常用<strong>补码</strong>表示，最高位是符号位（0 正，1 负）。<br>所以 <code>~a</code> 的结果计算方式简单记为：<code>-a - 1</code>。</p><p>对 <code>a=60</code>：<code>~60 = -60 -1 = -61</code>。</p><p><strong>所以</strong>：<code>~a = -61</code></p><hr><h3 id="五、左移"><a href="#五、左移" class="headerlink" title="五、左移 &lt;&lt;：二进制位整体向左移"></a>五、左移 <code>&lt;&lt;</code>：二进制位整体向左移</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1 &lt;&lt; 运算符：将一个数的二进制位全部向左移动指定的位数"></a>5.1 <code>&lt;&lt;</code> 运算符：将一个数的二进制位全部向左移动指定的位数</h4><p><strong>规则</strong>：</p><ul><li>左边（高位）溢出的二进制位会被丢弃。</li><li>右边（低位）空出来的位置用 <code>0</code> 补齐。</li><li>效果相当于：<code>a &lt;&lt; n</code> → <code>a * (2的n次方)</code></li></ul><p><strong>实例</strong>：计算 <code>a &lt;&lt; 2</code>，<code>a=60</code> (<code>0011 1100</code>)</p><p>向左移动 2 位：<br>原来：<code>0011 1100</code><br>左移1位：<code>0111 1000</code> (末尾补一个 0)<br>左移2位：<code>1111 0000</code> (末尾再补一个 0)</p><p>这个二进制 <code>1111 0000</code> 等于十进制的 <code>240</code>。<br>也可以算：<code>60 * (2^2) = 60 *4=240</code>。</p><p><strong>所以</strong>：<code>a &lt;&lt; 2 = 240</code></p><hr><h3 id="六、右移-：二进制位整体向右移"><a href="#六、右移-：二进制位整体向右移" class="headerlink" title="六、右移 &gt;&gt;：二进制位整体向右移"></a>六、右移 <code>&gt;&gt;</code>：二进制位整体向右移</h3><h4 id="6-1-运算符：将一个数的二进制位全部向右移动指定的位数"><a href="#6-1-运算符：将一个数的二进制位全部向右移动指定的位数" class="headerlink" title="6.1 &gt;&gt; 运算符：将一个数的二进制位全部向右移动指定的位数"></a>6.1 <code>&gt;&gt;</code> 运算符：将一个数的二进制位全部向右移动指定的位数</h4><p><strong>规则</strong>：</p><ul><li>右边（低位）溢出的二进制位会被丢弃。</li><li>左边（高位）空出来的位置，对于正数用 <code>0</code> 补齐，对于负数不同语言处理方式可能不同（Python 用 <code>0</code> 补齐）。</li><li>效果相当于：<code>a &gt;&gt; n</code> → <code>a // (2的n次方)</code> (整除)</li></ul><p><strong>实例</strong>：计算 <code>a &gt;&gt; 2</code>，<code>a=60</code> (<code>0011 1100</code>)</p><p>向右移动 2 位：<br>原来：<code>0011 1100</code><br>右移1位：<code>0001 1110</code> (丢弃最右边一位，左边补 0)<br>右移2位：<code>0000 1111</code> (再丢弃最右边一位，左边补 0)</p><p>这个二进制 <code>0000 1111</code> 等于十进制的 <code>15</code>。<br>也可以算：<code>60 // (2^2) = 60 //4=15</code>。</p><p><strong>所以</strong>：<code>a &gt;&gt; 2 = 15</code></p><hr><h3 id="位运算符表"><a href="#位运算符表" class="headerlink" title="位运算符表"></a>位运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">名称</th><th align="left">规则</th><th align="left">简单记法 (对正数)</th><th align="left">例子 (a&#x3D;60, b&#x3D;13)</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left"><code>&amp;</code></td><td align="left">按位与</td><td align="left">两位都为 1，结果才为 1</td><td align="left"></td><td align="left"><code>60 &amp; 13</code></td><td align="left">12</td></tr><tr><td align="left">&#96;</td><td align="left">&#96;</td><td align="left">按位或</td><td align="left">两位有一个为 1，结果就为 1</td><td align="left"></td><td align="left">&#96;60</td></tr><tr><td align="left"><code>^</code></td><td align="left">按位异或</td><td align="left">两位不同为 1，相同为 0</td><td align="left"></td><td align="left"><code>60 ^ 13</code></td><td align="left">49</td></tr><tr><td align="left"><code>~</code></td><td align="left">按位取反</td><td align="left">0 变 1，1 变 0</td><td align="left"><code>~a = -a - 1</code></td><td align="left"><code>~60</code></td><td align="left">-61</td></tr><tr><td align="left"><code>&lt;&lt;</code></td><td align="left">左移</td><td align="left">向左移 n 位，右边补 0</td><td align="left"><code>a &lt;&lt; n = a * (2^n)</code></td><td align="left"><code>60 &lt;&lt; 2</code></td><td align="left">240</td></tr><tr><td align="left"><code>&gt;&gt;</code></td><td align="left">右移</td><td align="left">向右移 n 位，左边补 0 (正数)，右边丢弃</td><td align="left"><code>a &gt;&gt; n = a // (2^n)</code></td><td align="left"><code>60 &gt;&gt; 2</code></td><td align="left">15</td></tr></tbody></table><hr><h2 id="为什么要学位运算？"><a href="#为什么要学位运算？" class="headerlink" title="为什么要学位运算？"></a>为什么要学位运算？</h2><p>位运算执行速度快，在底层编程、图形处理、加密算法等领域非常常用。虽然平时可能不天天用，但了解它能帮助你理解计算机的基本工作方式</p><h2 id="成员运算符">成员运算符</h2><p>现在，你去参加一个生日派对，门口有个 list（名单），上面写着所有被邀请人的名字。你想知道自己能不能进去，就要看你的名字<strong>在不在</strong>这个名单上。这里的<strong>在不在</strong>，就是成员运算符要解决的问题</p><p>在 Python 中，我们把像“名单”这样的东西叫做“序列”（sequence），比如我们之前提到过的 <strong>列表(list)<strong>，还有以后会学到的</strong>字符串(str)<strong>、</strong>元组(tuple)</strong> 等等。成员运算符就是用来判断一个元素是不是这个“序列”里的一员。</p><p>Python 有两个成员运算符：<code>in</code> 和 <code>not in</code>。</p><hr><h3 id="一、in-它在里面吗？"><a href="#一、in-它在里面吗？" class="headerlink" title="一、in 它在里面吗？"></a>一、<code>in</code> 它在里面吗？</h3><h4 id="1-1-in：判断某个元素是否是序列中的成员"><a href="#1-1-in：判断某个元素是否是序列中的成员" class="headerlink" title="1.1 in：判断某个元素是否是序列中的成员"></a>1.1 <code>in</code>：判断某个元素是否是序列中的成员</h4><p><strong>用处</strong>：如果 <strong>左边的元素</strong> 是 <strong>右边序列</strong>，比如列表、字符串、元组等等里的一员，就返回 <code>True</code>（是），否则返回 <code>False</code>（不是）。</p><p><strong>写法</strong>：<code>元素 in 序列</code></p><p><strong>生活例子</strong>：</p><ul><li>你的名字是“小明”，派对名单是 <code>[&quot;小红&quot;, &quot;小刚&quot;, &quot;小明&quot;]</code>。那么 <code>小明 in 名单</code> → <code>True</code>（可以进去！）。</li><li>如果名单是 <code>[&quot;小红&quot;, &quot;小刚&quot;]</code>，那么 <code>小明 in 名单</code> → <code>False</code> 不能进去</li></ul><p><strong>Python 实例</strong>：<br>假设我们有一个列表 <code>list = [1, 2, 3, 4, 5]</code>就像派对名单，里面有数字 1 到 5<br>变量 <code>a = 10</code>（比如“小明”）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> <span class="built_in">list</span>):  <span class="comment"># 判断 a (10) 是不是 list 里的成员？</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)  <span class="comment"># 如果是，打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)  <span class="comment"># 如果不是，打印这个</span></span><br></pre></td></tr></table></figure><p><strong>结果是什么？</strong><br><code>list</code> 里面是 <code>[1,2,3,4,5]</code>，<code>a</code> 是 <code>10</code>。<code>10</code> 不在 list 里，所以会打印：<br><code>1 - 变量 a 不在给定的列表中 list 中</code></p><hr><h3 id="二、not-in：它不在里面吗？"><a href="#二、not-in：它不在里面吗？" class="headerlink" title="二、not in：它不在里面吗？"></a>二、<code>not in</code>：它不在里面吗？</h3><h4 id="2-1-not-in：判断某个元素是否不是序列中的成员"><a href="#2-1-not-in：判断某个元素是否不是序列中的成员" class="headerlink" title="2.1 not in：判断某个元素是否不是序列中的成员"></a>2.1 <code>not in</code>：判断某个元素是否<strong>不是</strong>序列中的成员</h4><p><strong>用处</strong>：如果 <strong>左边的元素</strong> <strong>不是</strong> <strong>右边序列</strong> 里的一员，就返回 <code>True</code>（是），否则返回 <code>False</code>（不是）。<br>它刚好和 <code>in</code> 的结果相反。</p><p><strong>写法</strong>：<code>元素 not in 序列</code></p><p><strong>实际例子</strong>：</p><ul><li>你的名字是“小明”，派对名单是 <code>[&quot;小红&quot;, &quot;小刚&quot;]</code>。那么 <code>小明 not in 名单</code> → <code>True</code></li><li>如果名单上有“小明”，那么 <code>小明 not in 名单</code> → <code>False</code></li></ul><p><strong>Python 实例</strong>：<br>还是用上面的列表 <code>list = [1, 2, 3, 4, 5]</code>，变量 <code>b = 20</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span>):  <span class="comment"># 判断 b (20) 是不是不在 list 里？</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)  <span class="comment"># 如果不在，打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)  <span class="comment"># 如果在，打印这个</span></span><br></pre></td></tr></table></figure><p><strong>结果是什么？</strong><br><code>20</code> 肯定不在 <code>[1,2,3,4,5]</code> 里，所以 <code>b not in list</code> 是 <code>True</code>，会打印：<br><code>2 - 变量 b 不在给定的列表中 list 中</code></p><hr><h3 id="三、再试一次：如果元素在里面呢？"><a href="#三、再试一次：如果元素在里面呢？" class="headerlink" title="三、再试一次：如果元素在里面呢？"></a>三、再试一次：如果元素在里面呢？</h3><p>我们修改一下 <code>a</code> 的值，让它变成 <code>2</code>（<code>2</code> 是 <code>list [1,2,3,4,5]</code> 里的成员）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span>  <span class="comment"># 修改变量 a 的值为 2</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> <span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>现在结果是什么？</strong><br><code>2</code> 在 list 里，所以 <code>a in list</code> 是 <code>True</code>，会打印：<br><code>3 - 变量 a 在给定的列表中 list 中</code></p><hr><h3 id="四、综合实例-1"><a href="#四、综合实例-1" class="headerlink" title="四、综合实例"></a>四、综合实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">list</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]  <span class="comment"># 这是一个列表，里面有 1,2,3,4,5 这几个成员</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 a (10) 是否在 list 里</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> <span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - 变量 a 不在给定的列表中 list 中&quot;</span>)  <span class="comment"># 10 不在，所以打印这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查 b (20) 是否不在 list 里</span></span><br><span class="line"><span class="keyword">if</span> (b <span class="keyword">not</span> <span class="keyword">in</span> <span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 不在给定的列表中 list 中&quot;</span>)  <span class="comment"># 20 不在，所以打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - 变量 b 在给定的列表中 list 中&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 a 的值为 2</span></span><br><span class="line">a = <span class="number">2</span></span><br><span class="line"><span class="comment"># 再检查 a (2) 是否在 list 里</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">in</span> <span class="built_in">list</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 在给定的列表中 list 中&quot;</span>)  <span class="comment"># 2 在，所以打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - 变量 a 不在给定的列表中 list 中&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行上面的代码，输出结果和示例完全一样</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 - 变量 a 不在给定的列表中 list 中</span><br><span class="line">2 - 变量 b 不在给定的列表中 list 中</span><br><span class="line">3 - 变量 a 在给定的列表中 list 中</span><br></pre></td></tr></table></figure><hr><h3 id="五、字符串和元组的应用"><a href="#五、字符串和元组的应用" class="headerlink" title="五、字符串和元组的应用"></a>五、字符串和元组的应用</h3><p>成员运算符不止能用于列表，还能用于字符串和元组</p><h4 id="5-1-字符串示例："><a href="#5-1-字符串示例：" class="headerlink" title="5.1 字符串示例："></a>5.1 字符串示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;H&#x27;</span> <span class="keyword">in</span> s)      <span class="comment"># &#x27;H&#x27; 是不是在 &quot;Hello, World!&quot; 里？ → True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;x&#x27;</span> <span class="keyword">in</span> s)      <span class="comment"># &#x27;x&#x27; 是不是在里面？ → False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;llo&#x27;</span> <span class="keyword">in</span> s)    <span class="comment"># &#x27;llo&#x27; 这个子字符串是不是在里面？ → True (因为 &quot;Hello&quot; 里有 &quot;llo&quot;)</span></span><br></pre></td></tr></table></figure><h4 id="5-2-元组示例："><a href="#5-2-元组示例：" class="headerlink" title="5.2 元组示例："></a>5.2 元组示例：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="number">20</span> <span class="keyword">in</span> t)       <span class="comment"># 20 是不是在元组里？ → True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">40</span> <span class="keyword">not</span> <span class="keyword">in</span> t)   <span class="comment"># 40 是不是不在元组里？ → True</span></span><br></pre></td></tr></table></figure><hr><h3 id="成员运算符表"><a href="#成员运算符表" class="headerlink" title="成员运算符表"></a>成员运算符表</h3><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子 (list &#x3D; [1,2,3,4,5])</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left"><code>in</code></td><td align="left">如果元素在序列中，返回 <code>True</code></td><td align="left"><code>2 in list</code></td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>in</code></td><td align="left">如果元素不在序列中，返回 <code>False</code></td><td align="left"><code>10 in list</code></td><td align="left"><code>False</code></td></tr><tr><td align="left"><code>not in</code></td><td align="left">如果元素不在序列中，返回 <code>True</code></td><td align="left"><code>10 not in list</code></td><td align="left"><code>True</code></td></tr><tr><td align="left"><code>not in</code></td><td align="left">如果元素在序列中，返回 <code>False</code></td><td align="left"><code>2 not in list</code></td><td align="left"><code>False</code></td></tr></tbody></table><hr><h2 id="身份运算符">身份运算符</h2><p>生活中有这样的情况：</p><ol><li>你有一个双胞胎弟弟&#x2F;妹妹，你们长得一模一样（用python话来说，值相等），但你们是<strong>两个人</strong>（身份不同）。</li><li>你穿了一件红色的衣服，这件衣服和你是<strong>同一个人</strong>吗？当然不是！衣服只是你身上的东西（值）。</li><li>“你”这个个体，无论今天穿什么衣服（值怎么变），“你”的身份是独一无二的。</li></ol><p>在 Python 中，每个对象（就像“人”）都有一个独一无二的“身份证号”——<strong>内存地址</strong>（可以用 <code>id()</code> 函数查看）。身份运算符就是用来比较两个变量是不是指向<strong>同一个对象</strong>（即，<br><strong>身份证号</strong>是否相同）。</p><p>Python 有两个身份运算符：<code>is</code> 和 <code>is not</code>。</p><hr><h3 id="一、is：它们是不是同一个对象？"><a href="#一、is：它们是不是同一个对象？" class="headerlink" title="一、is：它们是不是同一个对象？"></a>一、<code>is</code>：它们是不是同一个对象？</h3><h4 id="1-1-is：判断两个变量是否引用同一个对象"><a href="#1-1-is：判断两个变量是否引用同一个对象" class="headerlink" title="1.1 is：判断两个变量是否引用同一个对象"></a>1.1 <code>is</code>：判断两个变量是否引用同一个对象</h4><p><strong>用处</strong>：如果 <strong>左边变量</strong> 和 <strong>右边变量</strong> 指向的是<strong>内存中的同一个对象</strong>（即，它们的<strong>身份证号</strong><code>id</code> 相同），就返回 <code>True</code>（是），否则返回 <code>False</code>（不是）。</p><p><strong>写法</strong>：<code>变量1 is 变量2</code></p><p><strong>生活例子</strong>：</p><ul><li>你叫“小明”，你的双胞胎弟弟也叫“小明”（假设）。<code>小明(你) is 小明(弟弟)</code> → <code>False</code>（你们是两个人，虽然名字和长相一样）。</li><li>你指着镜子里的自己说：“这就是我”。<code>我 is 镜子里的我</code> → <code>True</code>（都是你自己）。</li></ul><p><strong>Python 实例</strong>：<br>我们先看一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span>  <span class="comment"># 把数字 20 放进变量 a 这个“盒子”里。a 指向内存中存储 20 的那个对象。</span></span><br><span class="line">b = <span class="number">20</span>  <span class="comment"># 把数字 20 放进变量 b 这个“盒子”里。b 指向哪里呢？</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a 的内存地址:&quot;</span>, <span class="built_in">id</span>(a))  <span class="comment"># 查看 a 的“身份证号”</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;b 的内存地址:&quot;</span>, <span class="built_in">id</span>(b))  <span class="comment"># 查看 b 的“身份证号”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 是同一个对象&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 不是同一个对象&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>结果是什么？</strong><br>在 Python 中，对于一些简单的小整数（如 -5 到 256），为了提高效率，会被“缓存”起来。所以 <code>a=20</code> 和 <code>b=20</code>，Python 可能会让它们指向<strong>同一个内存地址</strong>。因此：<br><code>a 的内存地址</code> 和 <code>b 的内存地址</code> 会相同，<code>a is b</code> → <code>True</code>。</p><p>所以会打印：<br><code>a 和 b 有相同的标识</code> (即“a 和 b 是同一个对象”)</p><hr><h3 id="二、is-not：它们是不是不同的对象？"><a href="#二、is-not：它们是不是不同的对象？" class="headerlink" title="二、is not：它们是不是不同的对象？"></a>二、<code>is not</code>：它们是不是不同的对象？</h3><h4 id="2-1-is-not：判断两个变量是否引用不同的对象"><a href="#2-1-is-not：判断两个变量是否引用不同的对象" class="headerlink" title="2.1 is not：判断两个变量是否引用不同的对象"></a>2.1 <code>is not</code>：判断两个变量是否引用不同的对象</h4><p><strong>用处</strong>：如果 <strong>左边变量</strong> 和 <strong>右边变量</strong> 指向的是<strong>内存中的不同对象</strong>（即它们的“身份证号”<code>id</code> 不同），就返回 <code>True</code>（是不同的），否则返回 <code>False</code>（是同一个）。</p><p><strong>写法</strong>：<code>变量1 is not 变量2</code></p><p><strong>实际例子</strong>：</p><ul><li>你和你的好朋友。<code>你 is not 好朋友</code> → <code>True</code>（你们是不同的人）。</li><li>你和你自己。<code>你 is not 你</code> → <code>False</code>（就是同一个人）。</li></ul><p><strong>Python 实例</strong>：<br>接着上面的例子，我们修改 <code>b</code> 的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 前面 a is b → True</span></span><br><span class="line"></span><br><span class="line">b = <span class="number">30</span>  <span class="comment"># 现在 b 指向了新的对象（数字 30）</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后 b 的内存地址:&quot;</span>, <span class="built_in">id</span>(b))  <span class="comment"># 新的“身份证号”</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">not</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 不是同一个对象&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;a 和 b 是同一个对象&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：<br>现在 <code>a</code> 指向 20，<code>b</code> 指向 30，它们的内存地址肯定不同了。所以 <code>a is not b</code> → <code>True</code>，会打印：<br><code>a 和 b 没有相同的标识</code> (即，a 和 b 不是同一个对象)</p><hr><h3 id="三、综合实例"><a href="#三、综合实例" class="headerlink" title="三、综合实例"></a>三、综合实例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 判断 a 和 b 是否是同一个对象</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - a 和 b 有相同的标识&quot;</span>)  <span class="comment"># 如果是，打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;1 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 判断 a 和 b 是否不是同一个对象</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">not</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - a 和 b 没有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;2 - a 和 b 有相同的标识&quot;</span>)  <span class="comment"># 因为 a 和 b 现在还是同一个对象，所以打印这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改变量 b 的值为 30</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 再次判断 a 和 b 是否是同一个对象</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - a 和 b 有相同的标识&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;3 - a 和 b 没有相同的标识&quot;</span>)  <span class="comment"># 现在 b 指向了 30，所以打印这个</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 再次判断 a 和 b 是否不是同一个对象</span></span><br><span class="line"><span class="keyword">if</span> (a <span class="keyword">is</span> <span class="keyword">not</span> b):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - a 和 b 没有相同的标识&quot;</span>)  <span class="comment"># 现在它们不是同一个对象了，所以打印这个</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;4 - a 和 b 有相同的标识&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>运行结果和示例完全一样</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 - a 和 b 有相同的标识</span><br><span class="line">2 - a 和 b 有相同的标识</span><br><span class="line">3 - a 和 b 没有相同的标识</span><br><span class="line">4 - a 和 b 没有相同的标识</span><br></pre></td></tr></table></figure><hr><h3 id="四、is-vs-身份-vs-值"><a href="#四、is-vs-身份-vs-值" class="headerlink" title="四、is vs == (身份 vs 值)"></a>四、<code>is</code> vs <code>==</code> (身份 vs 值)</h3><p>这是初学者最容易混淆的两个概念！一定要分清楚：</p><table><thead><tr><th align="left"><code>is</code> (身份运算符)</th><th align="left"><code>==</code> (比较运算符)</th></tr></thead><tbody><tr><td align="left">判断 <strong>两个变量是否指向同一个对象</strong>（内存地址是否相同）</td><td align="left">判断 <strong>两个变量指向的对象的值是否相等</strong></td></tr><tr><td align="left">看“身份证号”是否一样</td><td align="left">看“长得像不像”</td></tr><tr><td align="left">例子：双胞胎（<code>== True</code>，<code>is False</code>）</td><td align="left">例子：双胞胎（<code>== True</code>，<code>is False</code>）</td></tr></tbody></table><h3 id="4-1-经典例子：列表的复制"><a href="#4-1-经典例子：列表的复制" class="headerlink" title="4.1 经典例子：列表的复制"></a>4.1 经典例子：列表的复制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]  <span class="comment"># a 指向一个列表 [1,2,3]</span></span><br><span class="line">b = a          <span class="comment"># b 也指向 a 指向的那个列表（同一个对象！）</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b == a)  <span class="comment"># b 的值和 a 的值一样吗？ → True</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)  <span class="comment"># b 和 a 是同一个对象吗？ → True (id(a) == id(b))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在，我们用切片创建一个新列表赋值给 b (切片会创建新对象)</span></span><br><span class="line">b = a[:]       <span class="comment"># a[:] 是 a 列表的一个副本，b 指向这个新副本</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(b == a)  <span class="comment"># 新副本的值还是 [1,2,3]，和 a 一样吗？ → True</span></span><br><span class="line"><span class="built_in">print</span>(b <span class="keyword">is</span> a)  <span class="comment"># 现在 b 和 a 还是同一个对象吗？ → False (id(a) != id(b)，它们是两个不同的列表，只是长得一样)</span></span><br></pre></td></tr></table></figure><p><strong>输出</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>这个例子完美说明了：<code>==</code> 只关心值是否相等，<code>is</code> 关心是否是同一个对象。</p><hr><h2 id="身份运算符表"><a href="#身份运算符表" class="headerlink" title="身份运算符表"></a>身份运算符表</h2><table><thead><tr><th align="left">运算符</th><th align="left">描述</th><th align="left">例子 (a 和 b 指向同一对象)</th><th align="left">例子 (a 和 b 指向不同对象)</th></tr></thead><tbody><tr><td align="left"><code>is</code></td><td align="left">如果是同一个对象，返回 <code>True</code></td><td align="left"><code>a is b</code> → <code>True</code></td><td align="left"><code>a is b</code> → <code>False</code></td></tr><tr><td align="left"><code>is not</code></td><td align="left">如果不是同一个对象，返回 <code>True</code></td><td align="left"><code>a is not b</code> → <code>False</code></td><td align="left"><code>a is not b</code> → <code>True</code></td></tr></tbody></table><p><strong>如何查看内存地址？</strong><br>用 <code>id()</code> 函数：<code>id(a)</code> 返回 a 指向的对象的内存地址。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(a))   <span class="comment"># 比如：140708432563296</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))   <span class="comment"># 比如：140708432563296 (可能和 a 一样，因为小整数缓存)</span></span><br><span class="line">b = <span class="number">30</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(b))   <span class="comment"># 比如：140708432563616 (和 a 不一样了)</span></span><br></pre></td></tr></table></figure><hr><h2 id="运算符优先级">运算符优先级</h2><hr><p>当一个表达式里有多个运算符时，<strong>先算哪个，后算哪个？</strong></p><p>比如数学题：<code>1 + 2 × 3</code>，答案是 <code>7</code> 而不是 <code>9</code>，因为我们规定先乘除后加减。这就是<strong>优先级</strong>的概念</p><p>Python 里的运算符也有自己的优先级排行榜。优先级高的运算符会先动手，优先级低的会后动手。如果优先级一样，就按从左到右的顺序算，但少数运算符如 <code>**</code> 是从右到左</p><p>不过，优先级表那么长，记不住怎么办？<strong>没关系！最重要的规则是：不确定就用括号 <code>()</code>，括号里的运算永远最先算！</strong></p><hr><h3 id="一、一个生活例子：早上出门的“优先级”"><a href="#一、一个生活例子：早上出门的“优先级”" class="headerlink" title="一、一个生活例子：早上出门的“优先级”"></a>一、一个生活例子：早上出门的“优先级”</h3><p>你可以设想，你早上出门前要做这些事：</p><ol><li>穿衣服（必须先穿，不然光着身子）</li><li>刷牙洗脸（可以在穿衣服后）</li><li>吃早餐（可以在刷牙后）</li><li>背书包出门（最后做）</li></ol><p>这就是生活中的优先级：穿衣服 &gt; 刷牙洗脸 &gt; 吃早餐 &gt; 背书包。</p><p>在 Python 中，运算符也有这样的先后顺序</p><hr><h3 id="二、最常用的优先级（记住这几个就够应付大部分情况！）"><a href="#二、最常用的优先级（记住这几个就够应付大部分情况！）" class="headerlink" title="二、最常用的优先级（记住这几个就够应付大部分情况！）"></a>二、最常用的优先级（记住这几个就够应付大部分情况！）</h3><p>我们从高到低列出一些最常用的运算符优先级（越上面越先算）：</p><table><thead><tr><th align="left">优先级顺序 (高→低)</th><th align="left">运算符类型</th><th align="left">举例</th><th align="left">解释</th></tr></thead><tbody><tr><td align="left">1 (最高)</td><td align="left">** 指数（乘方）</td><td align="left"><code>2**3</code> (2的3次方)</td><td align="left">先算乘方</td></tr><tr><td align="left">2</td><td align="left"><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td align="left"><code>3*4</code> <code>10/2</code></td><td align="left">乘、除、取模（余数）、取整除</td></tr><tr><td align="left">3</td><td align="left"><code>+</code> <code>-</code></td><td align="left"><code>5+6</code> <code>10-3</code></td><td align="left">加、减</td></tr><tr><td align="left">（括号随时可用）</td><td align="left"><code>()</code> 括号</td><td align="left"><code>(1+2)*3</code></td><td align="left">括号里的永远最先算，优先级最高！</td></tr></tbody></table><p><strong>记住这个口诀（和数学一样）：</strong><br><strong>先算括号内，再算乘方，然后乘除，最后加减。</strong></p><hr><h3 id="三、实例分析：为什么结果不一样？"><a href="#三、实例分析：为什么结果不一样？" class="headerlink" title="三、实例分析：为什么结果不一样？"></a>三、实例分析：为什么结果不一样？</h3><p>我们来看你提供的例子，理解优先级和括号的作用。</p><p>已知：<code>a=20, b=10, c=15, d=5</code></p><h4 id="3-1-例子-1：-a-b-c-d"><a href="#3-1-例子-1：-a-b-c-d" class="headerlink" title="3.1 例子 1：(a + b) * c / d"></a>3.1 例子 1：<code>(a + b) * c / d</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = (a + b) * c / d  <span class="comment"># a=20, b=10, c=15, d=5</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong>：</p><ol><li>先算括号里的 <code>a + b</code> → <code>20 + 10 = 30</code></li><li>再算 <code>* c</code> → <code>30 * 15 = 450</code></li><li>最后算 <code>/ d</code> → <code>450 / 5 = 90</code><br><strong>结果</strong>：<code>90</code></li></ol><h4 id="3-2-例子-2：-a-b-c-d"><a href="#3-2-例子-2：-a-b-c-d" class="headerlink" title="3.2 例子 2：((a + b) * c) / d"></a>3.2 例子 2：<code>((a + b) * c) / d</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = ((a + b) * c) / d</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br>括号多了几层，但运算顺序和例子 1 一样：</p><ol><li>最内层 <code>a + b = 30</code></li><li>中间层 <code>30 * 15 = 450</code></li><li>最外层 <code>450 /5 =90</code><br><strong>结果</strong>：<code>90</code>（和例子 1 一样，因为括号只是明确了顺序，没改变顺序）</li></ol><h4 id="3-3-例子-3：-a-b-c-d"><a href="#3-3-例子-3：-a-b-c-d" class="headerlink" title="3.3 例子 3：(a + b) * (c / d)"></a>3.3 例子 3：<code>(a + b) * (c / d)</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = (a + b) * (c / d)</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br>这里有两个括号，优先级一样，从左到右算：</p><ol><li>第一个括号 <code>a + b = 30</code></li><li>第二个括号 <code>c / d = 15 /5 =3</code></li><li>最后算 <code>30 * 3 =90</code><br><strong>结果</strong>：<code>90</code>（还是 90，因为 <code>(30*15)/5</code> 和 <code>30*(15/5)</code> 结果相同）</li></ol><h4 id="3-4-例子-4：a-b-c-d"><a href="#3-4-例子-4：a-b-c-d" class="headerlink" title="3.4 例子 4：a + (b * c) / d"></a>3.4 例子 4：<code>a + (b * c) / d</code></h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e = a + (b * c) / d</span><br></pre></td></tr></table></figure><p><strong>分析</strong>：<br>这里括号改变了运算顺序！如果没有括号，应该先算 <code>b*c/d</code>，再加 <code>a</code>（因为乘除优先级高于加减）。有括号也一样，因为 <code>*</code> 优先级已经比 <code>+</code> 高了。</p><ol><li>括号里 <code>b * c =10*15=150</code></li><li>再算 <code>/d</code> → <code>150 /5=30</code></li><li>最后算 <code>a + 30</code> → <code>20 +30=50</code><br><strong>结果</strong>：<code>50</code>（这个和前面不一样！因为先算了 <code>b*c/d</code>，再加的 <code>a</code>）</li></ol><hr><h3 id="四、运行实例的输出结果"><a href="#四、运行实例的输出结果" class="headerlink" title="四、运行实例的输出结果"></a>四、运行实例的输出结果</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">20</span></span><br><span class="line">b = <span class="number">10</span></span><br><span class="line">c = <span class="number">15</span></span><br><span class="line">d = <span class="number">5</span></span><br><span class="line">e = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">e = (a + b) * c / d       <span class="comment"># (30 * 15) /5 = 450/5=90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(a + b) * c / d 运算结果为：&quot;</span>, e)  <span class="comment"># 90</span></span><br><span class="line"></span><br><span class="line">e = ((a + b) * c) / d     <span class="comment"># (30*15)/5=450/5=90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;((a + b) * c) / d 运算结果为：&quot;</span>, e)  <span class="comment"># 90</span></span><br><span class="line"></span><br><span class="line">e = (a + b) * (c / d);    <span class="comment"># 30 * (15/5)=30*3=90</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;(a + b) * (c / d) 运算结果为：&quot;</span>, e)  <span class="comment"># 90</span></span><br><span class="line"></span><br><span class="line">e = a + (b * c) / d;      <span class="comment"># 20 + (150/5)=20+30=50</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;a + (b * c) / d 运算结果为：&quot;</span>, e)  <span class="comment"># 50</span></span><br></pre></td></tr></table></figure><p><strong>输出结果和示例完全一样</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(a + b) * c / d 运算结果为： 90</span><br><span class="line">((a + b) * c) / d 运算结果为： 90</span><br><span class="line">(a + b) * (c / d) 运算结果为： 90</span><br><span class="line">a + (b * c) / d 运算结果为： 50</span><br></pre></td></tr></table></figure><hr><h3 id="五、优先级表（不用死记硬背）"><a href="#五、优先级表（不用死记硬背）" class="headerlink" title="五、优先级表（不用死记硬背）"></a>五、优先级表（不用死记硬背）</h3><p>以下是从最高到最低优先级的常用运算符（完整版比较长，我们记重点）：</p><table><thead><tr><th align="left">优先级</th><th align="left">运算符类型</th><th align="left">符号</th><th align="left">例子</th></tr></thead><tbody><tr><td align="left">最高</td><td align="left">括号</td><td align="left"><code>()</code></td><td align="left"><code>(1+2)*3</code></td></tr><tr><td align="left"></td><td align="left">指数（乘方）</td><td align="left"><code>**</code></td><td align="left"><code>2**3=8</code></td></tr><tr><td align="left"></td><td align="left">乘、除、取模、整除</td><td align="left"><code>*</code> <code>/</code> <code>%</code> <code>//</code></td><td align="left"><code>3*4=12</code> <code>10//3=3</code></td></tr><tr><td align="left"></td><td align="left">加、减</td><td align="left"><code>+</code> <code>-</code></td><td align="left"><code>5+6=11</code></td></tr><tr><td align="left">最低</td><td align="left">赋值运算符</td><td align="left"><code>=</code> <code>+=</code> <code>-=</code> 等</td><td align="left"><code>a=10</code> <code>a+=5</code></td></tr></tbody></table><p><strong>原则</strong>：</p><ol><li><strong>括号 <code>()</code> 优先级最高</strong>，想先算谁就把谁括起来！</li><li><strong>先乘除后加减</strong>（和数学一样）。</li><li><strong>同一优先级从左到右算</strong> （比如 <code>30 /5 *2</code> 先算 <code>30/5=6</code>，再算 <code>6*2=12</code>）。</li></ol><hr><h3 id="六、提醒："><a href="#六、提醒：" class="headerlink" title="六、提醒："></a>六、提醒：</h3><p>优先级表很长，就算现在记住了，以后也可能忘。<strong>最简单、最安全的方法就是：用括号明确指定运算顺序！</strong></p><p>比如：</p><ul><li>不确定 <code>a + b * c</code> 先算哪个？写成 <code>a + (b * c)</code> 就清楚了（虽然 <code>*</code> 本身优先级就高，但括号让代码更易读）。</li><li>对于复杂的表达式，多用括号分组，不仅自己不容易错，别人看你的代码也能一目了然。</li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><h3 id="一、选择题（共5题）"><a href="#一、选择题（共5题）" class="headerlink" title="一、选择题（共5题）"></a><strong>一、选择题（共5题）</strong></h3><h4 id="1-以下表达式的结果是多少？5-3-2"><a href="#1-以下表达式的结果是多少？5-3-2" class="headerlink" title="1. 以下表达式的结果是多少？5 + 3 * 2"></a>1. 以下表达式的结果是多少？<code>5 + 3 * 2</code></h4><p>A. 16<br>B. 11<br>C. 26<br>D. 10</p><h4 id="2-执行-a-10-b-3-print-a-b-的输出结果是？"><a href="#2-执行-a-10-b-3-print-a-b-的输出结果是？" class="headerlink" title="2. 执行 a = 10; b = 3; print(a % b) 的输出结果是？"></a>2. 执行 <code>a = 10; b = 3; print(a % b)</code> 的输出结果是？</h4><p>A. 3<br>B. 1<br>C. 0<br>D. 4</p><h4 id="3-假设-x-5，执行-x-3-后，x-的值是？"><a href="#3-假设-x-5，执行-x-3-后，x-的值是？" class="headerlink" title="3. 假设 x = 5，执行 x += 3 后，x 的值是？"></a>3. 假设 <code>x = 5</code>，执行 <code>x += 3</code> 后，<code>x</code> 的值是？</h4><p>A. 5<br>B. 3<br>C. 8<br>D. 15</p><h4 id="4-以下哪个表达式的结果是-True？"><a href="#4-以下哪个表达式的结果是-True？" class="headerlink" title="4. 以下哪个表达式的结果是 True？"></a>4. 以下哪个表达式的结果是 <code>True</code>？</h4><p>A. <code>(3 &gt; 5) and (2 &lt; 4)</code><br>B. <code>not (5 &gt; 3)</code><br>C. <code>(10 // 3 == 3) or (5 % 2 == 0)</code><br>D. <code>2 **3 &lt; 10</code></p><h4 id="5-关于-is-和-的区别，以下说法正确的是？"><a href="#5-关于-is-和-的区别，以下说法正确的是？" class="headerlink" title="5. 关于 is 和 == 的区别，以下说法正确的是？"></a>5. 关于 <code>is</code> 和 <code>==</code> 的区别，以下说法正确的是？</h4><p>A. <code>is</code> 判断值是否相等，<code>==</code> 判断是否为同一对象<br>B.** <code>is</code> 判断是否为同一对象，<code>==</code> 判断值是否相等**C. 两者完全相同<br>D. <code>is</code> 只能用于数字，<code>==</code> 只能用于字符串</p><h3 id="二、填空题（共3题）"><a href="#二、填空题（共3题）" class="headerlink" title="二、填空题（共3题）"></a><strong>二、填空题（共3题）</strong></h3><h4 id="1-计算-8-3-的结果是-，8-3-的结果是-（保留一位小数）。"><a href="#1-计算-8-3-的结果是-，8-3-的结果是-（保留一位小数）。" class="headerlink" title="1. 计算 8 // 3 的结果是 ______，8 / 3 的结果是 ______（保留一位小数）。"></a>1. 计算 <code>8 // 3</code> 的结果是 ______，<code>8 / 3</code> 的结果是 ______（保留一位小数）。</h4><h4 id="2-假设-a-1-2-3-，b-a，则-b-is-a-的结果是-；若-b-a-copy-，则-b-is-a-的结果是-。"><a href="#2-假设-a-1-2-3-，b-a，则-b-is-a-的结果是-；若-b-a-copy-，则-b-is-a-的结果是-。" class="headerlink" title="2. 假设 a = [1, 2, 3]，b = a，则 b is a 的结果是 ______；若 b = a.copy()，则 b is a 的结果是 ______。"></a>2. 假设 <code>a = [1, 2, 3]</code>，<code>b = a</code>，则 <code>b is a</code> 的结果是 ______；若 <code>b = a.copy()</code>，则 <code>b is a</code> 的结果是 ______。</h4><h4 id="3-逻辑运算符中，and-表示-（逻辑与-逻辑或），or-表示-（逻辑与-逻辑或），not-表示-（取反-取余）。"><a href="#3-逻辑运算符中，and-表示-（逻辑与-逻辑或），or-表示-（逻辑与-逻辑或），not-表示-（取反-取余）。" class="headerlink" title="3. 逻辑运算符中，and 表示 ______（逻辑与&#x2F;逻辑或），or 表示 ______（逻辑与&#x2F;逻辑或），not 表示 ______（取反&#x2F;取余）。"></a>3. 逻辑运算符中，<code>and</code> 表示 ______（逻辑与&#x2F;逻辑或），<code>or</code> 表示 ______（逻辑与&#x2F;逻辑或），<code>not</code> 表示 ______（取反&#x2F;取余）。</h4><h3 id="三、代码实践题（共4题）"><a href="#三、代码实践题（共4题）" class="headerlink" title="三、代码实践题（共4题）"></a><strong>三、代码实践题（共4题）</strong></h3><h4 id="1-基础算术运算"><a href="#1-基础算术运算" class="headerlink" title="1. 基础算术运算"></a>1. 基础算术运算</h4><p><strong>问题</strong>：小明有 20 元零花钱，买零食花了 8 元，又收到妈妈给的 15 元红包，现在他有多少钱？用代码计算并打印结果。<br><strong>代码模板</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义初始金额、花费和红包金额</span></span><br><span class="line">initial = <span class="number">20</span></span><br><span class="line">cost = <span class="number">8</span></span><br><span class="line">red_packet = <span class="number">15</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算当前金额</span></span><br><span class="line">current = initial - cost + red_packet</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果（输出应为：27）</span></span><br><span class="line"><span class="built_in">print</span>(current)</span><br></pre></td></tr></table></figure><h4 id="2-比较运算符与条件判断"><a href="#2-比较运算符与条件判断" class="headerlink" title="2. 比较运算符与条件判断"></a>2. 比较运算符与条件判断</h4><p><strong>问题</strong>：判断一个整数 <code>num</code> 是否为偶数且大于 10。若满足条件，打印“符合条件”，否则打印“不符合条件”。（假设 <code>num = 12</code>）</p><h4 id="3-成员运算符实践"><a href="#3-成员运算符实践" class="headerlink" title="3. 成员运算符实践"></a>3. 成员运算符实践</h4><p><strong>问题</strong>：检查字符串 <code>&quot;Hello, Python&quot;</code> 中是否包含子串 <code>&quot;Python&quot;</code>，以及列表 <code>[1, 3, 5, 7]</code> 中是否包含数字 <code>4</code>，分别打印结果。</p><h4 id="4-综合运算：温度转换"><a href="#4-综合运算：温度转换" class="headerlink" title="4. 综合运算：温度转换"></a>4. 综合运算：温度转换</h4><p><strong>问题</strong>：编写代码将摄氏度 <code>celsius</code> 转换为华氏度，公式为：<code>华氏度 = 摄氏度 × 1.8 + 32</code>。<br>要求：用户输入摄氏度（假设输入 <code>25</code>），计算并打印转换后的华氏度（保留一位小数）。</p><h3 id="四、附加：逻辑运算符简要说明（供初学者参考）"><a href="#四、附加：逻辑运算符简要说明（供初学者参考）" class="headerlink" title="四、附加：逻辑运算符简要说明（供初学者参考）"></a><strong>四、附加：逻辑运算符简要说明（供初学者参考）</strong></h3><table><thead><tr><th>运算符</th><th>作用</th><th>例子</th><th>结果</th></tr></thead><tbody><tr><td><code>and</code></td><td>逻辑与（两边都为 <code>True</code> 才返回 <code>True</code>）</td><td><code>True and False</code></td><td><code>False</code></td></tr><tr><td><code>or</code></td><td>逻辑或（至少一边为 <code>True</code> 就返回 <code>True</code>）</td><td><code>True or False</code></td><td><code>True</code></td></tr><tr><td><code>not</code></td><td>逻辑非（取反）</td><td><code>not True</code></td><td><code>False</code></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 变量类型</title>
      <link href="/2025/10/26/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/10/26/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Python-变量入门：给数据起个“名字”"><a href="#Python-变量入门：给数据起个“名字”" class="headerlink" title="Python 变量入门：给数据起个“名字”"></a>Python 变量入门：给数据起个“名字”</h1><p>你可以把变量想象成一个盒子或者一个标签，我们用它来存放一些数据，比如数字、文字等等。这样，当我们以后想用到这些数据的时候，直接叫这个盒子的名字（也就是变量名）就行了，不用再记住具体的数据是什么。</p><h2 id="一、-什么是变量？它有什么用？"><a href="#一、-什么是变量？它有什么用？" class="headerlink" title="一、 什么是变量？它有什么用？"></a>一、 什么是变量？它有什么用？</h2><h3 id="1-1-变量就像贴了标签的盒子"><a href="#1-1-变量就像贴了标签的盒子" class="headerlink" title="1.1 变量就像贴了标签的盒子"></a>1.1 变量就像贴了标签的盒子</h3><p>现在，你有一个空盒子，你在盒子上贴了一张纸条，上面写着“我的年龄”。然后你把一张写着“18”的小纸条放进了这个盒子。这个贴了“我的年龄”标签的盒子，就可以理解为一个变量。</p><ul><li><strong>盒子</strong>：代表计算机内存中的一块存储空间。</li><li><strong>标签上的名字“我的年龄”</strong>：就是我们给变量起的名字（即变量名）。</li><li><strong>盒子里的“18”</strong>：就是这个变量存储的数据（即变量的值）。</li></ul><h3 id="1-2-变量为什么重要？"><a href="#1-2-变量为什么重要？" class="headerlink" title="1.2 变量为什么重要？"></a>1.2 变量为什么重要？</h3><p>如果我们没有变量，每次用到“18”这个数字，都得直接写“18”。万一哪天你想把年龄改成“19”，那所有用到“18”的地方都得一个个找出来改，多麻烦啊！有了变量，我们只需要把“我的年龄”这个盒子里的“18”换成“19”，之后所有用到“我的年龄”这个变量的地方，都会自动变成“19”了。是不是很方便？</p><h2 id="二、-怎么在-Python-中创建变量？"><a href="#二、-怎么在-Python-中创建变量？" class="headerlink" title="二、 怎么在 Python 中创建变量？"></a>二、 怎么在 Python 中创建变量？</h2><p>在 Python 中，创建变量非常简单，不需要像其他有些编程语言那样事先声明：我要一个装数字的盒子或者我要一个装文字的盒子。Python 很聪明，它会自己判断你要装什么类型的数据。</p><h3 id="2-1-基本赋值：用等号-把数据放进盒子"><a href="#2-1-基本赋值：用等号-把数据放进盒子" class="headerlink" title="2.1 基本赋值：用等号 = 把数据放进盒子"></a>2.1 基本赋值：用等号 <code>=</code> 把数据放进盒子</h3><p>创建变量的动作，我们叫做<strong>赋值</strong>。用一个<strong>等号 <code>=</code></strong> 来完成。<br><strong>规则是：等号左边是变量名（也就是盒子的标签），等号右边是你要存的数据（也就是盒子里的东西）。</strong></p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 我想创建一个叫 counter 的变量，存数字 100</span></span><br><span class="line">counter = <span class="number">100</span>  <span class="comment"># 这行代码的意思是：把 100 这个整数放进名为 counter 的盒子里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我想创建一个叫 miles 的变量，存数字 1000.0 (这里，带小数点的是浮点数，至于什么是浮点数，后面的数据类型会详细讲解)</span></span><br><span class="line">miles = <span class="number">1000.0</span>  <span class="comment"># 把 1000.0 这个小数放进名为 miles 的盒子里</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我想创建一个叫 name 的变量，存文字 &quot;John&quot; (这里用引号括起来的是字符串，表示文本)</span></span><br><span class="line">name = <span class="string">&quot;John&quot;</span>   <span class="comment"># 把 &quot;John&quot; 这个名字放进名为 name 的盒子里</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>Python 中，<strong>变量必须先赋值，才能使用</strong>。你不能凭空叫一个不存在的盒子的名字。</li><li>等号 <code>=</code> 在这里的意思是<strong>赋值</strong>，不是<strong>等于</strong>。它表示把右边的东西交给左边的变量。</li></ul><h3 id="2-2-怎么知道变量里存了啥？用-print-函数"><a href="#2-2-怎么知道变量里存了啥？用-print-函数" class="headerlink" title="2.2 怎么知道变量里存了啥？用 print() 函数"></a>2.2 怎么知道变量里存了啥？用 <code>print()</code> 函数</h3><p>我们把东西放进盒子了，怎么看看对不对呢？可以用 <code>print()</code> 函数，把变量名放进去，它就会帮我们把盒子里的东西拿出来看看。</p><p>比如上面的例子，我们可以这样查看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(counter)  <span class="comment"># 打印 counter 变量里的内容</span></span><br><span class="line"><span class="built_in">print</span>(miles)    <span class="comment"># 打印 miles 变量里的内容</span></span><br><span class="line"><span class="built_in">print</span>(name)     <span class="comment"># 打印 name 变量里的内容</span></span><br></pre></td></tr></table></figure><p><strong>运行这些代码，你会看到屏幕上输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">1000.0</span><br><span class="line">John</span><br></pre></td></tr></table></figure><p>是不是和我们存进去的一样？</p><h2 id="三、-变量可以存哪些类型的数据？"><a href="#三、-变量可以存哪些类型的数据？" class="headerlink" title="三、 变量可以存哪些类型的数据？"></a>三、 变量可以存哪些类型的数据？</h2><p>虽然我们不需要提前告诉 Python 变量是什么类型，但变量存储的数据本身是有类型的。常见的有：</p><h3 id="3-1-整数-int"><a href="#3-1-整数-int" class="headerlink" title="3.1 整数 (int)"></a>3.1 整数 (int)</h3><p>就是我们平时说的整数，比如 <code>100</code>, <code>-5</code>, <code>0</code>, <code>999</code> 等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">25</span>       <span class="comment"># age 里面存的是整数</span></span><br><span class="line">student_count = <span class="number">30</span>  <span class="comment"># student_count 里面存的是整数</span></span><br></pre></td></tr></table></figure><h3 id="3-2-浮点数-float"><a href="#3-2-浮点数-float" class="headerlink" title="3.2 浮点数 (float)"></a>3.2 浮点数 (float)</h3><p>带小数点的数字，比如 <code>1000.0</code>, <code>3.14159</code>, <code>-0.5</code> 等等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">height = <span class="number">1.75</span>  <span class="comment"># 身高 1.75 米，是浮点数</span></span><br><span class="line">pi = <span class="number">3.14159</span>   <span class="comment"># 圆周率 pi，是浮点数</span></span><br></pre></td></tr></table></figure><h3 id="3-3-字符串-str"><a href="#3-3-字符串-str" class="headerlink" title="3.3 字符串 (str)"></a>3.3 字符串 (str)</h3><p>就是文字、字符。在 Python 中，字符串需要用<strong>单引号 <code>&#39;</code></strong> 或者 <strong>双引号 <code>&quot;</code></strong> 括起来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;小明&quot;</span>    <span class="comment"># 用双引号</span></span><br><span class="line">message = <span class="string">&#x27;Hello, Python!&#x27;</span>  <span class="comment"># 用单引号</span></span><br><span class="line">favorite_color = <span class="string">&#x27;蓝色&#x27;</span></span><br></pre></td></tr></table></figure><p>Python 里还有其他类型的数据，比如后面会学到的列表、字典等，但这三种是最基础的。</p><h2 id="四、-一次创建多个变量"><a href="#四、-一次创建多个变量" class="headerlink" title="四、 一次创建多个变量"></a>四、 一次创建多个变量</h2><p>Python 还允许我们一次给多个变量赋值，这在某些情况下很方便。</p><h3 id="4-1-多个变量赋同一个值"><a href="#4-1-多个变量赋同一个值" class="headerlink" title="4.1 多个变量赋同一个值"></a>4.1 多个变量赋同一个值</h3><p>比如，我想让 <code>a</code>、<code>b</code>、<code>c</code> 这三个变量一开始都存数字 <code>1</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b = c = <span class="number">1</span>  <span class="comment"># 创建一个值为 1 的数据，然后 a, b, c 都指向它，可以理解为三个标签共用一个盒子</span></span><br></pre></td></tr></table></figure><p>现在，<code>a</code> 是 1，<code>b</code> 是 1，<code>c</code> 也是 1。</p><h3 id="4-2-多个变量赋不同的值"><a href="#4-2-多个变量赋不同的值" class="headerlink" title="4.2 多个变量赋不同的值"></a>4.2 多个变量赋不同的值</h3><p>我想让 <code>x</code> 等于 <code>10</code>，<code>y</code> 等于 <code>20</code>，<code>z</code> 等于 <code>&quot;你好&quot;</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x, y, z = <span class="number">10</span>, <span class="number">20</span>, <span class="string">&quot;你好&quot;</span>  <span class="comment"># 左边变量名用逗号隔开，右边值也用逗号隔开，一一对应</span></span><br></pre></td></tr></table></figure><p>这行代码比分开写三行 <code>x=10; y=20; z=&quot;你好&quot;</code> 要简洁一些。</p><p><strong>注意：</strong> 左边变量的数量和右边值的数量必须一样多，不然会出错！</p><hr><h1 id="Python-的标准数据类型"><a href="#Python-的标准数据类型" class="headerlink" title="Python 的标准数据类型"></a>Python 的标准数据类型</h1><p>当我们把数据存入变量这个盒子”时，Python 会根据数据的特性，将它们划分成不同的类型。就像我们现实中，盒子里可以放书、放玩具车、放积木一样</p><p>Python 有五种最基本、最常用的<strong>标准数据类型</strong>，它们就像乐高积木的基本块，可以组合出复杂的程序。</p><p>这五种标准数据类型是：</p><ol><li><strong>Numbers (数字)</strong></li><li><strong>String (字符串)</strong></li><li><strong>List (列表)</strong></li><li><strong>Tuple (元组)</strong></li><li><strong>Dictionary (字典)</strong></li></ol><p>我们一个个来看。</p><h3 id="3-1-Numbers"><a href="#3-1-Numbers" class="headerlink" title="3.1 Numbers"></a>3.1 Numbers</h3><p>数字类型，听名字就知道，是用来存储各种数值的数据类型。就像我们数学中用到的数字一样。</p><h4 id="3-1-1-数字类型的特点：不可改变"><a href="#3-1-1-数字类型的特点：不可改变" class="headerlink" title="3.1.1 数字类型的特点：不可改变"></a>3.1.1 数字类型的特点：不可改变</h4><p>数字类型是<strong>不可改变的数据类型</strong>。这是什么意思呢？<br>一旦你创建了一个数字类型的变量，并给它赋了值，比如 <code>a = 5</code>，这个 <code>5</code> 在内存中就固定了。如果你想让 <code>a</code> 变成 <code>6</code>，Python 不会去修改原来那个 <code>5</code> 的值，而是会在内存中重新找一块地方存 <code>6</code>，然后让 <code>a</code> 这个标签指向新的 <code>6</code>。原来的 <code>5</code> 如果没有其他变量指向它，就会被 Python 自动“回收”。</p><h4 id="3-1-2-Python-支持的数字类型-主要关注-Python-3-x"><a href="#3-1-2-Python-支持的数字类型-主要关注-Python-3-x" class="headerlink" title="3.1.2 Python 支持的数字类型 (主要关注 Python 3.x)"></a>3.1.2 Python 支持的数字类型 (主要关注 Python 3.x)</h4><p>在 Python 3 中，主要有以下几种数字类型：</p><ul><li><p>**int (有符号整数)**：</p><ul><li>就是我们日常说的整数，可以是正的、负的，也可以是零。</li><li>例如：<code>10</code>, <code>-20</code>, <code>0</code>, <code>1000000</code>, <code>-98765</code></li><li>Python 3 的 <code>int</code> 类型可以表示任意大小的整数，不像有些语言有长度限制。</li></ul></li><li><p>**float (浮点型)**：</p><ul><li>就是带小数点的数字，或者用科学计数法表示的数。</li><li>用于表示小数或精度要求不特别高的实数。</li><li>例如：<code>3.14</code>, <code>-0.001</code>, <code>2.5e3</code> (表示 2.5 × 10³ &#x3D; 2500.0), <code>1.0</code> (虽然是整数，但带了小数点就是 float)</li></ul></li><li><p>**complex (复数)**：</p><ul><li>复数由<strong>实部</strong>和<strong>虚部</strong>组成，形式为 <code>a + bj</code>，其中 <code>a</code> 是实部，<code>b</code> 是虚部，<code>j</code> (或 <code>J</code>) 表示虚数单位。</li><li><code>a</code> 和 <code>b</code> 都是浮点数。</li><li>例如：<code>3+4j</code>, <code>10.5-2.3j</code>, <code>-0.1j</code> (等价于 <code>0 - 0.1j</code>), <code>5j</code></li></ul></li></ul><p><strong>PS：对于刚接触编程的朋友，<code>int</code> 和 <code>float</code> 是最常用的，<code>complex</code> 在特定领域如科学计算中才会用到，初期可以先主要关注前两者。</strong></p><h4 id="3-1-3-创建数字类型变量-del-语句"><a href="#3-1-3-创建数字类型变量-del-语句" class="headerlink" title="3.1.3 创建数字类型变量 &amp; del 语句"></a>3.1.3 创建数字类型变量 &amp; <code>del</code> 语句</h4><p>创建数字类型的变量非常直接，直接赋值即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">25</span>          <span class="comment"># age 是 int 类型</span></span><br><span class="line">height = <span class="number">1.75</span>     <span class="comment"># height 是 float 类型</span></span><br><span class="line">temperature = -<span class="number">3.5</span>  <span class="comment"># temperature 是 float 类型</span></span><br><span class="line">my_complex = <span class="number">3</span> + <span class="number">4j</span>  <span class="comment"># my_complex 是 complex 类型</span></span><br></pre></td></tr></table></figure><p><strong><code>del</code> 语句：删除变量引用</strong><br>如果你不再需要某个变量了，可以使用 <code>del</code> 语句删除对它的引用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 输出：10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> x     <span class="comment"># 删除变量 x</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 这时候再打印 x 就会出错，因为 x 不存在了</span></span><br></pre></td></tr></table></figure><p><code>del</code> 也可以同时删除多个变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">b = <span class="number">2</span></span><br><span class="line">c = <span class="number">3</span></span><br><span class="line"><span class="keyword">del</span> a, b  <span class="comment"># 删除 a 和 b</span></span><br><span class="line"><span class="comment"># 现在 a 和 b 不存在了，但 c 还在</span></span><br></pre></td></tr></table></figure><p><strong>Python 2.x 小贴士 (了解即可)：</strong><br>在旧的 Python 2 版本中，还有一种 <code>long</code> (长整型) 类型，用来表示比普通 <code>int</code> 更大的整数。但在 Python 3 中，<code>long</code> 类型被取消了，统一用 <code>int</code> 来表示所有整数，<code>int</code> 可以自动处理任意大的整数。</p><h3 id="3-2-String-字符串类型"><a href="#3-2-String-字符串类型" class="headerlink" title="3.2 String (字符串类型)"></a>3.2 String (字符串类型)</h3><p>字符串，顾名思义，就是由一串字符组成的数据。我们平时看到的文字、符号，都可以用字符串来表示。</p><h4 id="3-2-1-字符串是什么样的？"><a href="#3-2-1-字符串是什么样的？" class="headerlink" title="3.2.1 字符串是什么样的？"></a>3.2.1 字符串是什么样的？</h4><p>在 Python 中，字符串是用<strong>单引号 <code>&#39; &#39;</code></strong> 或者 <strong>双引号 <code>&quot; &quot;</code></strong> 括起来的<strong>字符序列</strong>。<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Alice&quot;</span>       <span class="comment"># 双引号</span></span><br><span class="line">greeting = <span class="string">&#x27;Hello&#x27;</span>   <span class="comment"># 单引号</span></span><br><span class="line">message = <span class="string">&#x27;I\&#x27;m fine&#x27;</span> <span class="comment"># 单引号内有单引号，需要用反斜杠 \ 转义，或者改用双引号 &quot;I&#x27;m fine&quot;</span></span><br><span class="line">empty_string = <span class="string">&quot;&quot;</span>    <span class="comment"># 空字符串，里面什么都没有</span></span><br><span class="line">multi_line = <span class="string">&quot;&quot;&quot;这是一个</span></span><br><span class="line"><span class="string">多行的</span></span><br><span class="line"><span class="string">字符串&quot;&quot;&quot;</span>  <span class="comment"># 三引号 (&#x27;&#x27;&#x27; 或 &quot;&quot;&quot;) 可以用来表示多行字符串</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-字符串的特点"><a href="#3-2-2-字符串的特点" class="headerlink" title="3.2.2 字符串的特点"></a>3.2.2 字符串的特点</h4><p>和数字类型一样，字符串也是<strong>不可改变的数据类型</strong>。这意味着你不能直接修改字符串中的某个字符。比如说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># s[0] = &quot;H&quot;  # 这样做是错误的！会报错！</span></span><br></pre></td></tr></table></figure><p>如果想得到 “Hello”，你需要创建一个新的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line">new_s = <span class="string">&quot;H&quot;</span> + s[<span class="number">1</span>:]  <span class="comment"># &quot;H&quot; 加上 s 从第2个字符开始到结尾的部分 (ello)</span></span><br><span class="line"><span class="built_in">print</span>(new_s)  <span class="comment"># 输出：Hello</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-字符串的基本操作"><a href="#3-2-3-字符串的基本操作" class="headerlink" title="3.2.3 字符串的基本操作"></a>3.2.3 字符串的基本操作</h4><ul><li><strong>拼接</strong>：用 <code>+</code> 号可以将两个字符串连接起来。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_name = <span class="string">&quot;张&quot;</span></span><br><span class="line">last_name = <span class="string">&quot;三&quot;</span></span><br><span class="line">full_name = last_name + first_name  <span class="comment"># &quot;三&quot; + &quot;张&quot; = &quot;三张&quot; ，在这里，只是演示拼接</span></span><br><span class="line"><span class="comment"># 或者更正常的 &quot;张&quot; + &quot;三&quot; = &quot;张三&quot;</span></span><br></pre></td></tr></table></figure></li><li><strong>重复</strong>：用 <code>*</code> 号可以将字符串重复多次。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">star = <span class="string">&quot;*&quot;</span></span><br><span class="line">line = star * <span class="number">10</span>  <span class="comment"># 重复 10 次 &quot;*&quot;</span></span><br><span class="line"><span class="built_in">print</span>(line)  <span class="comment"># 输出：**********</span></span><br></pre></td></tr></table></figure></li><li><strong>索引 (Indexing)<strong>：字符串中的每个字符都有一个位置编号，叫做</strong>索引</strong>。我们可以通过索引来访问单个字符。<strong>注意：Python 中索引是从 0 开始的！</strong><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 输出第 1 个字符 &#x27;P&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])  <span class="comment"># 输出第 2 个字符 &#x27;y&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">5</span>])  <span class="comment"># 输出第 6 个字符 &#x27;n&#x27; ，因为 &quot;Python&quot; 有 6 个字母，索引 0-5</span></span><br></pre></td></tr></table></figure></li><li>**切片 (Slicing)**：通过切片可以获取字符串的一部分（子串）。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">5</span>])  <span class="comment"># 从索引 0 开始，到索引 5 之前结束 (不包含 5)，输出 &quot;Hello&quot;</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-2-String-字符串类型-深入了解"><a href="#3-2-String-字符串类型-深入了解" class="headerlink" title="3.2 String (字符串类型) - 深入了解"></a>3.2 String (字符串类型) - 深入了解</h3><p>字符串，就是把文字、符号等<strong>字符</strong>像穿珠子一样串起来形成的序列。在 Python 中，创建字符串非常简单。</p><h4 id="3-2-1-如何表示一个字符串？——-引号大法"><a href="#3-2-1-如何表示一个字符串？——-引号大法" class="headerlink" title="3.2.1 如何表示一个字符串？—— 引号大法"></a>3.2.1 如何表示一个字符串？—— 引号大法</h4><p>在 Python 中，字符串必须用<strong>引号</strong>括起来。你可以使用：</p><ul><li><strong>单引号 <code>&#39; &#39;</code></strong></li><li><strong>双引号 <code>&quot; &quot;</code></strong></li></ul><p>它们的作用是一样的，选一个你喜欢的用就行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">name1 = <span class="string">&#x27;小明&#x27;</span>    <span class="comment"># 单引号</span></span><br><span class="line">name2 = <span class="string">&quot;小红&quot;</span>    <span class="comment"># 双引号</span></span><br><span class="line"><span class="built_in">print</span>(name1)</span><br><span class="line"><span class="built_in">print</span>(name2)</span><br></pre></td></tr></table></figure><p><strong>为什么要有两种引号？</strong><br>有时候，字符串里面本身就包含了引号，这时候另一种引号就派上用场了，可以避免混淆。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 假设我们要表示 He said, &quot;Hello!&quot; 这句话</span></span><br><span class="line">sentence1 = <span class="string">&#x27;He said, &quot;Hello!&quot;&#x27;</span>  <span class="comment"># 外面用单引号，里面就可以直接用双引号</span></span><br><span class="line">sentence2 = <span class="string">&quot;He said, &#x27;Hello!&#x27;&quot;</span>  <span class="comment"># 外面用双引号，里面就可以直接用单引号</span></span><br><span class="line"><span class="built_in">print</span>(sentence1)</span><br><span class="line"><span class="built_in">print</span>(sentence2)</span><br></pre></td></tr></table></figure><p>如果字符串里既有单引号又有双引号，或者你坚持要用同一种引号，那么可以使用<strong>反斜杠 <code>\</code></strong> 来转义内部的引号。<code>\</code> 告诉 Python 后面的那个引号不是字符串的结束标志，而是字符串内容的一部分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentence3 = <span class="string">&#x27;He said, \&#x27;I\&#x27;m fine.\&#x27;&#x27;</span>  <span class="comment"># 用 \&#x27; 表示字符串内部的单引号</span></span><br><span class="line"><span class="built_in">print</span>(sentence3)  <span class="comment"># 输出: He said, &#x27;I&#x27;m fine.&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>三引号 <code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code></strong><br>还有一种特殊的三引号，它可以用来表示<strong>多行字符串</strong>，或者包含了很多单双引号且不想频繁转义的复杂字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">poem = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">床前明月光，</span></span><br><span class="line"><span class="string">疑是地上霜。</span></span><br><span class="line"><span class="string">举头望明月，</span></span><br><span class="line"><span class="string">低头思故乡。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(poem)  <span class="comment"># 会按照原格式（包括换行）输出</span></span><br></pre></td></tr></table></figure><h4 id="3-2-2-字符串的特点：“只读”属性-——-不可改变"><a href="#3-2-2-字符串的特点：“只读”属性-——-不可改变" class="headerlink" title="3.2.2 字符串的特点：“只读”属性 —— 不可改变"></a>3.2.2 字符串的特点：“只读”属性 —— 不可改变</h4><p><strong>重要！重要！重要！</strong> (说三遍)<br>和数字类型一样，Python 中的字符串也是<strong>不可改变的数据类型</strong>。<br>这意味着，一旦一个字符串被创建，你就不能直接修改它里面的某个字符。你能做的是创建一个新的字符串。</p><p>想象字符串像一个封死的胶囊，里面的内容不能改，但你可以把胶囊里的东西倒出来，加点别的，再装入一个新的胶囊。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="comment"># 尝试修改第一个字符为 &#x27;H&#x27;</span></span><br><span class="line"><span class="comment"># s[0] = &#x27;H&#x27;  # 这行代码会报错！！！ TypeError: &#x27;str&#x27; object does not support item assignment</span></span><br><span class="line"><span class="built_in">print</span>(s)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的做法：创建一个新的字符串</span></span><br><span class="line">new_s = <span class="string">&#x27;H&#x27;</span> + s[<span class="number">1</span>:]  <span class="comment"># &#x27;H&#x27; 加上 s 中从索引 1 开始到结尾的字符 (ello)</span></span><br><span class="line"><span class="built_in">print</span>(new_s)  <span class="comment"># 输出: Hello</span></span><br></pre></td></tr></table></figure><h4 id="3-2-3-字符串的索引-Index-访问单个字符"><a href="#3-2-3-字符串的索引-Index-访问单个字符" class="headerlink" title="3.2.3 字符串的索引 (Index) - 访问单个字符"></a>3.2.3 字符串的索引 (Index) - 访问单个字符</h4><p>字符串是字符的序列，就像一排座位，每个字符都坐在一个固定的位置上。我们可以通过<strong>位置编号</strong>来访问字符串中的单个字符，这个位置编号就叫做**索引 (Index)**。</p><p><strong>关键点：在 Python 中，索引是从 <code>0</code> 开始的！</strong> 第一个字符的索引是 <code>0</code>，第二个是 <code>1</code>，依此类推。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python&quot;</span>  <span class="comment"># 字符串 &quot;P&quot; &quot;y&quot; &quot;t&quot; &quot;h&quot; &quot;o&quot; &quot;n&quot;</span></span><br><span class="line"><span class="comment"># 索引:    0    1    2    3    4    5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>])  <span class="comment"># 获取索引为 0 的字符，即第一个字符。输出: P</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">1</span>])  <span class="comment"># 获取索引为 1 的字符。输出: y</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">5</span>])  <span class="comment"># 获取索引为 5 的字符。输出: n</span></span><br></pre></td></tr></table></figure><p><strong>如果索引超出了字符串的长度会怎么样？</strong><br>会报错！<code>IndexError: string index out of range</code> (字符串索引超出范围)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python&quot;</span>  <span class="comment"># 长度是 6，索引最大是 5</span></span><br><span class="line"><span class="comment"># print(s[6])  # 这行会报错！</span></span><br></pre></td></tr></table></figure><p><strong>负索引：从右边开始数</strong><br>除了从左往右从 <code>0</code> 开始，Python 还支持<strong>负索引</strong>，就是从字符串的右边开始数，最右边的字符是 <code>-1</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Python&quot;</span>  <span class="comment">#  &quot;P&quot;  &quot;y&quot;  &quot;t&quot;  &quot;h&quot;  &quot;o&quot;  &quot;n&quot;</span></span><br><span class="line"><span class="comment"># 正索引: 0    1    2    3    4    5</span></span><br><span class="line"><span class="comment"># 负索引: -6  -5   -4   -3   -2   -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">1</span>])  <span class="comment"># 获取最后一个字符。输出: n</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">2</span>])  <span class="comment"># 获取倒数第二个字符。输出: o</span></span><br><span class="line"><span class="built_in">print</span>(s[-<span class="number">6</span>])  <span class="comment"># 获取倒数第六个字符 (也就是第一个字符)。输出: P</span></span><br></pre></td></tr></table></figure><h4 id="3-2-4-字符串的切片"><a href="#3-2-4-字符串的切片" class="headerlink" title="3.2.4 字符串的切片"></a>3.2.4 字符串的切片</h4><p>有时候我们不需要整个字符串，只想得到它的一部分，比如前3个字符，或者中间某一段，这就是<strong>切片</strong>。</p><p><strong>切片的格式：<code>字符串[开始索引 : 结束索引]</code></strong></p><ul><li><strong>开始索引</strong>：包含在结果中。</li><li><strong>结束索引</strong>：<strong>不包含</strong>在结果中。切片会取到 <code>结束索引 - 1</code> 的位置。</li><li>切片得到的是一个<strong>新的字符串</strong>，原字符串不会被改变，因为字符串不可变</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s)          <span class="comment"># 输出整个字符串: Hello, World!</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子1：获取 &quot;Hello&quot;</span></span><br><span class="line"><span class="comment"># &quot;H&quot; &quot;e&quot; &quot;l&quot; &quot;l&quot; &quot;o&quot;</span></span><br><span class="line"><span class="comment">#  0   1   2   3   4</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">5</span>])     <span class="comment"># 从索引 0 开始，到索引 5 结束 ，但不包含 5。输出: Hello</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 例子2：获取 &quot;World&quot;</span></span><br><span class="line"><span class="comment"># &quot;, &quot; &quot;W&quot; &quot;o&quot; &quot;r&quot; &quot;l&quot; &quot;d&quot; &quot;!&quot;</span></span><br><span class="line"><span class="comment">#  5   6   7   8   9   10  11</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">7</span>:<span class="number">12</span>])    <span class="comment"># 从索引 7 开始，到索引 12 结束。输出: World</span></span><br></pre></td></tr></table></figure><p><strong>切片的省略写法：</strong></p><ul><li>如果省略 <code>开始索引</code>，表示从字符串的<strong>开头</strong>开始取。<ul><li><code>s[:5]</code> 等价于 <code>s[0:5]</code></li></ul></li><li>如果省略 <code>结束索引</code>，表示一直取到字符串的<strong>末尾</strong>（这里也包括最后一个字符）。<ul><li><code>s[7:]</code> 表示从索引7开始，取到最后。</li></ul></li><li>如果都省略，<code>s[:]</code>，表示取整个字符串的副本。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[:<span class="number">5</span>])   <span class="comment"># 输出: Hello ，从开头到索引5之前</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">7</span>:])   <span class="comment"># 输出: World! 从索引7到结尾</span></span><br><span class="line"><span class="built_in">print</span>(s[:])    <span class="comment"># 输出: Hello, World! 是整个字符串</span></span><br></pre></td></tr></table></figure><p><strong>步长 (step)：跳跃着取</strong><br>切片还有一个可选参数：<strong>步长</strong>，格式 <code>字符串[开始索引 : 结束索引 : 步长]</code>。步长默认是 <code>1</code>，表示一个一个挨着取。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;abcdefghijklmn&quot;</span></span><br><span class="line"><span class="built_in">print</span>(s[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>])  <span class="comment"># 从0到10，步长2 ，每隔1个取一个。输出: acegi</span></span><br><span class="line"><span class="built_in">print</span>(s[::<span class="number">3</span>])     <span class="comment"># 从开头到结尾，步长3。输出: adgjm</span></span><br><span class="line"><span class="built_in">print</span>(s[::-<span class="number">1</span>])    <span class="comment"># 步长为 -1，表示倒序！非常有用！输出: nmlkjihgfedcba</span></span><br></pre></td></tr></table></figure><h4 id="3-2-5-字符串的常用操作"><a href="#3-2-5-字符串的常用操作" class="headerlink" title="3.2.5 字符串的常用操作"></a>3.2.5 字符串的常用操作</h4><p>字符串有很多内置的小工具可以使用，也支持一些运算符。</p><h5 id="（1）字符串拼接-号"><a href="#（1）字符串拼接-号" class="headerlink" title="（1）字符串拼接 - + 号"></a>（1）字符串拼接 - <code>+</code> 号</h5><p>用 <code>+</code> 号可以把两个或多个字符串“粘”在一起，形成一个新的字符串。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">greeting = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">name = <span class="string">&quot;Alice&quot;</span></span><br><span class="line">message = greeting + <span class="string">&quot;, &quot;</span> + name + <span class="string">&quot;!&quot;</span>  <span class="comment"># &quot;Hello&quot; + &quot;, &quot; + &quot;Alice&quot; + &quot;!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(message)  <span class="comment"># 输出: Hello, Alice!</span></span><br></pre></td></tr></table></figure><p><strong>注意：<code>+</code> 号两边必须都是字符串才能拼接。你不能直接把字符串和数字用 <code>+</code> 拼接。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">age = <span class="number">18</span></span><br><span class="line"><span class="comment"># print(&quot;我今年&quot; + age + &quot;岁了&quot;)  # 这行会报错！因为 age 是整数。</span></span><br><span class="line"><span class="comment"># 正确做法：把数字转换成字符串 str(age)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;我今年&quot;</span> + <span class="built_in">str</span>(age) + <span class="string">&quot;岁了&quot;</span>)  <span class="comment"># 输出: 我今年18岁了</span></span><br></pre></td></tr></table></figure><h5 id="（2）字符串重复-号"><a href="#（2）字符串重复-号" class="headerlink" title="（2）字符串重复 - * 号"></a>（2）字符串重复 - <code>*</code> 号</h5><p>用 <code>*</code> 号可以让一个字符串重复多次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">star = <span class="string">&quot;*&quot;</span></span><br><span class="line">line = star * <span class="number">10</span>  <span class="comment"># 把 &quot;*&quot; 重复 10 次</span></span><br><span class="line"><span class="built_in">print</span>(line)       <span class="comment"># 输出: **********</span></span><br><span class="line"></span><br><span class="line">laugh = <span class="string">&quot;haha&quot;</span></span><br><span class="line">big_laugh = laugh * <span class="number">3</span>  <span class="comment"># &quot;haha&quot; *3 = &quot;hahahahaha&quot;</span></span><br><span class="line"><span class="built_in">print</span>(big_laugh)  <span class="comment"># 输出: hahahahahaha</span></span><br></pre></td></tr></table></figure><h5 id="（3）获取字符串长度-len-函数"><a href="#（3）获取字符串长度-len-函数" class="headerlink" title="（3）获取字符串长度 - len() 函数"></a>（3）获取字符串长度 - <code>len()</code> 函数</h5><p><code>len()</code> 是一个内置函数（不是字符串独有的，但字符串常用），它可以返回字符串中<strong>字符的个数</strong>，也就是字符串的长度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">length = <span class="built_in">len</span>(s)</span><br><span class="line"><span class="built_in">print</span>(length)  <span class="comment"># 输出: 5</span></span><br><span class="line"></span><br><span class="line">empty = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(empty))  <span class="comment"># 输出: 0 ，因为空字符串长度为0</span></span><br></pre></td></tr></table></figure><h3 id="3-3-List-，列表类型"><a href="#3-3-List-，列表类型" class="headerlink" title="3.3 List ，列表类型"></a>3.3 List ，列表类型</h3><p>列表（List）是 Python 中使用最频繁的数据类型之一，你可以把它想象成一个<strong>超级灵活的“集装箱”</strong> 或者一个<strong>有序的队伍</strong>。这个集装箱里可以装任何东西：数字、字符串、甚至是另一个列表（这叫嵌套），而且顺序是固定的，我们还可以随时往里加东西、减东西、改东西。</p><h4 id="3-3-1-列表长什么样？——-中括号-来标识"><a href="#3-3-1-列表长什么样？——-中括号-来标识" class="headerlink" title="3.3.1 列表长什么样？—— 中括号 [] 来标识"></a>3.3.1 列表长什么样？—— 中括号 <code>[]</code> 来标识</h4><p>列表使用 <strong>中括号 <code>[]</code></strong> 来创建，列表中的元素之间用 <strong>逗号 <code>,</code></strong> 分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个装水果名称的列表</span></span><br><span class="line">fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(fruits)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个装数字的列表</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个“大杂烩”列表：可以包含不同类型的元素</span></span><br><span class="line">mixed_list = [<span class="string">&#x27;Hello&#x27;</span>, <span class="number">42</span>, <span class="number">3.14</span>, <span class="literal">True</span>, fruits]  <span class="comment"># 甚至包含了上面的 fruits 列表！</span></span><br><span class="line"><span class="built_in">print</span>(mixed_list)</span><br></pre></td></tr></table></figure><h4 id="3-3-2-列表的特点："><a href="#3-3-2-列表的特点：" class="headerlink" title="3.3.2 列表的特点："></a>3.3.2 列表的特点：</h4><ol><li><strong>有序性</strong>：列表中的元素有明确的顺序，每个元素都有自己的位置</li><li><strong>可变性 (Mutable)<strong>：这是列表非常重要的一个特点！我们可以</strong>修改</strong>列表中的元素值，可以<strong>添加</strong>新元素，也可以<strong>删除</strong>已有元素。这和我们之前学的数字、字符串的“不可变性”形成了鲜明对比</li><li><strong>元素多样性</strong>：列表中的元素可以是不同类型的，整数、浮点数、字符串、布尔值、甚至其他列表或对象</li></ol><h4 id="3-3-3-访问列表元素-和字符串索引、切片很像！"><a href="#3-3-3-访问列表元素-和字符串索引、切片很像！" class="headerlink" title="3.3.3 访问列表元素 - 和字符串索引、切片很像！"></a>3.3.3 访问列表元素 - 和字符串索引、切片很像！</h4><p>因为列表是有序的，所以我们可以通过<strong>索引</strong> 来访问列表中的单个元素，也可以通过<strong>切片</strong> 来访问列表的一个子序列。这和字符串的索引、切片操作几乎完全一样！</p><p><strong>索引规则：</strong></p><ul><li>从左往右：第一个元素的索引是 <code>0</code>，第二个是 <code>1</code>，依此类推。</li><li>从右往左：最后一个元素的索引是 <code>-1</code>，倒数第二个是 <code>-2</code>，依此类推。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问列表中的第一个元素</span></span><br><span class="line"><span class="built_in">print</span>(fruits[<span class="number">0</span>])  <span class="comment"># 输出: apple</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问列表中的第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(fruits[<span class="number">1</span>])  <span class="comment"># 输出: banana</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问列表中的最后一个元素 </span></span><br><span class="line"><span class="built_in">print</span>(fruits[-<span class="number">1</span>])  <span class="comment"># 输出: date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问列表中的倒数第二个元素</span></span><br><span class="line"><span class="built_in">print</span>(fruits[-<span class="number">2</span>])  <span class="comment"># 输出: cherry</span></span><br></pre></td></tr></table></figure><p><strong>切片规则：<code>列表[开始索引 : 结束索引 : 步长]</code></strong></p><ul><li><strong>开始索引</strong>：包含在结果中。</li><li><strong>结束索引</strong>：<strong>不包含</strong>在结果中。</li><li><strong>步长</strong>：每隔多少个元素取一个，默认是 1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从索引 2 开始到索引 5 结束 </span></span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">2</span>:<span class="number">5</span>])   <span class="comment"># 输出: [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从索引 3 开始到列表末尾</span></span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">3</span>:])    <span class="comment"># 输出: [3, 4, 5, 6, 7, 8, 9]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从列表开头到索引 5 结束 </span></span><br><span class="line"><span class="built_in">print</span>(numbers[:<span class="number">5</span>])    <span class="comment"># 输出: [0, 1, 2, 3, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：步长为 2 (隔一个取一个)</span></span><br><span class="line"><span class="built_in">print</span>(numbers[<span class="number">0</span>:<span class="number">10</span>:<span class="number">2</span>]) <span class="comment"># 输出: [0, 2, 4, 6, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：步长为 -1 (倒序)</span></span><br><span class="line"><span class="built_in">print</span>(numbers[::-<span class="number">1</span>])   <span class="comment"># 输出: [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] 非常有用！</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：列表也可以嵌套</span></span><br><span class="line">nested_list = [<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>, <span class="string">&#x27;a&#x27;</span>], <span class="number">5</span>]</span><br><span class="line"><span class="built_in">print</span>(nested_list[<span class="number">2</span>])       <span class="comment"># 输出: [3, 4, &#x27;a&#x27;] 取出第三层的小列表</span></span><br><span class="line"><span class="built_in">print</span>(nested_list[<span class="number">2</span>][<span class="number">2</span>])    <span class="comment"># 输出: &#x27;a&#x27; 先取小列表，再取小列表的第三个元素</span></span><br></pre></td></tr></table></figure><h4 id="3-3-4-修改列表元素-直接赋值！"><a href="#3-3-4-修改列表元素-直接赋值！" class="headerlink" title="3.3.4 修改列表元素 - 直接赋值！"></a>3.3.4 修改列表元素 - 直接赋值！</h4><p>正是因为列表是“可变的”，所以我们可以直接通过索引来修改列表中某个位置的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前:&quot;</span>, colors)  <span class="comment"># 输出: 修改前: [&#x27;red&#x27;, &#x27;green&#x27;, &#x27;blue&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改第二个元素</span></span><br><span class="line">colors[<span class="number">1</span>] = <span class="string">&#x27;yellow&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后:&quot;</span>, colors)  <span class="comment"># 输出: 修改后: [&#x27;red&#x27;, &#x27;yellow&#x27;, &#x27;blue&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以修改切片</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">numbers[<span class="number">1</span>:<span class="number">3</span>] = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]  <span class="comment"># 把索引 1-2 的元素替换成 [&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(numbers)  <span class="comment"># 输出: [1, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, 4, 5]</span></span><br></pre></td></tr></table></figure><p>对比字符串：你能直接修改字符串中的某个字符吗？不能！<code>s = &quot;hello&quot;; s[0] = &quot;H&quot;</code> 会报错。但列表可以！</p><h4 id="3-3-5-列表的常用操作"><a href="#3-3-5-列表的常用操作" class="headerlink" title="3.3.5 列表的常用操作"></a>3.3.5 列表的常用操作</h4><h5 id="（1）列表连接-拼接-号"><a href="#（1）列表连接-拼接-号" class="headerlink" title="（1）列表连接 (拼接) - + 号"></a>（1）列表连接 (拼接) - <code>+</code> 号</h5><p>和字符串一样，<code>+</code> 号可以将两个列表连接起来，形成一个新的列表。原列表不会被改变。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">list2 = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line">combined_list = list1 + list2</span><br><span class="line"><span class="built_in">print</span>(combined_list)  <span class="comment"># 输出: [1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(list1)  <span class="comment"># 输出: [1, 2, 3] list1 本身没变</span></span><br><span class="line"><span class="built_in">print</span>(list2)  <span class="comment"># 输出: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;] list2 本身也没变</span></span><br></pre></td></tr></table></figure><h5 id="（2）列表重复-号"><a href="#（2）列表重复-号" class="headerlink" title="（2）列表重复 - * 号"></a>（2）列表重复 - <code>*</code> 号</h5><p>和字符串一样，<code>*</code> 号可以将列表中的元素重复多次，形成一个新的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">repeated = numbers * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(repeated)  <span class="comment"># 输出: [0, 1, 0, 1, 0, 1]</span></span><br></pre></td></tr></table></figure><h5 id="（3）获取列表长度-len-函数"><a href="#（3）获取列表长度-len-函数" class="headerlink" title="（3）获取列表长度  - len() 函数"></a>（3）获取列表长度  - <code>len()</code> 函数</h5><p><code>len()</code> 函数同样适用于列表，返回列表中元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(fruits))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure><h5 id="（4）步长参数在列表切片中的应用"><a href="#（4）步长参数在列表切片中的应用" class="headerlink" title="（4）步长参数在列表切片中的应用"></a>（4）步长参数在列表切片中的应用</h5><p>我们之前在字符串切片中见过步长，列表切片也完全支持。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">numbers = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从索引 1 到索引 8 ，步长为 2 每隔一个取一个</span></span><br><span class="line">sub_list = numbers[<span class="number">1</span>:<span class="number">8</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(sub_list)  <span class="comment"># 输出: [1, 3, 5, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长为负数，从后往前跳着取</span></span><br><span class="line">reverse_step = numbers[<span class="number">8</span>:<span class="number">1</span>:-<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(reverse_step)  <span class="comment"># 输出: [8, 6, 4, 2]</span></span><br></pre></td></tr></table></figure><h3 id="3-4-Tuple——元组类型"><a href="#3-4-Tuple——元组类型" class="headerlink" title="3.4 Tuple——元组类型"></a>3.4 Tuple——元组类型</h3><p>元组 (Tuple) 是 Python 中的另一个重要序列类型，它和我们刚刚学过的<strong>列表 (List)</strong> 非常相似，但又有一个关键的区别。</p><h4 id="3-4-1-元组长什么样？——-小括号-来标识"><a href="#3-4-1-元组长什么样？——-小括号-来标识" class="headerlink" title="3.4.1 元组长什么样？—— 小括号 () 来标识"></a>3.4.1 元组长什么样？—— 小括号 <code>()</code> 来标识</h4><p>元组使用 <strong>小括号 <code>()</code></strong> 来创建，元组中的元素之间同样用 <strong>逗号 <code>,</code></strong> 分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个装城市名称的元组</span></span><br><span class="line">cities = (<span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Shanghai&#x27;</span>, <span class="string">&#x27;Guangzhou&#x27;</span>, <span class="string">&#x27;Shenzhen&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(cities)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个装数字的元组</span></span><br><span class="line">coordinates = (<span class="number">10.5</span>, <span class="number">20.3</span>)  <span class="comment"># 比如表示一个二维坐标 (x, y)</span></span><br><span class="line"><span class="built_in">print</span>(coordinates)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个“大杂烩”元组：也可以包含不同类型的元素</span></span><br><span class="line">mixed_tuple = (<span class="string">&#x27;Hi&#x27;</span>, <span class="number">100</span>, <span class="number">3.14</span>, <span class="literal">True</span>, cities)  <span class="comment"># 也可以包含列表或其他元组</span></span><br><span class="line"><span class="built_in">print</span>(mixed_tuple)</span><br></pre></td></tr></table></figure><p><strong>一个特殊情况：创建只有一个元素的元组</strong><br>如果元组中只有一个元素，**必须在这个元素后面加上一个逗号 <code>,</code>**，否则 Python 会把它当成一个普通的括号表达式，而不是元组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">single_tuple1 = (<span class="number">5</span>)       <span class="comment"># 这不是元组！这只是一个整数 5 加上括号</span></span><br><span class="line">single_tuple2 = (<span class="number">5</span>,)      <span class="comment"># 这才是元组！元素后面有逗号</span></span><br><span class="line">single_tuple3 = <span class="string">&#x27;a&#x27;</span>,      <span class="comment"># 甚至可以不加括号，直接写 &#x27;a&#x27;, 也是一个元组 .但是不推荐，可读性差</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_tuple1))  <span class="comment"># 输出: &lt;class &#x27;int&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_tuple2))  <span class="comment"># 输出: &lt;class &#x27;tuple&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(single_tuple3))  <span class="comment"># 输出: &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-2-元组的特点："><a href="#3-4-2-元组的特点：" class="headerlink" title="3.4.2 元组的特点："></a>3.4.2 元组的特点：</h4><ol><li><strong>有序性</strong>：和列表一样，元组中的元素有明确的顺序，每个元素都有自己的位置。</li><li><strong>不可变性 (Immutable)<strong>：这是元组和列表最根本的区别！一旦一个元组被创建，你就</strong>不能修改</strong>它里面的元素值，<strong>不能添加</strong>新元素，也<strong>不能删除</strong>已有元素。是不是想到了字符串和数字？</li><li><strong>元素多样性</strong>：和列表一样，元组中的元素也可以是不同类型的</li></ol><h4 id="3-4-3-访问元组元素-和列表、字符串的索引、切片完全一样！"><a href="#3-4-3-访问元组元素-和列表、字符串的索引、切片完全一样！" class="headerlink" title="3.4.3 访问元组元素 - 和列表、字符串的索引、切片完全一样！"></a>3.4.3 访问元组元素 - 和列表、字符串的索引、切片完全一样！</h4><p>因为元组也是有序的序列，所以访问元组元素的方式和列表、字符串完全相同——使用<strong>索引 (Index)</strong> 访问单个元素，使用<strong>切片 (Slicing)</strong> 访问子序列。</p><p><strong>索引规则：</strong></p><ul><li>从左往右：第一个元素的索引是 <code>0</code>。</li><li>从右往左：最后一个元素的索引是 <code>-1</code>。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">languages = (<span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;JavaScript&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元组中的第一个元素 </span></span><br><span class="line"><span class="built_in">print</span>(languages[<span class="number">0</span>])  <span class="comment"># 输出: Python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元组中的第三个元素 </span></span><br><span class="line"><span class="built_in">print</span>(languages[<span class="number">2</span>])  <span class="comment"># 输出: C++</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问元组中的最后一个元素 </span></span><br><span class="line"><span class="built_in">print</span>(languages[-<span class="number">1</span>])  <span class="comment"># 输出: JavaScript</span></span><br></pre></td></tr></table></figure><p><strong>切片规则：<code>元组[开始索引 : 结束索引 : 步长]</code></strong></p><ul><li><strong>开始索引</strong>：包含。</li><li><strong>结束索引</strong>：不包含。</li><li><strong>步长</strong>：默认 1。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">numbers_tuple = (<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从索引 1 到索引 4 </span></span><br><span class="line"><span class="built_in">print</span>(numbers_tuple[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 输出: (1, 2, 3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切片：从索引 5 开始到末尾</span></span><br><span class="line"><span class="built_in">print</span>(numbers_tuple[<span class="number">5</span>:])   <span class="comment"># 输出: (5, 6, 7, 8, 9)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 步长为 2</span></span><br><span class="line"><span class="built_in">print</span>(numbers_tuple[::<span class="number">2</span>])  <span class="comment"># 输出: (0, 2, 4, 6, 8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套元组的访问</span></span><br><span class="line">nested_tuple = (<span class="number">1</span>, (<span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;a&#x27;</span>), <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(nested_tuple[<span class="number">1</span>])       <span class="comment"># 输出: (2, 3, &#x27;a&#x27;) 取出里面的小元组</span></span><br><span class="line"><span class="built_in">print</span>(nested_tuple[<span class="number">1</span>][<span class="number">2</span>])    <span class="comment"># 输出: &#x27;a&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="3-4-4-修改元组元素？"><a href="#3-4-4-修改元组元素？" class="headerlink" title="3.4.4 修改元组元素？"></a>3.4.4 修改元组元素？</h4><p><strong>元组是不可变 (Immutable) 的！</strong> 这是元组和列表最核心的区别。一旦创建，元组的内容就不能被修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fruits_tuple = (<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前:&quot;</span>, fruits_tuple)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 尝试修改元组中的第二个元素 </span></span><br><span class="line"><span class="comment"># fruits_tuple[1] = &#x27;orange&#x27;  # 这行代码会报错！！！</span></span><br><span class="line"><span class="comment"># 错误信息类似：TypeError: &#x27;tuple&#x27; object does not support item assignment</span></span><br></pre></td></tr></table></figure><p>你也不能直接给元组的切片赋值来修改它，或者删除它的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 尝试删除元组元素</span></span><br><span class="line"><span class="comment"># del fruits_tuple[0]  # 同样会报错！</span></span><br></pre></td></tr></table></figure><h4 id="3-4-5-元组的常用操作"><a href="#3-4-5-元组的常用操作" class="headerlink" title="3.4.5 元组的常用操作"></a>3.4.5 元组的常用操作</h4><p>因为元组不可变，所以很多修改性的操作都不能做。但一些非修改性的操作和列表类似。</p><h5 id="（1）元组连接-拼接-号"><a href="#（1）元组连接-拼接-号" class="headerlink" title="（1）元组连接 (拼接) - + 号"></a>（1）元组连接 (拼接) - <code>+</code> 号</h5><p><code>+</code> 号可以将两个元组连接起来，形成一个<strong>新的元组</strong>。<strong>原有的元组不会被改变</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tuple1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">tuple2 = (<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">combined_tuple = tuple1 + tuple2</span><br><span class="line"><span class="built_in">print</span>(combined_tuple)  <span class="comment"># 输出: (1, 2, 3, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(tuple1)  <span class="comment"># 输出: (1, 2, 3) (tuple1 本身没变)</span></span><br><span class="line"><span class="built_in">print</span>(tuple2)  <span class="comment"># 输出: (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (tuple2 本身也没变)</span></span><br></pre></td></tr></table></figure><h5 id="（2）元组重复-号"><a href="#（2）元组重复-号" class="headerlink" title="（2）元组重复 - * 号"></a>（2）元组重复 - <code>*</code> 号</h5><p><code>*</code> 号可以将元组中的元素重复多次，形成一个<strong>新的元组</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">simple_tuple = (<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">repeated_tuple = simple_tuple * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(repeated_tuple)  <span class="comment"># 输出: (&#x27;x&#x27;, &#x27;y&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;x&#x27;, &#x27;y&#x27;)</span></span><br></pre></td></tr></table></figure><h5 id="（3）获取元组长度-len-函数"><a href="#（3）获取元组长度-len-函数" class="headerlink" title="（3）获取元组长度 - len() 函数"></a>（3）获取元组长度 - <code>len()</code> 函数</h5><p><code>len()</code> 函数同样适用于元组，返回元组中元素的个数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fruits_tuple = (<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(fruits_tuple))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure><h4 id="3-4-6-元组-vs-列表：我该用哪个？"><a href="#3-4-6-元组-vs-列表：我该用哪个？" class="headerlink" title="3.4.6 元组 vs 列表：我该用哪个？"></a>3.4.6 元组 vs 列表：我该用哪个？</h4><p>既然元组和列表这么像，而且元组还不能修改，感觉好像不如列表好用？为什么还要有元组呢？</p><p>元组存在的价值在于其<strong>不可变性</strong>带来的好处：</p><ol><li><strong>安全性</strong>：如果某些数据在程序运行过程中不应该被修改（比如一些配置信息、坐标点、固定的选项等），用元组可以防止意外修改。</li><li><strong>效率</strong>：元组的创建和访问速度通常比列表要快一点点，因为它更简单。</li><li><strong>可哈希性</strong>：元组（假如，其所有元素都可哈希）可以作为字典的键，而列表不行（这里不理解也没关系，后面学习字典会讲）</li><li><strong>函数返回值</strong>：Python 函数可以很方便地返回一个元组，从而实现返回多个值的效果。</li></ol><p><strong>一句话总结：</strong></p><ul><li>如果你需要存储一组数据，并且可能会对其进行<strong>添加、删除、修改</strong>等操作，选择<strong>列表 (List)</strong></li><li>如果你需要存储一组数据，并且这组数据 <strong>一旦创建就不应被修改</strong>，或者你需要上述元组的优点，选择 <strong>元组 (Tuple)</strong></li></ul><hr><p>元组的许多用法都和列表相似，最大区别就在于<strong>不可变性</strong>。</p><h3 id="3-5-Dictionary-字典类型"><a href="#3-5-Dictionary-字典类型" class="headerlink" title="3.5 Dictionary (字典类型)"></a>3.5 Dictionary (字典类型)</h3><p>字典（Dictionary）是 Python 中除列表之外最灵活、也非常常用的内置数据结构。如果你熟悉其他语言，它类似于 “哈希表 (Hash Table)” 或 “关联数组 (Associative Array)”。</p><p><strong>思考一个问题：</strong> 列表、元组是通过<strong>位置（索引）</strong> 来访问元素的。如果元素很多，或者我们想通过<strong>有意义的名字</strong>来快速找到某个值，该怎么办呢？</p><p>这就是字典的用武之地！字典是一种<strong>键值对 ** 的集合。你可以把它看作成一本</strong>通讯录**：</p><ul><li>**<code>键 (key)</code>**：就像通讯录里的 <strong>人名</strong> (这是唯一的，不能重复的)。</li><li>**<code>值 (value)</code>**：就像通讯录里这个人对应的 <strong>电话号码&#x2F;地址</strong> (它们可以是任何类型的数据，并且可以重复)。</li></ul><p>我们通过 <strong>“键”</strong> 来快速查找和访问对应的 <strong>“值”</strong>。</p><h4 id="3-5-1-字典长什么样？——-花括号-来标识"><a href="#3-5-1-字典长什么样？——-花括号-来标识" class="headerlink" title="3.5.1 字典长什么样？—— 花括号 {} 来标识"></a>3.5.1 字典长什么样？—— 花括号 <code>&#123;&#125;</code> 来标识</h4><p>字典使用 <strong>花括号 <code>&#123;&#125;</code></strong> 来创建。</p><ul><li>每个键值对的格式是：<code>键: 值</code> (key: value)。</li><li>多个键值对之间用 <strong>逗号 <code>,</code></strong> 分隔。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个表示人的基本信息的字典</span></span><br><span class="line">person = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>,  <span class="comment"># 键 &quot;name&quot;，值 &quot;Alice&quot;</span></span><br><span class="line">    <span class="string">&quot;age&quot;</span>: <span class="number">30</span>,        <span class="comment"># 键 &quot;age&quot;，值 30</span></span><br><span class="line">    <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span> <span class="comment"># 键 &quot;city&quot;，值 &quot;New York&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个简单的电话簿字典</span></span><br><span class="line">phone_book = &#123;</span><br><span class="line">    <span class="string">&quot;John&quot;</span>: <span class="string">&quot;123-4567&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Jane&quot;</span>: <span class="string">&quot;987-6543&quot;</span>,</span><br><span class="line">    <span class="string">&quot;Bob&quot;</span>: <span class="string">&quot;555-1234&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(phone_book)</span><br></pre></td></tr></table></figure><h4 id="3-5-2-字典的特点："><a href="#3-5-2-字典的特点：" class="headerlink" title="3.5.2 字典的特点："></a>3.5.2 字典的特点：</h4><ol><li><strong>键值对集合</strong>：元素以 <code>key: value</code> 的形式存在。</li><li><strong>无序性</strong> (注意：Python 3.7+ 版本的字典已经保证了插入顺序，但访问方式仍不是通过索引)：字典中的元素没有固定的顺序，我们不能通过位置索引来访问，只能通过 <code>key</code> 来访问。最新的 Python 版本虽然保留了插入顺序，但这不是字典的核心特性，不应依赖索引操作字典。</li><li><strong>键的唯一性</strong>：字典中的 <strong><code>key</code> 必须是唯一的</strong>。如果出现重复的 <code>key</code>，后面的 <code>value</code> 会覆盖前面的。</li><li><strong>键的不可变性</strong>：**<code>key</code> 必须是不可变的数据类型<strong>，比如：字符串、数字、元组。</strong>列表不能作为 key**，因为列表是可变的。</li><li><strong>值的任意性</strong>：**<code>value</code> 可以是任何类型的数据**：数字、字符串、列表、字典、元组等，并且可以重复。</li><li><strong>可变性</strong>：字典本身是可变的，可以随时添加、修改或删除键值对。</li></ol><h4 id="3-5-3-访问字典中的值-通过-键-来访问！"><a href="#3-5-3-访问字典中的值-通过-键-来访问！" class="headerlink" title="3.5.3 访问字典中的值 - 通过 键 来访问！"></a>3.5.3 访问字典中的值 - 通过 <code>键</code> 来访问！</h4><p>要获取字典中某个 <code>key</code> 对应的 <code>value</code>，使用 <strong>方括号 <code>[]</code></strong> 并传入 <code>key</code>：<br><code>字典名[键]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 &quot;name&quot; 对应的值</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&quot;name&quot;</span>])  <span class="comment"># 输出: Alice</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 &quot;age&quot; 对应的值</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&quot;age&quot;</span>])   <span class="comment"># 输出: 30</span></span><br></pre></td></tr></table></figure><p><strong>如果访问一个不存在的 <code>key</code>，会怎么样？</strong><br>会报错！<code>KeyError: &#39;不存在的键&#39;</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># print(person[&quot;salary&quot;])  # 键 &quot;salary&quot; 不存在，会报错：KeyError: &#x27;salary&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>避免 KeyError 的小技巧：使用 <code>get()</code> 方法</strong><br>字典对象有一个 <code>get()</code> 方法，它也可以通过 <code>key</code> 获取 <code>value</code>。如果 <code>key</code> 不存在，它不会报错，而是返回 <code>None</code> ，或者你指定的默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 get() 方法获取值</span></span><br><span class="line"><span class="built_in">print</span>(person.get(<span class="string">&quot;name&quot;</span>))       <span class="comment"># 输出: Alice，和 person[&quot;name&quot;] 效果一样</span></span><br><span class="line"><span class="built_in">print</span>(person.get(<span class="string">&quot;salary&quot;</span>))     <span class="comment"># 输出: None，因为 &quot;salary&quot; 不存在</span></span><br><span class="line"><span class="built_in">print</span>(person.get(<span class="string">&quot;salary&quot;</span>, <span class="number">0</span>))  <span class="comment"># 输出: 0，如果 &quot;salary&quot; 不存在，返回指定的默认值 0</span></span><br></pre></td></tr></table></figure><h4 id="3-5-4-修改字典中的值-通过-键-直接赋值！"><a href="#3-5-4-修改字典中的值-通过-键-直接赋值！" class="headerlink" title="3.5.4 修改字典中的值 - 通过 键 直接赋值！"></a>3.5.4 修改字典中的值 - 通过 <code>键</code> 直接赋值！</h4><p>字典是可变的，我们可以通过 <strong><code>键</code></strong> 来修改对应的值。格式：<code>字典名[键] = 新值</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改前:&quot;</span>, person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 &quot;age&quot; 的值</span></span><br><span class="line">person[<span class="string">&quot;age&quot;</span>] = <span class="number">31</span>  <span class="comment"># 将键 &quot;age&quot; 对应的值改为 31</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;修改后:&quot;</span>, person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 key 不存在，赋值操作会变成添加新的键值对</span></span><br><span class="line">person[<span class="string">&quot;email&quot;</span>] = <span class="string">&quot;alice@example.com&quot;</span>  <span class="comment"># 新增键值对 &quot;email&quot;: &quot;alice@example.com&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;添加新键值对后:&quot;</span>, person)</span><br></pre></td></tr></table></figure><h4 id="3-5-5-字典的常用操作"><a href="#3-5-5-字典的常用操作" class="headerlink" title="3.5.5 字典的常用操作"></a>3.5.5 字典的常用操作</h4><h5 id="（1）添加新的键值对"><a href="#（1）添加新的键值对" class="headerlink" title="（1）添加新的键值对"></a>（1）添加新的键值对</h5><p>如上面所见，直接对一个新的 <code>key</code> 进行赋值，就会在字典中添加这个新的键值对。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>&#125;</span><br><span class="line">person[<span class="string">&quot;hobby&quot;</span>] = [<span class="string">&quot;reading&quot;</span>, <span class="string">&quot;traveling&quot;</span>]  <span class="comment"># 值可以是列表</span></span><br><span class="line"><span class="built_in">print</span>(person)  <span class="comment"># 输出: &#123;&#x27;name&#x27;: &#x27;Alice&#x27;, &#x27;hobby&#x27;: [&#x27;reading&#x27;, &#x27;traveling&#x27;]&#125;</span></span><br></pre></td></tr></table></figure><h5 id="（2）删除键值对-del-语句-或-pop-方法"><a href="#（2）删除键值对-del-语句-或-pop-方法" class="headerlink" title="（2）删除键值对 - del 语句 或 pop() 方法"></a>（2）删除键值对 - <code>del</code> 语句 或 <code>pop()</code> 方法</h5><ul><li><strong><code>del 字典名[键]</code></strong>: 删除指定 <code>key</code> 对应的键值对。如果 <code>key</code> 不存在，会报错。</li><li><strong><code>字典名.pop(键)</code></strong>: 删除指定 <code>key</code> 对应的键值对，并<strong>返回被删除的值</strong>。如果 <code>key</code> 不存在，可指定默认值避免报错。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;原始字典:&quot;</span>, person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 del 删除</span></span><br><span class="line"><span class="keyword">del</span> person[<span class="string">&quot;age&quot;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除 &#x27;age&#x27; 后:&quot;</span>, person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 pop() 删除，并获取被删除的值</span></span><br><span class="line">city = person.pop(<span class="string">&quot;city&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;被删除的 &#x27;city&#x27; 值是:&quot;</span>, city)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除 &#x27;city&#x27; 后:&quot;</span>, person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># pop() 可以指定默认值</span></span><br><span class="line">salary = person.pop(<span class="string">&quot;salary&quot;</span>, <span class="string">&quot;Not Found&quot;</span>)  <span class="comment"># &quot;salary&quot; 不存在，返回 &quot;Not Found&quot;</span></span><br><span class="line"><span class="built_in">print</span>(salary)</span><br></pre></td></tr></table></figure><h5 id="（3）获取所有的键、所有的值、所有的键值对"><a href="#（3）获取所有的键、所有的值、所有的键值对" class="headerlink" title="（3）获取所有的键、所有的值、所有的键值对"></a>（3）获取所有的键、所有的值、所有的键值对</h5><p>字典提供了方法来获取其所有的键、值或键值对：</p><ul><li><code>字典名.keys()</code>: 返回一个包含所有键的**视图对象 (view object)**，可以转成列表。</li><li><code>字典名.values()</code>: 返回一个包含所有值的<strong>视图对象</strong>，可以转成列表。</li><li><code>字典名.items()</code>: 返回一个包含所有键值对的<strong>视图对象</strong>，每个键值对是一个 <code>(key, value)</code> 元组，可以转成列表。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">phone_book = &#123;<span class="string">&quot;John&quot;</span>: <span class="string">&quot;123-4567&quot;</span>, <span class="string">&quot;Jane&quot;</span>: <span class="string">&quot;987-6543&quot;</span>, <span class="string">&quot;Bob&quot;</span>: <span class="string">&quot;555-1234&quot;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键</span></span><br><span class="line">all_keys = phone_book.keys()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有键:&quot;</span>, all_keys)                      <span class="comment"># 输出类似: dict_keys([&#x27;John&#x27;, &#x27;Jane&#x27;, &#x27;Bob&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有键 (转成列表):&quot;</span>, <span class="built_in">list</span>(all_keys))     <span class="comment"># 输出: [&#x27;John&#x27;, &#x27;Jane&#x27;, &#x27;Bob&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有值</span></span><br><span class="line">all_values = phone_book.values()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有值:&quot;</span>, all_values)                    <span class="comment"># 输出类似: dict_values([&#x27;123-4567&#x27;, &#x27;987-6543&#x27;, &#x27;555-1234&#x27;])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有值 (转成列表):&quot;</span>, <span class="built_in">list</span>(all_values))   <span class="comment"># 输出: [&#x27;123-4567&#x27;, &#x27;987-6543&#x27;, &#x27;555-1234&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取所有键值对</span></span><br><span class="line">all_items = phone_book.items()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有键值对:&quot;</span>, all_items)                  <span class="comment"># 输出类似: dict_items([(&#x27;John&#x27;, &#x27;123-4567&#x27;), (&#x27;Jane&#x27;, &#x27;987-6543&#x27;), (&#x27;Bob&#x27;, &#x27;555-1234&#x27;)])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;所有键值对 (转成列表):&quot;</span>, <span class="built_in">list</span>(all_items)) <span class="comment"># 输出: [(&#x27;John&#x27;, &#x27;123-4567&#x27;), (&#x27;Jane&#x27;, &#x27;987-6543&#x27;), (&#x27;Bob&#x27;, &#x27;555-1234&#x27;)]</span></span><br></pre></td></tr></table></figure><h5 id="（4）检查一个键是否在字典中-in-运算符"><a href="#（4）检查一个键是否在字典中-in-运算符" class="headerlink" title="（4）检查一个键是否在字典中 - in 运算符"></a>（4）检查一个键是否在字典中 - <code>in</code> 运算符</h5><p>使用 <code>in</code> 关键字可以判断一个 <code>key</code> 是否存在于字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;name&quot;</span> <span class="keyword">in</span> person)    <span class="comment"># 输出: True (键 &quot;name&quot; 存在)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;salary&quot;</span> <span class="keyword">in</span> person)  <span class="comment"># 输出: False (键 &quot;salary&quot; 不存在)</span></span><br></pre></td></tr></table></figure><h5 id="（5）获取字典长度-len-函数"><a href="#（5）获取字典长度-len-函数" class="headerlink" title="（5）获取字典长度 - len() 函数"></a>（5）获取字典长度 - <code>len()</code> 函数</h5><p><code>len()</code> 函数同样适用于字典，返回字典中<strong>键值对的数量</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>, <span class="string">&quot;city&quot;</span>: <span class="string">&quot;New York&quot;</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(person))  <span class="comment"># 输出: 3 (有 3 个键值对)</span></span><br></pre></td></tr></table></figure><h4 id="3-5-6-字典的键-key-的规则"><a href="#3-5-6-字典的键-key-的规则" class="headerlink" title="3.5.6 字典的键 (key) 的规则"></a>3.5.6 字典的键 (key) 的规则</h4><ul><li><strong>唯一性</strong>：同一个字典中，<code>key</code> 不能重复。如果重复定义，后面的 <code>value</code> 会覆盖前面的。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_with_duplicate_keys = &#123;<span class="string">&quot;a&quot;</span>: <span class="number">1</span>, <span class="string">&quot;b&quot;</span>: <span class="number">2</span>, <span class="string">&quot;a&quot;</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(dict_with_duplicate_keys)  <span class="comment"># 输出: &#123;&#x27;a&#x27;: 3, &#x27;b&#x27;: 2&#125; (前面的 &quot;a&quot;:1 被覆盖了)</span></span><br></pre></td></tr></table></figure></li><li><strong>不可变性</strong>：<code>key</code> 必须是<strong>不可变的数据类型</strong>。<ul><li><strong>合法的 key</strong>：字符串 (<code>&quot;name&quot;</code>), 数字 (<code>123</code>), 元组 (<code>(1,2)</code> 如果元组内元素都是不可变的</li><li><strong>不合法的 key</strong>：列表 (<code>[1,2]</code>), 字典 (<code>&#123;&#125;</code>) 。因为它们是可变的<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">valid_dict = &#123;</span><br><span class="line">    <span class="string">&quot;string_key&quot;</span>: <span class="string">&quot;value&quot;</span>,</span><br><span class="line">    <span class="number">123</span>: <span class="string">&quot;number_key&quot;</span>,</span><br><span class="line">    (<span class="number">1</span>, <span class="number">2</span>): <span class="string">&quot;tuple_key&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">print</span>(valid_dict)</span><br><span class="line"></span><br><span class="line"><span class="comment"># invalid_dict = &#123;[1, 2]: &quot;list_key&quot;&#125;  # 这行会报错！因为列表不能作为 key。TypeError: unhashable type: &#x27;list&#x27;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><p>恭喜你！到目前为止，我们已经学习了 Python 最核心的几种数据类型：<strong>数字 (int, float)<strong>、</strong>字符串 (str)<strong>、</strong>布尔值 (bool)<strong>、</strong>列表 (list)<strong>、</strong>元组 (tuple)</strong> 和 **字典 (dict)**。这些是你编写 Python 程序的基石。</p><h3 id="Python-基础数据类型小测验"><a href="#Python-基础数据类型小测验" class="headerlink" title="Python 基础数据类型小测验"></a><strong>Python 基础数据类型小测验</strong></h3><h4 id="一、选择题-每题5分，共30分"><a href="#一、选择题-每题5分，共30分" class="headerlink" title="一、选择题 (每题5分，共30分)"></a><strong>一、选择题 (每题5分，共30分)</strong></h4><ol><li><p>下列哪种数据类型在 Python 中是<strong>不可变</strong>的？( )<br>A. 列表 (List)<br>B. 元组 (Tuple)<br>C. 字典 (Dictionary)<br>D. 以上都是</p></li><li><p>要创建一个包含元素 <code>1</code>, <code>2</code>, <code>3</code> 的元组，下面哪种写法是<strong>正确</strong>的？( )<br>A. <code>(1, 2, 3)</code><br>B. <code>[1, 2, 3]</code><br>C. <code>&#123;1, 2, 3&#125;</code><br>D. <code>1, 2, 3</code> (不加括号)</p></li><li><p>对于字典 <code>person = &#123;&quot;name&quot;: &quot;Alice&quot;, &quot;age&quot;: 25&#125;</code>, 要获取 <code>&quot;Alice&quot;</code> 的值，应该使用哪种方式？( )<br>A. <code>person[0]</code><br>B. <code>person[&quot;name&quot;]</code><br>C. <code>person.get(&quot;Alice&quot;)</code><br>D. <code>person.values()[0]</code></p></li><li><p>执行语句 <code>my_list = [1, 2, 3]; my_list.append(4)</code> 后，<code>my_list</code> 的值是？( )<br>A. <code>[1, 2, 3]</code><br>B. <code>[4, 1, 2, 3]</code><br>C. <code>[1, 2, 3, 4]</code><br>D. 报错，因为列表不支持 <code>append</code> 方法</p></li><li><p><code>str(123) + &quot;abc&quot;</code> 的结果是？( )<br>A. <code>123abc</code> (字符串类型)<br>B. <code>123abc</code> (整数类型)<br>C. <code>123 + abc</code> (字符串类型)<br>D. 报错，因为整数不能和字符串相加</p></li><li><p>下列哪个函数可以将字符串 <code>&quot;123.45&quot;</code> 转换为浮点数 <code>123.45</code>？( )<br>A. <code>int()</code><br>B. <code>float()</code><br>C. <code>str()</code><br>D. <code>number()</code></p></li></ol><h4 id="二、看程序写结果-每题10分，共20分"><a href="#二、看程序写结果-每题10分，共20分" class="headerlink" title="二、看程序写结果 (每题10分，共20分)"></a><strong>二、看程序写结果 (每题10分，共20分)</strong></h4><ol><li><p>写出下面代码的输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_tuple = (<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>)</span><br><span class="line"><span class="built_in">print</span>(my_tuple[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(my_tuple[-<span class="number">2</span>])</span><br></pre></td></tr></table></figure></li><li><p>写出下面代码的输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">student = &#123;</span><br><span class="line">    <span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>,</span><br><span class="line">    <span class="string">&quot;grades&quot;</span>: [<span class="number">90</span>, <span class="number">85</span>, <span class="number">95</span>]</span><br><span class="line">&#125;</span><br><span class="line">student[<span class="string">&quot;grades&quot;</span>].append(<span class="number">88</span>)</span><br><span class="line"><span class="built_in">print</span>(student[<span class="string">&quot;grades&quot;</span>])</span><br></pre></td></tr></table></figure></li></ol><h4 id="三、编程题-每题10分，共50分"><a href="#三、编程题-每题10分，共50分" class="headerlink" title="三、编程题 (每题10分，共50分)"></a><strong>三、编程题 (每题10分，共50分)</strong></h4><ol><li><p><strong>创建列表并访问</strong>：创建一个名为 <code>fruits</code> 的列表，包含元素 <code>&quot;apple&quot;</code>, <code>&quot;banana&quot;</code>, <code>&quot;cherry&quot;</code>，然后打印列表的第二个元素（索引为1的元素）。</p></li><li><p><strong>修改字典</strong>：有字典 <code>car = &#123;&quot;brand&quot;: &quot;Toyota&quot;, &quot;year&quot;: 2020&#125;</code>，请将 <code>&quot;year&quot;</code> 的值修改为 <code>2023</code>，并打印修改后的字典。</p></li><li><p><strong>列表切片</strong>：有列表 <code>numbers = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code>，请使用切片获取列表中从索引 2 到索引 5（不包含5）的元素，并打印结果。</p></li><li><p><strong>简单类型转换</strong>：用户输入一个数字（例如 <code>&quot;5&quot;</code>），请将其转换为整数后乘以 2，并打印结果。<br><em>提示：用 <code>input()</code> 获取输入，用 <code>int()</code> 转换。</em></p></li><li><p>**字典遍历基础 (选做，有难度)**：有字典 <code>scores = &#123;&quot;math&quot;: 90, &quot;english&quot;: 85, &quot;science&quot;: 95&#125;</code>，请打印出所有学科的名称（即字典的所有键）。<br><em>提示：使用 <code>keys()</code> 方法。</em></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基本语法</title>
      <link href="/2025/10/22/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/10/22/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Python标识符"><a href="#Python标识符" class="headerlink" title="Python标识符"></a>Python标识符</h1><p>想象一下，你要在代码世界里“开公司”做项目，那每个变量、函数、类都得有个<strong>独一无二的“代号”</strong>，这“代号”就是「标识符」~ 所以接下来要说的就是，把 Python 标识符的规矩讲明白，保证有趣又好懂👇</p><h2 id="一、基础规则：能叫什么？不能叫什么？"><a href="#一、基础规则：能叫什么？不能叫什么？" class="headerlink" title="一、基础规则：能叫什么？不能叫什么？"></a>一、基础规则：能叫什么？不能叫什么？</h2><p>Python 里的标识符，就像给代码里的组件取名字，得守点小规矩：</p><h3 id="1-允许的字符：字母、数字、下划线"><a href="#1-允许的字符：字母、数字、下划线" class="headerlink" title="1. 允许的字符：字母、数字、下划线"></a>1. 允许的字符：字母、数字、下划线</h3><p>比如想给变量取个名字，可以用 <code>my_name</code>（即字母+下划线）、<code>age18</code>（字母+数字）、<code>_secret</code>（下划线开头）……但注意<strong>不能有空格、标点符号（除了下划线）</strong> ！<br>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">my_name = <span class="string">&quot;小明&quot;</span>   <span class="comment"># 合法：字母+下划线</span></span><br><span class="line">age18 = <span class="number">18</span>        <span class="comment"># 合法：字母+数字</span></span><br><span class="line">_secret = <span class="string">&quot;藏起来&quot;</span> <span class="comment"># 合法：下划线开头</span></span><br></pre></td></tr></table></figure><h3 id="2-不能以数字开头"><a href="#2-不能以数字开头" class="headerlink" title="2. 不能以数字开头"></a>2. 不能以数字开头</h3><p>如果一上来就用数字，Python 看不懂你写的什么，懵圈了，这给我干哪来了！<br>反面教材🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">18age = <span class="number">18</span>  <span class="comment"># 报错！不能以数字开头，Python看不懂“18age”是什么！</span></span><br></pre></td></tr></table></figure><h3 id="3-区分大小写"><a href="#3-区分大小写" class="headerlink" title="3. 区分大小写"></a>3. 区分大小写</h3><p>Python里，<code>Name</code> 和 <code>name</code> 完全是两个不同的标识符！就像“张三”和“张叁”是两个人<br>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Name = <span class="string">&quot;大写的名字&quot;</span></span><br><span class="line">name = <span class="string">&quot;小写的名字&quot;</span></span><br><span class="line"><span class="built_in">print</span>(Name)  <span class="comment"># 输出：大写的名字</span></span><br><span class="line"><span class="built_in">print</span>(name)  <span class="comment"># 输出：小写的名字</span></span><br></pre></td></tr></table></figure><h2 id="二、特殊下划线"><a href="#二、特殊下划线" class="headerlink" title="二、特殊下划线"></a>二、特殊下划线</h2><p>在Python里，<strong>下划线开头</strong>的标识符，往往有特殊身份，就像电影里带暗号的接头人~</p><h3 id="1-单下划线开头：-foo（我称之为低调的类属性）"><a href="#1-单下划线开头：-foo（我称之为低调的类属性）" class="headerlink" title="1. 单下划线开头：_foo（我称之为低调的类属性）"></a>1. 单下划线开头：_foo（我称之为低调的类属性）</h3><p>当你在类里看到 <code>_foo</code> 这样的变量或者方法名的时候，它相当于在说：“我是内部用的，外面最好别直接访问我”<br>就好比公司里的内部文档，外人想调阅得走流，即通过类提供的接口来访问，不能随随便便 <code>from xxx import *</code> 直接把它暴露出去</p><p>举个类的例子🌰（这里你即使暂时看不懂类也没关系，先感受下划线意思）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.name = <span class="string">&quot;公开姓名&quot;</span></span><br><span class="line">        <span class="variable language_">self</span>._age = <span class="number">18</span>  <span class="comment"># 单下划线开头，暗示内部属性</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_age</span>(<span class="params">self</span>):  <span class="comment"># 提供接口，让外部可以间接拿到_age</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>._age</span><br><span class="line"></span><br><span class="line">p = Person()</span><br><span class="line"><span class="built_in">print</span>(p.name)     <span class="comment"># 直接访问公开属性，输出：公开姓名</span></span><br><span class="line"><span class="built_in">print</span>(p.get_age())<span class="comment"># 通过接口访问_age，输出：18</span></span><br><span class="line"><span class="comment"># print(p._age)   # 虽然能硬访问，但不推荐，相当于没走流程偷看内部文档</span></span><br></pre></td></tr></table></figure><h3 id="2-双下划线开头：-foo（私有成员，自我保护）"><a href="#2-双下划线开头：-foo（私有成员，自我保护）" class="headerlink" title="2. 双下划线开头：__foo（私有成员，自我保护）"></a>2. 双下划线开头：__foo（私有成员，自我保护）</h3><p>双下划线 <code>__foo</code> 开头的标识符，Python会自动做一层名字混淆，相当于给它加了个保险箱，外部想直接碰它，难度直线上升！<br>这就像公司里的高层机密文档，不是随便谁都能看的</p><p>举个🌰（还是类的例子，感受意思即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.__nickname = <span class="string">&quot;喵小秘&quot;</span>  <span class="comment"># 双下划线开头，变成私有属性</span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_nickname</span>(<span class="params">self</span>):       <span class="comment"># 提供专门的方法，才能让外部看到</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="variable language_">self</span>.__nickname)</span><br><span class="line"></span><br><span class="line">c = Cat()</span><br><span class="line"><span class="comment"># print(c.__nickname)  # 直接访问？报错！Python：“年轻人，这是私有滴，不能碰！”</span></span><br><span class="line">c.show_nickname()     <span class="comment"># 通过方法访问，输出：喵小秘</span></span><br></pre></td></tr></table></figure><h3 id="3-双下划线开头-结尾：-foo-（Python的官方暗号）"><a href="#3-双下划线开头-结尾：-foo-（Python的官方暗号）" class="headerlink" title="3. 双下划线开头+结尾：__foo__（Python的官方暗号）"></a>3. 双下划线开头+结尾：__foo__（Python的官方暗号）</h3><p>这种格式是Python给自己留的特殊通道，比如最常见的 <code>__init__()</code>（即类的构造函数，创建对象时自动触发）、<code>__str__()</code>（控制对象打印成什么样）……<br>你可以理解成：“这是Python内置功能的专属标识，别瞎用！”</p><p>举个🌰（经典的__init__和__str__）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):  <span class="comment"># __init__是构造函数，创建对象时自动调用</span></span><br><span class="line">        <span class="variable language_">self</span>.name = name</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):        <span class="comment"># __str__控制print(dog)时输出啥</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;一只叫<span class="subst">&#123;self.name&#125;</span>的狗&quot;</span></span><br><span class="line"></span><br><span class="line">d = Dog(<span class="string">&quot;旺财&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># 输出：一只叫旺财的狗，因为__str__定义了打印格式</span></span><br></pre></td></tr></table></figure><h2 id="三、小彩蛋：一行写多条语句（分号-助攻）"><a href="#三、小彩蛋：一行写多条语句（分号-助攻）" class="headerlink" title="三、小彩蛋：一行写多条语句（分号 ; 助攻）"></a>三、小彩蛋：一行写多条语句（分号 ; 助攻）</h2><p>Python里，你还可以用<strong>分号 ;</strong> 把多条语句塞到同一行，就像买奶茶时，同时备注要三分糖、去冰、加珍珠</p><p>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>); <span class="built_in">print</span>(<span class="string">&quot;Python&quot;</span>); <span class="built_in">print</span>(<span class="string">&quot;你好&quot;</span>)</span><br><span class="line"><span class="comment"># 执行后会依次输出：</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># 你好</span></span><br></pre></td></tr></table></figure><p>不过要注意：这种写法适合简短代码，太长的话可读性就崩了，所以别贪多，适度用用就行</p><h2 id="来简简单单总结一下标识符的“取名守则”"><a href="#来简简单单总结一下标识符的“取名守则”" class="headerlink" title="来简简单单总结一下标识符的“取名守则”"></a>来简简单单总结一下标识符的“取名守则”</h2><ul><li>能由<strong>字母、数字、下划线</strong>组成，但<strong>数字不能开头</strong>~</li><li>大小写敏感（<code>A</code>和<code>a</code>不是同一个东西）~</li><li>下划线开头的有特殊含义：<code>_foo</code>（低调内部货）、<code>__foo</code>（私有藏起来）、<code>__foo__</code>（Python官方通道）</li><li>想一行写多条语句？分号 <code>;</code> 帮你忙</li></ul><h1 id="Python保留字，代码里的禁区警示牌"><a href="#Python保留字，代码里的禁区警示牌" class="headerlink" title="Python保留字，代码里的禁区警示牌"></a>Python保留字，代码里的禁区警示牌</h1><p>打个比方，假如Python世界里有一批专属贵宾席位，这些位置被Python官方霸占了，我们写代码时<strong>绝对不能抢</strong>。而这些席位就是保留字（关键字）。</p><h2 id="一、什么是保留字？"><a href="#一、什么是保留字？" class="headerlink" title="一、什么是保留字？"></a>一、什么是保留字？</h2><p>保留字是Python语言<strong>预先定义好的特殊单词</strong>，每个都有特定语法功能，就像交通规则里的“红灯停、绿灯行”。你不能把这些规则牌拆了自己用，不然整个语言逻辑就会乱套</p><h2 id="二、Python保留字全名单"><a href="#二、Python保留字全名单" class="headerlink" title="二、Python保留字全名单"></a>二、Python保留字全名单</h2><p>先把所有保留字列出来，为了方便理解，每个关键字贴个功能标签：</p><table><thead><tr><th>保留字</th><th>功能类比</th><th>保留字</th><th>功能类比</th><th>保留字</th><th>功能类比</th></tr></thead><tbody><tr><td>and</td><td>逻辑“与”（和）</td><td>exec</td><td>执行外部代码（进阶）</td><td>not</td><td>逻辑“非”（取反）</td></tr><tr><td>assert</td><td>断言（调试时检查条件）</td><td>finally</td><td>异常处理的最终保障区</td><td>or</td><td>逻辑“或”（或者）</td></tr><tr><td>break</td><td>打断循环（跳出循环）</td><td>for</td><td>循环遍历（比如遍历列表）</td><td>pass</td><td>占位符（代码还没想好，先占坑）</td></tr><tr><td>class</td><td>定义类（面向对象核心）</td><td>from</td><td>模块导入专用（从哪导入）</td><td>print</td><td>打印输出（新手最爱🤣）</td></tr><tr><td>continue</td><td>跳过当前循环，继续下一轮</td><td>global</td><td>声明全局变量</td><td>raise</td><td>主动抛异常（告诉程序出错了）</td></tr><tr><td>def</td><td>定义函数</td><td>if</td><td>条件判断（如果…那么…）</td><td>return</td><td>函数返回结果</td></tr><tr><td>del</td><td>删除对象引用（回收变量）</td><td>import</td><td>导入模块（把工具包拿进来）</td><td>try</td><td>异常捕获（试试这段代码，出错了处理）</td></tr><tr><td>elif</td><td>条件判断的否则如果”</td><td>in</td><td>判断成员关系（在…里面吗？）</td><td>while</td><td>循环（满足条件就一直做）</td></tr><tr><td>else</td><td>条件或循环的否则分支</td><td>is</td><td>判断对象身份（是不是同一个？）</td><td>with</td><td>上下文管理（比如自动关文件）</td></tr><tr><td>except</td><td>异常处理的except捕获区</td><td>lambda</td><td>定义匿名函数（超简短函数）</td><td>yield</td><td>生成器专用（逐步产出数据）</td></tr></tbody></table><p>看完上面的表，是不是感觉每个保留字都有自己的岗位职责？就像公司里的每个岗位都有专属工作，不能乱串</p><h2 id="三、误用保留字会怎样？"><a href="#三、误用保留字会怎样？" class="headerlink" title="三、误用保留字会怎样？"></a>三、误用保留字会怎样？</h2><p>如果你偏要把保留字当变量名或者函数名，Python会直接给你丢个<strong>语法错误</strong>，相当于你抢了交警的指挥岗，交通直接瘫痪</p><p>举个🌰（错误示范）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> = <span class="number">18</span>  <span class="comment"># 错误！if是保留字，不能当变量名</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">if</span>)</span><br></pre></td></tr></table></figure><p>运行后会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure><p>人话：语法错误！你用了不能用的词！</p><h2 id="四、如何快速判断是不是保留字？"><a href="#四、如何快速判断是不是保留字？" class="headerlink" title="四、如何快速判断是不是保留字？"></a>四、如何快速判断是不是保留字？</h2><p>有个简单的方法：在Python交互环境，或PyCharm里写代码时，试着把单词当变量名用，看会不会爆红或者报错<br>或者更主动点，记住，保留字都是Python语法的“脊梁骨”，用来控制流程、定义结构，像 <code>if</code>（判断）、<code>for</code>（循环）、<code>def</code>（函数）这些高频词，肯定是保留字！</p><h2 id="五、趣味记忆口诀（可选）"><a href="#五、趣味记忆口诀（可选）" class="headerlink" title="五、趣味记忆口诀（可选）"></a>五、趣味记忆口诀（可选）</h2><p>把保留字串成顺口溜，没事念一念，印象更深<br>（押韵不重要，顺嘴就行🤣）</p><blockquote><p>循环断跳有for、while，break、continue不能瞎；<br>条件分支if、elif、else，断言assert调试要检查；<br>定义函数def、类class，全局变量global得声明；<br>异常处理try、except、finally，主动抛错raise别犯傻；<br>导入模块import、from，逻辑运算and、or、not；<br>成员判断in、is，上下文管理with；<br>匿名函数lambda，生成器yield，占位符pass先占下；<br>del删引用，print输呱呱</p></blockquote><p>现在你已经摸清Python保留字的脾气，写代码时，一定要绕开这些禁区，给变量、函数取名字前，先想想：这词是不是保留字？会不会抢了Python的饭碗？😎 要是拿不准，就打开Python交互模式，输入 <code>import keyword; print(keyword.kwlist)</code> ，能直接看到所有保留字列表，随时查岗</p><h1 id="行和缩进"><a href="#行和缩进" class="headerlink" title="行和缩进"></a>行和缩进</h1><p>如果把 Python 代码比作一支舞蹈队，<strong>缩进</strong>就是队形规则——每个动作（即代码块）都得对齐，否则整个舞蹈（也就是程序逻辑）都得乱套</p><h2 id="一、为什么是缩进？其他语言用大括号，Python为什么特立独行？"><a href="#一、为什么是缩进？其他语言用大括号，Python为什么特立独行？" class="headerlink" title="一、为什么是缩进？其他语言用大括号，Python为什么特立独行？"></a>一、为什么是缩进？其他语言用大括号，Python为什么特立独行？</h2><p>其他语言（比如 Java、C++）用 <code>&#123;&#125;</code> 划分代码块，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;True&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;False&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 Python 偏不！它选择用<strong>缩进</strong>代替大括号，理由很简单：<strong>让代码更简洁、更readable（读得懂）</strong></p><p>你可以这么想，如果所有代码都挤在一起，没有缩进，你得在大括号里找半天逻辑；但有了统一缩进，一眼就能看出哪些代码属于 if 分支，哪些属于 else 分支</p><h2 id="二、缩进规则"><a href="#二、缩进规则" class="headerlink" title="二、缩进规则"></a>二、缩进规则</h2><p>Python 里，<strong>同一逻辑块的代码必须有相同的缩进量</strong>，好比舞蹈队里同一排的演员得站对齐</p><h3 id="1-示例：if-else-的缩进"><a href="#1-示例：if-else-的缩进" class="headerlink" title="1. 示例：if-else 的缩进"></a>1. 示例：if-else 的缩进</h3><p>看这段代码（4个空格缩进，最常见的选择）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进了if分支～&quot;</span>)  <span class="comment"># 属于if的代码块，缩进4空格</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;还在if里～&quot;</span>)    <span class="comment"># 同样缩进4空格，和上面是一伙的</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进了else分支～&quot;</span>)<span class="comment"># 属于else的代码块，缩进4空格</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;还在else里～&quot;</span>)  <span class="comment"># 同样缩进4空格</span></span><br></pre></td></tr></table></figure><p>执行后，因为 <code>True</code> 成立，会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进了if分支～</span><br><span class="line">还在if里～</span><br></pre></td></tr></table></figure><h3 id="2-错误示范：缩进不一致，程序直接崩"><a href="#2-错误示范：缩进不一致，程序直接崩" class="headerlink" title="2. 错误示范：缩进不一致，程序直接崩"></a>2. 错误示范：缩进不一致，程序直接崩</h3><p>如果缩进乱了，比如下面这样（else 分支里某行缩进少了）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进了if分支～&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;还在if里～&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;进了else分支～&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&quot;这里缩进乱了！&quot;</span>)  <span class="comment"># 错误：和上面else的缩进不一样</span></span><br></pre></td></tr></table></figure><p>Python 会直接报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndentationError: unindent does not match any outer indentation level</span><br></pre></td></tr></table></figure><p>人话：缩进不正确！你这行和外面的缩进层次对不上！</p><h2 id="三、常见缩进错误-排雷技巧"><a href="#三、常见缩进错误-排雷技巧" class="headerlink" title="三、常见缩进错误 &amp; 排雷技巧"></a>三、常见缩进错误 &amp; 排雷技巧</h2><p>Python 对缩进<strong>格式一致性</strong>要求到苛刻，新手很容易踩坑，常见错误有两种：</p><h3 id="1-错误1：Tab-和-空格混用"><a href="#1-错误1：Tab-和-空格混用" class="headerlink" title="1. 错误1：Tab 和 空格混用"></a>1. 错误1：Tab 和 空格混用</h3><p>有的编辑器按 <code>Tab</code> 是<strong>1个制表符</strong>，有的用 <code>空格</code>（比如4个空格代表一级缩进）。如果代码里既有 Tab 又有空格，Python 会懵圈：到底谁和谁是一伙的？</p><p>举个🌰（混合用了Tab和空格）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;用了4个空格缩进&quot;</span>)  <span class="comment"># 空格</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;这里用了Tab&quot;</span>)     <span class="comment"># Tab → 错误！和上面格式不一致</span></span><br></pre></td></tr></table></figure><p>运行后报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndentationError: inconsistent use of tabs and spaces in indentation</span><br></pre></td></tr></table></figure><h3 id="2-错误2：意外缩进（即unexpected-indent）"><a href="#2-错误2：意外缩进（即unexpected-indent）" class="headerlink" title="2. 错误2：意外缩进（即unexpected indent）"></a>2. 错误2：意外缩进（即unexpected indent）</h3><p>有时候不小心多按了空格&#x2F;Tab，某行代码莫名缩进了，Python 也会报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;正常缩进&quot;</span>)</span><br><span class="line">     <span class="built_in">print</span>(<span class="string">&quot;这里多按了个空格→意外缩进！&quot;</span>)  <span class="comment"># 错误</span></span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IndentationError: unexpected indent</span><br></pre></td></tr></table></figure><h3 id="排雷技巧："><a href="#排雷技巧：" class="headerlink" title="排雷技巧："></a>排雷技巧：</h3><ul><li>选一种缩进风格贯穿始终（推荐 <strong>4个空格</strong>，PyCharm 等编辑器也默认用4空格）。</li><li>用编辑器&#x2F;IDE 的“显示空白符”功能（比如 PyCharm 里打开 <code>查看 → 活动编辑器 → 显示空白</code>），能直观看到 Tab 和 空格，避免混用。</li></ul><h2 id="四、缩进层次：嵌套代码的“队形纵深”"><a href="#四、缩进层次：嵌套代码的“队形纵深”" class="headerlink" title="四、缩进层次：嵌套代码的“队形纵深”"></a>四、缩进层次：嵌套代码的“队形纵深”</h2><p>当代码有多层嵌套（比如 if 里套 if，循环里套函数），<strong>每一层嵌套都要多一级缩进</strong>，就像舞蹈队里的方阵纵深，第一层站第一排，第二层站第二排，以此类推</p><p>举个多层嵌套的🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 成绩 &gt; <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line">    <span class="keyword">if</span> 单科 &gt; <span class="number">95</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;单科接近满分&quot;</span>)  <span class="comment"># 比外层if多一级缩进（比如4→8空格）</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;单科还能冲一冲&quot;</span>)<span class="comment"># 同样和内层if的else对齐</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续努力&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="五、类比"><a href="#五、类比" class="headerlink" title="五、类比"></a>五、类比</h2><p>可以把<strong>行</strong>理解成舞蹈动作，<strong>缩进</strong>是动作的归属，即，哪个动作属于哪个分支&#x2F;循环，全看缩进对齐</p><ul><li>同一分支的代码 → 同一排演员，同一缩进</li><li>嵌套分支的代码 → 后排演员，多一级缩进</li><li>混用 Tab&#x2F;空格 → 队伍里混进了穿不同鞋子的人，队形大乱</li><li>意外缩进 → 某演员站错排，整个方阵崩坏</li></ul><h1 id="多行语句、引号与注释"><a href="#多行语句、引号与注释" class="headerlink" title="多行语句、引号与注释"></a>多行语句、引号与注释</h1><p>如果把 Python 代码比作一篇文章，<strong>多行语句</strong>是分段换行的技巧，<strong>引号</strong>是给文字加引号的花样，<strong>注释</strong>则是写给自己悄悄话</p><h2 id="一、多行语句"><a href="#一、多行语句" class="headerlink" title="一、多行语句"></a>一、多行语句</h2><p>写文章时，长句子一口气写不下，得换行；Python 里长代码也一样,但得守点换行规矩</p><h3 id="1-用反斜杠“-”手动换行"><a href="#1-用反斜杠“-”手动换行" class="headerlink" title="1. 用反斜杠“ \ ”手动换行"></a>1. 用反斜杠“ \ ”手动换行</h3><p>如果一行代码太长，比如多个变量相加，可以用 <strong>反斜杠 \ </strong>* 告诉 Python：这行没结束，下一行接着来</p><p>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br><span class="line"><span class="comment"># 反斜杠后要紧跟换行，不能有空格！否则会报错～</span></span><br></pre></td></tr></table></figure><p>就像写文章时，在换行处加个续行符，告诉读者这句话还没说完，下一行继续</p><h3 id="2-括号里自动换行（-）"><a href="#2-括号里自动换行（-）" class="headerlink" title="2. 括号里自动换行（[], {}, ()）"></a>2. 括号里自动换行（[], {}, ()）</h3><p>如果代码里有 <strong>列表[]、字典{}、元组()</strong> 这些带括号的结构，Python 会自动识别括号里的换行，不用手动加 \ </p><p>举个🌰（列表里换行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days = [<span class="string">&#x27;Monday&#x27;</span>, <span class="string">&#x27;Tuesday&#x27;</span>, <span class="string">&#x27;Wednesday&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Thursday&#x27;</span>, <span class="string">&#x27;Friday&#x27;</span>]  <span class="comment"># 括号内换行，Python自动认</span></span><br></pre></td></tr></table></figure><p>再比如函数调用传参（括号里换行）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">result = calculate(</span><br><span class="line">    num1,</span><br><span class="line">    num2,</span><br><span class="line">    num3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这种括号内自由换行，就像文章里括号内的解释可以分多行写，Python 能智能识别</p><h2 id="二、Python-引号"><a href="#二、Python-引号" class="headerlink" title="二、Python 引号"></a>二、Python 引号</h2><p>写文章时，引语可以用单引号、双引号；Python 里“字符串”也有三种引号选择，各有特色～</p><h3 id="1-单引号-‘’-和-双引号-“”"><a href="#1-单引号-‘’-和-双引号-“”" class="headerlink" title="1. 单引号 ‘’ 和 双引号 “”"></a>1. 单引号 ‘’ 和 双引号 “”</h3><p>单引号和双引号功能几乎一样，选哪个看个人习惯。主要用来包<strong>短字符串</strong>，比如单词、句子</p><p>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;Python&#x27;</span>  <span class="comment"># 单引号包单词</span></span><br><span class="line">sentence = <span class="string">&quot;人生苦短，我用Python&quot;</span>  <span class="comment"># 双引号包句子</span></span><br></pre></td></tr></table></figure><p>如果字符串里<strong>包含单引号</strong>，就用双引号包；包含双引号，就用单引号包，避免引号打架</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text = <span class="string">&quot;He said, &#x27;Python is easy!&#x27;&quot;</span>  <span class="comment"># 字符串里有单引号，外层用双引号</span></span><br><span class="line">text2 = <span class="string">&#x27;She said, &quot;Python is fun!&quot;&#x27;</span> <span class="comment"># 字符串里有双引号，外层用单引号</span></span><br></pre></td></tr></table></figure><h3 id="2-三引号-‘’’-‘’’-或-“””-“””：多行字符串-注释"><a href="#2-三引号-‘’’-‘’’-或-“””-“””：多行字符串-注释" class="headerlink" title="2. 三引号 ‘’’ ‘’’ 或 “”” “””：多行字符串+注释"></a>2. 三引号 ‘’’ ‘’’ 或 “”” “””：多行字符串+注释</h3><p>三引号就像大括号，能包<strong>跨越多行的字符串</strong>，还能当多行注释使</p><h4 id="（1）包多行字符串"><a href="#（1）包多行字符串" class="headerlink" title="（1）包多行字符串"></a>（1）包多行字符串</h4><p>比如写一段散文式的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">paragraph = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">从前有座山，</span></span><br><span class="line"><span class="string">山里有座庙，</span></span><br><span class="line"><span class="string">庙里有个老和尚讲故事～</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(paragraph)</span><br><span class="line"><span class="comment"># 输出会保留换行和缩进，原封不动打印～</span></span><br></pre></td></tr></table></figure><h4 id="（2）当多行注释用"><a href="#（2）当多行注释用" class="headerlink" title="（2）当多行注释用"></a>（2）当多行注释用</h4><p>因为三引号包起来的内容如果没被赋值给变量，Python 会把它当空气忽略掉，所以可以用来写多行注释</p><p>比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是一段多行注释，</span></span><br><span class="line"><span class="string">用来解释下面的代码逻辑：</span></span><br><span class="line"><span class="string">1. 先获取用户输入</span></span><br><span class="line"><span class="string">2. 再处理数据</span></span><br><span class="line"><span class="string">3. 最后输出结果</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入名字：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你好，<span class="subst">&#123;name&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>也可以用双引号的三引号 “”” “”””，效果一样</p><h2 id="三、Python-注释"><a href="#三、Python-注释" class="headerlink" title="三、Python 注释"></a>三、Python 注释</h2><p>写文章时，会加批注、注释帮读者理解；代码里的注释，是帮自己快速看懂逻辑</p><h3 id="1-单行注释：-开头"><a href="#1-单行注释：-开头" class="headerlink" title="1. 单行注释：# 开头"></a>1. 单行注释：# 开头</h3><p><strong>井号 #</strong> 后面的内容，Python 会直接忽略， commonly 用来写单行说明</p><p>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是单行注释，解释下面代码的作用</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, Python!&quot;</span>)  <span class="comment"># 也可以跟在代码后面，解释这行干啥</span></span><br></pre></td></tr></table></figure><p>就像文章里的脚注，一行一个小说明</p><h3 id="2-多行注释：三引号包起来"><a href="#2-多行注释：三引号包起来" class="headerlink" title="2. 多行注释：三引号包起来"></a>2. 多行注释：三引号包起来</h3><p>前面提过，三引号如果没被赋值，就会被当注释， 所以可以用来写<strong>大段解释</strong>，比如函数用途、整个模块的说明</p><p>举个🌰（双引号三引号版）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这个脚本用来实现用户登录功能：</span></span><br><span class="line"><span class="string">步骤1：读取用户输入的账号密码</span></span><br><span class="line"><span class="string">步骤2：和数据库存储的账号密码比对</span></span><br><span class="line"><span class="string">步骤3：返回登录结果</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>():</span><br><span class="line">    <span class="comment"># 此处写登录逻辑...</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="把代码当文章写"><a href="#把代码当文章写" class="headerlink" title="把代码当文章写"></a>把代码当文章写</h2><ul><li><strong>多行语句</strong> → 文章的换行规则：长句用 \ 续行，括号里自由换行</li><li><strong>引号</strong> → 文章的号风格：短引语用单&#x2F;双引号，大段文字用三引号</li><li><strong>注释</strong> → 文章的批注&#x2F;解说：单行用 # 当脚注，多行用三引号当大段说明</li></ul><h1 id="空行、输入输出与代码组织"><a href="#空行、输入输出与代码组织" class="headerlink" title="空行、输入输出与代码组织"></a>空行、输入输出与代码组织</h1><p>如果把 Python 代码比作一座房子，<strong>空行</strong>是房间之间的走廊，<strong>输入输出</strong>是房子和外界的交互窗，<strong>代码组织</strong>是家具的摆放逻辑</p><h2 id="一、空行"><a href="#一、空行" class="headerlink" title="一、空行"></a>一、空行</h2><p>写代码和写文章一样，密密麻麻挤在一起，读起来累；适当加空行，逻辑更清晰</p><h3 id="1-空行的作用"><a href="#1-空行的作用" class="headerlink" title="1. 空行的作用"></a>1. 空行的作用</h3><ul><li><strong>函数&#x2F;类方法之间</strong>加空行：比如一个文件里有多个函数，用空行隔开，一眼能分清这是函数 A，那是函数 B</li><li><strong>类和函数之间</strong>加空行：类是大模块，函数是小工具，空行分隔让结构更明确～</li></ul><p>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数1的功能&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func2</span>():  <span class="comment"># 和上面func1之间空一行，区分不同函数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;函数2的功能&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method1</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类里的方法1&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">method2</span>(<span class="params">self</span>):  <span class="comment"># 类内方法之间，也可以酌情空行</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;类里的方法2&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="2-空行不是语法要求，但灵魂需要"><a href="#2-空行不是语法要求，但灵魂需要" class="headerlink" title="2. 空行不是语法要求，但灵魂需要"></a>2. 空行不是语法要求，但灵魂需要</h3><p>Python 解释器不管有没有空行，都能运行；但<strong>空行是写给人看的</strong>～ 就像房子里的走廊，没走廊也能走，但有了更舒服、好整理</p><h2 id="二、等待用户输入"><a href="#二、等待用户输入" class="headerlink" title="二、等待用户输入"></a>二、等待用户输入</h2><p>程序不是孤岛，得和用户互动。Python 里用 <code>input()</code>（ Python3 ）或 <code>raw_input()</code>（ Python2 ）让程序等用户输入</p><h3 id="1-基本用法：等用户输入，按回车继续"><a href="#1-基本用法：等用户输入，按回车继续" class="headerlink" title="1. 基本用法：等用户输入，按回车继续"></a>1. 基本用法：等用户输入，按回车继续</h3><p>比如写个按回车退出，按其他键显示内容的小交互：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(<span class="string">&quot;按下 enter 键退出，按其他键+回车显示...\n&quot;</span>)</span><br><span class="line"><span class="comment"># 运行后，程序暂停，等你输入～</span></span><br><span class="line"><span class="comment"># 按回车 → 程序结束；按其他键+回车 → 程序也结束（但可以捕获输入内容）</span></span><br></pre></td></tr></table></figure><h3 id="2-捕获用户输入内容"><a href="#2-捕获用户输入内容" class="headerlink" title="2. 捕获用户输入内容"></a>2. 捕获用户输入内容</h3><p>要用变量接住用户输入的内容，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;你好，<span class="subst">&#123;name&#125;</span>！&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行后，你输入小明，程序会输出你好，小明！。就像房子装了语音对话装置，能回应用户</p><h2 id="三、同一行写多条语句：紧凑但谨慎用"><a href="#三、同一行写多条语句：紧凑但谨慎用" class="headerlink" title="三、同一行写多条语句：紧凑但谨慎用"></a>三、同一行写多条语句：紧凑但谨慎用</h2><p>Python 允许一行写多个语句，用 <strong>分号 ;</strong> 隔开～ 但别滥用，否则代码像挤地铁，可读性差</p><h3 id="1-简单示例"><a href="#1-简单示例" class="headerlink" title="1. 简单示例"></a>1. 简单示例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys; x = <span class="string">&#x27;Python&#x27;</span>; sys.stdout.write(x + <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"><span class="comment"># 一行里做了三件事：导入模块、定义变量、打印内容</span></span><br></pre></td></tr></table></figure><h3 id="2-什么时候用？"><a href="#2-什么时候用？" class="headerlink" title="2. 什么时候用？"></a>2. 什么时候用？</h3><p>适合写<strong>极简短、逻辑关联强</strong>的语句，比如测试代码、单行脚本。 但项目里尽量一行一条语句，方便调试和阅读</p><h2 id="四、print-输出"><a href="#四、print-输出" class="headerlink" title="四、print 输出"></a>四、print 输出</h2><p><code>print()</code> 是 Python 最常用的输出窗口，默认<strong>输出后换行</strong>；但也能控制不换行</p><h3 id="1-默认换行输出"><a href="#1-默认换行输出" class="headerlink" title="1. 默认换行输出"></a>1. 默认换行输出</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二行&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="comment"># 第一行</span></span><br><span class="line"><span class="comment"># 第二行</span></span><br></pre></td></tr></table></figure><h3 id="2-不换行输出（Python2-风格，少用）"><a href="#2-不换行输出（Python2-风格，少用）" class="headerlink" title="2. 不换行输出（Python2 风格，少用）"></a>2. 不换行输出（Python2 风格，少用）</h3><p>Python2 里可以用逗号 <code>,</code> 让 <code>print</code> 不换行，但 Python3 里更推荐用 <code>end</code> 参数～</p><p>Python2 示例（现在少用，了解即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;第一部分&quot;</span>,</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;第二部分&quot;</span></span><br><span class="line"><span class="comment"># 输出：第一部分第二部分</span></span><br></pre></td></tr></table></figure><p>Python3 更优雅的写法（用 <code>end</code>）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一部分&quot;</span>, end=<span class="string">&quot;&quot;</span>)  <span class="comment"># end=&quot;&quot; 表示输出后不加换行符</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二部分&quot;</span>)</span><br><span class="line"><span class="comment"># 输出：第一部分第二部分</span></span><br></pre></td></tr></table></figure><h2 id="五、多个语句构成代码组"><a href="#五、多个语句构成代码组" class="headerlink" title="五、多个语句构成代码组"></a>五、多个语句构成代码组</h2><p>像 <code>if</code>、<code>while</code>、<code>def</code>、<code>class</code> 这些关键字开头的语句，后面要跟<strong>冒号 :<strong>，再跟</strong>缩进的代码组</strong></p><h3 id="1-示例：if-语句的代码组"><a href="#1-示例：if-语句的代码组" class="headerlink" title="1. 示例：if 语句的代码组"></a>1. 示例：if 语句的代码组</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">85</span></span><br><span class="line"><span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;优秀&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> score &gt;= <span class="number">80</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;良好&quot;</span>)  <span class="comment"># 属于elif的代码组，缩进一致</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;继续努力&quot;</span>)  <span class="comment"># 属于else的代码组，缩进一致</span></span><br></pre></td></tr></table></figure><h3 id="2-代码组的本质"><a href="#2-代码组的本质" class="headerlink" title="2. 代码组的本质"></a>2. 代码组的本质</h3><p>同一代码组的语句，必须有相同的缩进，比如都4个空格，就像同一队的队友站同一排</p><h2 id="六、命令行参数"><a href="#六、命令行参数" class="headerlink" title="六、命令行参数"></a>六、命令行参数</h2><p>运行 Python 脚本时，可以通过命令行给程序传参数，像给房子外接拓展装备</p><h3 id="1-查看帮助：python-h"><a href="#1-查看帮助：python-h" class="headerlink" title="1. 查看帮助：python -h"></a>1. 查看帮助：<code>python -h</code></h3><p>在终端输入 <code>python -h</code>（或 <code>python --help</code>），能看到 Python 命令行的帮助信息，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">usage: python [option] ... [-c cmd | -m mod | file | -] [arg] ... </span><br><span class="line">Options and arguments: </span><br><span class="line">-c cmd : 执行字符串里的代码</span><br><span class="line">-d     : 开启调试模式</span><br><span class="line">-h     : 显示帮助信息</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="2-脚本接收参数：sys-argv"><a href="#2-脚本接收参数：sys-argv" class="headerlink" title="2. 脚本接收参数：sys.argv"></a>2. 脚本接收参数：<code>sys.argv</code></h3><p>如果写了个脚本 <code>test.py</code>，想让用户运行时传参数，可以用 <code>sys.argv</code> 读取～</p><p>示例 <code>test.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;传入的参数是：&quot;</span>, sys.argv)</span><br></pre></td></tr></table></figure><p>终端运行 <code>python test.py 张三 20</code>，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传入的参数是： [&#x27;test.py&#x27;, &#x27;张三&#x27;, &#x27;20&#x27;]</span><br></pre></td></tr></table></figure><p><code>sys.argv[0]</code> 是脚本名，<code>sys.argv[1]</code> 是第一个参数，依此类推</p><p>以上内容，便是基础语法的全部内容，下一部分内容将开始讲解 Python 的变量类型。下面是一些问题，请动手做一做：</p><h3 id="一、基础选择题"><a href="#一、基础选择题" class="headerlink" title="一、基础选择题"></a>一、基础选择题</h3><ol><li><p>以下关于 Python 缩进的说法，错误的是？（  ）<br>A) 同一代码块必须用相同数量的空格缩进<br>B) 缩进可以用 Tab 或空格，但不能混用<br>C) <code>IndentationError: unexpected indent</code> 通常是因为某行代码“意外多了缩进”<br>D) Python 允许不同代码块用不同数量的缩进，只要各自内部统一</p></li><li><p>要让 Python 打印内容后<strong>不换行</strong>，以下 Python3 写法正确的是？（  ）<br>A) <code>print(&quot;Hello&quot;, end=&quot;&quot;)</code><br>B) <code>print(&quot;Hello&quot;, &quot;,&quot;)</code><br>C) <code>print &quot;Hello&quot;,</code> （Python2 风格，Python3 不支持）<br>D) <code>print(&quot;Hello&quot;)</code> 后手动加 <code>\n</code></p></li><li><p>关于 Python 引号的使用，正确的是？（  ）<br>A) 单引号和双引号完全等价，随便选<br>B) 三引号 <code>&#39;&#39;&#39; </code> 只能用来写多行字符串，不能当注释<br>C) 如果字符串里包含单引号，外层必须用双引号包裹<br>D) 三引号 <code>&quot;&quot;&quot; </code> 包裹的字符串，换行和缩进会被原封不动保留</p></li><li><p>以下关于空行的说法，正确的是？（  ）<br>A) 空行是 Python 语法要求，必须严格按行数加<br>B) 函数之间加空行是为了让代码运行更快<br>C) 空行能分隔不同功能的代码，提升可读性<br>D) 类内部的方法之间绝对不能加空行</p></li><li><p>运行 <code>python test.py 小明 18</code> 时，<code>sys.argv</code> 的结果是？（  ）<br>A) <code>[&#39;test.py&#39;, &#39;小明&#39;, &#39;18&#39;]</code><br>B) <code>[&#39;小明&#39;, &#39;18&#39;]</code><br>C) <code>[&#39;python&#39;, &#39;test.py&#39;, &#39;小明&#39;, &#39;18&#39;]</code><br>D) 报错，因为不能传中文</p></li><li><p>以下代码运行后，输出结果是？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Python&quot;</span>)</span><br></pre></td></tr></table></figure><p>A) HelloPython<br>B) Hello<br>Python<br>C) 报错<br>D) 只打印 Hello</p></li><li><p>看代码，选出注释正确的选项（多选）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是单行注释</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第一行&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是</span></span><br><span class="line"><span class="string">多行</span></span><br><span class="line"><span class="string">注释</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;第二行&quot;</span>)</span><br></pre></td></tr></table></figure><p>A) <code># 这是单行注释</code> 是单行注释，会被执行<br>B) 三引号 <code>&#39;&#39;&#39;</code> 包裹的内容是多行注释，不会被执行<br>C) <code>print(&quot;第一行&quot;)</code> 会打印内容，<code>print(&quot;第二行&quot;)</code> 不会<br>D) 注释的作用是给代码加说明，Python 会忽略注释内容</p></li><li><p>关于以下多行语句写法，正确的是？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>A) 反斜杠 <code>\</code> 后必须紧跟换行，不能有空格<br>B) 可以把反斜杠换成逗号 <code>,</code> 达到同样效果<br>C) 这种写法是错误的，Python 不允许一行拆多行<br>D) 反斜杠可以随便加在代码任何位置</p></li><li><p>下面代码中，字符串的引号使用正确的是？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">&#x27;Python&#x27;</span></span><br><span class="line">sentence = <span class="string">&quot;I&#x27;s learn Python&quot;</span></span><br><span class="line">paragraph = <span class="string">&quot;&quot;&quot;这是一段</span></span><br><span class="line"><span class="string">多行文字&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>A) <code>word</code> 用单引号，完全没问题<br>B) <code>sentence</code> 里有单引号 <code>&#39;</code>，外层用双引号正确<br>C) <code>paragraph</code> 用三引号包多行字符串，正确<br>D) 以上全对</p></li></ol><h3 id="二、改代码除-Bug（考验语法细节）"><a href="#二、改代码除-Bug（考验语法细节）" class="headerlink" title="二、改代码除 Bug（考验语法细节）"></a>二、改代码除 Bug（考验语法细节）</h3><h4 id="题1：引号不匹配导致报错"><a href="#题1：引号不匹配导致报错" class="headerlink" title="题1：引号不匹配导致报错"></a>题1：引号不匹配导致报错</h4><p>下面代码运行会报错（<code>SyntaxError: EOL while scanning string literal</code>），请修正引号，让代码正常打印诗句～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">poem = <span class="string">&#x27;床前明月光，</span></span><br><span class="line"><span class="string">疑是地上霜。&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(poem)</span><br></pre></td></tr></table></figure><h4 id="题2：缩进错误导致报错"><a href="#题2：缩进错误导致报错" class="headerlink" title="题2：缩进错误导致报错"></a>题2：缩进错误导致报错</h4><p>下面代码因缩进问题报错（<code>IndentationError</code>），请修正缩进，让代码能正常输出“Hello Python”～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>)</span><br><span class="line"> <span class="built_in">print</span>(<span class="string">&quot;Python&quot;</span>)  <span class="comment"># 注意这行开头</span></span><br></pre></td></tr></table></figure><h4 id="题3：多行语句的反斜杠错误"><a href="#题3：多行语句的反斜杠错误" class="headerlink" title="题3：多行语句的反斜杠错误"></a>题3：多行语句的反斜杠错误</h4><p>下面代码想把长运算拆成多行，但反斜杠用错了导致报错，请修正～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">total = <span class="number">10</span> + <span class="number">20</span> + \ <span class="number">30</span> + <span class="number">40</span>  <span class="comment"># 注意反斜杠位置</span></span><br><span class="line"><span class="built_in">print</span>(total)</span><br></pre></td></tr></table></figure><h3 id="三、写代码实现需求（考验知识应用）"><a href="#三、写代码实现需求（考验知识应用）" class="headerlink" title="三、写代码实现需求（考验知识应用）"></a>三、写代码实现需求（考验知识应用）</h3><h4 id="题1：用三引号写介绍并打印"><a href="#题1：用三引号写介绍并打印" class="headerlink" title="题1：用三引号写介绍并打印"></a>题1：用三引号写介绍并打印</h4><p>需求：</p><ul><li>用<strong>三引号</strong>写一段“我的爱好”（至少两行，比如爱好是读书、跑步等）。</li><li>用 <code>print()</code> 把这段爱好打印出来。</li><li>给代码加<strong>单行注释</strong>，解释每一步做了什么。</li></ul><h4 id="题2：用-input-互动并输出"><a href="#题2：用-input-互动并输出" class="headerlink" title="题2：用 input 互动并输出"></a>题2：用 input 互动并输出</h4><p>需求：</p><ul><li>用 <code>input()</code> 提示用户“请输入你的名字：”，并把输入的内容存到变量 <code>name</code> 里。</li><li>用 <code>print()</code> 输出“你好，name 的值！”（比如用户输入“阿花”，输出“你好，阿花！”）。</li></ul><h4 id="题3：给代码加空行提升可读性"><a href="#题3：给代码加空行提升可读性" class="headerlink" title="题3：给代码加空行提升可读性"></a>题3：给代码加空行提升可读性</h4><p>需求：<br>下面代码没有空行，显得很挤～ 请在<strong>函数之间、函数和打印逻辑之间</strong>加空行，让结构更清晰～</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">say_hello</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello!&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">say_goodbye</span>():</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Goodbye!&quot;</span>)</span><br><span class="line">say_hello()</span><br><span class="line">say_goodbye()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基本语法(第一个程序)</title>
      <link href="/2025/10/22/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/10/22/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python 和PHP、C或者Java等编程语言都有相似之处，但其中亦有差异。接下来这部分的学习，将开始学习 Python 的基本语法</p><h1 id="第一个-Python-程序"><a href="#第一个-Python-程序" class="headerlink" title="第一个 Python 程序"></a>第一个 Python 程序</h1><h2 id="交互式编程"><a href="#交互式编程" class="headerlink" title="交互式编程"></a>交互式编程</h2><p>交互式编程，就像和电脑对话一样。你不需要先创建一个代码文件，而是直接打开 Python 解释器，输入一行代码，它就会立刻给你一行结果。这是一种即写即得、非常适合测试小段代码和快速入门的方式。<br>好的，我们换一种更通俗的方式来解释交互式编程：</p><h3 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h3><p><strong>在 Linux 系统上，操作非常简单：</strong></p><ol><li>打开你的终端窗口。</li><li>直接输入命令 <code>python3</code> 然后按回车。</li></ol><p>接着，你会看到类似下面的提示信息（不同电脑上的版本和日期可能不一样）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">Python 3.9.7 (default, Sep 3 2025, 18:45:43) </span><br><span class="line">[GCC 11.2.0] on linux</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> or <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当你看到 <code>&gt;&gt;&gt;</code> 这三个大于号时，就说明你已经成功进入了 Python 的交互模式，可以开始和 Python“对话”，编写你的代码了。</p><h3 id="Windows系统（以Windows11为例）"><a href="#Windows系统（以Windows11为例）" class="headerlink" title="Windows系统（以Windows11为例）"></a>Windows系统（以Windows11为例）</h3><p>在 Windows 上，当你安装好 Python 后，就已经自带了一个可以“即输即跑”的交互式编程环境。<br><strong>启动方法很简单：</strong></p><ol><li>在开始菜单中找到并打开 <strong>“Python 3.12”</strong>（版本号可能不同）这个文件夹。</li><li>点击运行 <strong>Python 3.12 (64-bit)</strong> 这个程序。这会打开一个命令提示符窗口，也就是 Python 的交互模式。</li></ol><p>打开后，你会看到如下所示的窗口：</p><div style="text-align:center">  <img src="/img_2/QQ截图20251022212609.png" alt="图一" style="width:50%;" ></div><p>在窗口中，你会看到 <code>&gt;&gt;&gt;</code> 这个提示符。这就像是 Python 在对你说：“我准备好了，请下指令吧”。</p><p><strong>现在，你可以开始尝试和它“对话”了：</strong><br>在 <code>&gt;&gt;&gt;</code> 后面输入以下代码，然后按 Enter 键：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure><p>按下回车后，你会立刻在下一行看到代码的执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br></pre></td></tr></table></figure><h2 id="脚本式编程"><a href="#脚本式编程" class="headerlink" title="脚本式编程"></a>脚本式编程</h2><h2 id="什么是脚本式编程？与“即输即跑”的交互式编程不同，脚本式编程是先编写完整的代码文件，然后一次性执行。这种方式适合编写较复杂的程序，代码会被保存下来，可以反复运行和修改"><a href="#什么是脚本式编程？与“即输即跑”的交互式编程不同，脚本式编程是先编写完整的代码文件，然后一次性执行。这种方式适合编写较复杂的程序，代码会被保存下来，可以反复运行和修改" class="headerlink" title="什么是脚本式编程？与“即输即跑”的交互式编程不同，脚本式编程是先编写完整的代码文件，然后一次性执行。这种方式适合编写较复杂的程序，代码会被保存下来，可以反复运行和修改"></a>什么是脚本式编程？<br>与“即输即跑”的交互式编程不同，脚本式编程是先编写完整的代码文件，然后一次性执行。这种方式适合编写较复杂的程序，代码会被保存下来，可以反复运行和修改</h2><p>下面是<strong>使用 PyCharm 2023.3新建 Python 项目、编写并运行第一个 Python 程序</strong>的详细步骤，同时会解释界面里常见选项的含义，帮你消除困惑～</p><h3 id="一、新建-Python-项目"><a href="#一、新建-Python-项目" class="headerlink" title="一、新建 Python 项目"></a>一、新建 Python 项目</h3><p>打开 PyCharm 后，跟着以下步骤创建新项目：</p><ol><li><p><strong>点击“新建项目”</strong><br>如果你是第一次打开 PyCharm，会看到欢迎界面，选择 <code>新建项目</code>；如果已经打开过其他项目，可点击顶部菜单栏 <code>文件(F)</code> → <code>新建项目(N)...</code>。</p></li><li><p><strong>理解“新建项目”界面里的关键选项</strong><br>打开“新建项目”窗口后，你会看到类似下图的界面，下面逐个解释重要区域&#x2F;选项：</p><div style="text-align:center"><img src="/img_2/QQ截图20251022222411.png" alt="图二" style="width:50%;" ></div><ul><li><p><strong>左侧列表</strong>：</p><ul><li><code>纯 Python</code>：表示创建一个最基础的 Python 项目，不含其他 Web 框架或特殊模板。</li><li><code>Django</code>、<code>FastAPI</code>、<code>Flask</code> 等：这些是 Python 常用的 Web 框架模板，用来快速创建对应框架的项目结构（本次我们先选最基础的 <code>纯 Python</code>）。</li><li><code>科学</code>、<code>其他</code> 分类下的 <code>Angular CLI</code>、<code>React</code>、<code>Vue.js</code> 等：这些是用来整合前端框架或做全栈项目的模板，初学者暂时用不到。</li></ul></li><li><p><strong>右侧 - 项目名称与位置</strong>：</p><ul><li><code>名称</code>：你给新项目起的名字，比如 <code>myFirstPythonProject</code>，PyCharm 会默认生成类似 <code>pythonProjectX</code>，你可以改成自己喜欢的名字。</li><li><code>位置</code>：项目要保存到电脑里的哪个文件夹。点击输入框最右边的文件夹小图标，能打开文件浏览器选择路径，比如 <code>F:\pythonProject\myFirstPythonProject</code></li></ul></li><li><p><strong>右侧 - 解释器相关</strong>：</p><ul><li><code>解释器类型</code>：<ul><li><code>项目 venv</code>：PyCharm 会在项目目录下自动帮你创建一个独立的虚拟环境，叫做 <code>venv</code>，隔离不同项目的 Python 包，避免版本冲突。</li><li><code>基础 conda</code>：如果你电脑里装了 Anaconda&#x2F;Miniconda，想用 conda 来管理虚拟环境，就选这个，但是初学者一般先用 <code>venv</code> 就行</li><li><code>自定义环境</code>：如果你已经手动配置好了虚拟环境，想指定已有的解释器路径，选这个。</li></ul></li><li><code>环境</code>：<ul><li><code>生成新的</code>：让 PyCharm 帮我们在项目里新建一个虚拟环境（推荐新手选这个）。</li><li><code>选择现有</code>：如果你之前已经手动创建过虚拟环境，想复用它，就选这个。</li></ul></li><li><code>类型</code>：<ul><li>一般默认选 <code>Virtualenv</code> 即可，这是 Python 官方的虚拟环境工具。如果你装了 <code>conda</code>，也会出现 <code>Conda</code> 选项，但新手先不管这个。</li></ul></li><li><code>基础 Python</code>：<ul><li>这里要选择你电脑上<strong>已经安装好的 Python 解释器可执行文件</strong>。比如 ：<code>F:\Python\python.exe</code>。PyCharm 一般会自动检测到系统里的 Python 解释器，直接选它就行。</li></ul></li><li><code>位置</code>（即虚拟环境的位置）：<ul><li>这是虚拟环境文件夹在你项目里的路径，默认是 <code>&lt;项目路径&gt;/venv</code>，不用手动改，保持默认就好。</li></ul></li><li>下面还有两个复选框（<code>从基础解释器继承软件包</code>、<code>可用于所有项目</code>）：新手阶段不用管，保持不勾选即可。</li></ul></li><li><p><strong>额外选项</strong>：</p><ul><li><code>创建 Git 仓库</code>：如果你需要用 Git 做版本管理，就勾选；新手暂时可以不勾。</li><li><code>创建 main.py 欢迎脚本</code>：勾选的话，PyCharm 会自动在项目里生成一个带示例代码的 <code>main.py</code> 文件，方便你直接开始写代码；也可以不勾，之后自己手动新建 <code>.py</code> 文件。</li></ul></li></ul></li><li><p><strong>确认配置，点击“创建”</strong><br>把上面的选项大概看明白后，保持最基础的配置（选 <code>纯 Python</code>、填好项目名称和位置、解释器选系统里已装的 Python、环境选“生成新的”、类型选 <code>Virtualenv</code> 等），然后点击右下角 <code>创建</code> 按钮，PyCharm 就会帮你搭建好第一个 Python 项目的目录结构～</p></li></ol><h3 id="三、在新项目里写第一个-Python-程序"><a href="#三、在新项目里写第一个-Python-程序" class="headerlink" title="三、在新项目里写第一个 Python 程序"></a>三、在新项目里写第一个 Python 程序</h3><p>项目创建好后，PyCharm 会自动打开项目界面。接下来我们来写你的第一个 Python 程序吧：</p><ol><li><p><strong>新建 Python 文件</strong></p><ul><li>在左侧的“项目”导航栏里，对着项目名称，或项目里的 <code>venv</code> 上一级文件夹，鼠标右键 → <code>新建</code> → <code>Python 文件</code>。<div style="text-align:center"><img src="/img_2/QQ截图20251022223745.png" alt="图三" style="width:50%;" ></div></li><li>给这个文件起个名字，比如 <code>test.py</code>，<strong>注意</strong>：后缀是 <code>.py</code>，表示这是 Python 源代码文件，然后按回车键确认。<div style="text-align:center"><img src="/img_2/QQ截图20251022223930.png" alt="图四" style="width:50%;" ><img src="/img_2/QQ截图20251022223938.png" alt="图五" style="width:50%;" ></div></li></ul></li><li><p><strong>编写代码</strong><br>在新打开的 <code>test.py</code> 编辑区域，输入以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>运行代码</strong><br>有以下几种常见方式可以运行这个 Python 文件：</p><ul><li>点击代码编辑区域右上角的绿色三角（运行按钮），或者右键点击 <code>test.py</code> 文件 → <code>运行 &#39;test&#39;</code>。</li><li>也可以用快捷键：一般是 <code>Shift + F10</code>（具体快捷键以你 PyCharm 的设置为准，可在顶部菜单栏 <code>运行</code> 里查看）。<div style="text-align:center"><img src="/img_2/QQ截图20251022224213.png" alt="图六" style="width:50%;" ></div>运行后，你会在底部的“运行”控制台看到输出结果：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, Python!</span><br></pre></td></tr></table></figure><div style="text-align:center"><img src="/img_2/QQ截图20251022224338.png" alt="图七" style="width:50%;" ></div></li></ul></li></ol><h3 id="四、额外说明（可选了解）"><a href="#四、额外说明（可选了解）" class="headerlink" title="四、额外说明（可选了解）"></a>四、额外说明（可选了解）</h3><p>如果你在“新建项目”时勾选了 <code>创建 main.py 欢迎脚本</code>，PyCharm 会自动生成一个 <code>main.py</code>，里面可能长这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>这也是一种常见的 Python 程序组织方式（把代码放到函数里，再通过 <code>if __name__ == &quot;__main__&quot;</code> 来执行），运行它也会在控制台输出 <code>Hello, World!</code>～</p><p>到这里，你就已经在 PyCharm 2023.3 里成功创建了第一个 Python 项目，并且运行了人生第一段 Python 代码 ✨～ 如果后续想写更复杂的程序，只需要继续在项目里新建 <code>.py</code> 文件、写代码、运行即可～</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 环境搭建</title>
      <link href="/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Pythobn%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Pythobn%E7%9A%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python 作为一款跨平台编程语言，能够在多种主流操作系统及环境中运行。本章将指导您完成本地 Python 开发环境的安装与配置。</p><p>目前，Python 已广泛兼容以下系统平台：</p><ul><li><strong>桌面操作系统</strong>：Windows（7及以上版本）、macOS（所有主流版本）、Linux（Ubuntu、Debian、Fedora、CentOS等）</li><li><strong>类 Unix 系统</strong>：FreeBSD、OpenBSD 等</li><li><strong>嵌入式设备</strong>：树莓派等开发板</li><li><strong>移动平台</strong>：通过 Kivy 等框架支持 iOS 和 Android</li><li><strong>云服务平台</strong>：AWS、Google Cloud、Azure 等</li></ul><h2 id="环境检查与准备工作"><a href="#环境检查与准备工作" class="headerlink" title="环境检查与准备工作"></a>环境检查与准备工作</h2><h3 id="打开终端-命令提示符"><a href="#打开终端-命令提示符" class="headerlink" title="打开终端&#x2F;命令提示符"></a>打开终端&#x2F;命令提示符</h3><p>在检查 Python 安装前，需要先打开系统终端：</p><p><strong>Windows</strong></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 方法<span class="number">1</span>：按 Win+R，输入 <span class="built_in">cmd</span> 回车</span><br><span class="line"># 方法<span class="number">2</span>：在开始菜单搜索&quot;命令提示符&quot;或&quot;<span class="built_in">CMD</span>&quot;</span><br><span class="line"># 方法<span class="number">3</span>：按 Win+X，选择&quot;终端&quot;（或终端管理员）</span><br></pre></td></tr></table></figure><p><strong>macOS</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：Cmd+空格，搜索&quot;终端&quot;</span></span><br><span class="line"><span class="comment"># 方法2：应用程序-实用工具-终端</span></span><br><span class="line"><span class="comment"># 方法3：使用 iTerm2 等第三方终端</span></span><br></pre></td></tr></table></figure><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 方法1：Ctrl+Alt+T（大多数发行版）</span></span><br><span class="line"><span class="comment"># 方法2：应用程序-系统工具-终端</span></span><br><span class="line"><span class="comment"># 方法3：右键桌面选择&quot;打开终端&quot;</span></span><br></pre></td></tr></table></figure><h3 id="检查-Python-安装"><a href="#检查-Python-安装" class="headerlink" title="检查 Python 安装"></a>检查 Python 安装</h3><p>打开终端后，输入以下命令检查 Python 状态：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 检查 Python 是否安装及版本</span></span><br><span class="line">python --version</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line">python3 --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在某些系统中可能需要使用特定版本号</span></span><br><span class="line">python3.9 --version</span><br><span class="line">python3.11 --version</span><br></pre></td></tr></table></figure><p>如果系统已安装 Python，命令将返回版本号；如果未安装，会显示”未找到命令”或类似提示。</p><h3 id="各平台安装指引"><a href="#各平台安装指引" class="headerlink" title="各平台安装指引"></a>各平台安装指引</h3><p><strong>Windows</strong></p><ul><li>访问 python.org 下载官方安装包</li><li>安装时勾选”Add Python to PATH”</li><li>可通过 Microsoft Store 安装</li></ul><p><strong>macOS</strong></p><ul><li>使用 Homebrew：<code>brew install python</code></li><li>下载官方安装包</li><li>系统可能预装 Python，但建议安装新版</li></ul><p><strong>Linux</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Ubuntu/Debian</span></span><br><span class="line"><span class="built_in">sudo</span> apt update &amp;&amp; <span class="built_in">sudo</span> apt install python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># CentOS/RHEL</span></span><br><span class="line"><span class="built_in">sudo</span> yum install python3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或使用包管理器</span></span><br><span class="line"><span class="built_in">sudo</span> dnf install python3</span><br></pre></td></tr></table></figure><p>完成安装后，重新打开终端并再次运行 <code>python --version</code> 确认安装成功。</p><h2 id="Python-下载"><a href="#Python-下载" class="headerlink" title="Python 下载"></a>Python 下载</h2><p>Python 的最新源码，二进制文档，新闻资讯都可以在官网查询到，以下是 Python 官网：<br><a href="https://www.python.org/">https://www.python.org/</a><br>你可以在以下链接中下载 Python 的文档，但是考虑到部分人访问官网会很慢，所以这里提供一个国内的网站来供大家下载（Python3.7版的）：<br><a href="https://repo.huaweicloud.com/python/3.7.9/">https://repo.huaweicloud.com/python/3.7.9/</a></p><p>进入网站之后，按照下面图示，选择这个版本的安装即可</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021000450.png" alt="图一" style="width:50%;" ></div><p>安装好以后，找到这个文件，双击点击安装</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021123959.png" alt="图二" style="width:50%;" >  <img src="/img_2/QQ截图20251021130005.png" alt="图三" style="width:50%;" ></div><p>图三中的内容，第一个选项的意思是表示以管理员权限安装 Python<br>而第二个的意思是表示自动添加Python的环境路径 **（强烈建议勾选上否则你需要单独配置环境变量）<br>上面的 <strong>Install Now</strong> 可以理解成默认路径安装，也就是在C盘进行安装，同样你可以选择下面的 <strong>Customize installation</strong> 以自定义选择安装的位置。（我的建议是默认即可）。如果还是想要选择自定义安装的话，<a href="https://blog.toumatou.cn/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%A1%A5%E6%A1%A3/">请跳转这里</a></p><p><strong>如果弹出是否允许之类的弹窗选择是即可</strong><br>如果直接点击上面的 <strong>Install Now</strong> 等待片刻后，他就会安装完毕，出现如下画面</p><div style="text-align:center">  <img src="/img_2/F44F4901A067BEF2F27AF28C566E210F.jpg" alt="图四" style="width:50%;" ></div><p>这里的 Diable path length limit 是为了防止文件路径名字过长而取消路径长度限制，建议不要点击，直接点击Close就好。<br>至此，安装流程已经结束。<br><strong>PS</strong> : 以后在安装软件的时候，养成一个好习惯，不要把它安装在由中文命名的文件夹处，否则可能会出现一些莫名其妙的问题，把它放在一个以英文命名的文件夹下，哪怕你用拼音命名也可以。<strong>请养成这个好习惯!!!</strong> ×3（重要的事情说三遍）</p><h2 id="检测安装"><a href="#检测安装" class="headerlink" title="检测安装"></a>检测安装</h2><p>让我们打开命令行（以Windows系统为例）<br>如果你忘记了怎么的打开，你可以在键盘上按住 <strong>win＋R</strong> （Win键，通常标有Windows徽标（一个四格窗口图标）），然后输入 <strong>cmd</strong> 这个指令，接着回车，得到如下图所示结果：</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021133511.png" alt="图五" style="width:50%;" >  <img src="/img_2/QQ截图20251021133645.png" alt="图六" style="width:50%;" ></div><p>接着在命令行里输入 <strong>python</strong> ，结果如图类似即可，由于我安装的是Python 3.12.0版本所以出现的就是Python 3.12.0，如果你是其他版本就是对应版本</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021133824.png" alt="图七" style="width:50%;" ></div>当然，你也可以输入 python --version （中间有空格，两个减号，别忘了），结果如图所示：<div style="text-align:center">  <img src="/img_2/QQ截图20251021134103.png" alt="图八" style="width:50%;" ></div>如果你的结果不像上面几张图所示，而是出现的是"...不是外部或内部命令，也不是可运行的程序"，你可能在环境配置中遇到了问题，你可以再次看一遍教程，重做前面的步骤。至此你已经完成了Python的安装与环境配置。<h2 id="Python的使用（通过IDE来使用）"><a href="#Python的使用（通过IDE来使用）" class="headerlink" title="Python的使用（通过IDE来使用）"></a>Python的使用（通过IDE来使用）</h2><p>有不少人都喜欢用 <strong>Pycharm</strong> 来编写 Python ，我也是。所以这部分教程将使用 Pycharm 来作为使用 Python 的工具</p><h3 id="IDE工具的下载"><a href="#IDE工具的下载" class="headerlink" title="IDE工具的下载"></a>IDE工具的下载</h3><p>以下是 Pycharm 的官网地址：<br><a href="https://www.jetbrains.com/pycharm">https://www.jetbrains.com/pycharm</a></p><p>但是，考虑到有些朋友访问的比较慢，下载的也慢，<strong>最最重要的是</strong>，官方正版的是要花钱的，成本还不少，仅仅只是为了学习，没必要花那么多钱，等你以后有了收入再去支持正版也不迟，所以接下来我提供一个链接，里面包含了 Pycharm 的激活步骤。<br><strong>声明</strong> ：<strong>以下内容仅供参考学习，不得商用！！！违背的必将追究！！！</strong><br><strong>链接</strong>：<br>链接一：<strong><a href="https://wwrr.lanzoul.com/iZzaL38yy06b">https://wwrr.lanzoul.com/iZzaL38yy06b</a></strong><br>链接二：通过百度网盘分享的文件：pycharm-professional-2024.1.exe<br><strong><a href="https://pan.baidu.com/s/1mIYrIZ-0ECFI4wICZbomLA?pwd=cxgu">https://pan.baidu.com/s/1mIYrIZ-0ECFI4wICZbomLA?pwd=cxgu</a></strong><br>提取码: cxgu<br>连接三：我用夸克网盘给你分享了「pycharm-professional-2024.1.exe」，点击链接或复制整段内容，打开「夸克APP」即可获取。<br><strong>&#x2F;<del>164a38mHUb</del>:&#x2F;</strong><br><strong><a href="https://pan.quark.cn/s/27f5a93eaef2?pwd=txV8">https://pan.quark.cn/s/27f5a93eaef2?pwd=txV8</a></strong><br>提取码：txV8<br>其中，链接一是激活工具，链接二和链接三分别是百度网盘和夸克网盘分享的 Pycharm 软件的链接。想要使用 Pycharm，除了需要有软件以外，还要有激活工具。如果你是通过官网下载的，那么请下载 Pycharm 2024.1版本的，否则可能会激活失败。补充一下，怎么找到除了最新版的其它版本？<br>当你进入 <a href="https://www.jetbrains.com/pycharm/download/?section=windows">PyCharm官网的时候</a>，点击 <strong>Other versions</strong>（其它版本）就可以直接跳转到其它版本的页面,鼠标滚轮向下滑动并找到2024.1版本。如下图所示：</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021144719.png" alt="图九" style="width:50%;" >  <img src="/img_2/QQ截图20251021145523.png" alt="图十" style="width:50%;" >  <img src="/img_2/QQ截图20251021145703.png" alt="图十一" style="width:50%;" >  <img src="/img_2/QQ截图20251021145847.png" alt="图十二" style="width:50%;" ></div>下载好以后在你的文件资源管理器里面找到它，如图：<div style="text-align:center">  <img src="/img_2/QQ截图20251021150048.png" alt="图十三" style="width:50%;" ></div><p>双击唤起，会弹出以下提示，点击 <strong>下一步</strong> </p><div style="text-align:center">  <img src="/img_2/QQ截图20251021150251.png" alt="图十四" style="width:50%;" ></div><p>下一步是选择安装的位置，可以选择默认（即装在C盘），但是我不推荐装在C盘，所以强烈建议手动修改一下安装位置，装在其它盘，我这里装在了D盘，你也可以选择装在其它盘，完成之后再点击 <strong>下一步</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021150738.png" alt="图十五" style="width:50%;" ></div><p><strong>创建桌面快捷方式</strong>的这个地方和<strong>更新PATH变量</strong>的地方可以打上勾，当然你也可以不打勾直接 <strong>下一步</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021150936.png" alt="图十六" style="width:50%;" ></div><p>到这里直接点击安装</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021151039.png" alt="图十七" style="width:50%;" ></div><p>等待一段时间，直至</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021151154.png" alt="图十八" style="width:50%;" ></div><p>接着点击完成，至此你的 Pycharm 便安装完成了</p><h3 id="Pycharm的激活"><a href="#Pycharm的激活" class="headerlink" title="Pycharm的激活"></a>Pycharm的激活</h3><p>进入 Pycharm ，引入眼帘的是一个协议，直接点击 <strong>Continue</strong> 即可</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021151613.png" alt="图十九" style="width:50%;" ></div><p>接下来这个是关于数据共享的，同意后他会将一些数据以匿名的形式返回给阿帕奇，可选可不选</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021151903.png" alt="图二十" style="width:50%;" ></div><p>好了，到这一步，先关闭 Pycharm ，然后打开我提供的那个激活工具，找到这个部分</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021152228.png" alt="图二十一" style="width:50%;" ></div><p>接着双击它，等待一会儿，当弹出 <strong>success</strong> 的时候，则表示激活成功。之后进入 Pycahrm，就会弹出这个界面</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021152836.png" alt="图二十二" style="width:50%;" ></div><p>点击 <strong>Plugins</strong> ，在上方的搜索搜索栏搜索 <strong>Chinese</strong> ，找到这个图标对应插件，点击旁边的 <strong>Install</strong> ，等待其安装成功后就会弹出一个 <strong>Restart IDE</strong> ,意思就是安装完这个插件以后需要重启一下 Pycharm ，点击即可</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021152836.png" alt="图二十三" style="width:50%;" >  <img src="/img_2/QQ截图20251021153420.png" alt="图二十四" style="width:50%;" >  <img src="/img_2/QQ截图20251021153805.png" alt="图二十五" style="width:50%;" >  <img src="/img_2/QQ截图20251021154118.png" alt="图二十六" style="width:50%;" >  <img src="/img_2/QQ截图20251021154343.png" alt="图二十七" style="width:50%;" ></div><p>重启 Pycharm 以后，你就会看界面以及变成中文了</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021154455.png" alt="图二十八" style="width:50%;" ></div><p>至此， <strong>Python</strong> 的环境搭建已全部完成。下一部分的内容则正式进入到 Python 的学习中</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 环境搭建补档</title>
      <link href="/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%A1%A5%E6%A1%A3/"/>
      <url>/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%20%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%A1%A5%E6%A1%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>可能有的朋友在安装 Python 的时候还是会选择自定义安装，那么考虑到这部分朋友，就补档这一部分的内容</p><h2 id="自定义安装步骤"><a href="#自定义安装步骤" class="headerlink" title="自定义安装步骤"></a>自定义安装步骤</h2><p>在打开安装包后还是建议勾选下面两项，然后选择 <strong>Customize installation</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021163545.png" alt="图一" style="width:50%;" ></div><p>后面的这些内容，不需要动，直接点击 <strong>Next</strong> 下一步就好<br>下面解释一下这些内容是什么意思：<br>好的，我们来用更通俗的方式解释这些安装选项：</p><ul><li><p><strong>Documentation（文档）</strong><br>就是 Python 的官方说明书和帮助文件。<strong>建议勾选</strong>，这样你可以在没网的时候也能本地查阅，很方便。</p></li><li><p><strong>pip（包管理工具）</strong><br>这是 Python 的“应用商店”，你以后想用别人写好的现成代码（称为“库”或“包”），比如做数据分析、爬虫等，都需要通过 pip 来下载安装。<strong>这是最关键的工具，必须安装。</strong></p></li><li><p><strong>tcl&#x2F;tk and IDLE</strong></p><ul><li><code>tcl/tk</code> 是两款用来做简单窗口程序（GUI）的底层工具。</li><li><code>IDLE</code> 是 Python 自带的一个非常基础的“记事本”式的代码编写和运行环境。<br>对于新手，你<strong>可以不勾选</strong>。因为它功能简单，我们后文会推荐更强大、好用的 PyCharm 作为代码编辑器。</li></ul></li><li><p><strong>Python test suite（测试套件）</strong><br>这是 Python 官方用来自己检查身体（测试解释器和标准库）的一套工具。<strong>不用管它，保持默认勾选即可</strong>，普通用户基本用不上。</p></li><li><p><strong>py launcher（启动器）</strong><br>这个工具能让你在电脑的命令行里，简单地输入 <code>py</code> 命令来启动不同版本的 Python。而 “for all users” 是问你是否为电脑上的所有用户都安装这个功能。</p><ul><li><strong>如果你是个人电脑，勾不勾都行</strong>。勾选需要管理员权限，不勾选就只给你当前这个用户安装。</li><li><strong>建议勾选</strong>，这样更方便。</li></ul></li></ul><p>简单总结一下：<br><strong>pip 必选；Documentation 和 py launcher 建议选；IDLE 可以不选；test suite 留着就行。</strong>（但是刚开始建议还是都选上吧）</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021164407.png" alt="图二" style="width:50%;" ></div><p><strong>Customize install location</strong> 选择的是安装路径，这个可以自选（<strong>建议路径中不要带中文，再次强调</strong>），选择好后点击Install<br>下面来解释一下这些内容是什么意思：<br>好的，我们来用通俗易懂的语言解释这些安装选项：</p><ul><li><p><strong>Install Python 3.12 for all users（为所有用户安装）</strong></p><ul><li><strong>通俗解释</strong>：如果勾选，电脑上所有的用户账户都能使用这个 Python。就像在公共区域安装一个软件，大家都能用。这需要管理员权限。</li><li><strong>建议</strong>：如果你是电脑的唯一用户，<strong>勾不勾都行</strong>。如果在公司或学校的电脑上，想自己用，就别勾。</li></ul></li><li><p><strong>Associate files with Python（将文件与 Python 关联）</strong></p><ul><li><strong>通俗解释</strong>：勾选后，当你直接在文件夹里双击一个 <code>.py</code> 的 Python 脚本文件时，电脑会自动用 Python 来运行它，非常方便。</li><li><strong>建议</strong>：<strong>建议勾选</strong>，省去手动操作的麻烦。</li></ul></li><li><p><strong>Create shortcuts for installed applications（创建快捷方式）</strong></p><ul><li><strong>通俗解释</strong>：就是在开始菜单里放一个 Python 的快捷启动入口，方便你找到它。</li><li><strong>建议</strong>：<strong>建议勾选</strong>，找起来方便。</li></ul></li><li><p><strong>Add Python to environment variables（添加 Python 到环境变量）</strong></p><ul><li><strong>通俗解释</strong>：这是<strong>非常重要</strong>的一步！勾选后，你可以在电脑的命令行（那个黑乎乎的窗口）的任何位置，直接输入 <code>python</code> 命令来启动 Python。如果不勾选，你就得输入一长串完整的安装路径才行，非常麻烦。</li><li><strong>建议</strong>：<strong>务必确保它勾选着</strong>（安装程序默认通常会勾好），千万别取消！</li></ul></li><li><p><strong>Precompile standard library（预编译标准库）</strong></p><ul><li><strong>通俗解释</strong>：相当于提前把 Python 自带的“官方工具箱”整理好，这样你以后使用它们的时候，打开速度会快一点点。对电脑没坏处，只是安装时会多花一两分钟。</li><li><strong>建议</strong>：<strong>勾上就行</strong>，对新手没影响，图个以后速度快。</li></ul></li><li><p><strong>Download debugging symbols &#x2F; Download debug binaries（下载调试符号&#x2F;调试文件）</strong></p><ul><li><strong>通俗解释</strong>：这是给“Python 医生”（高级开发人员）准备的“诊断工具”。当 Python 本身出现极其深奥的崩溃问题时，用来排查定位的。</li><li><strong>建议</strong>：<strong>普通用户完全不需要</strong>，会白白占用磁盘空间，<strong>取消勾选</strong>即可。</li></ul></li></ul><div style="text-align:center">  <img src="/img_2/QQ截图20251021164639.png" alt="图三" style="width:50%;" ></div><p>安装完毕后，出现如下画面，直接点击 <strong>Close</strong>：</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021164848.png" alt="图四" style="width:50%;" ></div><h2 id="环境变量的配置"><a href="#环境变量的配置" class="headerlink" title="环境变量的配置"></a>环境变量的配置</h2><p>如果你没有点击 <strong>Add python.exe to PATH</strong> 这一步或者你忘记是否点击这一步，这里建议你可以再次点击安装包，它将出现如下界面，然后点击 <strong>Uninstall</strong> 即可开始卸载</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021165014.png" alt="图五" style="width:50%;" ></div><p>出现如下界面表示卸载成功，然后你可以回到上一步安装 Python 中重新安装 Python ，在 Python 安装的第一页点击 <strong>Add python.exe to PATH</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021165201.png" alt="图六" style="width:50%;" ></div><p>当然，这个自动环境配置出现于 <strong>Python 3.3</strong> 版本，如果你想安装这个版本之前的 Python 你需要手动进行环境配置，如果你不想进行卸载重新安装这样的操作，而是想自己配置环境的话你也可以继续看下面的步骤<br>打开<strong>设置</strong>里的<strong>系统信息</strong>然后点击<strong>高级系统设置</strong>，再点击<strong>环境变量</strong>打开到对应环境配置界面</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021165435.png" alt="图七" style="width:50%;" ></div><p>另一种方式是，右击桌面上的<strong>此电脑</strong>或者<strong>文件管理器</strong>中的<strong>此电脑</strong>选择<strong>属性</strong>打开系统信息界面再选择<strong>高级系统设置</strong>打开<strong>环境变量</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021165546.png" alt="图八" style="width:50%;" ></div><p><strong>文件管理器</strong>如上图所示，是菜单栏长的这个像文件夹的软件<br>如果你还是找不到文件管理器，你可以再从刚刚下载的地方选择<strong>在文件夹中显示</strong>，打开文件管理器在左边能找到<strong>此电脑</strong></p><p>或者你还可以通过命令行打开文件管理器，只需要像前文中在键盘上<strong>同时按住 win+R键</strong>，然后输入 <strong>cmd</strong> 按下回车就可以打开命令行</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021133511.png" alt="图九" style="width:50%;" ></div><p>然后输入 <strong>explorer</strong> 这个指令，系统即会弹出文件管理器</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021170031.png" alt="图十" style="width:50%;" ></div><p>打开环境配置后，在下面的<strong>系统变量</strong>中双击 <strong>Path</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20251021170154.png" alt="图十一" style="width:50%;" ></div><p>然后点击<strong>新建</strong>，接着<strong>输入 Python 的路径</strong>，再点击<strong>确定</strong>。如果你刚刚选择的是默认安装，那么路径应该是类似于以下的路径：</p><p>C:\Users\DCY\AppData\Local\Programs\Python\Python312\</p><p>其中Users\后面跟的是你个人的用户名，Python 后跟的应该是你 Python 对应的版本，你可以先在文件管理器中尝试寻找到自己电脑上的 Python 路径。如果你是自定义安装，这里的路径就是自己自定义选择的路径</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021170358.png" alt="图十二" style="width:50%;" ></div><p>如果你是在安装的时候选择自动配置环境的话，你可以双击<strong>用户变量</strong>的 <strong>Path</strong> 中查看到 Python 安装时候自动帮你配置好的环境</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021170535.png" alt="图十三" style="width:50%;" ></div><p>如果你想知道用户变量和系统变量的不同你可以看本文后面的问题环节</p><p>你也可以使用命令行来配置环境</p><p>如前文在键盘上同时按住 <strong>win+R键</strong>，然后输入 <strong>cmd</strong> ，然后按下回车，打开命令行后输入<strong>path&#x3D;%path%;C:\Users\DCY\AppData\Local\Programs\Python\Python312</strong> 加粗部分是对应的路径名，可以看前面讲解怎么找到路径名</p><h2 id="检测安装是否成功"><a href="#检测安装是否成功" class="headerlink" title="检测安装是否成功"></a>检测安装是否成功</h2><p>这一步和默认安装的步骤是一样的。让我们打开命令行（以Windows系统为例）<br>如果你忘记了怎么的打开，你可以在键盘上按住 <strong>win＋R</strong> （Win键，通常标有Windows徽标（一个四格窗口图标）），然后输入 <strong>cmd</strong> 这个指令，接着回车，得到如下图所示结果：</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021133511.png" alt="图五" style="width:50%;" >  <img src="/img_2/QQ截图20251021133645.png" alt="图六" style="width:50%;" ></div><p>接着在命令行里输入 <strong>python</strong> ，结果如图类似即可，由于我安装的是Python 3.12.0版本所以出现的就是Python 3.12.0，如果你是其他版本就是对应版本</p><div style="text-align:center">  <img src="/img_2/QQ截图20251021133824.png" alt="图七" style="width:50%;" ></div>当然，你也可以输入 python --version （中间有空格，两个减号，别忘了），结果如图所示：<div style="text-align:center">  <img src="/img_2/QQ截图20251021134103.png" alt="图八" style="width:50%;" ></div>如果你的结果不像上面几张图所示，而是出现的是"...不是外部或内部命令，也不是可运行的程序"，你可能在环境配置中遇到了问题，你可以再次看一遍教程，重做前面的步骤。至此你已经完成了Python的安装与环境配置。]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 的基本简介</title>
      <link href="/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%E5%9F%BA%E6%9C%AC%E7%AE%80%E4%BB%8B/"/>
      <url>/2025/10/20/Python-%E5%9F%BA%E7%A1%80%E7%AF%87/Python%E5%9F%BA%E6%9C%AC%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="谁适合阅读这部分教程？"><a href="#谁适合阅读这部分教程？" class="headerlink" title="谁适合阅读这部分教程？"></a>谁适合阅读这部分教程？</h2><p>本教程适合刚开始学习编程或者刚开始学习 <strong>Python</strong> 编程语言的开发人员。当然，这部分教程也会对一些模块进行深入，让大家更好的了解 <strong>Python</strong> 在实际的应用。这部分教程主要是针对 <strong>Python</strong> 2.x的学习。</p><h2 id="一些关于Python的小知识"><a href="#一些关于Python的小知识" class="headerlink" title="一些关于Python的小知识"></a>一些关于Python的小知识</h2><p>Python 是一种解释型、面向对象、动态数据类型的高级程序设计语言。</p><p>Python 由 Guido van Rossum 于 1989 年底发明，第一个公开发行版发行于 1991 年。</p><p>像 Perl 语言一样, Python 源代码同样遵循 GPL(GNU General Public License) 协议。</p><p>官方宣布，2020 年 1 月 1 日， 停止 Python 2 的更新。</p><p>Python 2.7 被确定为最后一个 Python 2.x 版本。</p><p><strong>PS</strong> : 上面提到的一些词汇，解释型、面向对象、GPL。点击文字即可跳转了解</p><h2 id="Pyhton的特点"><a href="#Pyhton的特点" class="headerlink" title="Pyhton的特点"></a>Pyhton的特点</h2><p>Python 作为一种流行的编程语言，具有以下多方面的优势：</p><ol><li><p><strong>语法亲和，快速上手</strong>：Python 的关键字数量有限，语法结构简洁规范，非常适合编程初学者入门学习。</p></li><li><p><strong>代码清晰，可读性强</strong>：其语法设计强调可读性，使得代码结构清晰、易于理解，如同阅读英文段落一般自然。</p></li><li><p><strong>源码整洁，维护便捷</strong>：Python 代码通常具有良好的可维护性，这使得项目长期维护和团队协作变得更加高效。</p></li><li><p><strong>标准库丰富，跨平台支持</strong>：拥有功能全面、跨平台兼容的标准库，覆盖网络通信、文件处理、数据处理等多个领域，为开发者提供了强大支持。</p></li><li><p><strong>交互式编程，即时反馈</strong>：提供交互式解释器环境，支持代码片段的即时测试与调试，便于快速验证想法和排查问题。</p></li><li><p><strong>开源移植，多平台运行</strong>：作为开源语言，Python 已被成功移植到多种操作系统平台上，具备良好的可移植性。</p></li><li><p><strong>扩展灵活，性能可优化</strong>：开发者可通过 C&#x2F;C++ 编写关键性能模块，并在 Python 中调用，兼顾开发效率与执行性能。</p></li><li><p><strong>数据库接口完善</strong>：提供了对各种主流商业数据库的连接支持，方便进行数据存储与管理操作。</p></li><li><p><strong>图形界面开发支持</strong>：内置 GUI 开发库，同时支持集成第三方工具，能够创建跨平台的桌面应用程序。</p></li><li><p><strong>嵌入集成，脚本化扩展</strong>：可将 Python 解释器嵌入到 C&#x2F;C++ 应用程序中，为原有程序添加脚本化扩展能力。</p></li></ol><p>基本的就介绍到这里，感兴趣的可以自己去阅读一些书籍，这章内容主要是简单介绍一下 <strong>Python</strong> 语言，下一章内容将会介绍如何搭建Python的环境搭建。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> Python 教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言位域</title>
      <link href="/2025/02/06/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9F/"/>
      <url>/2025/02/06/C%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言位域（位段）-😊👇"><a href="#👇😊-C语言位域（位段）-😊👇" class="headerlink" title="👇😊 C语言位域（位段） 😊👇"></a>👇😊 <strong>C语言位域（位段）</strong> 😊👇</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h2 id="本节内容是C语言基础教程的最后一节内容，如果大家还想学习C语言的较为深入的知识，可以在评论区留言，我会根据反馈考虑是否加入😊"><a href="#本节内容是C语言基础教程的最后一节内容，如果大家还想学习C语言的较为深入的知识，可以在评论区留言，我会根据反馈考虑是否加入😊" class="headerlink" title="本节内容是C语言基础教程的最后一节内容，如果大家还想学习C语言的较为深入的知识，可以在评论区留言，我会根据反馈考虑是否加入😊"></a><strong>本节内容是C语言基础教程的最后一节内容，如果大家还想学习C语言的较为深入的知识，可以在评论区留言，我会根据反馈考虑是否加入😊</strong></h2><h2 id="🌈-1-位域是什么？"><a href="#🌈-1-位域是什么？" class="headerlink" title="🌈 1. 位域是什么？"></a><strong>🌈 1. 位域是什么？</strong></h2><p>想象你有一个<strong>收纳盒</strong>📦，里面有多个小格子，每个格子只放 <strong>1位</strong>（0或1）。位域（Bit-field）就是这样的“格子”，允许你在结构体中<strong>按位分配成员</strong>，极致节省内存！  </p><ul><li><strong>作用</strong>：处理开关量、状态标志等小数据（如：是否登录、权限标记）  </li><li><strong>特点</strong>：多个位域成员共享<strong>同一块内存单元</strong></li></ul><hr><h2 id="🌈-2-为什么需要位域？"><a href="#🌈-2-为什么需要位域？" class="headerlink" title="🌈 2. 为什么需要位域？"></a><strong>🌈 2. 为什么需要位域？</strong></h2><p><strong>普通结构体的问题</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> isLogin;    <span class="comment">// 4字节（32位），但只用1位（0/1）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> isAdmin;    <span class="comment">// 4字节 → 浪费31位！</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：8字节（64位系统）</span></span><br></pre></td></tr></table></figure><p><strong>位域解决方案</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Status</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> isLogin : <span class="number">1</span>; <span class="comment">// 只占1位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> isAdmin : <span class="number">1</span>; <span class="comment">// 再占1位</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：4字节（32位中只用了2位，剩余30位可用）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-位域的定义与使用"><a href="#🌈-3-位域的定义与使用" class="headerlink" title="🌈 3. 位域的定义与使用"></a><strong>🌈 3. 位域的定义与使用</strong></h2><h3 id="3-1-定义位域"><a href="#3-1-定义位域" class="headerlink" title="3.1 定义位域"></a><strong>3.1 定义位域</strong></h3><p>📝 <strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名 &#123;</span></span><br><span class="line">    类型 成员名 : 位宽;  </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>🌰 <strong>例子</strong>：存储3个开关状态  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> power : <span class="number">1</span>;  <span class="comment">// 1位（0关/1开）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode  : <span class="number">2</span>;  <span class="comment">// 2位（0~3共4种模式）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> error : <span class="number">1</span>;  <span class="comment">// 1位（0正常/1故障）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-使用位域"><a href="#3-2-使用位域" class="headerlink" title="3.2 使用位域"></a><strong>3.2 使用位域</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Switch</span> <span class="title">sw</span>;</span></span><br><span class="line">sw.power = <span class="number">1</span>;  <span class="comment">// 开</span></span><br><span class="line">sw.mode = <span class="number">3</span>;   <span class="comment">// 模式3（二进制11）</span></span><br><span class="line">sw.error = <span class="number">0</span>;  <span class="comment">// 正常</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;功率：%d，模式：%d\n&quot;</span>, sw.power, sw.mode);</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-位域的内存分配规则"><a href="#🌈-4-位域的内存分配规则" class="headerlink" title="🌈 4. 位域的内存分配规则"></a><strong>🌈 4. 位域的内存分配规则</strong></h2><h3 id="规则1：位域总大小不超过其类型大小"><a href="#规则1：位域总大小不超过其类型大小" class="headerlink" title="规则1：位域总大小不超过其类型大小"></a><strong>规则1</strong>：位域总大小不超过其类型大小</h3><ul><li><strong>类型</strong>：<code>unsigned int</code>（通常4字节&#x3D;32位）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">5</span>;  <span class="comment">// 5位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">3</span>;  <span class="comment">// 3位 → 共8位 &lt; 32位 → 同一内存单元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：4字节（int的大小）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="规则2：位域成员按定义顺序紧密排列"><a href="#规则2：位域成员按定义顺序紧密排列" class="headerlink" title="规则2：位域成员按定义顺序紧密排列"></a><strong>规则2</strong>：位域成员按定义顺序紧密排列</h3><ul><li><strong>若剩余空间不足</strong>，则分配到下一个内存单元  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Packed</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">20</span>; <span class="comment">// 占20位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">15</span>; <span class="comment">// 剩余12位不足 → 分配到下一int单元</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：8字节（两个int）</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="规则3：无名位域用于填充或对齐"><a href="#规则3：无名位域用于填充或对齐" class="headerlink" title="规则3：无名位域用于填充或对齐"></a><strong>规则3</strong>：无名位域用于填充或对齐</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Align</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">4</span>;  </span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>   : <span class="number">4</span>;  <span class="comment">// 无名位域，填充4位（不可用）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">8</span>;  <span class="comment">// 从下一字节开始</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：4字节（a占4位+填充4位，b单独8位）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-位域的注意事项"><a href="#🌈-5-位域的注意事项" class="headerlink" title="🌈 5. 位域的注意事项"></a><strong>🌈 5. 位域的注意事项</strong></h2><ol><li><p><strong>赋值不能超限</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Switch</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> mode : <span class="number">2</span>; <span class="comment">// 最大存储值3（二进制11）</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Switch</span> <span class="title">sw</span>;</span></span><br><span class="line">sw.mode = <span class="number">5</span>; <span class="comment">// ❌ 5=101（超出2位） → 实际存入1（01）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>不能取地址</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *p = &amp;sw.mode; ❌ <span class="comment">// 位域无地址！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>类型限制</strong>：</p></li></ol><ul><li>位域成员必须是整型（<code>int</code>、<code>unsigned int</code>等）  </li><li>不能是数组或浮点数</li></ul><ol start="4"><li><strong>编译器差异</strong>：</li></ol><ul><li>不同编译器对位域的内存分配可能不同（需谨慎跨平台）</li></ul><hr><h2 id="🌈-6-实例代码全解析"><a href="#🌈-6-实例代码全解析" class="headerlink" title="🌈 6. 实例代码全解析"></a><strong>🌈 6. 实例代码全解析</strong></h2><h3 id="实例1：基本使用"><a href="#实例1：基本使用" class="headerlink" title="实例1：基本使用"></a><strong>实例1：基本使用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Packed</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> type : <span class="number">4</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> value : <span class="number">9</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Packed</span> <span class="title">p</span>;</span></span><br><span class="line">    p.a = <span class="number">1</span>;</span><br><span class="line">    p.b = <span class="number">0</span>;</span><br><span class="line">    p.c = <span class="number">1</span>;</span><br><span class="line">    p.type = <span class="number">7</span>;    <span class="comment">// 4位最大15</span></span><br><span class="line">    p.value = <span class="number">255</span>; <span class="comment">// 9位最大511</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%u, b=%u, c=%u, type=%u, value=%u\n&quot;</span>, </span><br><span class="line">           p.a, p.b, p.c, p.type, p.value);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=1, b=0, c=1, type=7, value=255</span><br></pre></td></tr></table></figure><h3 id="实例2：超限赋值"><a href="#实例2：超限赋值" class="headerlink" title="实例2：超限赋值"></a><strong>实例2：超限赋值</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Age</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> age : <span class="number">3</span>; <span class="comment">// 3位 → 最大7</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Age</span> <span class="title">a</span>;</span></span><br><span class="line">    a.age = <span class="number">4</span>;  <span class="comment">// ✅ 4 &lt; 7</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, a.age); <span class="comment">// 输出4</span></span><br><span class="line"></span><br><span class="line">    a.age = <span class="number">8</span>;  <span class="comment">// ❌ 8=1000（超3位） → 实际存入0</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Age: %d\n&quot;</span>, a.age); <span class="comment">// 输出0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-综合练习"><a href="#🌈-7-综合练习" class="headerlink" title="🌈 7. 综合练习"></a><strong>🌈 7. 综合练习</strong></h2><h3 id="练习1：定义位域结构体"><a href="#练习1：定义位域结构体" class="headerlink" title="练习1：定义位域结构体"></a><strong>练习1：定义位域结构体</strong></h3><p>定义一个 <code>RGB</code> 结构体，用位域表示颜色（R:5位，G:6位，B:5位），并计算其内存大小。  </p><h3 id="练习2：赋值验证"><a href="#练习2：赋值验证" class="headerlink" title="练习2：赋值验证"></a><strong>练习2：赋值验证</strong></h3><p>若 <code>RGB</code> 结构体中 R 占5位，赋值 <code>R=32</code> 会发生什么？  </p><h3 id="练习3：错误修复"><a href="#练习3：错误修复" class="headerlink" title="练习3：错误修复"></a><strong>练习3：错误修复</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> a : <span class="number">3</span>;</span><br><span class="line">    <span class="type">float</span> b : <span class="number">2</span>; ❌</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RGB</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> R : <span class="number">5</span>; <span class="comment">// 0~31</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> G : <span class="number">6</span>; <span class="comment">// 0~63</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> B : <span class="number">5</span>; <span class="comment">// 0~31</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：5+6+5=16位 → 对齐到4字节（int大小）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sizeof RGB: %zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> RGB)); <span class="comment">// 输出4</span></span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RGB</span> <span class="title">color</span>;</span></span><br><span class="line">color.R = <span class="number">32</span>; <span class="comment">// 32=100000（超5位 → 实际存入0）</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, color.R); <span class="comment">// 输出0</span></span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>错误</strong>：位域成员不能是 <code>float</code> 类型<br><strong>修正</strong>：改为整型（如 <code>unsigned int</code>）  </p><hr><p>🚀 <strong>总结</strong>：  </p><ul><li>位域是<strong>内存节省大师</strong>，适合存储小范围整数  </li><li><strong>位宽限制</strong>：赋值不能超过指定位数  </li><li><strong>内存对齐</strong>：注意编译器分配规则  </li><li><strong>适用场景</strong>：嵌入式开发、协议解析、硬件寄存器操作</li></ul><p><strong>记住</strong>：位域虽好，但需谨慎处理超限和跨平台问题！ 💻🔧</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言共用体</title>
      <link href="/2025/02/06/C%E8%AF%AD%E8%A8%80%E5%85%B1%E7%94%A8%E4%BD%93/"/>
      <url>/2025/02/06/C%E8%AF%AD%E8%A8%80%E5%85%B1%E7%94%A8%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言共用体（Union）-😊👇"><a href="#👇😊-C语言共用体（Union）-😊👇" class="headerlink" title="👇😊 C语言共用体（Union） 😊👇"></a>👇😊 <strong>C语言共用体（Union）</strong> 😊👇</h1><hr><h2 id="🌈-1-共用体是什么？"><a href="#🌈-1-共用体是什么？" class="headerlink" title="🌈 1. 共用体是什么？"></a><strong>🌈 1. 共用体是什么？</strong></h2><p>现在你有一个<strong>多功能储物箱</strong>🎁，同一时间只能放一种物品（比如书、水杯或零食），但箱子会根据物品自动调整内部空间。共用体（Union）就是这样的“箱子”：  </p><ul><li><strong>特点</strong>：所有成员共享<strong>同一块内存</strong>，同一时间只能使用一个成员！  </li><li><strong>目的</strong>：节省内存，灵活处理不同类型数据（但不能同时存储）</li></ul><hr><h2 id="🌈-2-共用体-vs-结构体：关键区别"><a href="#🌈-2-共用体-vs-结构体：关键区别" class="headerlink" title="🌈 2. 共用体 vs 结构体：关键区别"></a><strong>🌈 2. 共用体 vs 结构体：关键区别</strong></h2><table><thead><tr><th></th><th><strong>共用体（Union）</strong></th><th><strong>结构体（Struct）</strong></th></tr></thead><tbody><tr><td><strong>内存分配</strong></td><td>所有成员共享同一块内存</td><td>每个成员有独立内存</td></tr><tr><td><strong>内存大小</strong></td><td>等于最大成员的大小</td><td>等于所有成员大小之和（考虑对齐）</td></tr><tr><td><strong>使用场景</strong></td><td>同一时间只存一种类型数据</td><td>同时存储多个类型数据</td></tr></tbody></table><hr><h2 id="🌈-3-共用体的定义与内存分配"><a href="#🌈-3-共用体的定义与内存分配" class="headerlink" title="🌈 3. 共用体的定义与内存分配"></a><strong>🌈 3. 共用体的定义与内存分配</strong></h2><h3 id="3-1-定义共用体"><a href="#3-1-定义共用体" class="headerlink" title="3.1 定义共用体"></a><strong>3.1 定义共用体</strong></h3><p>📝 <strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> 共用体标签 &#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;</span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; 变量名; <span class="comment">// 可选变量声明</span></span><br></pre></td></tr></table></figure><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;      <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">float</span> f;    <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">char</span> str[<span class="number">20</span>]; <span class="comment">// 20字节 → 共用体总大小=20字节</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span> <span class="comment">// 声明共用体变量</span></span><br></pre></td></tr></table></figure><h3 id="3-2-内存大小验证"><a href="#3-2-内存大小验证" class="headerlink" title="3.2 内存大小验证"></a><strong>3.2 内存大小验证</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;共用体大小：%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Data)); <span class="comment">// 输出20</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-共用体成员访问"><a href="#🌈-4-共用体成员访问" class="headerlink" title="🌈 4. 共用体成员访问"></a><strong>🌈 4. 共用体成员访问</strong></h2><h3 id="4-1-基本访问"><a href="#4-1-基本访问" class="headerlink" title="4.1 基本访问"></a><strong>4.1 基本访问</strong></h3><p>使用 <strong><code>.</code> 运算符</strong>访问成员（与结构体相同）：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">10</span>;       <span class="comment">// 存入整数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, data.i);</span><br><span class="line"></span><br><span class="line">data.f = <span class="number">3.14</span>;     <span class="comment">// 存入浮点数 → 覆盖之前的数据！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, data.f);</span><br><span class="line"></span><br><span class="line"><span class="built_in">strcpy</span>(data.str, <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 存入字符串 → 覆盖浮点数！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, data.str);</span><br></pre></td></tr></table></figure><h3 id="4-2-重要特性"><a href="#4-2-重要特性" class="headerlink" title="4.2 重要特性"></a><strong>4.2 重要特性</strong></h3><ul><li><strong>内存共享</strong>：修改一个成员会覆盖其他成员的值！  </li><li><strong>同一时间只能用一种成员</strong>，否则数据会混乱！</li></ul><p>🌰 <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">10</span>;</span><br><span class="line">data.f = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data.i); <span class="comment">// 输出的是被覆盖后的垃圾值！❌</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确用法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data.i = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data.i); <span class="comment">// 先使用i</span></span><br><span class="line"></span><br><span class="line">data.f = <span class="number">3.14</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, data.f); <span class="comment">// 再使用f（此时i已被覆盖）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-共用体的应用场景"><a href="#🌈-5-共用体的应用场景" class="headerlink" title="🌈 5. 共用体的应用场景"></a><strong>🌈 5. 共用体的应用场景</strong></h2><ol><li><strong>节省内存</strong>：处理多个类型数据但不同时使用的情况  <ul><li>如：嵌入式设备中，根据模式存储温度（float）或状态码（int）</li></ul></li><li><strong>解析不同数据格式</strong>  <ul><li>如：网络协议中，同一字段可能是IP地址（字符串）或错误码（整数）</li></ul></li><li><strong>类型转换黑科技</strong>  <ul><li>通过共用体直接将整数的内存解释为浮点数（谨慎使用！）</li></ul></li></ol><p>🌰 <strong>类型转换示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Converter</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Converter</span> <span class="title">c</span>;</span></span><br><span class="line">c.i = <span class="number">1092616192</span>; <span class="comment">// 0x41200000 的十进制</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f\n&quot;</span>, c.f); <span class="comment">// 输出10.0（解释为浮点数）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-共用体的初始化"><a href="#🌈-6-共用体的初始化" class="headerlink" title="🌈 6. 共用体的初始化"></a><strong>🌈 6. 共用体的初始化</strong></h2><p>共用体只能初始化<strong>第一个成员</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span> =</span> &#123;<span class="number">10</span>&#125;; <span class="comment">// 正确 → 初始化i为10</span></span><br><span class="line"><span class="comment">// union Data data = &#123;3.14&#125;; ❌ 错误！必须初始化第一个成员</span></span><br></pre></td></tr></table></figure><p>其他成员需后续赋值：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.f = <span class="number">3.14</span>; <span class="comment">// 正确，但会覆盖i的值</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-共用体与结构体嵌套"><a href="#🌈-7-共用体与结构体嵌套" class="headerlink" title="🌈 7. 共用体与结构体嵌套"></a><strong>🌈 7. 共用体与结构体嵌套</strong></h2><p>共用体可以作为结构体的成员，反之亦然。  </p><p>🌰 <strong>例子</strong>：根据数据类型存储不同信息  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SensorData</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 数据类型标识</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> intValue;</span><br><span class="line">        <span class="type">float</span> floatValue;</span><br><span class="line">        <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">    &#125; data; <span class="comment">// 共用体成员</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SensorData</span> <span class="title">sd</span>;</span></span><br><span class="line">sd.type = <span class="number">1</span>; <span class="comment">// 1表示存储浮点数</span></span><br><span class="line">sd.data.floatValue = <span class="number">36.5</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-8-常见错误与避坑指南"><a href="#🌈-8-常见错误与避坑指南" class="headerlink" title="🌈 8. 常见错误与避坑指南"></a><strong>🌈 8. 常见错误与避坑指南</strong></h2><ol><li><p><strong>同时使用多个成员</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line">data.i = <span class="number">10</span>;</span><br><span class="line">data.f = <span class="number">3.14</span>; <span class="comment">// i的值被覆盖！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data.i); <span class="comment">// 输出错误数据 ❌</span></span><br></pre></td></tr></table></figure></li><li><p><strong>未初始化直接使用</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> <span class="title">data</span>;</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, data.i); <span class="comment">// 随机值！可能引发问题 ❌</span></span><br></pre></td></tr></table></figure></li><li><p><strong>错误计算内存大小</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Data</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">double</span> d; <span class="comment">// 8字节 → 共用体总大小=8</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">union</span> Data)); <span class="comment">// 正确输出8 ✅</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌈-9-综合练习"><a href="#🌈-9-综合练习" class="headerlink" title="🌈 9. 综合练习"></a><strong>🌈 9. 综合练习</strong></h2><h3 id="练习1：类型转换器"><a href="#练习1：类型转换器" class="headerlink" title="练习1：类型转换器"></a><strong>练习1：类型转换器</strong></h3><p>用共用体实现一个整数和浮点数的互相转换器，验证内存共享特性。  </p><h3 id="练习2：协议解析"><a href="#练习2：协议解析" class="headerlink" title="练习2：协议解析"></a><strong>练习2：协议解析</strong></h3><p>定义一个共用体 <code>Packet</code>，包含整数ID、浮点数值和字符串消息，根据类型字段解析数据。  </p><h3 id="练习3：错误修复"><a href="#练习3：错误修复" class="headerlink" title="练习3：错误修复"></a><strong>练习3：错误修复</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">char</span> str[<span class="number">10</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Value</span> <span class="title">v</span> =</span> &#123;<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(v.str, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v.num); <span class="comment">// 输出什么？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">Converter</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">Converter</span> <span class="title">c</span>;</span></span><br><span class="line">    c.i = <span class="number">1092616192</span>; <span class="comment">// 对应浮点数10.0的二进制</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;浮点数值：%f\n&quot;</span>, c.f); <span class="comment">// 输出10.0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> type; <span class="comment">// 0:int, 1:float, 2:string</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="type">int</span> intValue;</span><br><span class="line">        <span class="type">float</span> floatValue;</span><br><span class="line">        <span class="type">char</span> stringValue[<span class="number">20</span>];</span><br><span class="line">    &#125; data;</span><br><span class="line">&#125; Packet;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printPacket</span><span class="params">(Packet p)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(p.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="built_in">printf</span>(<span class="string">&quot;Int: %d\n&quot;</span>, p.data.intValue); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;Float: %f\n&quot;</span>, p.data.floatValue); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;String: %s\n&quot;</span>, p.data.stringValue); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    Packet p1 = &#123;<span class="number">0</span>, .data.intValue = <span class="number">100</span>&#125;;</span><br><span class="line">    Packet p2 = &#123;<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">strcpy</span>(p2.data.stringValue, <span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    printPacket(p1);</span><br><span class="line">    printPacket(p2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>问题</strong>：存入字符串后，整数成员 <code>num</code> 的值被覆盖，输出的是字符串的内存解释值（垃圾值）。<br><strong>修正</strong>：确保同一时间只使用一个成员！  </p><hr><p>🚀 <strong>总结</strong>：  </p><ul><li>共用体是“内存共享大师”，节省内存但需谨慎使用！  </li><li><strong>同一时间只能激活一个成员</strong>，否则数据会“打架”！  </li><li>适合处理类型多变但不同时使用的数据场景</li></ul><p><strong>记住</strong>：多动手写代码，感受内存共享的神奇与陷阱！ 💻🔧</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言结构体</title>
      <link href="/2025/02/06/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/"/>
      <url>/2025/02/06/C%E8%AF%AD%E8%A8%80%E7%BB%93%E6%9E%84%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言结构体-😊👇"><a href="#👇😊-C语言结构体-😊👇" class="headerlink" title="👇😊 C语言结构体 😊👇"></a>👇😊 <strong>C语言结构体</strong> 😊👇</h1><hr><h2 id="🌈-1-结构体是什么？"><a href="#🌈-1-结构体是什么？" class="headerlink" title="🌈 1. 结构体是什么？"></a><strong>🌈 1. 结构体是什么？</strong></h2><p>现在你有一个<strong>收纳盒</strong>📦，里面可以放不同类型的物品（比如书、笔、橡皮）。结构体就是这样的“盒子”，用来组合<strong>不同类型的数据</strong>，形成一个新的复合数据类型！  </p><ul><li><strong>作用</strong>：把相关数据打包，方便管理（比如学生信息：姓名、年龄、成绩）</li></ul><hr><h2 id="🌈-2-结构体的定义与声明"><a href="#🌈-2-结构体的定义与声明" class="headerlink" title="🌈 2. 结构体的定义与声明"></a><strong>🌈 2. 结构体的定义与声明</strong></h2><h3 id="2-1-基本定义"><a href="#2-1-基本定义" class="headerlink" title="2.1 基本定义"></a><strong>2.1 基本定义</strong></h3><p>📝 <strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体标签 &#123;</span></span><br><span class="line">    数据类型 成员<span class="number">1</span>;</span><br><span class="line">    数据类型 成员<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125; 变量名; <span class="comment">// 可选的变量声明</span></span><br></pre></td></tr></table></figure><p>🌰 <strong>例子</strong>：定义一个学生结构体  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>]; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="type">int</span> age;       <span class="comment">// 年龄</span></span><br><span class="line">    <span class="type">float</span> score;   <span class="comment">// 成绩</span></span><br><span class="line">&#125; stu1; <span class="comment">// 直接声明一个结构体变量 stu1</span></span><br></pre></td></tr></table></figure><h3 id="2-2-用typedef简化"><a href="#2-2-用typedef简化" class="headerlink" title="2.2 用typedef简化"></a><strong>2.2 用typedef简化</strong></h3><p>避免每次声明都要写 <code>struct</code> 关键字：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student; <span class="comment">// 现在可以用 Student 代替 struct Student</span></span><br><span class="line"></span><br><span class="line">Student stu2; <span class="comment">// 声明变量更简洁</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-结构体初始化与成员访问"><a href="#🌈-3-结构体初始化与成员访问" class="headerlink" title="🌈 3. 结构体初始化与成员访问"></a><strong>🌈 3. 结构体初始化与成员访问</strong></h2><h3 id="3-1-初始化结构体"><a href="#3-1-初始化结构体" class="headerlink" title="3.1 初始化结构体"></a><strong>3.1 初始化结构体</strong></h3><ul><li><p><strong>方式1：定义时初始化</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu3</span> =</span> &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">18</span>, <span class="number">95.5</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>方式2：逐个赋值</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span> <span class="title">stu4</span>;</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu4.name, <span class="string">&quot;Bob&quot;</span>); <span class="comment">// 字符串必须用strcpy</span></span><br><span class="line">stu4.age = <span class="number">20</span>;</span><br><span class="line">stu4.score = <span class="number">88.5</span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-访问成员"><a href="#3-2-访问成员" class="headerlink" title="3.2 访问成员"></a><strong>3.2 访问成员</strong></h3><p>使用 <strong><code>.</code> 运算符</strong>访问成员：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>, stu3.name, stu3.age);</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-结构体指针"><a href="#🌈-4-结构体指针" class="headerlink" title="🌈 4. 结构体指针"></a><strong>🌈 4. 结构体指针</strong></h2><h3 id="4-1-指向结构体的指针"><a href="#4-1-指向结构体的指针" class="headerlink" title="4.1 指向结构体的指针"></a><strong>4.1 指向结构体的指针</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student *pStu = &amp;stu3; <span class="comment">// 定义指针并指向stu3</span></span><br></pre></td></tr></table></figure><h3 id="4-2-用指针访问成员"><a href="#4-2-用指针访问成员" class="headerlink" title="4.2 用指针访问成员"></a><strong>4.2 用指针访问成员</strong></h3><p>使用 <strong><code>-&gt;</code> 运算符</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;成绩：%.1f\n&quot;</span>, pStu-&gt;score); <span class="comment">// 等价于 (*pStu).score</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-结构体作为函数参数"><a href="#🌈-5-结构体作为函数参数" class="headerlink" title="🌈 5. 结构体作为函数参数"></a><strong>🌈 5. 结构体作为函数参数</strong></h2><h3 id="5-1-传值（拷贝整个结构体）"><a href="#5-1-传值（拷贝整个结构体）" class="headerlink" title="5.1 传值（拷贝整个结构体）"></a><strong>5.1 传值（拷贝整个结构体）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printStudent</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d\n&quot;</span>, stu.name, stu.age);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">printStudent(stu3);</span><br></pre></td></tr></table></figure><h3 id="5-2-传指针（高效，可修改原数据）"><a href="#5-2-传指针（高效，可修改原数据）" class="headerlink" title="5.2 传指针（高效，可修改原数据）"></a><strong>5.2 传指针（高效，可修改原数据）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">updateScore</span><span class="params">(Student *stu, <span class="type">float</span> newScore)</span> &#123;</span><br><span class="line">    stu-&gt;score = newScore; <span class="comment">// 修改原结构体的成绩</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line">updateScore(&amp;stu3, <span class="number">99.0</span>);</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-结构体的大小与内存对齐"><a href="#🌈-6-结构体的大小与内存对齐" class="headerlink" title="🌈 6. 结构体的大小与内存对齐"></a><strong>🌈 6. 结构体的大小与内存对齐</strong></h2><h3 id="6-1-计算结构体大小"><a href="#6-1-计算结构体大小" class="headerlink" title="6.1 计算结构体大小"></a><strong>6.1 计算结构体大小</strong></h3><p>用 <code>sizeof</code> 运算符：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Student结构体大小：%zu字节\n&quot;</span>, <span class="keyword">sizeof</span>(Student));</span><br></pre></td></tr></table></figure><h3 id="6-2-内存对齐规则"><a href="#6-2-内存对齐规则" class="headerlink" title="6.2 内存对齐规则"></a><strong>6.2 内存对齐规则</strong></h3><ul><li><strong>规则</strong>：成员变量按自身大小对齐（如int按4字节对齐）  </li><li><strong>填充字节</strong>：编译器可能插入空字节优化访问速度</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Example</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;    <span class="comment">// 1字节 → 填充3字节</span></span><br><span class="line">    <span class="type">int</span> b;     <span class="comment">// 4字节</span></span><br><span class="line">    <span class="type">double</span> c;  <span class="comment">// 8字节</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 总大小：1 + 3(填充) + 4 + 8 = 16字节</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-嵌套结构体与自引用"><a href="#🌈-7-嵌套结构体与自引用" class="headerlink" title="🌈 7. 嵌套结构体与自引用"></a><strong>🌈 7. 嵌套结构体与自引用</strong></h2><h3 id="7-1-嵌套结构体"><a href="#7-1-嵌套结构体" class="headerlink" title="7.1 嵌套结构体"></a><strong>7.1 嵌套结构体</strong></h3><p>结构体成员可以是其他结构体：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Date</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> year;</span><br><span class="line">    <span class="type">int</span> month;</span><br><span class="line">    <span class="type">int</span> day;</span><br><span class="line">&#125; Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Person</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    Date birthday; <span class="comment">// 嵌套Date结构体</span></span><br><span class="line">&#125; Person;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;Tom&quot;</span>, &#123;<span class="number">2000</span>, <span class="number">5</span>, <span class="number">20</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;出生年份：%d\n&quot;</span>, p.birthday.year);</span><br></pre></td></tr></table></figure><h3 id="7-2-自引用结构体（链表节点）"><a href="#7-2-自引用结构体（链表节点）" class="headerlink" title="7.2 自引用结构体（链表节点）"></a><strong>7.2 自引用结构体（链表节点）</strong></h3><p>结构体成员可以包含指向自己的指针：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span> <span class="comment">// 指向下一个节点的指针</span></span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-8-常见错误与避坑指南"><a href="#🌈-8-常见错误与避坑指南" class="headerlink" title="🌈 8. 常见错误与避坑指南"></a><strong>🌈 8. 常见错误与避坑指南</strong></h2><ol><li><p><strong>字符串赋值错误</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Student stu;</span><br><span class="line">stu.name = <span class="string">&quot;Alice&quot;</span>; ❌ <span class="comment">// 数组不能直接赋值</span></span><br><span class="line"><span class="built_in">strcpy</span>(stu.name, <span class="string">&quot;Alice&quot;</span>); ✅ <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure></li><li><p><strong>结构体类型不匹配</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span> <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span> <span class="type">int</span> x; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> <span class="title">a</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> <span class="title">b</span> =</span> a; ❌ <span class="comment">// 虽然成员相同，但类型不同！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>忽略内存对齐</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设结构体实际大小为12字节，但按4字节对齐后是16字节</span></span><br><span class="line"><span class="comment">// 若按12字节操作内存（如网络传输），可能导致数据错位！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌈-9-综合练习"><a href="#🌈-9-综合练习" class="headerlink" title="🌈 9. 综合练习"></a><strong>🌈 9. 综合练习</strong></h2><h3 id="练习1：定义坐标结构体"><a href="#练习1：定义坐标结构体" class="headerlink" title="练习1：定义坐标结构体"></a><strong>练习1：定义坐标结构体</strong></h3><p>定义一个 <code>Point</code> 结构体，包含x和y坐标，并写函数计算两点距离。  </p><h3 id="练习2：学生管理系统"><a href="#练习2：学生管理系统" class="headerlink" title="练习2：学生管理系统"></a><strong>练习2：学生管理系统</strong></h3><p>定义一个 <code>Student</code> 结构体（姓名、年龄、成绩），实现函数：  </p><ul><li><code>void inputStudent(Student *stu)</code> 输入学生信息  </li><li><code>void printStudent(Student stu)</code> 输出学生信息</li></ul><h3 id="练习3：结构体大小计算"><a href="#练习3：结构体大小计算" class="headerlink" title="练习3：结构体大小计算"></a><strong>练习3：结构体大小计算</strong></h3><p>预测以下结构体的大小，并用 <code>sizeof</code> 验证：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line">    <span class="type">int</span> b;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Point</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> x;</span><br><span class="line">    <span class="type">float</span> y;</span><br><span class="line">&#125; Point;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="title function_">distance</span><span class="params">(Point p1, Point p2)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(p1.x - p2.x, <span class="number">2</span>) + <span class="built_in">pow</span>(p1.y - p2.y, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Student</span> &#123;</span></span><br><span class="line">    <span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">    <span class="type">float</span> score;</span><br><span class="line">&#125; Student;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">inputStudent</span><span class="params">(Student *stu)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入姓名、年龄、成绩：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s %d %f&quot;</span>, stu-&gt;name, &amp;stu-&gt;age, &amp;stu-&gt;score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printStudent</span><span class="params">(Student stu)</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;姓名：%s，年龄：%d，成绩：%.1f\n&quot;</span>, stu.name, stu.age, stu.score);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>预测</strong>：  </p><ul><li><code>char a</code> 占1字节 → 填充3字节（对齐到4）  </li><li><code>int b</code> 占4字节  </li><li><code>char c</code> 占1字节 → 填充3字节<br>总大小：1 + 3 + 4 + 1 + 3 &#x3D; <strong>12字节</strong></li></ul><p><strong>验证</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Sizeof Test: %zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Test)); <span class="comment">// 输出12</span></span><br></pre></td></tr></table></figure><hr><p>🚀 <strong>总结</strong>：  </p><ul><li>结构体是“数据收纳盒”，管理不同类型的数据  </li><li>用<code>.</code>访问成员，<code>-&gt;</code>访问指针成员  </li><li>内存对齐可能影响结构体大小，需注意  </li><li>多练习结构体的嵌套和指针操作，轻松应对复杂数据！</li></ul><p><strong>记住</strong>：结构体让代码更整洁，数据更直观！ 💻📦</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言字符串</title>
      <link href="/2025/02/04/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2025/02/04/C%E8%AF%AD%E8%A8%80%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言字符串-😊👇"><a href="#👇😊-C语言字符串-😊👇" class="headerlink" title="👇😊 C语言字符串 😊👇"></a>👇😊 <strong>C语言字符串</strong> 😊👇</h1><hr><h2 id="🌈-1-字符串是什么？"><a href="#🌈-1-字符串是什么？" class="headerlink" title="🌈 1. 字符串是什么？"></a><strong>🌈 1. 字符串是什么？</strong></h2><p>想象你有一串<strong>珍珠项链</strong>📿，每颗珍珠代表一个字符，最后一颗是特殊的<strong>透明珠子</strong>（<code>\0</code>）表示项链结束。  </p><ul><li><strong>本质</strong>：以 <code>\0</code> 结尾的字符数组  </li><li><strong>特点</strong>：必须手动管理内存，没有自动扩容！</li></ul><hr><h2 id="🌈-2-字符串的创建与初始化"><a href="#🌈-2-字符串的创建与初始化" class="headerlink" title="🌈 2. 字符串的创建与初始化"></a><strong>🌈 2. 字符串的创建与初始化</strong></h2><h3 id="2-1-两种初始化方式"><a href="#2-1-两种初始化方式" class="headerlink" title="2.1 两种初始化方式"></a><strong>2.1 两种初始化方式</strong></h3><ul><li><strong>方式1：逐个字符初始化</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">7</span>] = &#123;<span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;!&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;; <span class="comment">// 必须手动加\0</span></span><br></pre></td></tr></table></figure></li><li><strong>方式2：字符串字面量</strong>（推荐 ✅）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;Hello!&quot;</span>; <span class="comment">// 自动添加\0，数组长度=字符数+1 → 7</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>易错点</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str3[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>; ❌ <span class="comment">// 长度不够（需要6字节：5字符+\0）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-字符串的输入与输出"><a href="#🌈-3-字符串的输入与输出" class="headerlink" title="🌈 3. 字符串的输入与输出"></a><strong>🌈 3. 字符串的输入与输出</strong></h2><h3 id="3-1-输入字符串"><a href="#3-1-输入字符串" class="headerlink" title="3.1 输入字符串"></a><strong>3.1 输入字符串</strong></h3><ul><li><p><strong>使用 <code>scanf</code>（有空格会截断）</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> name[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入名字：&quot;</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, name); <span class="comment">// 输入 &quot;Anna Smith&quot; → 只能读取&quot;Anna&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用 <code>fgets</code>（可包含空格）</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入全名：&quot;</span>);</span><br><span class="line">fgets(name, <span class="keyword">sizeof</span>(name), <span class="built_in">stdin</span>); <span class="comment">// 输入 &quot;Anna Smith&quot; → 完整读取</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="3-2-输出字符串"><a href="#3-2-输出字符串" class="headerlink" title="3.2 输出字符串"></a><strong>3.2 输出字符串</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;名字是：%s\n&quot;</span>, name); <span class="comment">// 输出整个字符串直到遇到\0</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-常用字符串函数详解"><a href="#🌈-4-常用字符串函数详解" class="headerlink" title="🌈 4. 常用字符串函数详解"></a><strong>🌈 4. 常用字符串函数详解</strong></h2><h3 id="4-1-字符串长度：strlen"><a href="#4-1-字符串长度：strlen" class="headerlink" title="4.1 字符串长度：strlen"></a><strong>4.1 字符串长度：<code>strlen</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// len = 5（不算\0）</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>陷阱</strong>：若字符串未以 <code>\0</code> 结尾，<code>strlen</code> 会一直找直到内存中的 <code>\0</code> → 导致错误！</p><hr><h3 id="4-2-字符串复制：strcpy"><a href="#4-2-字符串复制：strcpy" class="headerlink" title="4.2 字符串复制：strcpy"></a><strong>4.2 字符串复制：<code>strcpy</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> src[] = <span class="string">&quot;Copy me!&quot;</span>;</span><br><span class="line"><span class="type">char</span> dest[<span class="number">20</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(dest, src); <span class="comment">// dest = &quot;Copy me!&quot;</span></span><br></pre></td></tr></table></figure><p>💥 <strong>危险操作</strong>：目标数组空间不足 → 缓冲区溢出！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> dest[<span class="number">5</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(dest, <span class="string">&quot;Hello World&quot;</span>); ❌ <span class="comment">// dest只有5字节，装不下！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>安全替代</strong>：<code>strncpy</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncpy</span>(dest, src, <span class="keyword">sizeof</span>(dest)<span class="number">-1</span>); <span class="comment">// 限制最大复制长度</span></span><br><span class="line">dest[<span class="keyword">sizeof</span>(dest)<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 手动加\0</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-3-字符串连接：strcat"><a href="#4-3-字符串连接：strcat" class="headerlink" title="4.3 字符串连接：strcat"></a><strong>4.3 字符串连接：<code>strcat</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot; World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2); <span class="comment">// str1 = &quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure><p>💥 <strong>危险操作</strong>：目标数组空间不足 → 溢出！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, <span class="string">&quot; World!&quot;</span>); ❌ <span class="comment">// 总长度超过10！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>安全替代</strong>：<code>strncat</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strncat</span>(str1, str2, <span class="keyword">sizeof</span>(str1)-<span class="built_in">strlen</span>(str1)<span class="number">-1</span>); <span class="comment">// 计算剩余空间</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-4-字符串比较：strcmp"><a href="#4-4-字符串比较：strcmp" class="headerlink" title="4.4 字符串比较：strcmp"></a><strong>4.4 字符串比较：<code>strcmp</code></strong></h3><ul><li><strong>比较规则</strong>：按ASCII码逐个字符比较  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;apple&quot;</span>);   <span class="comment">// 0 → 相等</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(<span class="string">&quot;apple&quot;</span>, <span class="string">&quot;banana&quot;</span>);  <span class="comment">// 负数 → &quot;apple&quot; &lt; &quot;banana&quot;</span></span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(<span class="string">&quot;zoo&quot;</span>, <span class="string">&quot;apple&quot;</span>);     <span class="comment">// 正数 → &quot;zoo&quot; &gt; &quot;apple&quot;</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>易错点</strong>：不能用 <code>==</code> 比较字符串！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(str1 == str2) &#123; ... &#125; ❌ <span class="comment">// 比较的是地址，不是内容！</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(str1, str2) == <span class="number">0</span>) &#123; ... &#125; ✅ <span class="comment">// 正确方式</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-5-查找字符：strchr"><a href="#4-5-查找字符：strchr" class="headerlink" title="4.5 查找字符：strchr"></a><strong>4.5 查找字符：<code>strchr</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pos = <span class="built_in">strchr</span>(<span class="string">&quot;Hello&quot;</span>, <span class="string">&#x27;l&#x27;</span>); <span class="comment">// 找到第一个&#x27;l&#x27;的位置</span></span><br><span class="line"><span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找到字符，位置：%ld\n&quot;</span>, pos - <span class="string">&quot;Hello&quot;</span>); <span class="comment">// 输出2（索引从0开始）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="4-6-查找子串：strstr"><a href="#4-6-查找子串：strstr" class="headerlink" title="4.6 查找子串：strstr"></a><strong>4.6 查找子串：<code>strstr</code></strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *pos = <span class="built_in">strstr</span>(<span class="string">&quot;Hello World&quot;</span>, <span class="string">&quot;World&quot;</span>); </span><br><span class="line"><span class="keyword">if</span>(pos != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;找到子串，位置：%ld\n&quot;</span>, pos - <span class="string">&quot;Hello World&quot;</span>); <span class="comment">// 输出6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-代码实例全解析"><a href="#🌈-5-代码实例全解析" class="headerlink" title="🌈 5. 代码实例全解析"></a><strong>🌈 5. 代码实例全解析</strong></h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a><strong>示例代码</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">14</span>] = <span class="string">&quot;runoob&quot;</span>; <span class="comment">// 实际长度7（6字符+\0）</span></span><br><span class="line">    <span class="type">char</span> str2[<span class="number">14</span>] = <span class="string">&quot;google&quot;</span>; <span class="comment">// 实际长度7</span></span><br><span class="line">    <span class="type">char</span> str3[<span class="number">14</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制：str3 = str1</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1); <span class="comment">// 正确，str3足够大</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;复制结果：%s\n&quot;</span>, str3); <span class="comment">// 输出runoob</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接：str1 = str1 + str2</span></span><br><span class="line">    <span class="built_in">strcat</span>(str1, str2); <span class="comment">// 总长度6+6=12 +1(\0) =13 &lt;14 → 安全</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;连接结果：%s\n&quot;</span>, str1); <span class="comment">// 输出runoobgoogle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1); <span class="comment">// 12（不含\0）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;长度：%d\n&quot;</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="逐行解释"><a href="#逐行解释" class="headerlink" title="逐行解释"></a><strong>逐行解释</strong></h2><ol><li><p><strong>声明数组</strong>  </p><ul><li><code>str1[14]</code> 初始化为 <code>&quot;runoob&quot;</code> → 实际占用7字节（6字符 + <code>\0</code>）  </li><li><code>str2[14]</code> 同理  </li><li><code>str3[14]</code> 未初始化，用于存储复制结果</li></ul></li><li><p><strong>复制操作 <code>strcpy</code></strong>  </p><ul><li>将 <code>str1</code> 的内容复制到 <code>str3</code>，<code>str3</code> 变为 <code>&quot;runoob\0&quot;</code></li></ul></li><li><p><strong>连接操作 <code>strcat</code></strong>  </p><ul><li>将 <code>str2</code> 的内容追加到 <code>str1</code> 末尾  </li><li>原 <code>str1</code> 内容为 <code>&quot;runoob\0&quot;</code> → 追加后变为 <code>&quot;runoobgoogle\0&quot;</code>（总长度12字符 + <code>\0</code>）</li></ul></li><li><p><strong>计算长度 <code>strlen</code></strong>  </p><ul><li>返回 <code>str1</code> 中 <code>\0</code> 前的字符数 → 12</li></ul></li></ol><hr><h2 id="🌈-6-常见错误大集合"><a href="#🌈-6-常见错误大集合" class="headerlink" title="🌈 6. 常见错误大集合"></a><strong>🌈 6. 常见错误大集合</strong></h2><ol><li><p><strong>数组越界</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[<span class="number">5</span>] = <span class="string">&quot;Hello&quot;</span>; ❌ <span class="comment">// 需要6字节（5字符+\0）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>忘记 <code>\0</code></strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;; <span class="comment">// 没有\0 → 不是合法字符串！</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, s); <span class="comment">// 可能输出乱码或崩溃！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用未初始化的指针</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s;</span><br><span class="line"><span class="built_in">strcpy</span>(s, <span class="string">&quot;Hello&quot;</span>); ❌ <span class="comment">// s未指向有效内存！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌈-7-综合练习"><a href="#🌈-7-综合练习" class="headerlink" title="🌈 7. 综合练习"></a><strong>🌈 7. 综合练习</strong></h2><h3 id="练习1：字符串反转"><a href="#练习1：字符串反转" class="headerlink" title="练习1：字符串反转"></a><strong>练习1：字符串反转</strong></h3><p>写一个函数 <code>void reverseString(char str[])</code>，将输入的字符串原地反转。<br><strong>示例</strong>：输入 <code>&quot;Hello&quot;</code> → 输出 <code>&quot;olleH&quot;</code>  </p><h3 id="练习2：统计单词数"><a href="#练习2：统计单词数" class="headerlink" title="练习2：统计单词数"></a><strong>练习2：统计单词数</strong></h3><p>写一个函数 <code>int countWords(char str[])</code>，统计字符串中的单词数（假设单词间用空格分隔）。<br><strong>示例</strong>：输入 <code>&quot;Hello World C&quot;</code> → 输出3  </p><h3 id="练习3：错误修复"><a href="#练习3：错误修复" class="headerlink" title="练习3：错误修复"></a><strong>练习3：错误修复</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> s1[<span class="number">10</span>] = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"><span class="type">char</span> s2[] = <span class="string">&quot;World!&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(s1, s2); <span class="comment">// 试图连接成&quot;HelloWorld!&quot;</span></span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverseString</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">char</span> temp = str[i];</span><br><span class="line">        str[i] = str[len<span class="number">-1</span>-i];</span><br><span class="line">        str[len<span class="number">-1</span>-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">countWords</span><span class="params">(<span class="type">char</span> str[])</span> &#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> inWord = <span class="number">0</span>; <span class="comment">// 0表示不在单词中，1表示在单词中</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; str[i] != <span class="string">&#x27;\0&#x27;</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            inWord = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(inWord == <span class="number">0</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            inWord = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>错误</strong>：<code>s1</code> 初始长度10，<code>&quot;Hello&quot;</code>占6字节（含\0），连接 <code>&quot;World!&quot;</code>（7字节）总长度6+6&#x3D;12+1&#x3D;13 → 超出s1容量！<br><strong>修正</strong>：增大 <code>s1</code> 的容量，如 <code>char s1[20];</code>  </p><hr><p>🚀 <strong>总结</strong>：  </p><ul><li>字符串是 <code>\0</code> 结尾的字符数组  </li><li>操作字符串要时刻注意内存安全  </li><li>掌握 <code>strcpy</code>、<code>strcat</code>、<code>strcmp</code> 等函数，避免常见错误</li></ul><p><strong>记住</strong>：多练习调试，字符串操作会越来越熟练！ 💻🔍</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针与回调函数</title>
      <link href="/2025/02/04/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2025/02/04/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88%E4%B8%8E%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言函数指针-😊👇"><a href="#👇😊-C语言函数指针-😊👇" class="headerlink" title="👇😊 C语言函数指针 😊👇"></a>👇😊 <strong>C语言函数指针</strong> 😊👇</h1><hr><h2 id="🌈-1-函数指针是什么？"><a href="#🌈-1-函数指针是什么？" class="headerlink" title="🌈 1. 函数指针是什么？"></a><strong>🌈 1. 函数指针是什么？</strong></h2><p>想象你有一个<strong>遥控器</strong>📱，可以控制不同的电器（比如电视、空调）。每个按钮对应一个功能。  </p><ul><li><strong>函数指针</strong>就像这个遥控器，它“指向”一个函数，按下按钮（调用指针）就能执行对应的函数！  </li><li><strong>本质</strong>：存储函数的内存地址，通过地址调用函数。</li></ul><hr><h2 id="🌈-2-函数指针的声明与赋值"><a href="#🌈-2-函数指针的声明与赋值" class="headerlink" title="🌈 2. 函数指针的声明与赋值"></a><strong>🌈 2. 函数指针的声明与赋值</strong></h2><h3 id="2-1-声明函数指针"><a href="#2-1-声明函数指针" class="headerlink" title="2.1 声明函数指针"></a><strong>2.1 声明函数指针</strong></h3><p>📝 <strong>语法</strong>：<code>返回类型 (*指针名)(参数类型1, 参数类型2...);</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个指向“接受两个int参数，返回int”的函数的指针</span></span><br><span class="line"><span class="type">int</span> (*pFunc)(<span class="type">int</span>, <span class="type">int</span>); </span><br></pre></td></tr></table></figure><p>🔍 <strong>对比普通函数声明</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 普通函数</span></span><br><span class="line"><span class="type">int</span> (*pFunc)(<span class="type">int</span>, <span class="type">int</span>); <span class="comment">// 函数指针</span></span><br></pre></td></tr></table></figure><h3 id="2-2-给函数指针赋值"><a href="#2-2-给函数指针赋值" class="headerlink" title="2.2 给函数指针赋值"></a><strong>2.2 给函数指针赋值</strong></h3><p>将函数名（即函数地址）赋给指针（<code>&amp;</code>可省略）：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pFunc = max;   <span class="comment">// 正确 ✅</span></span><br><span class="line">pFunc = &amp;max;  <span class="comment">// 也正确 ✅</span></span><br></pre></td></tr></table></figure><p>❌ <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pFunc = max(); <span class="comment">// ❌ max()是调用函数，返回int，无法赋值给指针！</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-通过函数指针调用函数"><a href="#🌈-3-通过函数指针调用函数" class="headerlink" title="🌈 3. 通过函数指针调用函数"></a><strong>🌈 3. 通过函数指针调用函数</strong></h2><h3 id="3-1-直接调用"><a href="#3-1-直接调用" class="headerlink" title="3.1 直接调用"></a><strong>3.1 直接调用</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = pFunc(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 等价于 max(3,5)</span></span><br></pre></td></tr></table></figure><h3 id="3-2-解引用调用（清晰写法）"><a href="#3-2-解引用调用（清晰写法）" class="headerlink" title="3.2 解引用调用（清晰写法）"></a><strong>3.2 解引用调用（清晰写法）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = (*pFunc)(<span class="number">3</span>, <span class="number">5</span>); <span class="comment">// 与上面等价</span></span><br></pre></td></tr></table></figure><p>🌰 <strong>完整示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (a &gt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = max; <span class="comment">// 定义函数指针并赋值</span></span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>, y = <span class="number">20</span>;</span><br><span class="line">    <span class="type">int</span> z = p(x, y); <span class="comment">// 调用</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;最大值：%d\n&quot;</span>, z); <span class="comment">// 输出20</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-函数指针的用途：回调函数（超重要！）"><a href="#🌈-4-函数指针的用途：回调函数（超重要！）" class="headerlink" title="🌈 4. 函数指针的用途：回调函数（超重要！）"></a><strong>🌈 4. 函数指针的用途：回调函数（超重要！）</strong></h2><h3 id="4-1-什么是回调函数？"><a href="#4-1-什么是回调函数？" class="headerlink" title="4.1 什么是回调函数？"></a><strong>4.1 什么是回调函数？</strong></h3><ul><li><strong>你定义函数</strong> → <strong>别人调用你的函数</strong>  </li><li><strong>场景</strong>：将函数作为参数传递给另一个函数，在特定事件发生时被调用。</li></ul><p>🌰 <strong>生活比喻</strong>：  </p><ul><li>你去餐厅吃饭，排队等位时留下手机号（<strong>注册回调函数</strong>）。  </li><li>有空位时，餐厅打电话通知你（<strong>触发回调</strong>）。  </li><li>你去就餐（<strong>执行回调函数</strong>）。</li></ul><h3 id="4-2-代码示例：生成随机数组"><a href="#4-2-代码示例：生成随机数组" class="headerlink" title="4.2 代码示例：生成随机数组"></a><strong>4.2 代码示例：生成随机数组</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数类型：无参数，返回int</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*GetValueFunc)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高阶函数：用回调函数填充数组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fillArray</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> size, GetValueFunc getValue)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        arr[i] = getValue(); <span class="comment">// 调用回调函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数1：返回随机数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> rand();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 回调函数2：返回固定序列值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">getSequence</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr1[<span class="number">10</span>], arr2[<span class="number">10</span>];</span><br><span class="line">    </span><br><span class="line">    fillArray(arr1, <span class="number">10</span>, getRandom);   <span class="comment">// 用随机数填充</span></span><br><span class="line">    fillArray(arr2, <span class="number">10</span>, getSequence); <span class="comment">// 用序列值填充</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印arr1</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;随机数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr1[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印arr2</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n序列数组：&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr2[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">随机数组：1804289383 846930886 1681692777 ... </span><br><span class="line">序列数组：0 1 2 3 4 5 6 7 8 9 </span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-函数指针的高级用法"><a href="#🌈-5-函数指针的高级用法" class="headerlink" title="🌈 5. 函数指针的高级用法"></a><strong>🌈 5. 函数指针的高级用法</strong></h2><h3 id="5-1-函数指针数组"><a href="#5-1-函数指针数组" class="headerlink" title="5.1 函数指针数组"></a><strong>5.1 函数指针数组</strong></h3><p>可以创建函数指针数组，实现“多态”效果。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义两个函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sayBye</span><span class="params">()</span> &#123; <span class="built_in">printf</span>(<span class="string">&quot;Bye!\n&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 函数指针数组</span></span><br><span class="line">    <span class="type">void</span> (*funcs[<span class="number">2</span>])() = &#123;sayHello, sayBye&#125;;</span><br><span class="line">    </span><br><span class="line">    funcs[<span class="number">0</span>](); <span class="comment">// 输出Hello!</span></span><br><span class="line">    funcs[<span class="number">1</span>](); <span class="comment">// 输出Bye!</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-使用typedef简化"><a href="#5-2-使用typedef简化" class="headerlink" title="5.2 使用typedef简化"></a><strong>5.2 使用typedef简化</strong></h3><p>为复杂的函数指针类型定义别名，提高可读性。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义类型别名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">int</span> <span class="params">(*CompareFunc)</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用别名声明函数指针</span></span><br><span class="line">CompareFunc pCompare = max;</span><br></pre></td></tr></table></figure><hr><h2 id="❌-6-常见错误与注意事项"><a href="#❌-6-常见错误与注意事项" class="headerlink" title="❌ 6. 常见错误与注意事项"></a><strong>❌ 6. 常见错误与注意事项</strong></h2><ol><li><p><strong>函数签名不匹配</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">void</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = max; <span class="comment">// ❌ 返回类型不匹配！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>错误传递回调函数</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fillArray(arr, <span class="number">10</span>, getRandom()); <span class="comment">// ❌ 加了括号，传递的是int而非函数指针！</span></span><br></pre></td></tr></table></figure></li><li><p><strong>未初始化函数指针</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>); </span><br><span class="line">p(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// ❌ p未赋值，指向随机地址 → 程序崩溃！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌈-7-综合练习"><a href="#🌈-7-综合练习" class="headerlink" title="🌈 7. 综合练习"></a><strong>🌈 7. 综合练习</strong></h2><h3 id="练习1：排序策略选择"><a href="#练习1：排序策略选择" class="headerlink" title="练习1：排序策略选择"></a><strong>练习1：排序策略选择</strong></h3><p>写一个排序函数 <code>void sort(int arr[], int size, CompareFunc compare)</code>，根据传入的比较函数决定升序或降序排序。  </p><ul><li>定义两个比较函数：<code>int ascending(int a, int b)</code>（a&gt;b返回1）和 <code>int descending(int a, int b)</code>（a&lt;b返回1）。  </li><li>在main函数中测试两种排序方式。</li></ul><h3 id="练习2：计算器函数"><a href="#练习2：计算器函数" class="headerlink" title="练习2：计算器函数"></a><strong>练习2：计算器函数</strong></h3><p>用函数指针数组实现计算器（加、减、乘、除），根据用户选择调用对应操作。  </p><h3 id="练习3：找错误"><a href="#练习3：找错误" class="headerlink" title="练习3：找错误"></a><strong>练习3：找错误</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*p)(<span class="type">int</span>) = add; <span class="comment">// 这里有问题！</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p(<span class="number">2</span>, <span class="number">3</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 比较函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">ascending</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &gt; b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">descending</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a &lt; b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冒泡排序（根据compare决定顺序）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size, CompareFunc compare)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size<span class="number">-1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;size<span class="number">-1</span>-i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(compare(arr[j], arr[j+<span class="number">1</span>])) &#123;</span><br><span class="line">                <span class="type">int</span> temp = arr[j];</span><br><span class="line">                arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">                arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用示例</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    sort(arr, <span class="number">5</span>, ascending);  <span class="comment">// 升序 → 1,1,3,4,5</span></span><br><span class="line">    sort(arr, <span class="number">5</span>, descending); <span class="comment">// 降序 → 5,4,3,1,1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a - b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">mul</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a * b; &#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a / b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> (*ops[<span class="number">4</span>])(<span class="type">int</span>, <span class="type">int</span>) = &#123;add, sub, mul, div&#125;;</span><br><span class="line">    <span class="type">int</span> choice, x, y;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;选择操作：0.加 1.减 2.乘 3.除\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;choice);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入两个数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果：%d\n&quot;</span>, ops[choice](x, y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>错误</strong>：函数指针 <code>p</code> 的声明参数数量与 <code>add</code> 不匹配。<br><strong>修正</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> (*p)(<span class="type">int</span>, <span class="type">int</span>) = add; <span class="comment">// 参数应为两个int</span></span><br></pre></td></tr></table></figure><hr><p>🚀 <strong>总结</strong>：  </p><ul><li>函数指针是<strong>指向代码的指针</strong>，实现灵活的函数调用。  </li><li>回调函数是“<strong>你定义，别人调用</strong>”的机制，广泛用于事件处理、库设计。  </li><li>牢记<strong>函数签名匹配</strong>，避免野指针调用！</li></ul><p><strong>口诀</strong>：函数指针像遥控，指向函数真奇妙，回调机制很灵活，签名一致要记牢！ 🎮🔧</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言指针</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容十分的重要，所以需要非常认真的对待，我也会可能的用最容易理解的方式进行讲解！！！</strong></p><h1 id="🧭-C语言指针终极详解——从零到精通，逐层击破！"><a href="#🧭-C语言指针终极详解——从零到精通，逐层击破！" class="headerlink" title="🧭 C语言指针终极详解——从零到精通，逐层击破！"></a>🧭 <strong>C语言指针终极详解——从零到精通，逐层击破！</strong></h1><p>指针是C语言的灵魂，但也是新手最头疼的部分。别怕！这篇教程将用 <strong>保姆级讲解 + 超多生活化比喻</strong>，带你彻底征服指针！  </p><hr><h2 id="一、指针的本质——内存世界的「GPS坐标」"><a href="#一、指针的本质——内存世界的「GPS坐标」" class="headerlink" title="一、指针的本质——内存世界的「GPS坐标」"></a><strong>一、指针的本质——内存世界的「GPS坐标」</strong></h2><h3 id="1-内存就像快递柜"><a href="#1-内存就像快递柜" class="headerlink" title="1. 内存就像快递柜"></a>1. <strong>内存就像快递柜</strong></h3><p>计算的内存被划分成无数个小格子（字节），每个格子有<strong>唯一编号</strong>（地址）。  </p><ul><li><strong>变量</strong>：快递柜里的包裹📦（数据）  </li><li><strong>指针</strong>：记录包裹所在柜子编号的纸条📝</li></ul><pre><code class="c">int num = 10;  // 假设num存放在编号0x1000的柜子  printf(&quot;变量地址：%p&quot;, &amp;num); // 输出0x1000  </code></pre><h3 id="2-指针变量——专门存地址的「地址簿」"><a href="#2-指针变量——专门存地址的「地址簿」" class="headerlink" title="2. 指针变量——专门存地址的「地址簿」"></a>2. <strong>指针变量——专门存地址的「地址簿」</strong></h3><ul><li><strong>声明指针</strong>：告诉编译器这个本子记录哪种柜子的地址  <pre><code class="c">int *p;    // 记录“整数柜”的地址  char *cp;  // 记录“字符柜”的地址  </code></pre><strong>重点</strong>：<code>int *</code>中的<code>*</code>表示这是一个指针变量，<code>int</code>指明指向的数据类型。</li></ul><hr><h2 id="二、指针的「三步操作」——从入门到熟练"><a href="#二、指针的「三步操作」——从入门到熟练" class="headerlink" title="二、指针的「三步操作」——从入门到熟练"></a><strong>二、指针的「三步操作」——从入门到熟练</strong></h2><h3 id="1-第一步：给地址簿绑定柜子（赋值）"><a href="#1-第一步：给地址簿绑定柜子（赋值）" class="headerlink" title="1. 第一步：给地址簿绑定柜子（赋值）"></a>1. <strong>第一步：给地址簿绑定柜子（赋值）</strong></h3><p>用<code>&amp;</code>获取变量地址，存入指针：  </p><pre><code class="c">int num = 99;  int *p = &amp;num; // p里记下num的地址0x1000  </code></pre><h3 id="2-第二步：按地址找包裹（解引用）"><a href="#2-第二步：按地址找包裹（解引用）" class="headerlink" title="2. 第二步：按地址找包裹（解引用）"></a>2. <strong>第二步：按地址找包裹（解引用）</strong></h3><p>用<code>*</code>访问指针指向的值：  </p><pre><code class="c">printf(&quot;柜子里的值：%d&quot;, *p); // 输出99  *p = 200; // 修改柜子里的值 → num变成200  </code></pre><p><strong>关键理解</strong>：  </p><ul><li><code>p</code> 是地址（0x1000）  </li><li><code>*p</code> 是地址里的值（200）</li></ul><h3 id="3-第三步：指针的「关系网」"><a href="#3-第三步：指针的「关系网」" class="headerlink" title="3. 第三步：指针的「关系网」"></a>3. <strong>第三步：指针的「关系网」</strong></h3><ul><li><strong>指针与指针</strong>：可以比较地址是否相同  <pre><code class="c">int *p1 = &amp;num;  int *p2 = &amp;num;  if (p1 == p2) &#123; // true，指向同一地址      printf(&quot;地址相同！&quot;);  &#125;  </code></pre></li></ul><hr><h2 id="三、NULL指针——避免「野指针」的保险锁"><a href="#三、NULL指针——避免「野指针」的保险锁" class="headerlink" title="三、NULL指针——避免「野指针」的保险锁"></a><strong>三、NULL指针——避免「野指针」的保险锁</strong></h2><h3 id="1-什么是野指针？"><a href="#1-什么是野指针？" class="headerlink" title="1. 什么是野指针？"></a>1. <strong>什么是野指针？</strong></h3><p>指针未初始化时，存储的是随机地址（像胡乱写的假地址🗑️），访问会导致崩溃。  </p><pre><code class="c">int *p; // 野指针！  *p = 10; // ❌ 危险！可能破坏其他数据  </code></pre><h3 id="2-安全初始化"><a href="#2-安全初始化" class="headerlink" title="2. 安全初始化"></a>2. <strong>安全初始化</strong></h3><pre><code class="c">int *p = NULL; // 初始化为空指针（地址0）  if (p != NULL) &#123;      *p = 10; // 安全操作  &#125;  </code></pre><p><strong>重要规则</strong>：  </p><ul><li>访问<code>NULL</code>指针会导致程序崩溃（如打开不存在的柜子）  </li><li>函数返回指针时，若出错常返回<code>NULL</code></li></ul><hr><h2 id="四、指针算术——地址的「跳跃游戏」"><a href="#四、指针算术——地址的「跳跃游戏」" class="headerlink" title="四、指针算术——地址的「跳跃游戏」"></a><strong>四、指针算术——地址的「跳跃游戏」</strong></h2><p>指针加减法不是数学运算，而是<strong>按类型大小移动地址</strong>！  </p><h3 id="1-基础规则"><a href="#1-基础规则" class="headerlink" title="1. 基础规则"></a>1. <strong>基础规则</strong></h3><pre><code class="c">int arr[3] = &#123;10, 20, 30&#125;;  int *p = &amp;arr[0]; // p指向10  p++; // p跳转到&amp;arr[1]（地址+4，假设int占4字节）  printf(&quot;%d&quot;, *p); // 输出20  </code></pre><p><strong>公式</strong>：<br><code>新地址 = 原地址 ± n * sizeof(类型)</code>  </p><h3 id="2-遍历数组的高级技巧"><a href="#2-遍历数组的高级技巧" class="headerlink" title="2. 遍历数组的高级技巧"></a>2. <strong>遍历数组的高级技巧</strong></h3><pre><code class="c">int arr[5] = &#123;1,2,3,4,5&#125;;  for(int *ptr=arr; ptr &lt; arr+5; ptr++) &#123;      printf(&quot;%d &quot;, *ptr); // 输出1 2 3 4 5  &#125;  </code></pre><p><strong>解析</strong>：  </p><ul><li><code>arr</code>是数组首地址（等价于<code>&amp;arr[0]</code>）  </li><li><code>arr+5</code>是第6个元素的地址（结束条件）</li></ul><hr><h2 id="五、指针与数组——「一体两面」的亲密关系"><a href="#五、指针与数组——「一体两面」的亲密关系" class="headerlink" title="五、指针与数组——「一体两面」的亲密关系"></a><strong>五、指针与数组——「一体两面」的亲密关系</strong></h2><h3 id="1-数组名是常量指针"><a href="#1-数组名是常量指针" class="headerlink" title="1. 数组名是常量指针"></a>1. <strong>数组名是常量指针</strong></h3><pre><code class="c">int arr[3] = &#123;10,20,30&#125;;  printf(&quot;arr[1] = %d&quot;, *(arr + 1)); // 输出20  </code></pre><p><strong>禁止操作</strong>：  </p><pre><code class="c">arr++; // ❌ 数组名是常量，不能修改！  </code></pre><h3 id="2-指针模拟数组"><a href="#2-指针模拟数组" class="headerlink" title="2. 指针模拟数组"></a>2. <strong>指针模拟数组</strong></h3><pre><code class="c">int *p = arr;  p[1] = 99; // 等价于arr[1] = 99  </code></pre><p><strong>底层原理</strong>：<br><code>p[1]</code>会被编译器转换为<code>*(p + 1)</code>  </p><hr><h2 id="六、多级指针——「套娃」寻址"><a href="#六、多级指针——「套娃」寻址" class="headerlink" title="六、多级指针——「套娃」寻址"></a><strong>六、多级指针——「套娃」寻址</strong></h2><h3 id="1-二级指针（指针的指针）"><a href="#1-二级指针（指针的指针）" class="headerlink" title="1. 二级指针（指针的指针）"></a>1. <strong>二级指针（指针的指针）</strong></h3><pre><code class="c">int num = 100;  int *p = &amp;num;     // p存储num的地址  int **pp = &amp;p;     // pp存储p的地址  printf(&quot;num = %d&quot;, **pp); // 输出100  </code></pre><p><strong>内存图示</strong>：  </p><pre><code>pp → p → num  </code></pre><h3 id="2-应用场景"><a href="#2-应用场景" class="headerlink" title="2. 应用场景"></a>2. <strong>应用场景</strong></h3><ul><li>动态二维数组  </li><li>修改函数外的指针变量</li></ul><hr><h2 id="七、函数与指针——「隔空取物」的魔法"><a href="#七、函数与指针——「隔空取物」的魔法" class="headerlink" title="七、函数与指针——「隔空取物」的魔法"></a><strong>七、函数与指针——「隔空取物」的魔法</strong></h2><h3 id="1-指针作为函数参数（传址调用）"><a href="#1-指针作为函数参数（传址调用）" class="headerlink" title="1. 指针作为函数参数（传址调用）"></a>1. <strong>指针作为函数参数（传址调用）</strong></h3><pre><code class="c">void addTen(int *num) &#123;      *num += 10; // 修改外部变量  &#125;  int main() &#123;      int x = 5;      addTen(&amp;x); // x变成15  &#125;  </code></pre><p><strong>对比传值调用</strong>：  </p><ul><li>传值：函数内修改不影响外部变量  </li><li>传址：通过指针直接修改内存</li></ul><h3 id="2-返回指针的函数"><a href="#2-返回指针的函数" class="headerlink" title="2. 返回指针的函数"></a>2. <strong>返回指针的函数</strong></h3><pre><code class="c">int* createArray(int size) &#123;      int *arr = (int*)malloc(size * sizeof(int));      return arr; // 返回动态数组指针  &#125;  // 使用后必须释放内存！  int *myArr = createArray(10);  free(myArr);  </code></pre><p><strong>致命错误</strong>：  </p><pre><code class="c">int* dangerous() &#123;      int num = 10;      return &amp;num; // ❌ 返回局部变量地址！  &#125;  </code></pre><p><strong>解析</strong>：函数结束后局部变量内存被回收，指针变野指针！  </p><hr><h2 id="八、指针的「死亡陷阱」——必须避免的错误"><a href="#八、指针的「死亡陷阱」——必须避免的错误" class="headerlink" title="八、指针的「死亡陷阱」——必须避免的错误"></a><strong>八、指针的「死亡陷阱」——必须避免的错误</strong></h2><h3 id="1-操作越界指针"><a href="#1-操作越界指针" class="headerlink" title="1. 操作越界指针"></a>1. <strong>操作越界指针</strong></h3><pre><code class="c">int arr[3] = &#123;1,2,3&#125;;  int *p = &amp;arr[3]; // ❌ 越界！arr最大索引是2  *p = 4;           // 破坏未知内存  </code></pre><h3 id="2-误解指针类型"><a href="#2-误解指针类型" class="headerlink" title="2. 误解指针类型"></a>2. <strong>误解指针类型</strong></h3><pre><code class="c">float f = 3.14;  int *p = (int*)&amp;f; // 强制转换类型  printf(&quot;%d&quot;, *p);  // 输出乱码！二进制解释不同  </code></pre><h3 id="3-忘记释放动态内存"><a href="#3-忘记释放动态内存" class="headerlink" title="3. 忘记释放动态内存"></a>3. <strong>忘记释放动态内存</strong></h3><pre><code class="c">int *arr = malloc(100 * sizeof(int));  // ...使用后...  free(arr); // 必须释放！  </code></pre><hr><h2 id="九、实战训练营——巩固指针技能"><a href="#九、实战训练营——巩固指针技能" class="headerlink" title="九、实战训练营——巩固指针技能"></a><strong>九、实战训练营——巩固指针技能</strong></h2><h3 id="练习1：字符串反转"><a href="#练习1：字符串反转" class="headerlink" title="练习1：字符串反转"></a>练习1：字符串反转</h3><p>用指针实现字符串反转函数：  </p><pre><code class="c">void reverseString(char *str) &#123;      char *start = str;      char *end = str + strlen(str) - 1;      while (start &lt; end) &#123;          char temp = *start;          *start = *end;          *end = temp;          start++;          end--;      &#125;  &#125;  </code></pre><h3 id="练习2：动态二维数组"><a href="#练习2：动态二维数组" class="headerlink" title="练习2：动态二维数组"></a>练习2：动态二维数组</h3><p>用指针的指针创建二维数组：  </p><pre><code class="c">int **matrix = malloc(3 * sizeof(int*));  for(int i=0; i&lt;3; i++) &#123;      matrix[i] = malloc(3 * sizeof(int));  &#125;  // 使用后逐行释放  </code></pre><hr><h2 id="💡-终极总结口诀"><a href="#💡-终极总结口诀" class="headerlink" title="💡 终极总结口诀"></a>💡 <strong>终极总结口诀</strong></h2><blockquote><p>指针即地址，变量门牌号。<br>声明带星号，类型要配套。<br>取址用&amp;符，解引用星号。<br>算术按类型，数组关系妙。<br>函数传地址，返回谨慎保。<br>NULL防野针，内存泄漏要除掉！  </p></blockquote><p><strong>学习建议</strong>：  </p><ol><li>多画内存图理解指针指向  </li><li>写代码时添加注释说明指针作用  </li><li>使用调试器观察指针地址变化</li></ol><p>掌握指针，你就掌握了C语言的精髓！🚀任何问题欢迎随时交流,遇到问题多画内存图，理解会更深刻哦~</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C enum(枚举)</title>
      <link href="/2025/02/03/Cenum-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2025/02/03/Cenum-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="📚-C语言枚举（enum）——给数字赋予意义的名字"><a href="#📚-C语言枚举（enum）——给数字赋予意义的名字" class="headerlink" title="📚 C语言枚举（enum）——给数字赋予意义的名字"></a>📚 <strong>C语言枚举（enum）——给数字赋予意义的名字</strong></h1><hr><h2 id="一、什么是枚举？——数字的「身份证」"><a href="#一、什么是枚举？——数字的「身份证」" class="headerlink" title="一、什么是枚举？——数字的「身份证」"></a><strong>一、什么是枚举？——数字的「身份证」</strong></h2><p><strong>概念</strong>：枚举（Enumeration）是一种用户自定义的数据类型，用于为一组整数常量赋予有意义的名字。<br><strong>思想</strong>：用易于理解的单词代替数字，让代码更清晰、更易维护。<br><strong>作用</strong>：  </p><ul><li>提高代码可读性（看到名字就知道含义）  </li><li>限制变量的取值范围（只能选枚举中的值）  </li><li>替代散乱的<code>#define</code>宏定义</li></ul><p><strong>类比理解</strong>：  </p><ul><li>假设你管理一个图书馆📚，书籍分类用数字表示：  <ul><li><strong>不用枚举</strong>：看到<code>1</code>，需要查文档才知道是“科幻类”  </li><li><strong>使用枚举</strong>：直接写<code>SciFi</code>，一看就懂！</li></ul></li></ul><hr><h2 id="二、为什么需要枚举？——告别「神秘数字」"><a href="#二、为什么需要枚举？——告别「神秘数字」" class="headerlink" title="二、为什么需要枚举？——告别「神秘数字」"></a><strong>二、为什么需要枚举？——告别「神秘数字」</strong></h2><p><strong>痛点</strong>：  </p><pre><code class="c">// 用数字表示状态，难以记忆！if (status == 1) &#123; /* 处理成功 */ &#125;  else if (status == 2) &#123; /* 处理失败 */ &#125;</code></pre><p><strong>枚举解决方案</strong>：  </p><pre><code class="c">enum Status &#123;Success=1, Failure=2&#125;;if (status == Success) &#123; ... &#125; // 一目了然✨</code></pre><p><strong>优点</strong>：  </p><ol><li><strong>代码自解释</strong>：名字比数字更易懂  </li><li><strong>类型安全</strong>：编译器检查枚举变量赋值  </li><li><strong>易维护</strong>：修改枚举值只需改一处</li></ol><p><strong>缺点</strong>：  </p><ol><li><strong>本质是整数</strong>：无法直接打印名字（需手动转换）  </li><li><strong>不连续枚举难遍历</strong>：无法自动获取所有值</li></ol><hr><h2 id="三、枚举的定义与使用——三步创建「命名册」"><a href="#三、枚举的定义与使用——三步创建「命名册」" class="headerlink" title="三、枚举的定义与使用——三步创建「命名册」"></a><strong>三、枚举的定义与使用——三步创建「命名册」</strong></h2><h3 id="1-定义枚举类型"><a href="#1-定义枚举类型" class="headerlink" title="1. 定义枚举类型"></a><strong>1. 定义枚举类型</strong></h3><p><strong>语法</strong>：  </p><pre><code class="c">enum 枚举类型名 &#123;      名字1,      名字2,      // ...  &#125;;  </code></pre><p><strong>示例</strong>：  </p><pre><code class="c">// 定义星期枚举  enum Week &#123;      Monday,    // 默认值0      Tuesday,   // 自动+1 → 1      Wednesday, // 2      // ...  &#125;;  </code></pre><h3 id="2-创建枚举变量"><a href="#2-创建枚举变量" class="headerlink" title="2. 创建枚举变量"></a><strong>2. 创建枚举变量</strong></h3><p><strong>三种方式</strong>：  </p><ul><li><p><strong>先声明类型，后定义变量</strong>：  </p><pre><code class="c">enum Week &#123;Mon, Tue, Wed&#125;;  enum Week today;  // 定义变量  today = Mon;      // 赋值  </code></pre></li><li><p><strong>声明同时定义变量</strong>：  </p><pre><code class="c">enum Week &#123;Mon, Tue, Wed&#125; today;  today = Tue;  </code></pre></li><li><p><strong>匿名枚举（不推荐）</strong>：  </p><pre><code class="c">enum &#123;Mon=1, Tue, Wed&#125; today; // 无类型名，无法复用  </code></pre></li></ul><h3 id="3-赋值规则"><a href="#3-赋值规则" class="headerlink" title="3. 赋值规则"></a><strong>3. 赋值规则</strong></h3><ul><li><p><strong>默认从0开始</strong>：  </p><pre><code class="c">enum Color &#123;Red, Green, Blue&#125;; // Red=0, Green=1, Blue=2  </code></pre></li><li><p><strong>手动指定起始值</strong>：  </p><pre><code class="c">enum Week &#123;Mon=1, Tue, Wed&#125;; // Mon=1, Tue=2, Wed=3  </code></pre></li><li><p><strong>跳跃赋值</strong>：  </p><pre><code class="c">enum HttpStatus &#123;OK=200, NotFound=404, Error=500&#125;;  </code></pre></li></ul><hr><h2 id="四、枚举的实战应用——让代码「会说话」"><a href="#四、枚举的实战应用——让代码「会说话」" class="headerlink" title="四、枚举的实战应用——让代码「会说话」"></a><strong>四、枚举的实战应用——让代码「会说话」</strong></h2><h3 id="1-替代魔数（Magic-Number）"><a href="#1-替代魔数（Magic-Number）" class="headerlink" title="1. 替代魔数（Magic Number）"></a><strong>1. 替代魔数（Magic Number）</strong></h3><p><strong>坏代码</strong>：  </p><pre><code class="c">if (status == 404) &#123; ... &#125; // 404是什么？需要查文档！  </code></pre><p><strong>好代码</strong>：  </p><pre><code class="c">enum HttpStatus &#123;OK=200, NotFound=404&#125;;  if (status == NotFound) &#123; ... &#125; // 清晰！  </code></pre><h3 id="2-在switch-case中使用"><a href="#2-在switch-case中使用" class="headerlink" title="2. 在switch-case中使用"></a><strong>2. 在switch-case中使用</strong></h3><pre><code class="c">enum Color &#123;Red=1, Green, Blue&#125;;  enum Color favorite = Green;  switch (favorite) &#123;      case Red:   printf(&quot;❤️&quot;); break;      case Green: printf(&quot;💚&quot;); break;      case Blue:  printf(&quot;💙&quot;); break;      default:    printf(&quot;未知颜色&quot;);  &#125;  </code></pre><h3 id="3-限制变量取值范围"><a href="#3-限制变量取值范围" class="headerlink" title="3. 限制变量取值范围"></a><strong>3. 限制变量取值范围</strong></h3><pre><code class="c">enum Week day = 99; // ❌ 编译器警告！99不在枚举范围内  </code></pre><hr><h2 id="五、常见错误——小白的「避坑指南」"><a href="#五、常见错误——小白的「避坑指南」" class="headerlink" title="五、常见错误——小白的「避坑指南」"></a><strong>五、常见错误——小白的「避坑指南」</strong></h2><ol><li><p><strong>误以为枚举是字符串</strong>  </p><pre><code class="c">printf(&quot;%s&quot;, Tue); // ❌ 错误！Tue是整数，不是字符串  // 正确：需手动映射  char* weekNames[] = &#123;&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;&#125;;  printf(&quot;%s&quot;, weekNames[today]);  </code></pre></li><li><p><strong>遍历不连续枚举</strong>  </p><pre><code class="c">enum Gaps &#123;A=1, B=3, C&#125;; // C=4  for (int i=A; i&lt;=C; i++) &#123;      // i=1,2,3,4 → 但B=3和C=4有效，i=2无效！  &#125;  </code></pre></li><li><p><strong>忘记枚举的整型本质</strong>  </p><pre><code class="c">enum Week day = Wed;  int num = day; // ✅ 合法！枚举值可赋值给整型  day = 5;       // ❌ 如果枚举最大值是3，会越界！  </code></pre></li></ol><hr><h2 id="六、枚举的「伪遍历」技巧"><a href="#六、枚举的「伪遍历」技巧" class="headerlink" title="六、枚举的「伪遍历」技巧"></a><strong>六、枚举的「伪遍历」技巧</strong></h2><p><strong>前提</strong>：枚举值必须连续！  </p><pre><code class="c">enum Week &#123;Mon=1, Tue, Wed, Thu, Fri&#125;;  // 遍历所有枚举值  for (enum Week day = Mon; day &lt;= Fri; day++) &#123;      printf(&quot;Day %d\n&quot;, day);  &#125;  </code></pre><p><strong>输出</strong>：  </p><pre><code>Day 1  Day 2  Day 3  Day 4  Day 5  </code></pre><hr><h2 id="七、综合练习——巩固知识"><a href="#七、综合练习——巩固知识" class="headerlink" title="七、综合练习——巩固知识"></a><strong>七、综合练习——巩固知识</strong></h2><ol><li><p><strong>创建菜单系统</strong>  </p><ul><li>定义枚举：<code>Menu &#123;Start=1, Load, Save, Exit&#125;</code>  </li><li>用户输入数字选择菜单项  </li><li>用switch处理选项</li></ul></li><li><p><strong>处理错误码</strong>  </p><ul><li>定义枚举：<code>enum ErrorCode &#123;Success=0, FileNotFound=-1, Timeout=100&#125;</code>  </li><li>根据函数返回的错误码打印提示信息</li></ul></li></ol><hr><h2 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 <strong>总结</strong></h2><p>枚举是让代码「自解释」的利器，通过为数字赋予有意义的名字，让程序更易读、更健壮。记住：  </p><ul><li><strong>优点</strong>：代码清晰、类型安全、易维护  </li><li><strong>缺点</strong>：本质是整数、遍历受限  </li><li><strong>核心规则</strong>：默认从0开始，可手动赋值，避免不连续遍历</li></ul><p>现在，尝试用枚举替换代码中的魔数，让你的程序像故事书一样易懂吧！📖✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言二维数组</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言二维数组深度解析！-😊👇"><a href="#👇😊-C语言二维数组深度解析！-😊👇" class="headerlink" title="👇😊 C语言二维数组深度解析！ 😊👇"></a>👇😊 <strong>C语言二维数组深度解析！</strong> 😊👇</h1><hr><h2 id="🌈-1-二维数组是什么？"><a href="#🌈-1-二维数组是什么？" class="headerlink" title="🌈 1. 二维数组是什么？"></a><strong>🌈 1. 二维数组是什么？</strong></h2><p>现在你的手里一个<strong>数学表格</strong>📊，或者一个<strong>棋盘</strong>♟️，每个格子可以存放一个数据。  </p><ul><li><strong>行（Row）</strong> → 横向排列（比如Excel中的行号）  </li><li><strong>列（Column）</strong> → 纵向排列（比如Excel中的列标）  </li><li><strong>元素</strong> → 每个格子里的数据</li></ul><p><strong>例如</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">学生成绩表（3个学生，2门课）</span><br><span class="line">行 → 学生 | 列 → 科目</span><br><span class="line">+----+----+</span><br><span class="line">| 80 | 90 | → 学生1的成绩</span><br><span class="line">+----+----+</span><br><span class="line">| 70 | 85 | → 学生2的成绩</span><br><span class="line">+----+----+</span><br><span class="line">| 95 | 88 | → 学生3的成绩</span><br><span class="line">+----+----+</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-2-二维数组的声明与初始化"><a href="#🌈-2-二维数组的声明与初始化" class="headerlink" title="🌈 2. 二维数组的声明与初始化"></a><strong>🌈 2. 二维数组的声明与初始化</strong></h2><h3 id="2-1-声明二维数组"><a href="#2-1-声明二维数组" class="headerlink" title="2.1 声明二维数组"></a><strong>2.1 声明二维数组</strong></h3><p>📝 <strong>语法</strong>：<code>数据类型 数组名[行数][列数];</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>];  <span class="comment">// 3行2列的整型数组（3学生×2科目）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化二维数组"><a href="#2-2-初始化二维数组" class="headerlink" title="2.2 初始化二维数组"></a><strong>2.2 初始化二维数组</strong></h3><ul><li><p><strong>逐行初始化</strong>：用大括号分组  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">80</span>, <span class="number">90</span>&#125;, <span class="comment">// 第0行：学生1的语文和数学成绩</span></span><br><span class="line">    &#123;<span class="number">70</span>, <span class="number">85</span>&#125;, <span class="comment">// 第1行：学生2的成绩</span></span><br><span class="line">    &#123;<span class="number">95</span>, <span class="number">88</span>&#125;  <span class="comment">// 第2行：学生3的成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>省略行数</strong>（编译器自动计算行数）：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[][<span class="number">2</span>] = &#123; </span><br><span class="line">    &#123;<span class="number">80</span>, <span class="number">90</span>&#125;,</span><br><span class="line">    &#123;<span class="number">70</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="number">95</span>, <span class="number">88</span>&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>不完整初始化</strong>：剩余元素补0  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,       <span class="comment">// 第0行 → [1,0,0]</span></span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;      <span class="comment">// 第1行 → [2,3,0]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="🌈-3-访问二维数组元素"><a href="#🌈-3-访问二维数组元素" class="headerlink" title="🌈 3. 访问二维数组元素"></a><strong>🌈 3. 访问二维数组元素</strong></h2><ul><li><strong>索引规则</strong>：<code>数组名[行号][列号]</code>  </li><li><strong>索引从0开始</strong>！最大行号 &#x3D; 行数-1，最大列号 &#x3D; 列数-1</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">80</span>,<span class="number">90</span>&#125;, &#123;<span class="number">70</span>,<span class="number">85</span>&#125;, &#123;<span class="number">95</span>,<span class="number">88</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, scores[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 输出第0行第1列 → 90</span></span><br><span class="line">scores[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span>;         <span class="comment">// 修改第2行第0列 → 变成100</span></span><br></pre></td></tr></table></figure><p>💥 <strong>致命错误</strong>：越界访问！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">60</span>; <span class="comment">// ❌ 行号最大是2（共3行）</span></span><br><span class="line">scores[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">75</span>; <span class="comment">// ❌ 列号最大是1（共2列）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-内存中的二维数组"><a href="#🌈-4-内存中的二维数组" class="headerlink" title="🌈 4. 内存中的二维数组"></a><strong>🌈 4. 内存中的二维数组</strong></h2><p>二维数组在内存中是<strong>按行连续存储</strong>的！<br>例如 <code>int arr[2][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;</code> 的内存布局：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址低 → 高</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><ul><li>访问 <code>arr[1][1]</code> → 实际是第 <code>1*3 +1 =4</code> 个元素（值5）</li></ul><h3 id="用一维视角理解二维数组"><a href="#用一维视角理解二维数组" class="headerlink" title="用一维视角理解二维数组"></a><strong>用一维视角理解二维数组</strong></h3><p>可以把二维数组看作一个“被折叠”的一维数组：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">int</span> arr_flat[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-遍历二维数组"><a href="#🌈-5-遍历二维数组" class="headerlink" title="🌈 5. 遍历二维数组"></a><strong>🌈 5. 遍历二维数组</strong></h2><p>用<strong>嵌套循环</strong>：外层循环行，内层循环列  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">80</span>,<span class="number">90</span>&#125;, &#123;<span class="number">70</span>,<span class="number">85</span>&#125;, &#123;<span class="number">95</span>,<span class="number">88</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;       <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;   <span class="comment">// 遍历列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, scores[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80 90 </span><br><span class="line">70 85 </span><br><span class="line">95 88 </span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-二维数组与指针"><a href="#🌈-6-二维数组与指针" class="headerlink" title="🌈 6. 二维数组与指针"></a><strong>🌈 6. 二维数组与指针</strong></h2><p>二维数组名是<strong>指向第一个元素（即第0行）的指针</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>] = arr; <span class="comment">// p指向第0行（整个一维数组）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第1行第2列 → 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 等价于 arr[1][2]</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-动态二维数组（进阶）"><a href="#🌈-7-动态二维数组（进阶）" class="headerlink" title="🌈 7. 动态二维数组（进阶）"></a><strong>🌈 7. 动态二维数组（进阶）</strong></h2><p>使用<strong>指针数组</strong> + <strong>malloc</strong> 动态创建二维数组：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *)); <span class="comment">// 申请行指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 每行申请列空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存（先释放列，再释放行）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(matrix[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(matrix);</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-8-常见错误"><a href="#🌈-8-常见错误" class="headerlink" title="🌈 8. 常见错误"></a><strong>🌈 8. 常见错误</strong></h2><ol><li><p><strong>行列顺序颠倒</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">// ❌ 行号最大1，列号最大2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>错误初始化</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// ✅ 但可读性差</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;  <span class="comment">// ✅ 补0 → [1,2,0], [3,0,0]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;   <span class="comment">// ❌ 第0行元素过多</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态数组未释放内存</strong> → 内存泄漏！</p></li></ol><hr><h2 id="🌈-9-练习时间！"><a href="#🌈-9-练习时间！" class="headerlink" title="🌈 9. 练习时间！"></a><strong>🌈 9. 练习时间！</strong></h2><h3 id="练习1：求二维数组的总和"><a href="#练习1：求二维数组的总和" class="headerlink" title="练习1：求二维数组的总和"></a><strong>练习1：求二维数组的总和</strong></h3><p>写一个函数 <code>int sumMatrix(int matrix[][3], int rows)</code>，计算3列二维数组所有元素的和。  </p><h3 id="练习2：矩阵转置"><a href="#练习2：矩阵转置" class="headerlink" title="练习2：矩阵转置"></a><strong>练习2：矩阵转置</strong></h3><p>写一个函数 <code>void transpose(int src[][3], int dest[][2], int rows)</code>，将2行3列的矩阵转置为3行2列的矩阵（行列互换）。  </p><h3 id="练习3：动态创建二维数组"><a href="#练习3：动态创建二维数组" class="headerlink" title="练习3：动态创建二维数组"></a><strong>练习3：动态创建二维数组</strong></h3><p>动态创建一个4行5列的整型二维数组，并初始化所有元素为0。  </p><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumMatrix</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">3</span>], <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            sum += matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose</span><span class="params">(<span class="type">int</span> src[][<span class="number">3</span>], <span class="type">int</span> dest[][<span class="number">2</span>], <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            dest[j][i] = src[i][j]; <span class="comment">// 行列互换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">4</span>, cols = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">        matrix[i][j] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>🚀 <strong>总结</strong>：二维数组就是“数组的数组”，想象成表格或棋盘更容易理解！掌握行优先存储、嵌套循环遍历和动态内存管理，其实二维数组也不难！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言数组-😊👇"><a href="#👇😊-C语言数组-😊👇" class="headerlink" title="👇😊 C语言数组 😊👇"></a>👇😊 <strong>C语言数组</strong> 😊👇</h1><hr><h2 id="🌈-1-数组是什么？"><a href="#🌈-1-数组是什么？" class="headerlink" title="🌈 1. 数组是什么？"></a><strong>🌈 1. 数组是什么？</strong></h2><p>想象你有一排<strong>储物柜</strong>🔒，每个柜子编号从0开始，存放同类型物品（比如全是书包）。这就是数组！  </p><ul><li><strong>作用</strong>：一次性管理多个同类数据，避免定义一堆变量！  </li><li><strong>特点</strong>：<strong>连续内存</strong>存储，快速访问任意元素！</li></ul><hr><h2 id="🌈-2-数组的声明与初始化"><a href="#🌈-2-数组的声明与初始化" class="headerlink" title="🌈 2. 数组的声明与初始化"></a><strong>🌈 2. 数组的声明与初始化</strong></h2><h3 id="2-1-声明数组"><a href="#2-1-声明数组" class="headerlink" title="2.1 声明数组"></a><strong>2.1 声明数组</strong></h3><p>📝 <strong>语法</strong>：<code>数据类型 数组名[元素个数];</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">5</span>];      <span class="comment">// 声明能存5个整数的数组</span></span><br><span class="line"><span class="type">double</span> prices[<span class="number">10</span>];  <span class="comment">// 声明能存10个双精度数的数组</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// ❌ 错误！数组大小必须是常量（C99前）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化数组"><a href="#2-2-初始化数组" class="headerlink" title="2.2 初始化数组"></a><strong>2.2 初始化数组</strong></h3><ul><li><strong>完全初始化</strong>：指定所有元素  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// nums[0]=10, nums[1]=20, nums[2]=30</span></span><br></pre></td></tr></table></figure></li><li><strong>部分初始化</strong>：剩余元素自动补0  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// arr = [1,2,0,0,0]</span></span><br></pre></td></tr></table></figure></li><li><strong>自动计算大小</strong>：省略元素个数  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letters[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;; <span class="comment">// 自动识别长度为3</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// ❌ 初始值太多！</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-访问数组元素"><a href="#🌈-3-访问数组元素" class="headerlink" title="🌈 3. 访问数组元素"></a><strong>🌈 3. 访问数组元素</strong></h2><ul><li><strong>索引从0开始</strong>！最后一个元素索引是<code>长度-1</code>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, nums[<span class="number">0</span>]); <span class="comment">// 输出10</span></span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">40</span>;          <span class="comment">// 修改第三个元素为40</span></span><br></pre></td></tr></table></figure></li></ul><p>💥 <strong>致命错误</strong>：数组越界！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">10</span>; <span class="comment">// ❌ 有效索引是0-4，越界可能导致程序崩溃！</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-获取数组长度"><a href="#🌈-4-获取数组长度" class="headerlink" title="🌈 4. 获取数组长度"></a><strong>🌈 4. 获取数组长度</strong></h2><p>使用 <code>sizeof</code> 计算总大小除以单个元素大小：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>🔧 <strong>进阶技巧</strong>：用宏定义简化  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEN(arr) (sizeof(arr)/sizeof(arr[0]))</span></span><br><span class="line"><span class="type">int</span> len = LEN(arr); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意</strong>：<strong>在函数中传递数组时，无法用此法获取长度</strong>（数组退化为指针）！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">// sizeof(arr) 这里得到的是指针大小，不是数组大小！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-数组名与指针的关系"><a href="#🌈-5-数组名与指针的关系" class="headerlink" title="🌈 5. 数组名与指针的关系"></a><strong>🌈 5. 数组名与指针的关系</strong></h2><ul><li><p><strong>数组名</strong>是首元素地址的<strong>常量指针</strong>（不能修改指向）  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr; <span class="comment">// 等价于 ptr = &amp;arr[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>用指针遍历数组</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(ptr + i)); <span class="comment">// 访问arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>易混淆点</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="comment">// arr++;  // ❌ 数组名是常量，不能修改！</span></span><br><span class="line">p++;      <span class="comment">// ✅ 指针可以移动</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-数组作为函数参数"><a href="#🌈-6-数组作为函数参数" class="headerlink" title="🌈 6. 数组作为函数参数"></a><strong>🌈 6. 数组作为函数参数</strong></h2><p>传递数组给函数时，实际传递的是<strong>指针</strong>（首地址），函数内可修改原数组！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doubleValues</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        arr[i] *= <span class="number">2</span>; <span class="comment">// 修改原数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    doubleValues(nums, <span class="number">3</span>); <span class="comment">// 传递数组名和长度</span></span><br><span class="line">    <span class="comment">// nums变成[2,4,6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-多维数组（以二维为例）"><a href="#🌈-7-多维数组（以二维为例）" class="headerlink" title="🌈 7. 多维数组（以二维为例）"></a><strong>🌈 7. 多维数组（以二维为例）</strong></h2><h3 id="7-1-声明与初始化"><a href="#7-1-声明与初始化" class="headerlink" title="7.1 声明与初始化"></a><strong>7.1 声明与初始化</strong></h3><p>二维数组类似表格📊，有行和列：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,  <span class="comment">// 第0行</span></span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;   <span class="comment">// 第1行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-2-访问元素"><a href="#7-2-访问元素" class="headerlink" title="7.2 访问元素"></a><strong>7.2 访问元素</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, matrix[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 输出6（第1行第2列）</span></span><br></pre></td></tr></table></figure><h2 id="后续的话会单独用一篇文章来讲解二维数组！！！😏"><a href="#后续的话会单独用一篇文章来讲解二维数组！！！😏" class="headerlink" title="后续的话会单独用一篇文章来讲解二维数组！！！😏"></a><strong>后续的话会单独用一篇文章来讲解二维数组！！！😏</strong></h2><h2 id="🌈-8-静态数组-vs-动态数组"><a href="#🌈-8-静态数组-vs-动态数组" class="headerlink" title="🌈 8. 静态数组 vs 动态数组"></a><strong>🌈 8. 静态数组 vs 动态数组</strong></h2><table><thead><tr><th>类型</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td><strong>静态数组</strong></td><td>编译时确定大小，内存自动分配&#x2F;释放</td><td><code>int arr[10];</code></td></tr><tr><td><strong>动态数组</strong></td><td>运行时手动分配（<code>malloc</code>），需手动释放</td><td><code>int *arr = malloc(n * sizeof(int));</code></td></tr></tbody></table><p>🌰 <strong>动态数组示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="keyword">if</span>(arr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        arr[i] = i+<span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(arr); <span class="comment">// 释放内存！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="❌-9-常见错误集锦"><a href="#❌-9-常见错误集锦" class="headerlink" title="❌ 9. 常见错误集锦"></a><strong>❌ 9. 常见错误集锦</strong></h2><ol><li><strong>越界访问</strong>：索引超出范围 → 程序崩溃  </li><li><strong>未初始化就使用</strong>：局部数组元素是随机值  </li><li><strong>在函数中用sizeof求长度</strong>：得到指针大小而非数组长度  </li><li><strong>修改数组名</strong>：数组名是常量指针，不能<code>arr++</code></li></ol><hr><h2 id="🌈-10-综合练习"><a href="#🌈-10-综合练习" class="headerlink" title="🌈 10. 综合练习"></a><strong>🌈 10. 综合练习</strong></h2><h3 id="练习1：求数组最大值"><a href="#练习1：求数组最大值" class="headerlink" title="练习1：求数组最大值"></a><strong>练习1：求数组最大值</strong></h3><p>写一个函数 <code>int findMax(int arr[], int len)</code>，返回数组中的最大值。  </p><h3 id="练习2：反转数组"><a href="#练习2：反转数组" class="headerlink" title="练习2：反转数组"></a><strong>练习2：反转数组</strong></h3><p>写一个函数 <code>void reverse(int arr[], int len)</code>，将数组元素原地反转。  </p><h3 id="练习3：错误修复"><a href="#练习3：错误修复" class="headerlink" title="练习3：错误修复"></a><strong>练习3：错误修复</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">3</span>]); <span class="comment">// 输出第4个元素？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max) max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[len<span class="number">-1</span>-i];</span><br><span class="line">        arr[len<span class="number">-1</span>-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>错误</strong>：<code>arr[3]</code> 越界访问（有效索引为0-2）<br><strong>修正</strong>：<code>printf(&quot;%d&quot;, arr[2]);</code>  </p><hr><p>🚀 <strong>总结</strong>：数组是C语言的“数据集装箱”，掌握索引、内存布局和指针操作是关键！多练习，多调试，轻松玩转数组！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言作用域规则</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言作用域规则-😊👇"><a href="#👇😊-C语言作用域规则-😊👇" class="headerlink" title="👇😊 C语言作用域规则 😊👇"></a>👇😊 <strong>C语言作用域规则</strong> 😊👇</h1><hr><h2 id="🌈-1-作用域是什么？"><a href="#🌈-1-作用域是什么？" class="headerlink" title="🌈 1. 作用域是什么？"></a><strong>🌈 1. 作用域是什么？</strong></h2><p>想象你家的房间🏠：  </p><ul><li><strong>客厅的零食</strong>🍿 → 全家人都能拿（<strong>全局变量</strong>）  </li><li><strong>你抽屉里的日记</strong>📔 → 只有你能看到（<strong>局部变量</strong>）<br><strong>作用域</strong>就是变量的“可见范围”——出了这个区域，变量就“隐身”了！👻</li></ul><hr><h2 id="🌈-2-变量的三种身份"><a href="#🌈-2-变量的三种身份" class="headerlink" title="🌈 2. 变量的三种身份"></a><strong>🌈 2. 变量的三种身份</strong></h2><h3 id="2-1-局部变量（Local-Variables）"><a href="#2-1-局部变量（Local-Variables）" class="headerlink" title="2.1 局部变量（Local Variables）"></a><strong>2.1 局部变量（Local Variables）</strong></h3><ul><li><strong>位置</strong>：在<strong>函数或代码块内部</strong>定义  </li><li><strong>寿命</strong>：函数被调用时“出生”，函数结束“死亡”💀  </li><li><strong>特点</strong>：只能在所属函数&#x2F;代码块内使用</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside function: %d\n&quot;</span>, localVar); <span class="comment">// 正常输出5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="comment">// printf(&quot;%d&quot;, localVar); ❌ 错误！localVar在这里不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❌ <strong>常见错误</strong>：在代码块外使用局部变量  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x的作用域只在if块内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); ❌ 错误！x已经“死了”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-全局变量（Global-Variables）"><a href="#2-2-全局变量（Global-Variables）" class="headerlink" title="2.2 全局变量（Global Variables）"></a><strong>2.2 全局变量（Global Variables）</strong></h3><ul><li><strong>位置</strong>：在<strong>所有函数外部</strong>定义  </li><li><strong>寿命</strong>：程序启动时“出生”，程序结束时“死亡”⚰️  </li><li><strong>特点</strong>：所有函数都能访问和修改它！</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    globalVar += <span class="number">10</span>; <span class="comment">// 修改全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GlobalVar: %d\n&quot;</span>, globalVar); <span class="comment">// 输出110（如果func1被调用过）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">    func2(); <span class="comment">// 输出110</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ <strong>危险操作</strong>：局部变量同名覆盖全局变量  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">50</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num); <span class="comment">// 输出20，全局变量被“屏蔽”！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-形式参数（Formal-Parameters）"><a href="#2-3-形式参数（Formal-Parameters）" class="headerlink" title="2.3 形式参数（Formal Parameters）"></a><strong>2.3 形式参数（Formal Parameters）</strong></h3><ul><li><strong>位置</strong>：函数定义的参数列表  </li><li><strong>寿命</strong>：函数被调用时“出生”，函数结束“死亡”💀  </li><li><strong>特点</strong>：本质是函数的<strong>局部变量</strong>，优先于全局变量</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">99</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">// 形式参数a是局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;参数a: %d\n&quot;</span>, a); <span class="comment">// 输出5，优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    check(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-变量初始化陷阱"><a href="#🌈-3-变量初始化陷阱" class="headerlink" title="🌈 3. 变量初始化陷阱"></a><strong>🌈 3. 变量初始化陷阱</strong></h2><table><thead><tr><th>变量类型</th><th>默认初始值</th><th>必须手动初始化？</th></tr></thead><tbody><tr><td><strong>全局变量</strong></td><td>0（int）、0.0（float）等</td><td>否 ✅</td></tr><tr><td><strong>局部变量</strong></td><td>随机值（垃圾值）🗑️</td><td>是 ❗</td></tr></tbody></table><p>🌰 <strong>例子</strong>：未初始化的局部变量导致问题  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// 输出随机值，可能是-32421、0等！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❌ <strong>危险代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">// sum未初始化，结果不可预测！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum); <span class="comment">// 可能是奇怪的数值！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确做法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 初始化！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">// 正确累加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-内存中的变量存储"><a href="#🌈-4-内存中的变量存储" class="headerlink" title="🌈 4. 内存中的变量存储"></a><strong>🌈 4. 内存中的变量存储</strong></h2><table><thead><tr><th>变量类型</th><th>存储位置</th><th>特点</th></tr></thead><tbody><tr><td><strong>全局变量</strong></td><td>全局&#x2F;静态存储区</td><td>程序整个生命周期存在</td></tr><tr><td><strong>局部变量</strong></td><td>栈区（Stack）</td><td>函数结束时自动释放</td></tr></tbody></table><p>🌰 <strong>比喻</strong>：  </p><ul><li><strong>全局变量</strong> → 公共储物柜🗄️，随时存取  </li><li><strong>局部变量</strong> → 临时寄存柜📦，用后清空</li></ul><hr><h2 id="🌈-5-综合练习：测测你掌握了吗？"><a href="#🌈-5-综合练习：测测你掌握了吗？" class="headerlink" title="🌈 5. 综合练习：测测你掌握了吗？"></a><strong>🌈 5. 综合练习：测测你掌握了吗？</strong></h2><h3 id="练习1：猜输出"><a href="#练习1：猜输出" class="headerlink" title="练习1：猜输出"></a><strong>练习1：猜输出</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：20 10  </p><hr><h3 id="练习2：找错误"><a href="#练习2：找错误" class="headerlink" title="练习2：找错误"></a><strong>练习2：找错误</strong></h3><p>以下代码有什么问题？如何修正？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printSum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 这里有问题！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误原因</strong>：<code>a</code>是<code>printSum</code>的局部变量，不能在<code>main</code>中使用<br><strong>修正</strong>：删除<code>printf(&quot;%d&quot;, a);</code>  </p><hr><h3 id="练习3：写代码"><a href="#练习3：写代码" class="headerlink" title="练习3：写代码"></a><strong>练习3：写代码</strong></h3><p>写一个函数<code>void updateGlobal()</code>，将全局变量<code>count</code>（初始为0）每次调用加1，并在<code>main</code>中调用3次后输出结果。  </p><p><strong>参考答案</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateGlobal</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    updateGlobal();</span><br><span class="line">    updateGlobal();</span><br><span class="line">    updateGlobal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count: %d&quot;</span>, count); <span class="comment">// 输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h2><ul><li><strong>局部变量</strong>：函数内部的小秘密，用完即焚 🔥  </li><li><strong>全局变量</strong>：全程序的公共财产，谨慎使用 ⚠️  </li><li><strong>形式参数</strong>：函数的“临时工”，优先级最高 🥇  </li><li><strong>初始化</strong>：局部变量必须手动初始化，否则后果自负！</li></ul><p><strong>记住</strong>：作用域是变量的“活动范围”，超出范围就会“消失”！多写代码多调试，变量作用域不再迷路！ 🧭💻</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>👇😊 <strong>C语言函数超超详细讲解！新手保姆级教程！</strong> 😊👇</p><hr><h3 id="🌈-0-为什么要学函数？"><a href="#🌈-0-为什么要学函数？" class="headerlink" title="🌈 0. 为什么要学函数？"></a><strong>🌈 0. 为什么要学函数？</strong></h3><p>想象你要盖一座房子🏠：</p><ul><li>如果所有砖头、水泥、电线都堆在一起，你会疯掉！</li><li><strong>函数</strong>就像提前做好的“预制件”：窗户、门、楼梯… 随用随拿，<strong>代码复用</strong>！</li></ul><p><strong>举个栗子🌰</strong>：<br>你需要<strong>10次</strong>计算两个数的最大值，如果不用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1次计算</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) max = a; <span class="keyword">else</span> max = b; </span><br><span class="line"><span class="comment">// 第2次计算</span></span><br><span class="line"><span class="keyword">if</span>(c &gt; d) max = c; <span class="keyword">else</span> max = d; </span><br><span class="line"><span class="comment">// ...重复10次！😫</span></span><br></pre></td></tr></table></figure><p>用函数后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> (x &gt; y) ? x : y; &#125; <span class="comment">// 定义一次</span></span><br><span class="line"><span class="comment">// 调用10次！</span></span><br><span class="line">max(a, b); </span><br><span class="line">max(c, d); </span><br><span class="line"><span class="comment">// ...清爽！✨</span></span><br></pre></td></tr></table></figure><hr><h3 id="🌈-1-解剖函数：从“头”到“脚”"><a href="#🌈-1-解剖函数：从“头”到“脚”" class="headerlink" title="🌈 1. 解剖函数：从“头”到“脚”"></a><strong>🌈 1. 解剖函数：从“头”到“脚”</strong></h3><h4 id="1-1-函数头（Function-Header）"><a href="#1-1-函数头（Function-Header）" class="headerlink" title="1.1 函数头（Function Header）"></a><strong>1.1 函数头（Function Header）</strong></h4><p>就像人的“身份证”🆔，告诉编译器：“我是谁，我能做什么”<br>📝 <strong>格式</strong>：<code>返回类型 函数名(参数类型1 参数1, 参数类型2 参数2...)</code><br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回int | 函数名max | 参数int a, int b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br></pre></td></tr></table></figure><h4 id="1-2-函数体（Function-Body）"><a href="#1-2-函数体（Function-Body）" class="headerlink" title="1.2 函数体（Function Body）"></a><strong>1.2 函数体（Function Body）</strong></h4><p>大括号 <code>&#123;&#125;</code> 里的代码是函数的“内脏”🧠，负责具体干活！<br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line">   result = (a &gt; b) ? a : b; <span class="comment">// 三目运算符简化</span></span><br><span class="line">   <span class="keyword">return</span> result; <span class="comment">// 必须返回与声明类型一致的值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-重要细节："><a href="#1-3-重要细节：" class="headerlink" title="1.3 重要细节："></a><strong>1.3 重要细节</strong>：</h4><ul><li><strong>返回值</strong>：如果函数声明为 <code>void</code>（无返回值），<strong>不能</strong>写 <code>return 值;</code>！</li><li><strong>参数列表</strong>：可以是0个或多个参数，用逗号分隔，每个参数必须指明类型！</li></ul><hr><h3 id="🌈-2-函数声明-vs-函数定义：别搞混！"><a href="#🌈-2-函数声明-vs-函数定义：别搞混！" class="headerlink" title="🌈 2. 函数声明 vs 函数定义：别搞混！"></a><strong>🌈 2. 函数声明 vs 函数定义：别搞混！</strong></h3><table><thead><tr><th></th><th><strong>函数声明</strong></th><th><strong>函数定义</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>告诉编译器“这个函数存在”👋</td><td>告诉编译器“这个函数具体怎么做”💪</td></tr><tr><td><strong>位置</strong></td><td>通常在头文件<code>.h</code>或代码开头</td><td>在源文件<code>.c</code>中</td></tr><tr><td><strong>格式</strong></td><td><code>int max(int, int);</code> （分号结尾）</td><td><code>int max(int a, int b) &#123; ... &#125;</code></td></tr></tbody></table><h4 id="❌-致命错误示例："><a href="#❌-致命错误示例：" class="headerlink" title="❌ 致命错误示例："></a><strong>❌ 致命错误示例</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误1：声明和定义参数类型不一致！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; ... &#125; <span class="comment">// 定义 → 编译错误！🚨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误2：忘记声明函数，直接调用！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = max(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 编译器：max是谁？我不认识！→ 报错！😱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-3-参数传递：值传递-vs-指针传递（超重要！）"><a href="#🌈-3-参数传递：值传递-vs-指针传递（超重要！）" class="headerlink" title="🌈 3. 参数传递：值传递 vs 指针传递（超重要！）"></a><strong>🌈 3. 参数传递：值传递 vs 指针传递（超重要！）</strong></h3><h4 id="3-1-值传递（默认）"><a href="#3-1-值传递（默认）" class="headerlink" title="3.1 值传递（默认）"></a><strong>3.1 值传递（默认）</strong></h4><ul><li><strong>原理</strong>：把变量的值复制一份给函数，<strong>原变量不受影响</strong><br>🌰 <strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    x = <span class="number">100</span>; <span class="comment">// 修改的是副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    change(a); <span class="comment">// 把5复制给x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出5，a没变！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-指针传递（引用传递）"><a href="#3-2-指针传递（引用传递）" class="headerlink" title="3.2 指针传递（引用传递）"></a><strong>3.2 指针传递（引用传递）</strong></h4><ul><li><strong>原理</strong>：传递变量的地址，函数内可直接修改原变量<br>🌰 <strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *x)</span> &#123; <span class="comment">// 参数是指针</span></span><br><span class="line">    *x = <span class="number">100</span>; <span class="comment">// 通过地址修改原值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    change(&amp;a); <span class="comment">// 传递a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出100！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="❌-常见错误："><a href="#❌-常见错误：" class="headerlink" title="❌ 常见错误："></a><strong>❌ 常见错误</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：试图在值传递中修改原变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp; <span class="comment">// 交换的是副本，原变量不变！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">    swap(x, y); <span class="comment">// 调用后x还是1，y还是2！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：用指针传递！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp; <span class="comment">// 成功交换！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-4-作用域：变量能活多久？"><a href="#🌈-4-作用域：变量能活多久？" class="headerlink" title="🌈 4. 作用域：变量能活多久？"></a><strong>🌈 4. 作用域：变量能活多久？</strong></h3><ul><li><p><strong>局部变量</strong>：函数内部定义的变量，<strong>只能在函数内使用</strong>，函数结束就“死亡”💀<br>🌰 <strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// 报错！local不存在！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>：在函数外定义的变量，<strong>所有函数都可以访问</strong><br>🌰 <strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global = <span class="number">20</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// 输出20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    global = <span class="number">30</span>; <span class="comment">// 修改全局变量</span></span><br><span class="line">    func(); <span class="comment">// 输出30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="❌-危险操作：局部变量同名覆盖全局变量！"><a href="#❌-危险操作：局部变量同名覆盖全局变量！" class="headerlink" title="❌ 危险操作：局部变量同名覆盖全局变量！"></a><strong>❌ 危险操作</strong>：局部变量同名覆盖全局变量！</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">50</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num); <span class="comment">// 输出50，全局变量被“遮盖”！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-5-综合练习：动手巩固知识！"><a href="#🌈-5-综合练习：动手巩固知识！" class="headerlink" title="🌈 5. 综合练习：动手巩固知识！"></a><strong>🌈 5. 综合练习：动手巩固知识！</strong></h3><h4 id="练习1：温度转换函数"><a href="#练习1：温度转换函数" class="headerlink" title="练习1：温度转换函数"></a><strong>练习1：温度转换函数</strong></h4><p>写一个函数 <code>float celsiusToFahrenheit(float celsius)</code>，将摄氏温度转换为华氏温度（公式：<code>华氏度 = 摄氏度 × 9/5 + 32</code>）</p><h4 id="练习2：数组求和"><a href="#练习2：数组求和" class="headerlink" title="练习2：数组求和"></a><strong>练习2：数组求和</strong></h4><p>写一个函数 <code>int arraySum(int arr[], int size)</code>，计算整型数组的和</p><h4 id="练习3：错误找茬"><a href="#练习3：错误找茬" class="headerlink" title="练习3：错误找茬"></a><strong>练习3：错误找茬</strong></h4><p>找出以下代码中的错误并修正：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h3><h4 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">celsiusToFahrenheit</span><span class="params">(<span class="type">float</span> celsius)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> celsius * <span class="number">9.0</span> / <span class="number">5.0</span> + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">arraySum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h4><p><strong>错误</strong>：在 <code>main</code> 函数中调用了未声明的 <code>add</code> 函数<br><strong>修正</strong>：在 <code>main</code> 前添加函数声明  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">// 添加声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...原代码不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h3><ul><li>函数是代码复用的核心，避免重复造轮子！</li><li><strong>声明</strong>是预告片，<strong>定义</strong>是正片，两者参数类型必须一致！</li><li><strong>值传递</strong>复制值，<strong>指针传递</strong>操作原变量！</li><li>变量作用域决定了它的“生命周期”⏳</li></ul><p>遇到问题就多写代码，<strong>调试是学习编程的最佳途径</strong>！💻✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言循环</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="🔄-C语言循环——编程中的「重复劳动小助手」"><a href="#🔄-C语言循环——编程中的「重复劳动小助手」" class="headerlink" title="🔄 C语言循环——编程中的「重复劳动小助手」"></a>🔄 <strong>C语言循环——编程中的「重复劳动小助手」</strong></h1><p>循环就像洗碗机👩🍳，自动重复执行任务直到完成！下面用最有趣的方式拆解循环结构！</p><hr><h2 id="一、循环类型——三种「洗碗模式」"><a href="#一、循环类型——三种「洗碗模式」" class="headerlink" title="一、循环类型——三种「洗碗模式」"></a>一、<strong>循环类型——三种「洗碗模式」</strong></h2><h4 id="1-while循环——先检查再洗碗"><a href="#1-while循环——先检查再洗碗" class="headerlink" title="1. while循环——先检查再洗碗"></a>1. <strong>while循环——先检查再洗碗</strong></h4><p><strong>特点</strong>：先看碗脏不脏，再决定洗不洗<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 脏碗数量 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(脏碗数量 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;洗了1个碗🍽️\n&quot;</span>);</span><br><span class="line">    脏碗数量--; <span class="comment">// 别忘更新条件，否则无限循环！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-for循环——精确定时洗碗"><a href="#2-for循环——精确定时洗碗" class="headerlink" title="2. for循环——精确定时洗碗"></a>2. <strong>for循环——精确定时洗碗</strong></h3><p><strong>特点</strong>：明确知道要洗多少次<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次洗碗\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">第1次洗碗</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">第5次洗碗 */</span></span><br></pre></td></tr></table></figure><p><strong>for循环三要素</strong>：  </p><ul><li><strong>初始化</strong>：设置起点（<code>i=1</code>）  </li><li><strong>条件</strong>：循环继续的条件（<code>i&lt;=5</code>）  </li><li><strong>更新</strong>：每次循环后的操作（<code>i++</code>）</li></ul><hr><h3 id="3-do…while循环——先洗一次再检查"><a href="#3-do…while循环——先洗一次再检查" class="headerlink" title="3. do…while循环——先洗一次再检查"></a>3. <strong>do…while循环——先洗一次再检查</strong></h3><p><strong>特点</strong>：至少执行一次，适合先行动再判断<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 先执行代码</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件);</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 水杯状态;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冲洗水杯🚰\n&quot;</span>);</span><br><span class="line">    水杯状态 = 检查是否干净(); </span><br><span class="line">&#125; <span class="keyword">while</span>(水杯状态 == 脏);</span><br></pre></td></tr></table></figure><hr><h2 id="二、循环控制——「紧急按钮」和「跳过键」"><a href="#二、循环控制——「紧急按钮」和「跳过键」" class="headerlink" title="二、循环控制——「紧急按钮」和「跳过键」"></a>二、<strong>循环控制——「紧急按钮」和「跳过键」</strong></h2><table><thead><tr><th>控制语句</th><th>作用</th><th>生活类比</th></tr></thead><tbody><tr><td><code>break</code></td><td>立刻终止整个循环</td><td>洗碗中途停电⚡，直接停止</td></tr><tr><td><code>continue</code></td><td>跳过本次循环，继续下次</td><td>跳过破损的碗，洗下一个</td></tr><tr><td><code>goto</code></td><td>跳转到指定标签（慎用❗）</td><td>突然跑去擦桌子，打乱流程🗑️</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过第3次</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">8</span>) <span class="keyword">break</span>;    <span class="comment">// 到第8次停止</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次洗碗\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：1 2 4 5 6 7 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、无限循环——永不停止的洗碗机"><a href="#三、无限循环——永不停止的洗碗机" class="headerlink" title="三、无限循环——永不停止的洗碗机"></a>三、<strong>无限循环——永不停止的洗碗机</strong></h2><p><strong>应用场景</strong>：服务器监听请求、游戏主循环<br><strong>创建方式</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：for循环留空条件</span></span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;一直洗...🌀\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：while(1)</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;根本停不下来！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>必须包含能退出循环的<code>break</code>条件，否则程序卡死！  </li><li>按<code>Ctrl+C</code>强制终止程序</li></ul><hr><h2 id="四、嵌套循环——洗碗-擦碗组合"><a href="#四、嵌套循环——洗碗-擦碗组合" class="headerlink" title="四、嵌套循环——洗碗+擦碗组合"></a>四、<strong>嵌套循环——洗碗+擦碗组合</strong></h2><p><strong>作用</strong>：循环内包含另一个循环（像俄罗斯套娃）  </p><p><strong>示例</strong>：洗3个碗，每个碗擦2遍  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> 碗=<span class="number">1</span>; 碗&lt;=<span class="number">3</span>; 碗++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始洗第%d个碗\n&quot;</span>, 碗);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> 擦=<span class="number">1</span>; 擦&lt;=<span class="number">2</span>; 擦++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  第%d次擦拭\n&quot;</span>, 擦);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>忘记更新循环变量</strong> → 无限循环！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">5</span>) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;卡在这里了！&quot;</span>);</span><br><span class="line">    <span class="comment">// 漏写i++ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>误用<code>=</code>代替<code>==</code></strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x = <span class="number">1</span>) &#123; <span class="comment">// ❌ 总是真！应写x==1</span></span><br><span class="line">    <span class="comment">// 无限执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do…while忘记分号</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; ... &#125; <span class="keyword">while</span>(条件) <span class="comment">// ❌ 漏写分号！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><ol><li><strong>打印九九乘法表</strong>（使用嵌套for循环）  </li><li><strong>用户输入验证</strong>：直到输入正确数字才退出循环（do…while）</li></ol><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>循环三兄弟，各有各脾气。<br>while先查再执行，for精确控制行。<br>do…while至少走一次，控制语句要分清。<br>break彻底停，continue跳不停。<br>无限循环谨慎用，嵌套组合更聪明！  </p></blockquote><p>掌握这些循环技巧，让你的代码像智能家电一样高效运转！🤖✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言判断</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%88%A4%E6%96%AD/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="🚦-C语言判断结构——程序中的「红绿灯」"><a href="#🚦-C语言判断结构——程序中的「红绿灯」" class="headerlink" title="🚦 C语言判断结构——程序中的「红绿灯」"></a>🚦 <strong>C语言判断结构——程序中的「红绿灯」</strong></h1><p>判断结构让程序像交通信号灯一样，根据不同条件决定执行哪段代码。就像“红灯停🚦，绿灯行🚗”，程序也需要根据条件做出选择！</p><hr><h2 id="一、if-语句——单条件检查"><a href="#一、if-语句——单条件检查" class="headerlink" title="一、if 语句——单条件检查"></a>一、<strong>if 语句——单条件检查</strong></h2><p><strong>作用</strong>：如果条件成立，就执行代码块<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 下雨 = <span class="number">1</span>; <span class="comment">// 1表示下雨</span></span><br><span class="line"><span class="keyword">if</span>(下雨) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;带伞☔&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、if-else-语句——二选一"><a href="#二、if-else-语句——二选一" class="headerlink" title="二、if-else 语句——二选一"></a>二、<strong>if-else 语句——二选一</strong></h2><p><strong>作用</strong>：条件成立执行A，否则执行B<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 温度 = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span>(温度 &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调❄️&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;吹风扇💨&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、嵌套-if——多层条件筛选"><a href="#三、嵌套-if——多层条件筛选" class="headerlink" title="三、嵌套 if——多层条件筛选"></a>三、<strong>嵌套 if——多层条件筛选</strong></h2><p><strong>作用</strong>：在条件内部再判断（像闯关游戏🎮）<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(条件<span class="number">2</span>) &#123; </span><br><span class="line">        <span class="comment">// 条件1和2都满足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 年龄 = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> 身高 = <span class="number">175</span>;</span><br><span class="line"><span class="keyword">if</span>(年龄 &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(身高 &gt;= <span class="number">170</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;可以玩过山车🎢&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、switch-语句——多选一开关"><a href="#四、switch-语句——多选一开关" class="headerlink" title="四、switch 语句——多选一开关"></a>四、<strong>switch 语句——多选一开关</strong></h2><p><strong>作用</strong>：根据变量值选择不同分支<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>: 代码; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>: 代码; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: 默认代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 菜单选项 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(菜单选项) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;汉堡🍔&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;披萨🍕&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;暂无选项&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>每个<code>case</code>后要加<code>break</code>，否则会继续执行下一个case（称为“穿透”）  </li><li><code>default</code>是可选的，处理未匹配的情况</li></ul><hr><h2 id="五、三元运算符-——快捷判断"><a href="#五、三元运算符-——快捷判断" class="headerlink" title="五、三元运算符 ? : ——快捷判断"></a>五、<strong>三元运算符 ? : ——快捷判断</strong></h2><p><strong>作用</strong>：简化if-else，适合简单赋值<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 = (条件) ? 值<span class="number">1</span> : 值<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 分数 = <span class="number">75</span>;</span><br><span class="line"><span class="type">char</span> 结果 = (分数 &gt;= <span class="number">60</span>) ? <span class="string">&#x27;✅&#x27;</span> : <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, 结果); <span class="comment">// 输出✅</span></span><br></pre></td></tr></table></figure><p><strong>等价于</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(分数 &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    结果 = <span class="string">&#x27;✅&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    结果 = <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>忘记大括号</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>); <span class="comment">// 无论条件如何，B都会执行！</span></span><br><span class="line"><span class="comment">// 正确写法：加&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>switch穿透问题</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="comment">// 漏写break → 会继续执行case2的代码！</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: ...</span><br></pre></td></tr></table></figure></li><li><p><strong>浮点数判断</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0.3</span>) &#123; ... &#125; <span class="comment">// ❌ 可能不成立！应改为范围判断</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><ol><li><p><strong>成绩等级判断</strong>：<br>输入分数，输出等级（A:90+, B:80-89, C:60-79, D:&lt;60）<br><strong>提示</strong>：使用<code>if-else if</code>或<code>switch</code></p></li><li><p><strong>计算折扣</strong>：<br>根据会员等级（1-3级）计算商品折扣（9折、8折、7折）<br><strong>提示</strong>：使用<code>switch</code></p></li></ol><hr><h3 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h3><blockquote><p>判断结构像路口，条件成立向左走。<br>if单闯else双，嵌套多层像迷宫。<br>switch多选break防穿透，三元运算简写牛。<br>非零为真零为假，逻辑清晰bug少！  </p></blockquote><p>掌握了这些判断结构，你的程序就能像智能导航一样灵活决策啦！🗺️🔀</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="🧮-C运算符大全——编程世界的「数学工具包」"><a href="#🧮-C运算符大全——编程世界的「数学工具包」" class="headerlink" title="🧮 C运算符大全——编程世界的「数学工具包」"></a>🧮 <strong>C运算符大全——编程世界的「数学工具包」</strong></h1><p>运算符就像程序员手中的魔法棒✨，能进行各种计算和判断。下面用最有趣的方式拆解所有运算符！</p><hr><h2 id="一、算术运算符——基础计算器-🧮"><a href="#一、算术运算符——基础计算器-🧮" class="headerlink" title="一、算术运算符——基础计算器 🧮"></a>一、<strong>算术运算符——基础计算器</strong> 🧮</h2><p><strong>作用</strong>：处理数字的加减乘除  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>3 + 5 → 8</code></td><td>苹果🍎 + 香蕉🍌 &#x3D; 总水果数</td></tr><tr><td><code>-</code></td><td>减法</td><td><code>10 - 4 → 6</code></td><td>钱包💰减掉支出 &#x3D; 剩余金额</td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>2 * 3 → 6</code></td><td>每人2块🍕，3人共需6块</td></tr><tr><td><code>/</code></td><td>除法</td><td><code>10 / 3 → 3</code></td><td>10块糖分3人，每人3块（整数除）</td></tr><tr><td><code>%</code></td><td>取余</td><td><code>10 % 3 → 1</code></td><td>10块糖分3人，剩下1块🍬</td></tr><tr><td><code>++</code></td><td>自增1</td><td><code>a++</code> vs <code>++a</code></td><td>先吃蛋糕🎂 vs 先加奶油再吃</td></tr><tr><td><code>--</code></td><td>自减1</td><td><code>b--</code> vs <code>--b</code></td><td>先喝奶茶🧋 vs 先减糖再喝</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 苹果 = <span class="number">5</span>;</span><br><span class="line">苹果++; <span class="comment">// 苹果变成6（相当于 苹果 = 苹果 + 1）</span></span><br><span class="line"><span class="type">int</span> 奶茶 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> 余量 = 奶茶--; <span class="comment">// 余量=10，奶茶变成9</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、关系运算符——比大小专家-⚖️"><a href="#二、关系运算符——比大小专家-⚖️" class="headerlink" title="二、关系运算符——比大小专家 ⚖️"></a>二、<strong>关系运算符——比大小专家</strong> ⚖️</h2><p><strong>作用</strong>：比较两个值的关系，返回真(1)或假(0)  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td><code>5 == 3 → 0</code></td><td>检查密码是否正确🗝️</td></tr><tr><td><code>!=</code></td><td>不等于</td><td><code>5 != 3 → 1</code></td><td>判断奶茶口味是否不同🧋</td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>5 &gt; 3 → 1</code></td><td>比较考试成绩📊</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>5 &lt; 3 → 0</code></td><td>判断年龄是否符合条件👶→👨</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>5 &gt;= 5 → 1</code></td><td>身高是否达标📏</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>5 &lt;= 3 → 0</code></td><td>体重是否超标⚖️</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 温度 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">if</span> (温度 &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调❄️&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;吹风扇💨&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、逻辑运算符——真假判官-🕵️♂️"><a href="#三、逻辑运算符——真假判官-🕵️♂️" class="headerlink" title="三、逻辑运算符——真假判官 🕵️♂️"></a>三、<strong>逻辑运算符——真假判官</strong> 🕵️♂️</h2><p><strong>作用</strong>：组合多个条件判断  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td><code>(A &amp;&amp; B)</code></td><td>双人合作任务👫→都同意才执行</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>逻辑或</td></tr><tr><td><code>!</code></td><td>逻辑非</td><td><code>!A</code></td><td>取反操作🔄→真变假，假变真</td></tr></tbody></table><p><strong>短路特性</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">0</span> &amp;&amp; <span class="number">10</span>/a &gt; <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="comment">// 不会崩溃！因为a!=0为假，后面不执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、位运算符——二进制操控师-🔧"><a href="#四、位运算符——二进制操控师-🔧" class="headerlink" title="四、位运算符——二进制操控师 🔧"></a>四、<strong>位运算符——二进制操控师</strong> 🔧</h2><p><strong>作用</strong>：直接操作二进制位  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子（A&#x3D;60&#x3D;0011 1100）</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>A &amp; 13 → 12 (0000 1100)</code></td></tr><tr><td>&#96;</td><td>&#96;</td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>A ^ 13 → 49 (0011 0001)</code></td></tr><tr><td><code>~</code></td><td>按位取反</td><td><code>~A → -61 (1100 0011)</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>A &lt;&lt; 2 → 240 (1111 0000)</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>A &gt;&gt; 2 → 15 (0000 1111)</code></td></tr></tbody></table><p><strong>生活场景</strong>：  </p><ul><li>权限控制：用位掩码管理用户权限🔐  </li><li>加密算法：异或操作用于简单加密🔒</li></ul><hr><h2 id="五、赋值运算符——快捷存钱罐-🐖"><a href="#五、赋值运算符——快捷存钱罐-🐖" class="headerlink" title="五、赋值运算符——快捷存钱罐 🐖"></a>五、<strong>赋值运算符——快捷存钱罐</strong> 🐖</h2><p><strong>作用</strong>：简化变量赋值操作  </p><table><thead><tr><th>运算符</th><th>例子</th><th>等价写法</th><th>生活类比</th></tr></thead><tbody><tr><td><code>=</code></td><td><code>a = 5</code></td><td><code>a = 5</code></td><td>存钱罐放入5元💰</td></tr><tr><td><code>+=</code></td><td><code>a += 3</code></td><td><code>a = a + 3</code></td><td>往存钱罐加3元</td></tr><tr><td><code>-=</code></td><td><code>a -= 2</code></td><td><code>a = a - 2</code></td><td>取出2元</td></tr><tr><td><code>*=</code></td><td><code>a *= 4</code></td><td><code>a = a * 4</code></td><td>钱翻4倍</td></tr><tr><td><code>/=</code></td><td><code>a /= 2</code></td><td><code>a = a / 2</code></td><td>钱平分两份</td></tr><tr><td><code>%=</code></td><td><code>a %= 3</code></td><td><code>a = a % 3</code></td><td>分钱后剩下的零钱</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 钱包 = <span class="number">100</span>;</span><br><span class="line">钱包 += <span class="number">50</span>;  <span class="comment">// 钱包 = 150</span></span><br><span class="line">钱包 /= <span class="number">2</span>;   <span class="comment">// 钱包 = 75</span></span><br></pre></td></tr></table></figure><hr><h2 id="六、杂项运算符——多功能瑞士军刀-🔪"><a href="#六、杂项运算符——多功能瑞士军刀-🔪" class="headerlink" title="六、杂项运算符——多功能瑞士军刀 🔪"></a>六、<strong>杂项运算符——多功能瑞士军刀</strong> 🔪</h2><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>作用</th></tr></thead><tbody><tr><td><code>sizeof()</code></td><td>获取变量&#x2F;类型大小</td><td><code>sizeof(int) → 4</code></td><td>查看数据占内存多少字节💾</td></tr><tr><td><code>&amp;</code></td><td>获取变量地址</td><td><code>&amp;a → 0x7ffe...</code></td><td>找到变量在内存中的门牌号🏠</td></tr><tr><td><code>*</code></td><td>指针运算符</td><td><code>*ptr → 访问指针指向的值</code></td><td>用地址打开对应的储物柜🗄️</td></tr><tr><td><code>?:</code></td><td>三元条件运算符</td><td><code>a &gt; b ? a : b</code></td><td>快速二选一（像自动售货机🤖）</td></tr></tbody></table><p><strong>三元运算符示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 最大温度 = (今天温度 &gt; 昨天温度) ? 今天 : 昨天;</span><br></pre></td></tr></table></figure><hr><h2 id="七、运算符优先级——计算顺序交通灯-🚥"><a href="#七、运算符优先级——计算顺序交通灯-🚥" class="headerlink" title="七、运算符优先级——计算顺序交通灯 🚥"></a>七、<strong>运算符优先级——计算顺序交通灯</strong> 🚥</h2><p><strong>口诀</strong>：  </p><blockquote><p>括号成员是老大；<br>单目运算排老二；<br>乘除余三加减四；<br>移位五来关系六；<br>等与不等排第七；<br>位与异或位或八九十；<br>逻辑或和与；<br>条件赋值逗号垫底。  </p></blockquote><p><strong>优先级表速记</strong>：  </p><ol><li><code>()</code> → 最优先  </li><li><code>!</code> <code>++</code> <code>--</code> <code>&amp;</code>（单目）  </li><li><code>*</code> <code>/</code> <code>%</code>  </li><li><code>+</code> <code>-</code>  </li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code>  </li><li><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>  </li><li><code>==</code> <code>!=</code>  </li><li><code>&amp;&amp;</code> → 逻辑与  </li><li><code>||</code> → 逻辑或  </li><li><code>=</code> <code>+=</code> 等赋值操作</li></ol><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">5</span> + <span class="number">3</span> * <span class="number">2</span>; <span class="comment">// 先乘后加 → 11</span></span><br><span class="line"><span class="type">int</span> result2 = (<span class="number">5</span> + <span class="number">3</span>) * <span class="number">2</span>; <span class="comment">// 先加后乘 → 16</span></span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>自增&#x2F;自减陷阱</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = a++ + ++a; <span class="comment">// ❌ 结果不确定！避免同一变量多次自增</span></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点比较误差</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0.3</span>) &#123; <span class="comment">/* 可能不成立！应用范围判断 */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑与&#x2F;或短路</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span> &amp;&amp; *ptr &gt; <span class="number">0</span>) &#123; <span class="comment">/* 安全访问 */</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><p><strong>题目</strong>：用三元运算符判断成绩是否及格  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 分数 = <span class="number">75</span>;</span><br><span class="line"><span class="type">char</span> 结果 = (分数 &gt;= <span class="number">60</span>) ? <span class="string">&#x27;✅&#x27;</span> : <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, 结果); <span class="comment">// 输出✅</span></span><br></pre></td></tr></table></figure><p><strong>题目</strong>：位运算实现权限控制  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 读权限 0b001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写权限 0b010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 执行权限 0b100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> 用户权限 = 读权限 | 写权限; <span class="comment">// 0b011</span></span><br><span class="line"><span class="keyword">if</span> (用户权限 &amp; 写权限) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可编辑📝&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>掌握这些运算符，你就能像操控魔法一样编写程序啦！🎮 遇到问题随时复习这张”运算符地图”🗺️</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言存储类</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="🗂️-C存储类——变量的「职场身份」管理"><a href="#🗂️-C存储类——变量的「职场身份」管理" class="headerlink" title="🗂️ C存储类——变量的「职场身份」管理"></a>🗂️ <strong>C存储类——变量的「职场身份」管理</strong></h1><p>存储类决定变量在哪工作（内存位置）、工作多久（生命周期）、能去哪（作用域）。就像员工分为临时工、常驻员工、跨部门协作者，变量也有不同”职场身份”！🚀</p><hr><h2 id="一、auto存储类——默认的「临时工」"><a href="#一、auto存储类——默认的「临时工」" class="headerlink" title="一、auto存储类——默认的「临时工」"></a>一、<strong>auto存储类——默认的「临时工」</strong></h2><p><strong>特点</strong>：  </p><ul><li>所有局部变量默认是<code>auto</code>（可省略不写）  </li><li><strong>生命周期</strong>：函数开始时出生，函数结束被销毁  </li><li><strong>作用域</strong>：仅限于函数内部</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数() &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> 临时工 = <span class="number">10</span>; <span class="comment">// 等价于 int 临时工 = 10;</span></span><br><span class="line">    <span class="type">int</span> 另一个临时工 = <span class="number">20</span>; <span class="comment">// auto是默认的，不用写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像快餐店小时工，随叫随到，下班就离开</li></ul><hr><h2 id="二、register存储类——「VIP快速通道」"><a href="#二、register存储类——「VIP快速通道」" class="headerlink" title="二、register存储类——「VIP快速通道」"></a>二、<strong>register存储类——「VIP快速通道」</strong></h2><p><strong>特点</strong>：  </p><ul><li>请求将变量存储在寄存器（非内存），访问更快  </li><li><strong>不能取地址</strong>（因为不在内存）→ <code>&amp;变量</code> 会报错  </li><li>实际是否存寄存器由编译器决定</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 计算() &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> 计数器 = <span class="number">0</span>; <span class="comment">// 频繁使用的变量</span></span><br><span class="line">    <span class="keyword">while</span>(计数器 &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        计数器++; <span class="comment">// 快速访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>只用于<strong>频繁访问的小变量</strong>（如循环计数器）  </li><li>寄存器空间有限，申请太多可能无效</li></ul><p><strong>生活类比</strong>：  </p><ul><li>像银行VIP窗口，处理速度快但席位有限</li></ul><hr><h2 id="三、static存储类——「常驻员工」"><a href="#三、static存储类——「常驻员工」" class="headerlink" title="三、static存储类——「常驻员工」"></a>三、<strong>static存储类——「常驻员工」</strong></h2><p><strong>特点</strong>：  </p><ul><li><strong>局部变量</strong>：函数调用间保持值，只初始化一次  </li><li><strong>全局变量</strong>：限制作用域到当前文件</li></ul><h3 id="1-静态局部变量"><a href="#1-静态局部变量" class="headerlink" title="1. 静态局部变量"></a>1. <strong>静态局部变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 计数器函数() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> 计数 = <span class="number">0</span>; <span class="comment">// 只初始化一次！</span></span><br><span class="line">    计数++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用次数：%d&quot;</span>, 计数);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    计数器函数(); <span class="comment">// 输出1</span></span><br><span class="line">    计数器函数(); <span class="comment">// 输出2</span></span><br><span class="line">    计数器函数(); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像办公室里的保险箱，每次使用后内容保留</li></ul><h3 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2. 静态全局变量"></a>2. <strong>静态全局变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> 秘密数字 = <span class="number">42</span>; <span class="comment">// 只在当前文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 秘密数字; <span class="comment">// ❌ 错误！无法访问其他文件的static全局变量</span></span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像部门机密文件，其他部门无权查看</li></ul><hr><h2 id="四、extern存储类——「跨部门协作者」"><a href="#四、extern存储类——「跨部门协作者」" class="headerlink" title="四、extern存储类——「跨部门协作者」"></a>四、<strong>extern存储类——「跨部门协作者」</strong></h2><p><strong>特点</strong>：  </p><ul><li>声明在其他文件中定义的全局变量  </li><li><strong>不分配内存</strong>，只是引用已有变量</li></ul><p><strong>多文件示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件1.c */</span></span><br><span class="line"><span class="type">int</span> 全局员工数 = <span class="number">100</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件2.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 全局员工数; <span class="comment">// 声明：借用其他文件的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 打印员工数() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总数：%d&quot;</span>, 全局员工数); <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像分公司共享总部数据，无需重复创建</li></ul><hr><h2 id="🔍-存储类对比表"><a href="#🔍-存储类对比表" class="headerlink" title="🔍 存储类对比表"></a>🔍 <strong>存储类对比表</strong></h2><table><thead><tr><th><strong>存储类</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>函数内</td><td>函数执行期间</td><td>局部临时变量</td></tr><tr><td><code>register</code></td><td>函数内</td><td>函数执行期间</td><td>高频访问的小变量</td></tr><tr><td><code>static</code></td><td>文件或函数内</td><td>程序整个运行期</td><td>保持状态的局部变量</td></tr><tr><td><code>extern</code></td><td>跨文件</td><td>程序整个运行期</td><td>共享全局变量</td></tr></tbody></table><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>register变量取地址</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x; <span class="comment">// ❌ 错误！无法取寄存器变量地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重复定义extern变量</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1.c</span></span><br><span class="line"><span class="type">int</span> 全局变量 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2.c</span></span><br><span class="line"><span class="type">int</span> 全局变量 = <span class="number">20</span>; <span class="comment">// ❌ 重复定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 全局变量; <span class="comment">// ✅ 正确声明</span></span><br></pre></td></tr></table></figure></li><li><p><strong>误解static局部变量初始化</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 只执行一次！</span></span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用x=2，第二次x=3...</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌰-实战示例——静态变量累计调用次数"><a href="#🌰-实战示例——静态变量累计调用次数" class="headerlink" title="🌰 实战示例——静态变量累计调用次数"></a>🌰 <strong>实战示例——静态变量累计调用次数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 记录调用() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> 次数 = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    次数++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数被调用了%d次\n&quot;</span>, 次数);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    记录调用(); <span class="comment">// 第1次</span></span><br><span class="line">    记录调用(); <span class="comment">// 第2次</span></span><br><span class="line">    记录调用(); <span class="comment">// 第3次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数被调用了1次  </span><br><span class="line">函数被调用了2次  </span><br><span class="line">函数被调用了3次  </span><br></pre></td></tr></table></figure><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>auto临时局部藏，默认写在函数旁。<br>register求速度，高频小量最适当。<br>static常住不销毁，全局文件内隐藏。<br>extern声明借变量，跨文件协作强。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常量</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="📌-C语言常量——不可变的固定值"><a href="#📌-C语言常量——不可变的固定值" class="headerlink" title="📌 C语言常量——不可变的固定值"></a>📌 <strong>C语言常量——不可变的固定值</strong></h1><p>常量就像刻在石头上的数字🔢，一旦定义就不能修改。下面用最有趣的方式拆解常量知识！</p><hr><h2 id="一、常量的种类——不同口味的「固定饼干」🍪"><a href="#一、常量的种类——不同口味的「固定饼干」🍪" class="headerlink" title="一、常量的种类——不同口味的「固定饼干」🍪"></a>一、<strong>常量的种类</strong>——不同口味的「固定饼干」🍪</h2><h3 id="1-整数常量-🔢"><a href="#1-整数常量-🔢" class="headerlink" title="1. 整数常量 🔢"></a>1. <strong>整数常量</strong> 🔢</h3><p><strong>写法</strong>：支持十进制、八进制、十六进制<br><strong>生活类比</strong>：  </p><ul><li>十进制：日常计数（<code>100</code>）  </li><li>八进制：前导<code>0</code>（<code>0123</code> → 十进制的83）  </li><li>十六进制：前导<code>0x</code>（<code>0xFF</code> → 十进制的255）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">85</span>;       <span class="comment">// 十进制 → 85  </span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0213</span>;     <span class="comment">// 八进制 → 139  </span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0x4B</span>;     <span class="comment">// 十六进制 → 75  </span></span><br></pre></td></tr></table></figure><p><strong>后缀小贴士</strong>：  </p><ul><li><code>L</code>或<code>l</code> → 长整型（<code>100L</code>）  </li><li><code>U</code>或<code>u</code> → 无符号（<code>30U</code>）</li></ul><hr><h3 id="2-浮点常量-🌊"><a href="#2-浮点常量-🌊" class="headerlink" title="2. 浮点常量 🌊"></a>2. <strong>浮点常量</strong> 🌊</h3><p><strong>写法</strong>：小数或科学计数法<br><strong>生活类比</strong>：  </p><ul><li>普通小数：<code>3.14</code>  </li><li>科学计数法：<code>2.5E3</code>（即2500.0）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14f</span>;    <span class="comment">// 加f表示float  </span></span><br><span class="line"><span class="type">double</span> big = <span class="number">1.23e5</span>; <span class="comment">// 科学计数法 → 123000.0  </span></span><br></pre></td></tr></table></figure><p><strong>常见错误</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">3.14</span>;   <span class="comment">// ❌ 默认是double，建议加f  </span></span><br><span class="line"><span class="type">double</span> y = <span class="number">5</span>E;    <span class="comment">// ❌ 指数不完整  </span></span><br></pre></td></tr></table></figure><hr><h3 id="3-字符常量-🔤"><a href="#3-字符常量-🔤" class="headerlink" title="3. 字符常量 🔤"></a>3. <strong>字符常量</strong> 🔤</h3><p><strong>写法</strong>：单引号包裹，支持转义符<br><strong>生活类比</strong>：  </p><ul><li>普通字符：<code>&#39;A&#39;</code>  </li><li>转义字符：<code>&#39;\n&#39;</code>（换行）、<code>&#39;\t&#39;</code>（制表符）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> newline = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">// 换行符  </span></span><br><span class="line"><span class="type">char</span> tab = <span class="string">&#x27;\t&#x27;</span>;           <span class="comment">// 制表符  </span></span><br><span class="line"><span class="type">char</span> backslash = <span class="string">&#x27;\\&#x27;</span>;     <span class="comment">// 表示一个反斜杠  </span></span><br></pre></td></tr></table></figure><p><strong>ASCII值转换</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;  </span><br><span class="line"><span class="type">int</span> ascii = (<span class="type">int</span>)c;   <span class="comment">// 转为ASCII值97  </span></span><br></pre></td></tr></table></figure><hr><h3 id="4-字符串常量-📜"><a href="#4-字符串常量-📜" class="headerlink" title="4. 字符串常量 📜"></a>4. <strong>字符串常量</strong> 📜</h3><p><strong>写法</strong>：双引号包裹，自动加<code>\0</code>结尾<br><strong>生活类比</strong>：  </p><ul><li>字符串像火车🚂，每个字符是车厢，<code>\0</code>是终点标志</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 实际存储：H e l l o \0  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好\t世界\n&quot;</span>); <span class="comment">// 输出带转义符的字符串  </span></span><br></pre></td></tr></table></figure><p><strong>多行写法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;Hello &quot;</span>  </span><br><span class="line">             <span class="string">&quot;World!&quot;</span>; <span class="comment">// 等同于&quot;Hello World!&quot;  </span></span><br></pre></td></tr></table></figure><hr><h2 id="二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️"><a href="#二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️" class="headerlink" title="二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️"></a>二、<strong>定义常量的两种方式</strong>——「替换贴纸」vs「只读标签」🏷️</h2><h3 id="1-define-预处理-✨"><a href="#1-define-预处理-✨" class="headerlink" title="1. #define 预处理 ✨"></a>1. <strong>#define 预处理</strong> ✨</h3><p><strong>特点</strong>：  </p><ul><li>简单文本替换（像代码里的贴纸）  </li><li>无类型检查  </li><li>作用域全局</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREETING <span class="string">&quot;你好！&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">double</span> area = PI * <span class="number">5</span> * <span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, GREETING);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>⚠️ 陷阱</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100;  <span class="comment">// ❌ 末尾不要加分号！  </span></span></span><br><span class="line"><span class="type">int</span> x = MAX * <span class="number">2</span>;  <span class="comment">// 替换后变成 100; * 2 → 语法错误  </span></span><br></pre></td></tr></table></figure><hr><h3 id="2-const-关键字-🔒"><a href="#2-const-关键字-🔒" class="headerlink" title="2. const 关键字 🔒"></a>2. <strong>const 关键字</strong> 🔒</h3><p><strong>特点</strong>：  </p><ul><li>类型安全（编译器会检查）  </li><li>有作用域限制（像局部标签）  </li><li>实际占用内存</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TAX = <span class="number">0.1f</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LOCAL_CONST = <span class="number">50</span>; <span class="comment">// 只在函数内有效  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>常见错误</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x;  </span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// ❌ 必须定义时初始化！  </span></span><br></pre></td></tr></table></figure><hr><h2 id="三、define-vs-const-大比拼-🥊"><a href="#三、define-vs-const-大比拼-🥊" class="headerlink" title="三、define vs const 大比拼 🥊"></a>三、<strong>define vs const 大比拼</strong> 🥊</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>#define</strong> ✨</th><th><strong>const</strong> 🔒</th></tr></thead><tbody><tr><td><strong>类型检查</strong></td><td>❌ 无</td><td>✅ 有</td></tr><tr><td><strong>作用域</strong></td><td>全局</td><td>局部&#x2F;全局</td></tr><tr><td><strong>内存占用</strong></td><td>无（文本替换）</td><td>有</td></tr><tr><td><strong>调试</strong></td><td>难（替换后看不到原名）</td><td>易（保留变量名）</td></tr></tbody></table><p><strong>总结</strong>：  </p><ul><li>推荐多用<code>const</code>（更安全、易调试）  </li><li><code>#define</code>适合简单替换或跨文件常量</li></ul><hr><h2 id="四、实战避坑指南-🚧"><a href="#四、实战避坑指南-🚧" class="headerlink" title="四、实战避坑指南 🚧"></a>四、<strong>实战避坑指南</strong> 🚧</h2><h3 id="1-转义字符错误"><a href="#1-转义字符错误" class="headerlink" title="1. 转义字符错误"></a>1. <strong>转义字符错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;路径：C:\new\file.txt&quot;</span>); <span class="comment">// ❌ 输出乱码！  </span></span><br><span class="line"><span class="comment">// 正确写法：  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;路径：C:\\new\\file.txt&quot;</span>); <span class="comment">// ✅ 双反斜杠  </span></span><br></pre></td></tr></table></figure><h3 id="2-字符串忘记-0"><a href="#2-字符串忘记-0" class="headerlink" title="2. 字符串忘记\0"></a>2. <strong>字符串忘记\0</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">4</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;; <span class="comment">// ❌ 超出长度，无\0  </span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;             <span class="comment">// ✅ 自动补\0（长度5）  </span></span><br></pre></td></tr></table></figure><h3 id="3-八进制数字错误"><a href="#3-八进制数字错误" class="headerlink" title="3. 八进制数字错误"></a>3. <strong>八进制数字错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">089</span>; <span class="comment">// ❌ 八进制只能0~7！  </span></span><br></pre></td></tr></table></figure><hr><h2 id="五、常量的应用场景-🎯"><a href="#五、常量的应用场景-🎯" class="headerlink" title="五、常量的应用场景 🎯"></a>五、<strong>常量的应用场景</strong> 🎯</h2><ol><li><p><strong>固定配置</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_USERS 1000  </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TIMEOUT = <span class="number">30</span>;  </span><br></pre></td></tr></table></figure></li><li><p><strong>数学常数</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926535</span>;  </span><br></pre></td></tr></table></figure></li><li><p><strong>错误码定义</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_FILE_NOT_FOUND 404  </span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>常量不变值固定，类型不同用不同。<br>整数浮点字符串，转义字符要记清。<br>预处理或const选，安全类型选后者。<br>八进制前加个0，十六进制0x明。  </p></blockquote><hr><p><strong>考考你</strong> 🤔  </p><ol><li><code>0x1A</code> 的十进制值是多少？ → <strong>26</strong>  </li><li><code>const int x = 5; x = 10;</code> 合法吗？ → <strong>❌ 不合法</strong>  </li><li><code>#define</code>定义的常量能被调试吗？ → <strong>❌ 不能（替换后消失）</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言变量</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容将开始讲解一些关于变量的内容，如果你对之前内容还有不会的，可以回去再复习一下！</strong></p><h1 id="C程序变量"><a href="#C程序变量" class="headerlink" title="C程序变量"></a>C程序变量</h1><hr><h2 id="一、变量是什么？——「数据的快递盒」"><a href="#一、变量是什么？——「数据的快递盒」" class="headerlink" title="一、变量是什么？——「数据的快递盒」"></a>一、变量是什么？——「数据的快递盒」</h2><p>想象你有一个快递盒，这个盒子有 <strong>三个重要信息</strong>：</p><ol><li><strong>盒子名字</strong>（变量名）：比如「年龄盒」、「温度盒」</li><li><strong>盒子类型</strong>（数据类型）：决定能放什么（只能放数字？放小数？放文字？）</li><li><strong>盒子里装的东西</strong>（变量的值）：比如数字25、温度36.5</li></ol><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>; <span class="comment">// 创建一个叫age的整数盒，放数字25</span></span><br><span class="line"><span class="type">float</span> temperature = <span class="number">36.5f</span>; <span class="comment">// 温度盒，放小数36.5</span></span><br><span class="line"><span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 等级盒，放字母A</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、变量的定义——「买快递盒」"><a href="#二、变量的定义——「买快递盒」" class="headerlink" title="二、变量的定义——「买快递盒」"></a>二、变量的定义——「买快递盒」</h2><p><strong>步骤</strong>：告诉计算机你要什么类型、什么名字的盒子<br><strong>语法</strong>：<code>数据类型 变量名;</code><br><strong>重点</strong>：  </p><ul><li><strong>数据类型</strong>：就像盒子材质，决定能装什么（比如 <code>int</code> 盒子只能装整数）  </li><li><strong>变量名</strong>：盒子的标签，必须遵守起名规则（字母&#x2F;下划线开头，不含空格和特殊符号）</li></ul><p><strong>正确例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> student_age; <span class="comment">// 整数盒，名字是student_age</span></span><br><span class="line"><span class="type">float</span> _price;    <span class="comment">// 小数盒，名字是_price（下划线开头）</span></span><br></pre></td></tr></table></figure><p><strong>错误例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">3</span>students; <span class="comment">// ❌ 数字开头</span></span><br><span class="line"><span class="type">float</span> price$;  <span class="comment">// ❌ 包含特殊符号$</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、变量的赋值——「往盒子里放东西」"><a href="#三、变量的赋值——「往盒子里放东西」" class="headerlink" title="三、变量的赋值——「往盒子里放东西」"></a>三、变量的赋值——「往盒子里放东西」</h2><p><strong>两种方式</strong>：</p><ol><li><strong>定义时直接放</strong>（初始化）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>; <span class="comment">// 创建age盒，直接放18</span></span><br></pre></td></tr></table></figure></li><li><strong>先买盒子，后放东西</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;      <span class="comment">// 先买盒子（此时盒子里可能有垃圾）</span></span><br><span class="line">age = <span class="number">18</span>;     <span class="comment">// 再往盒子里放18</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>⚠️ 警告</strong>：  </p><ul><li><strong>局部变量</strong>（在函数内部定义的盒子）如果没放东西，打开时会看到<strong>随机垃圾值</strong>（可能引发bug！）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 没初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ 输出的是随机数！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、变量的类型——「盒子的种类」"><a href="#四、变量的类型——「盒子的种类」" class="headerlink" title="四、变量的类型——「盒子的种类」"></a>四、变量的类型——「盒子的种类」</h2><p>C语言常用的「盒子类型」：</p><table><thead><tr><th>类型</th><th>能装什么</th><th>例子</th><th>备注</th></tr></thead><tbody><tr><td><code>int</code></td><td>整数</td><td><code>int age = 20;</code></td><td>不带小数</td></tr><tr><td><code>float</code></td><td>小数（精度低）</td><td><code>float pi = 3.14f;</code></td><td>末尾加<code>f</code></td></tr><tr><td><code>double</code></td><td>小数（精度高）</td><td><code>double pi = 3.1415926;</code></td><td>默认小数类型</td></tr><tr><td><code>char</code></td><td>单个字符</td><td><code>char c = &#39;A&#39;;</code></td><td>用单引号包裹</td></tr></tbody></table><p><strong>特殊类型</strong>：</p><ul><li><code>void</code>：空盒子（不能装东西，用于特殊场合如函数返回值）  </li><li>其他复杂类型（数组、指针等）：后面章节解锁</li></ul><hr><h2 id="五、变量的作用域——「盒子在哪里能用？」"><a href="#五、变量的作用域——「盒子在哪里能用？」" class="headerlink" title="五、变量的作用域——「盒子在哪里能用？」"></a>五、变量的作用域——「盒子在哪里能用？」</h2><h3 id="1-全局变量：整个程序都能用的「公共快递柜」"><a href="#1-全局变量：整个程序都能用的「公共快递柜」" class="headerlink" title="1. 全局变量：整个程序都能用的「公共快递柜」"></a>1. <strong>全局变量</strong>：整个程序都能用的「公共快递柜」</h3><ul><li><strong>定义位置</strong>：函数外面  </li><li><strong>特点</strong>：默认初始化为0  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>; <span class="comment">// 全局变量，所有函数都能用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// ✅ 输出100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-局部变量：只能在某个函数里用的「私人快递盒」"><a href="#2-局部变量：只能在某个函数里用的「私人快递盒」" class="headerlink" title="2. 局部变量：只能在某个函数里用的「私人快递盒」"></a>2. <strong>局部变量</strong>：只能在某个函数里用的「私人快递盒」</h3><ul><li><strong>定义位置</strong>：函数内部  </li><li><strong>特点</strong>：不初始化会含垃圾值，函数结束后盒子销毁  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">50</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// ✅ 输出50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// ❌ 错误！main函数不认识local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六、变量的声明-vs-定义——「快递单-vs-真实包裹」"><a href="#六、变量的声明-vs-定义——「快递单-vs-真实包裹」" class="headerlink" title="六、变量的声明 vs 定义——「快递单 vs 真实包裹」"></a>六、变量的声明 vs 定义——「快递单 vs 真实包裹」</h2><h3 id="1-声明（Declaration）：告诉别人「这个盒子存在」"><a href="#1-声明（Declaration）：告诉别人「这个盒子存在」" class="headerlink" title="1. 声明（Declaration）：告诉别人「这个盒子存在」"></a>1. <strong>声明</strong>（Declaration）：告诉别人「这个盒子存在」</h3><ul><li><strong>语法</strong>：<code>extern 数据类型 变量名;</code>  </li><li><strong>作用</strong>：跨文件使用其他地方的变量（像借用别人的盒子）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>; <span class="comment">// 真实盒子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global; <span class="comment">// 声明：global盒子在别处</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// ✅ 输出100</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-定义（Definition）：实际创建盒子"><a href="#2-定义（Definition）：实际创建盒子" class="headerlink" title="2. 定义（Definition）：实际创建盒子"></a>2. <strong>定义</strong>（Definition）：实际创建盒子</h3><ul><li><strong>语法</strong>：<code>数据类型 变量名;</code>  </li><li><strong>特点</strong>：分配内存空间</li></ul><hr><h2 id="七、左值-vs-右值——「盒子本身-vs-盒子里的东西」"><a href="#七、左值-vs-右值——「盒子本身-vs-盒子里的东西」" class="headerlink" title="七、左值 vs 右值——「盒子本身 vs 盒子里的东西」"></a>七、左值 vs 右值——「盒子本身 vs 盒子里的东西」</h2><h3 id="1-左值（Lvalue）：能放在赋值左边的表达式"><a href="#1-左值（Lvalue）：能放在赋值左边的表达式" class="headerlink" title="1. 左值（Lvalue）：能放在赋值左边的表达式"></a>1. <strong>左值（Lvalue）</strong>：能放在赋值左边的表达式</h3><ul><li><strong>特点</strong>：有明确的内存位置（像快递盒本身）  </li><li><strong>例子</strong>：变量、数组元素  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// a是左值</span></span><br><span class="line">a = <span class="number">20</span>;     <span class="comment">// ✅ 正确：修改盒子的内容</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-右值（Rvalue）：只能放在赋值右边的表达式"><a href="#2-右值（Rvalue）：只能放在赋值右边的表达式" class="headerlink" title="2. 右值（Rvalue）：只能放在赋值右边的表达式"></a>2. <strong>右值（Rvalue）</strong>：只能放在赋值右边的表达式</h3><ul><li><strong>特点</strong>：临时值（像盒子里的物品）  </li><li><strong>例子</strong>：数字、计算结果  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = a + <span class="number">5</span>; <span class="comment">// (a+5)是右值</span></span><br><span class="line"><span class="number">10</span> = a;        <span class="comment">// ❌ 错误！不能给数字10赋值</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八、常见错误-调试技巧"><a href="#八、常见错误-调试技巧" class="headerlink" title="八、常见错误 &amp; 调试技巧"></a>八、常见错误 &amp; 调试技巧</h2><h3 id="1-变量名拼写错误"><a href="#1-变量名拼写错误" class="headerlink" title="1. 变量名拼写错误"></a>1. <strong>变量名拼写错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> studentAge = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, studentage); <span class="comment">// ❌ 大小写错误！</span></span><br></pre></td></tr></table></figure><h3 id="2-使用未初始化的局部变量"><a href="#2-使用未初始化的局部变量" class="headerlink" title="2. 使用未初始化的局部变量"></a>2. <strong>使用未初始化的局部变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ x是随机值！</span></span><br></pre></td></tr></table></figure><h3 id="3-类型不匹配"><a href="#3-类型不匹配" class="headerlink" title="3. 类型不匹配"></a>3. <strong>类型不匹配</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3.14</span>; <span class="comment">// ❌ 小数强制转整数（实际存3）</span></span><br><span class="line"><span class="type">float</span> b = <span class="number">10</span>; <span class="comment">// ✅ 整数转小数（自动转成10.0）</span></span><br></pre></td></tr></table></figure><h3 id="4-作用域错误"><a href="#4-作用域错误" class="headerlink" title="4. 作用域错误"></a>4. <strong>作用域错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ x只在func1里有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="九、练习：你来试试！"><a href="#九、练习：你来试试！" class="headerlink" title="九、练习：你来试试！"></a>九、练习：你来试试！</h2><ol><li><p><strong>题目1</strong>：修复以下代码的错误  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">1</span>st_place = <span class="number">100</span>;</span><br><span class="line"><span class="type">float</span> price = <span class="number">3.14</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Price);</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first_place = <span class="number">100</span>; <span class="comment">// 变量名不能数字开头</span></span><br><span class="line"><span class="type">float</span> price = <span class="number">3.14f</span>;   <span class="comment">// 缺少分号，float建议加f</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, price);   <span class="comment">// Price大小写不匹配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>题目2</strong>：以下代码输出什么？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global=%d, local=%d&quot;</span>, global, local);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：<br><code>global=0</code>（全局变量默认0），<code>local</code>的值不确定（随机垃圾值）</p></li></ol><hr><p>如果还有疑问，可以随时问我哦～ (•̀ω•́)✧</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C程序数据类型"><a href="#C程序数据类型" class="headerlink" title="C程序数据类型"></a>C程序数据类型</h1><p>咱们可以把 <strong>C语言的数据类型</strong> 想象成 <strong>不同规格的储物容器</strong>，用来存放各种数据。就像你存水用水杯、存书用书包一样，不同的数据类型对应不同的存储需求和大小</p><hr><h2 id="📦-数据类型——数据的「房子」"><a href="#📦-数据类型——数据的「房子」" class="headerlink" title="📦 数据类型——数据的「房子」"></a>📦 <strong>数据类型——数据的「房子」</strong></h2><p><strong>作用</strong>：决定数据在内存中占多大空间，能表示什么范围的数值。</p><hr><h2 id="🗂️-四大类「房子户型」"><a href="#🗂️-四大类「房子户型」" class="headerlink" title="🗂️ 四大类「房子户型」"></a>🗂️ <strong>四大类「房子户型」</strong></h2><ol><li><p><strong>基本类型（单身公寓）</strong>  </p><ul><li><strong>整型</strong>：存整数 → <code>int</code>（标准间）、<code>short</code>（小单间）、<code>long</code>（大平层）  </li><li><strong>字符型</strong>：存单个字符 → <code>char</code>（迷你仓，其实也是小整数）  </li><li><strong>浮点型</strong>：存小数 → <code>float</code>（普通水杯）、<code>double</code>（大桶水）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 年龄 = <span class="number">25</span>;          <span class="comment">// 整型：存年龄</span></span><br><span class="line"><span class="type">float</span> 体重 = <span class="number">65.5f</span>;     <span class="comment">// 浮点：存体重（带f表示float）</span></span><br><span class="line"><span class="type">char</span> 等级 = <span class="string">&#x27;A&#x27;</span>;        <span class="comment">// 字符：存成绩等级</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>枚举类型（VIP专属房）</strong>  </p><ul><li>只能存放预设的整数值（比如星期几、方向）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> &#123;</span> Mon=<span class="number">1</span>, Tue, Wed &#125;; <span class="comment">// 定义枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> 今天 =</span> Wed;           <span class="comment">// 今天=3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>void类型（隐形房）</strong>  </p><ul><li><strong>三副面孔</strong>：  <ul><li>函数不返回值 → <code>void 吃饭() &#123; ... &#125;</code>  </li><li>函数不需要参数 → <code>int 随机数(void) &#123; ... &#125;</code>  </li><li>万能指针（像万能钥匙，但要指定类型后才能用） → <code>void* 神秘地址;</code></li></ul></li></ul></li><li><p><strong>派生类型（组合别墅）</strong>  </p><ul><li>后续章节解锁：数组（一排连号房）、指针（门牌号）、结构体（套房）</li></ul></li></ol><hr><h3 id="🔢-整型「房型对比表」"><a href="#🔢-整型「房型对比表」" class="headerlink" title="🔢 整型「房型对比表」"></a>🔢 <strong>整型「房型对比表」</strong></h3><table><thead><tr><th>类型</th><th>存储空间</th><th>值范围（64位系统）</th><th>生活类比</th></tr></thead><tbody><tr><td><code>char</code></td><td>1字节</td><td>-128<del>127 或 0</del>255</td><td>小抽屉（存年龄）</td></tr><tr><td><code>unsigned int</code></td><td>4字节</td><td>0~4,294,967,295</td><td>超大储物箱</td></tr><tr><td><code>long</code></td><td>8字节</td><td>-9万亿~9万亿</td><td>仓库</td></tr></tbody></table><p><strong>📢 关键技巧</strong>  </p><ul><li>选类型就像选背包：<strong>够用就行</strong>，别浪费空间   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> 学生人数 = <span class="number">300</span>;  <span class="comment">// ✅ 0~65535足够</span></span><br><span class="line"><span class="type">short</span> 温度 = <span class="number">-30</span>;              <span class="comment">// ✅ 有符号存负数</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="🌊-浮点型「精度段位」"><a href="#🌊-浮点型「精度段位」" class="headerlink" title="🌊 浮点型「精度段位」"></a>🌊 <strong>浮点型「精度段位」</strong></h3><table><thead><tr><th>类型</th><th>存储空间</th><th>精度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>float</code></td><td>4字节</td><td>6~7位小数</td><td>日常测量（如体重）</td></tr><tr><td><code>double</code></td><td>8字节</td><td>15~16位小数</td><td>科学计算</td></tr><tr><td><code>long double</code></td><td>16字节</td><td>19位小数</td><td>超高精度需求</td></tr></tbody></table><p><strong>🌰 例子</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 圆周率 = <span class="number">3.141592653589793</span>; <span class="comment">// 高精度</span></span><br><span class="line"><span class="type">float</span> 身高 = <span class="number">1.75f</span>;                <span class="comment">// 普通精度</span></span><br></pre></td></tr></table></figure><hr><h3 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>整数溢出</strong> → 像水杯装满还硬倒：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 小杯子 = <span class="number">128</span>; <span class="comment">// ❌ char范围-128~127，128溢出成-128</span></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点精度陷阱</strong> → 别用<code>==</code>直接比较：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.3</span>) &#123; ... &#125; <span class="comment">// ❌ 可能失败！应用范围判断</span></span><br></pre></td></tr></table></figure></li><li><p><strong>忘记加<code>f</code>后缀</strong> → 默认是double：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 价格 = <span class="number">9.99</span>;   <span class="comment">// ❌ 9.99默认是double，转float可能丢失精度</span></span><br><span class="line"><span class="type">float</span> 正确价 = <span class="number">9.99f</span>; <span class="comment">// ✅ 加f明确是float</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="🔍-查看「房子」大小（sizeof神器）"><a href="#🔍-查看「房子」大小（sizeof神器）" class="headerlink" title="🔍 查看「房子」大小（sizeof神器）"></a>🔍 <strong>查看「房子」大小（sizeof神器）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int大小: %zu字节\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));      <span class="comment">// 输出4（64位系统）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double大小: %zu字节\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="💡-类型选择口诀"><a href="#💡-类型选择口诀" class="headerlink" title="💡 类型选择口诀"></a>💡 <strong>类型选择口诀</strong></h3><blockquote><p>整型看范围，浮点看精度，<br>日常用int&#x2F;double，省心又省力。<br>超大数字上long，负号别忘记，<br>字符本质是整数，存字母很容易！</p></blockquote><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>char 能存300吗？</code> → ❌ 最大255（unsigned char）  </li><li><code>5.0 默认是什么类型？</code> → ✅ double  </li><li><code>void* 指针能直接存整数吗？</code> → ❌ 需要强制转换类型，如<code>(void*)&amp;num</code></li></ol><p>咱们可以把<strong>类型转换</strong>想象成<strong>不同容器之间的倒水操作</strong>——比如把矿泉水倒进保温杯，或者把大桶水分装到小瓶子里。以下是通俗版解释：</p><hr><h2 id="🔄-类型转换——数据的「变形记」"><a href="#🔄-类型转换——数据的「变形记」" class="headerlink" title="🔄 类型转换——数据的「变形记」"></a>🔄 <strong>类型转换——数据的「变形记」</strong></h2><p><strong>作用</strong>：让不同类型的数据能一起工作，但要注意可能发生的数据丢失（像倒水时洒出来）。</p><hr><h3 id="🕵️♂️-两种转换方式"><a href="#🕵️♂️-两种转换方式" class="headerlink" title="🕵️♂️ 两种转换方式"></a>🕵️♂️ <strong>两种转换方式</strong></h3><ol><li><p><strong>隐式转换（自动倒水）</strong>  </p><ul><li><strong>规则</strong>：从小杯转大杯（系统自动帮你完成）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 小杯子 = <span class="number">100</span>;        <span class="comment">// 整型（4字节）</span></span><br><span class="line"><span class="type">float</span> 中杯子 = <span class="number">3.14f</span>;    <span class="comment">// 浮点（4字节）</span></span><br><span class="line"><span class="type">double</span> 大桶 = 小杯子 + 中杯子; <span class="comment">// ✅ 自动转成double计算（8字节）</span></span><br></pre></td></tr></table></figure></li><li><strong>风险</strong>：大杯转小杯可能溢出（但系统不会提醒你）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 瓶子 = <span class="number">3.14</span>; <span class="comment">// ✅ 合法，但会截断成3（像只留整数部分的水量）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显式转换（手动切割）</strong>  </p><ul><li><strong>规则</strong>：强制转换类型（像用模具切出指定形状）  </li><li><strong>语法</strong>：<code>(目标类型)数据</code>  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 精准身高 = <span class="number">175.8</span>;</span><br><span class="line"><span class="type">int</span> 大致身高 = (<span class="type">int</span>)精准身高; <span class="comment">// ✅ 砍掉小数，变成175</span></span><br></pre></td></tr></table></figure></li><li><strong>风险</strong>：数据可能被截断或失真  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 小瓶 = (<span class="type">char</span>)<span class="number">300</span>; <span class="comment">// ❌ char最大255，300转成44（溢出像水溢出杯子）</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活场景对比"><a href="#🌰-生活场景对比" class="headerlink" title="🌰 生活场景对比"></a>🌰 <strong>生活场景对比</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>隐式转换</strong></th><th><strong>显式转换</strong></th></tr></thead><tbody><tr><td><strong>混合计算</strong></td><td><code>int + float</code> 自动转<code>float</code></td><td>无</td></tr><tr><td><strong>精确控制结果类型</strong></td><td>无</td><td><code>double 价格 = (int)9.99 + 1; // 10</code></td></tr><tr><td><strong>处理函数参数类型</strong></td><td><code>sqrt(25)</code> 自动把int转double</td><td><code>sqrt((double)25)</code></td></tr></tbody></table><hr><h3 id="🚧-避坑指南-1"><a href="#🚧-避坑指南-1" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>浮点转整型丢失精度</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 温度 = <span class="number">36.6f</span>;</span><br><span class="line"><span class="type">int</span> 近似温度 = 温度; <span class="comment">// 隐式转成36（直接砍掉小数，不是四舍五入！）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>大类型转小类型溢出</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> 大数字 = <span class="number">2147483648L</span>; <span class="comment">// 假设long是8字节</span></span><br><span class="line"><span class="type">int</span> 小存储 = (<span class="type">int</span>)大数字;   <span class="comment">// ❌ 溢出成-2147483648（像大桶水灌炸小瓶）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>无符号和有符号混用</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> 库存 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> 销售量 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">if</span> (销售量 &gt; 库存) &#123; ... &#125; <span class="comment">// ✅ 隐式转无符号，可能导致逻辑错误！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="💡-类型转换口诀"><a href="#💡-类型转换口诀" class="headerlink" title="💡 类型转换口诀"></a>💡 <strong>类型转换口诀</strong></h3><blockquote><p>隐式转换系统帮，小杯转大杯无痕。<br>显式转换需手动，砍头去尾要谨慎。<br>浮点转整丢小数，大数化小会失真。<br>混用类型先统一，避免暗坑代码稳。</p></blockquote><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>(int)3.99</code>等于多少？ → <strong>3</strong>（直接砍掉小数）  </li><li><code>char c = 1.5 + 2.7;</code>中c的值？ → <strong>4</strong>（隐式转int&#x3D;4，再转char）  </li><li><code>int a = 5; double b = a/2;</code>b的值？ → <strong>2.0</strong>（先做整数除法5&#x2F;2&#x3D;2，再转double）<br><strong>修正方法</strong>：<code>double b = (double)a/2;</code> → 得到2.5</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础语法</title>
      <link href="/2025/02/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.toumatou.cn/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/">面向对象与面向过程</a>，本节我将正式开始讲解关于C程序的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C语言基础语法"><a href="#C语言基础语法" class="headerlink" title="C语言基础语法"></a>C语言基础语法</h1><p>C 语言是一种通用的编程语言，广泛应用于系统编程、嵌入式开发和高性能计算等领域。</p><p>C 语言具有高效、灵活、可移植性强等特点，是许多其他编程语言的基础。</p><p>在 C 语言中，令牌（Token）是程序的基本组成单位，编译器通过对源代码进行词法分析，将代码分解成一个个的令牌。</p><p>C 语言的令牌主要包括以下几种类型：</p><p><strong>关键字（Keywords）</strong><br><strong>标识符（Identifiers）</strong><br><strong>常量（Constants）</strong><br><strong>字符串字面量（String Literals）</strong><br><strong>运算符（Operators）</strong><br><strong>分隔符（Separators）</strong></p><h2 id="C程序的基本结构"><a href="#C程序的基本结构" class="headerlink" title="C程序的基本结构"></a>C程序的基本结构</h2><p>让我们用更生活化的比喻和简单语言来解释 C 程序的结构</p><h3 id="C-程序就像盖房子-🏠"><a href="#C-程序就像盖房子-🏠" class="headerlink" title="C 程序就像盖房子 🏠"></a>C 程序就像盖房子 🏠</h3><p>想象你要盖一个房子（写程序），需要按步骤准备材料和组织工人。C 程序的结构可以这样理解：</p><h4 id="1-准备工具包（头文件包含）"><a href="#1-准备工具包（头文件包含）" class="headerlink" title="1. 准备工具包（头文件包含）"></a>1. <strong>准备工具包（头文件包含）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 相当于从仓库借工具</span></span></span><br></pre></td></tr></table></figure><ul><li>就像盖房子需要先借电钻、锤子一样，<code>#include</code> 是告诉电脑：”我要用打印文字（<code>printf</code>）和读取输入（<code>scanf</code>）这些工具”。<code>stdio.h</code> 就是存放这些工具的工具箱。</li></ul><h4 id="2-贴便利贴（宏定义）"><a href="#2-贴便利贴（宏定义）" class="headerlink" title="2. 贴便利贴（宏定义）"></a>2. <strong>贴便利贴（宏定义）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159 <span class="comment">// 相当于在墙上贴个便利贴</span></span></span><br></pre></td></tr></table></figure><ul><li>你可以在墙上贴一张便利贴写着”PI&#x3D;3.14”，之后每次看到”PI”就直接替换成数字。<code>#define</code> 就是给常用的值起个简单名字，电脑会自动替换。</li></ul><h4 id="3-设计图纸（函数声明）"><a href="#3-设计图纸（函数声明）" class="headerlink" title="3. 设计图纸（函数声明）"></a>3. <strong>设计图纸（函数声明）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 提前告诉工人：&quot;我要一个加法器&quot;</span></span><br></pre></td></tr></table></figure><ul><li>就像先告诉工人”我要一个能加两个数的机器”，但具体怎么造先不说。函数声明就是提前告诉电脑：”后面会有一个叫<code>add</code>的函数，先记着它的样子”。</li></ul><h4 id="4-大门入口（主函数）"><a href="#4-大门入口（主函数）" class="headerlink" title="4. 大门入口（主函数）"></a>4. <strong>大门入口（主函数）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 这里写程序的主要动作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 最后交钥匙表示完工</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>main()</code> 是程序的”大门”，电脑从这里开始执行。<code>return 0;</code> 相当于最后说一句：”一切正常，结束啦！”</li></ul><h4 id="5-准备材料（变量声明）"><a href="#5-准备材料（变量声明）" class="headerlink" title="5. 准备材料（变量声明）"></a>5. <strong>准备材料（变量声明）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1, num2, sum; <span class="comment">// 准备三个盒子装数字</span></span><br></pre></td></tr></table></figure><ul><li>就像提前准备几个盒子（变量），贴上标签（变量名）用来存数字。在 C 语言中必须提前声明：”我要用这三个盒子装整数！”</li></ul><h4 id="6-具体操作（语句和函数调用）"><a href="#6-具体操作（语句和函数调用）" class="headerlink" title="6. 具体操作（语句和函数调用）"></a>6. <strong>具体操作（语句和函数调用）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入两个数字：&quot;</span>); <span class="comment">// 在屏幕上打印文字</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2); <span class="comment">// 读取用户输入的数字</span></span><br><span class="line">sum = add(num1, num2); <span class="comment">// 调用加法器计算结果</span></span><br></pre></td></tr></table></figure><ul><li>这些就像具体的施工步骤：先贴告示让用户输入（<code>printf</code>），然后接收用户输入的数字存到盒子里（<code>scanf</code>），最后用加法器计算（调用函数<code>add</code>）。</li></ul><h4 id="7-建造机器（函数定义）"><a href="#7-建造机器（函数定义）" class="headerlink" title="7. 建造机器（函数定义）"></a>7. <strong>建造机器（函数定义）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 机器的内部构造：两数相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里是真正建造加法器的地方。当<code>add</code>被调用时，它会把两个数相加，然后”吐”出结果。</li></ul><hr><h3 id="举个完整例子-🌰"><a href="#举个完整例子-🌰" class="headerlink" title="举个完整例子 🌰"></a>举个完整例子 🌰</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 工具包：借来打印和输入工具</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREETING <span class="string">&quot;你好呀！&quot;</span> <span class="comment">// 贴个便利贴：把GREETING替换成&quot;你好呀！&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;        <span class="comment">// 提前声明：&quot;我要一个打招呼的机器&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sayHello();         <span class="comment">// 使用打招呼机器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, GREETING); <span class="comment">// 打印便利贴内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 交钥匙结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;       <span class="comment">// 建造打招呼机器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序运行效果："><a href="#程序运行效果：" class="headerlink" title="程序运行效果："></a>程序运行效果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">你好呀！</span><br></pre></td></tr></table></figure><hr><h3 id="关键点总结-🔑"><a href="#关键点总结-🔑" class="headerlink" title="关键点总结 🔑"></a>关键点总结 🔑</h3><ol><li><strong>工具包在前</strong>：所有<code>#include</code>和<code>#define</code>要写在最前面</li><li><strong>入口不能少</strong>：每个程序必须有<code>main()</code>函数</li><li><strong>先声明后使用</strong>：函数和变量都要先告诉电脑它们的存在</li><li><strong>语句像步骤</strong>：一行行代码就像做菜的步骤，按顺序执行</li><li><strong>函数像机器</strong>：先设计机器图纸（声明），再具体建造（定义）</li></ol><p>就像盖房子需要先备料再施工一样，C 程序的结构就是一步步告诉电脑该做什么。刚开始可能觉得步骤繁琐，但熟悉后会发现这是为了保证程序清晰可靠！</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>咱们可以把编程里的”分隔符”想象成写作文时用的标点符号，它们的作用就是让代码更有条理、更容易读懂。下面用最生活化的方式解释：</p><ol><li><p><strong>逗号（,）——像购物清单的分隔符</strong>  </p><ul><li>比如你写购物清单：”苹果、香蕉、牛奶”，逗号就像中间的顿号，用来分开多个东西。</li><li>编程中用它分隔变量或函数参数：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 身高 = <span class="number">180</span>, 体重 = <span class="number">70</span>; <span class="comment">// 同时声明两个变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好&quot;</span>, name);      <span class="comment">// 分隔函数的两个参数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>分号（;）——代码的句号</strong>  </p><ul><li>就像写句子结尾要打句号，写代码每句话结束必须加分号。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我写完代码啦！&quot;</span>); <span class="comment">// 这句结束了，打上分号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">// 这句也结束了，再打个分号</span></span><br></pre></td></tr></table></figure></li><li>甚至可以直接写个光杆分号，表示”这里啥也不干”：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="comment">// 相当于对电脑说：&quot;你先歇会儿，我暂时没指令&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>括号三兄弟</strong>  </p><ul><li><p><strong>圆括号 () —— 像数学公式里的括号</strong><br>计算优先级&#x2F;函数调用时用：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>+<span class="number">5</span>)*<span class="number">2</span>       <span class="comment">// 先算括号里的3+5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好&quot;</span>) <span class="comment">// 调用函数时必须带这对括号</span></span><br></pre></td></tr></table></figure></li><li><p><strong>花括号 {} —— 代码的集装箱</strong><br>把多行代码打包成一个整体，比如函数、循环、条件判断：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (下雨了) &#123;</span><br><span class="line">    拿伞();</span><br><span class="line">    关窗();    <span class="comment">// 这两行代码被&#123;&#125;包裹成一组操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方括号 [] —— 储物柜编号</strong><br>主要用来标记数组的位置：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 成绩[<span class="number">3</span>] = &#123;<span class="number">90</span>,<span class="number">85</span>,<span class="number">95</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,成绩[<span class="number">1</span>]); <span class="comment">// 取出第2个储物柜（下标从0开始）的值85</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>新手常见误区</strong>  </p><ul><li>漏加分号就像说话不喘气，计算机会懵：”你这句话到底结束没？”  </li><li>括号不匹配就像只说了”大家好（今天天气真好”，计算机等着你补上另一半呢！</li></ul><h2 id="📝-注释——代码的便利贴"><a href="#📝-注释——代码的便利贴" class="headerlink" title="📝 注释——代码的便利贴"></a>📝 <strong>注释——代码的便利贴</strong></h2><p><strong>作用</strong>：用来在代码里写<strong>解释说明</strong>，但不会影响程序运行（就像看书时写在空白处的笔记，电脑会直接忽略它们）。</p><hr><h3 id="✏️-两种注释写法"><a href="#✏️-两种注释写法" class="headerlink" title="✏️ 两种注释写法"></a>✏️ <strong>两种注释写法</strong></h3><ol><li><p><strong>单行注释 <code>//</code> —— 便利贴</strong>  </p><ul><li>适合写简短提醒，贴在<strong>某一行代码旁边</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算用户年龄（这个便利贴只占一行）</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">2023</span> - birthYear; </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多行注释 <code>/* */</code> —— 笔记本上的补充说明</strong>  </p><ul><li>当你想写<strong>大段解释</strong>，或者<strong>暂时屏蔽多行代码</strong>时用：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 这个函数用来计算工资：</span></span><br><span class="line"><span class="comment"> 1. 获取基本工资</span></span><br><span class="line"><span class="comment"> 2. 加上奖金</span></span><br><span class="line"><span class="comment"> 3. 扣除税</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> salary = base + bonus - tax;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🚧-使用禁忌（千万别踩坑！）"><a href="#🚧-使用禁忌（千万别踩坑！）" class="headerlink" title="🚧 使用禁忌（千万别踩坑！）"></a>🚧 <strong>使用禁忌（千万别踩坑！）</strong></h3><ol><li><p><strong>禁止套娃注释</strong> ❌  </p><ul><li>不能在一个注释里<strong>再塞另一个注释</strong>，就像便利贴上不能再贴便利贴（会混乱）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 外层注释 </span></span><br><span class="line"><span class="comment">   // 内层注释（错误！电脑会懵） </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>别在”对话”中插注释</strong> ❌  </p><ul><li>注释不能写在<strong>字符串（比如printf里的文字）</strong>中，就像聊天时突然说括号话会让人迷惑：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好啊 /* 这是注释吗？ */&quot;</span>); <span class="comment">// 电脑会原样输出整句话，包括/*</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活化例子"><a href="#🌰-生活化例子" class="headerlink" title="🌰 生活化例子"></a>🌰 <strong>生活化例子</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释：今天要买什么菜（电脑不会管这句）</span></span><br><span class="line"><span class="type">int</span> 土豆 = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  多行注释：</span></span><br><span class="line"><span class="comment">  1. 西红柿炒蛋的步骤：</span></span><br><span class="line"><span class="comment">  2. 先炒鸡蛋</span></span><br><span class="line"><span class="comment">  3. 再加西红柿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> 西红柿 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="💡-为什么需要注释？"><a href="#💡-为什么需要注释？" class="headerlink" title="💡 为什么需要注释？"></a>💡 <strong>为什么需要注释？</strong></h3><ul><li><strong>给未来的自己</strong>：一个月后回来看代码，可能完全忘记当时为啥这么写</li><li><strong>给队友看</strong>：就像在代码里留”使用说明书”</li><li><strong>临时禁用代码</strong>：调试时让某段代码暂时失效（像用胶带贴住不想用的部分）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf(&quot;测试用，先屏蔽掉&quot;); </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正式功能运行中...&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p><strong>新手常见翻车现场</strong> 🚑  </p><ul><li>忘关多行注释：<code>/* 开头没写 */</code>，结果后面代码全被当成注释！</li><li>在字符串里手滑写<code>//</code>：<code>printf(&quot;网址://xxx.com&quot;);</code>（电脑会正常输出，但你可能以为这是注释）</li></ul><h2 id="🏷️-标识符——代码世界的起名规范"><a href="#🏷️-标识符——代码世界的起名规范" class="headerlink" title="🏷️ 标识符——代码世界的起名规范"></a>🏷️ <strong>标识符——代码世界的起名规范</strong></h2><p><strong>作用</strong>：用来给变量、函数、数组等起名字（比如你养的猫叫<code>喵喵</code>，代码里的数字可以叫<code>年龄</code>）。</p><hr><h3 id="📜-起名三大铁律"><a href="#📜-起名三大铁律" class="headerlink" title="📜 起名三大铁律"></a>📜 <strong>起名三大铁律</strong></h3><ol><li><p><strong>开头必须字母或下划线</strong>  </p><ul><li>❌ 禁止数字打头（像手机号不能当人名）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">123</span>abc;  <span class="comment">// 错误！数字开头</span></span><br><span class="line"><span class="type">float</span> _体重;  <span class="comment">// 正确√ 下划线开头</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>只能用字母、数字、下划线</strong>  </p><ul><li>❌ 禁用特殊符号（@、$、%等）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 邮箱@qq; <span class="comment">// 错误！带了@</span></span><br><span class="line"><span class="type">double</span> $价格;  <span class="comment">// 错误！C语言不支持$（其他语言可能允许）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>严格区分大小写</strong>  </p><ul><li>就像<code>iPhone</code>和<code>iphone</code>是两回事：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Age = <span class="number">18</span>;  <span class="comment">// 全大写的Age</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">20</span>;  <span class="comment">// 全小写的age（和上面是两个不同变量）</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活化例子对比"><a href="#🌰-生活化例子对比" class="headerlink" title="🌰 生活化例子对比"></a>🌰 <strong>生活化例子对比</strong></h3><table><thead><tr><th>✅ 合法名字</th><th>❌ 非法名字</th><th>错误原因</th></tr></thead><tbody><tr><td><code>userName</code></td><td><code>user-name</code></td><td>中间有减号（只能用下划线<code>_</code>）</td></tr><tr><td><code>_count</code></td><td><code>3D模型</code></td><td>数字开头</td></tr><tr><td><code>price2023</code></td><td><code>价格$</code></td><td>包含$符号</td></tr><tr><td><code>isValid</code>（驼峰命名）</td><td><code>break</code></td><td>用了C语言的关键字（后文解释）</td></tr></tbody></table><hr><h3 id="💡-起名技巧"><a href="#💡-起名技巧" class="headerlink" title="💡 起名技巧"></a>💡 <strong>起名技巧</strong></h3><ol><li><p><strong>见名知意</strong>：  </p><ul><li>烂名字 → <code>int a;</code>（鬼知道a代表啥）  </li><li>好名字 → <code>int 学生年龄;</code>（拼音或英文均可，推荐英文）</li></ul></li><li><p><strong>风格统一</strong>：  </p><ul><li>小写+下划线：<code>student_age</code>  </li><li>驼峰式：<code>studentAge</code></li></ul></li><li><p><strong>避开关键字</strong>：  </p><ul><li>别用C语言预留的单词（比如<code>int</code>, <code>return</code>等），就像不能给孩子起名叫”人类”。</li></ul></li></ol><hr><h3 id="🤯-经典翻车现场"><a href="#🤯-经典翻车现场" class="headerlink" title="🤯 经典翻车现场"></a>🤯 <strong>经典翻车现场</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">1</span>号学生 = <span class="number">60</span>;    <span class="comment">// 错误！数字开头</span></span><br><span class="line"><span class="type">float</span> 体重<span class="meta">#kg = 50.5; <span class="comment">// 错误！带#号</span></span></span><br><span class="line"><span class="type">char</span> <span class="class"><span class="keyword">class</span> =</span> <span class="string">&#x27;A&#x27;</span>;    <span class="comment">// 错误！class是关键字</span></span><br></pre></td></tr></table></figure><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li>能起名叫<code>_3D模型</code>吗？ → ✅ 可以（下划线开头+数字）  </li><li><code>UserName</code>和<code>username</code>是同一个变量吗？ → ❌ 不是（大小写敏感）  </li><li><code>支付宝到账$100</code>能当变量名吗？ → ❌ 不行（有$和中文，且C建议用英文）</li></ol><h2 id="📌-常量——像冰箱上的便利贴，贴完不能改"><a href="#📌-常量——像冰箱上的便利贴，贴完不能改" class="headerlink" title="📌 常量——像冰箱上的便利贴，贴完不能改"></a>📌 <strong>常量——像冰箱上的便利贴，贴完不能改</strong></h2><p><strong>作用</strong>：定义固定不变的值（比如圆周率π&#x3D;3.14），程序运行中禁止修改。</p><h3 id="🌰-生活化例子-1"><a href="#🌰-生活化例子-1" class="headerlink" title="🌰 生活化例子"></a>🌰 <strong>生活化例子</strong></h3><table><thead><tr><th>类型</th><th>例子</th><th>类比</th></tr></thead><tbody><tr><td>整型常量</td><td><code>const int 最大人数=100;</code></td><td>教室最多容纳100人</td></tr><tr><td>浮点型常量</td><td><code>const float 税率=0.05;</code></td><td>商品统一加5%税</td></tr><tr><td>字符常量</td><td><code>const char 换行=&#39;\n&#39;;</code></td><td>每次敲回车键的效果</td></tr><tr><td>字符串字面量</td><td><code>char 问候[]=&quot;你好呀&quot;;</code></td><td>自动加隐形句号（\0）</td></tr></tbody></table><p><strong>📢 重点提醒</strong>  </p><ul><li>字符串用<strong>双引号</strong>包裹，且末尾会悄悄加个<code>\0</code>（像快递单号末尾的结束符）  </li><li>修改常量会报错（就像撕掉冰箱贴换数字会被家人骂）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.1415</span>; <span class="comment">// ❌ 错误！常量禁止修改</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧰-运算符——代码的多功能瑞士军刀"><a href="#🧰-运算符——代码的多功能瑞士军刀" class="headerlink" title="🧰 运算符——代码的多功能瑞士军刀"></a>🧰 <strong>运算符——代码的多功能瑞士军刀</strong></h2><p><strong>作用</strong>：对数据进行各种操作（计算、比较、判断等）</p><h3 id="🔢-常见运算符分类"><a href="#🔢-常见运算符分类" class="headerlink" title="🔢 常见运算符分类"></a>🔢 <strong>常见运算符分类</strong></h3><table><thead><tr><th>类型</th><th>运算符示例</th><th>生活类比</th></tr></thead><tbody><tr><td><strong>算术</strong></td><td><code>+ - * / %</code></td><td>加减乘除（%是求余数）</td></tr><tr><td><strong>关系</strong></td><td><code>&gt; &lt; == !=</code></td><td>比身高、称体重判断是否达标</td></tr><tr><td><strong>逻辑</strong></td><td><code>&amp;&amp; || !</code></td><td>多重条件（比如”雨天&amp;&amp;带伞”）</td></tr><tr><td><strong>赋值</strong></td><td><code>= += -=</code></td><td>快捷操作（钱包+&#x3D;100 就是加钱）</td></tr><tr><td><strong>位运算</strong></td><td><code>&amp; | ^ ~</code></td><td>二进制开关操作（像电路板）</td></tr></tbody></table><h3 id="🌰-代码场景演示"><a href="#🌰-代码场景演示" class="headerlink" title="🌰 代码场景演示"></a>🌰 <strong>代码场景演示</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 钱包 = <span class="number">50</span>;</span><br><span class="line">钱包 += <span class="number">20</span>; <span class="comment">// ✅ 钱包变成70（等价于 钱包 = 钱包 + 20）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (温度 &gt; <span class="number">35</span> &amp;&amp; 有空调) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调！&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 同时满足高温和有空调才执行</span></span><br></pre></td></tr></table></figure><hr><h3 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>字符串忘记\0</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 错误写法[<span class="number">3</span>] = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;; <span class="comment">// ❌ 缺少\0，打印可能乱码</span></span><br><span class="line"><span class="type">char</span> 正确写法[] = <span class="string">&quot;ABC&quot;</span>;          <span class="comment">// ✅ 自动补\0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>混淆&#x3D;和&#x3D;&#x3D;</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (身高 = <span class="number">180</span>) &#123; ... &#125;  <span class="comment">// ❌ 其实是赋值，永远为真</span></span><br><span class="line"><span class="keyword">if</span> (身高 == <span class="number">180</span>) &#123; ... &#125; <span class="comment">// ✅ 比较是否等于180</span></span><br></pre></td></tr></table></figure></li><li><p><strong>整数除法陷阱</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 结果 = <span class="number">5</span> / <span class="number">2</span>;    <span class="comment">// ❌ 得到2而不是2.5</span></span><br><span class="line"><span class="type">float</span> 正确 = <span class="number">5.0</span> / <span class="number">2</span>;  <span class="comment">// ✅ 得到2.5</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="🛠️-运算符优先级口诀"><a href="#🛠️-运算符优先级口诀" class="headerlink" title="🛠️ 运算符优先级口诀"></a>🛠️ <strong>运算符优先级口诀</strong></h3><blockquote><p>先算乘除再加减，逻辑比关系优先，括号永远最牛逼！<br>记不住就加<code>()</code>，就像用便签明确优先级。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 迷惑计算 = <span class="number">3</span> + <span class="number">5</span> * <span class="number">2</span>;   <span class="comment">// 结果是13（先算5*2）</span></span><br><span class="line"><span class="type">int</span> 明确计算 = (<span class="number">3</span> + <span class="number">5</span>) * <span class="number">2</span>; <span class="comment">// 结果是16</span></span><br></pre></td></tr></table></figure><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>&quot;Hello&quot;[5]</code>是什么？ → <code>\0</code>（字符串结尾隐身保镖）  </li><li><code>10 % 3</code>等于多少？ → 1（10除以3余1）  </li><li><code>价格 *= 0.8;</code> 等价于？ → 价格 &#x3D; 价格 * 0.8（打8折）</li></ol><h2 id="🔑-关键字——编程界的「禁用词库」"><a href="#🔑-关键字——编程界的「禁用词库」" class="headerlink" title="🔑 关键字——编程界的「禁用词库」"></a>🔑 <strong>关键字——编程界的「禁用词库」</strong></h2><p><strong>作用</strong>：这些单词是C语言预留的<strong>特殊指令</strong>，就像「红灯」「出口」不能随便当人名用。  </p><h3 id="🗂️-分类记忆法（重点掌握常用部分）"><a href="#🗂️-分类记忆法（重点掌握常用部分）" class="headerlink" title="🗂️ 分类记忆法（重点掌握常用部分）"></a>🗂️ <strong>分类记忆法</strong>（重点掌握常用部分）</h3><table><thead><tr><th><strong>类别</strong></th><th><strong>关键字举例</strong></th><th><strong>生活比喻</strong></th></tr></thead><tbody><tr><td><strong>数据类型</strong></td><td><code>int</code>, <code>char</code>, <code>float</code></td><td>不同容器（水杯、饭盒、油桶）</td></tr><tr><td><strong>流程控制</strong></td><td><code>if</code>, <code>for</code>, <code>switch</code></td><td>交通信号灯（停、转弯、直行）</td></tr><tr><td><strong>函数相关</strong></td><td><code>return</code>, <code>void</code></td><td>快递签收（返回包裹&#x2F;空手而归）</td></tr><tr><td><strong>存储方式</strong></td><td><code>static</code>, <code>extern</code></td><td>物品存放位置（固定柜子&#x2F;借隔壁东西）</td></tr><tr><td><strong>特殊操作</strong></td><td><code>sizeof</code>, <code>typedef</code></td><td>工具尺（测量大小）和贴标签（起别名）</td></tr></tbody></table><h3 id="🚫-绝对禁区示例"><a href="#🚫-绝对禁区示例" class="headerlink" title="🚫 绝对禁区示例"></a>🚫 <strong>绝对禁区示例</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">int</span> = <span class="number">5</span>;      <span class="comment">// ❌ 用关键字int当变量名 → 就像给孩子取名&quot;法律&quot;</span></span><br><span class="line"><span class="type">char</span> <span class="keyword">return</span> = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// ❌ return是指令词 → 像用&quot;红灯&quot;当店名</span></span><br></pre></td></tr></table></figure><hr><h2 id="📏-空格规则——代码的呼吸感"><a href="#📏-空格规则——代码的呼吸感" class="headerlink" title="📏 空格规则——代码的呼吸感"></a>📏 <strong>空格规则——代码的呼吸感</strong></h2><p><strong>作用</strong>：让代码像排版优美的文章，既方便阅读，又能让编译器准确识别元素。</p><h3 id="✅-必须加空格的情况"><a href="#✅-必须加空格的情况" class="headerlink" title="✅ 必须加空格的情况"></a>✅ <strong>必须加空格的情况</strong></h3><ul><li><strong>关键字和变量名之间</strong> → 像中英文混写要加空格  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>年龄 = <span class="number">18</span>;   <span class="comment">// ❌ 报错！连体婴写法</span></span><br><span class="line"><span class="type">int</span> 年龄 = <span class="number">18</span>;  <span class="comment">// ✅ 正确间距</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🌟-推荐加空格提升可读性"><a href="#🌟-推荐加空格提升可读性" class="headerlink" title="🌟 推荐加空格提升可读性"></a>🌟 <strong>推荐加空格提升可读性</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧凑写法（合法但费眼）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 舒适写法（推荐！）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩-可灵活处理的场景"><a href="#🚩-可灵活处理的场景" class="headerlink" title="🚩 可灵活处理的场景"></a>🚩 <strong>可灵活处理的场景</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">price=<span class="number">100</span>*<span class="number">2</span>;     <span class="comment">// ✅ 合法但拥挤</span></span><br><span class="line">price = <span class="number">100</span> * <span class="number">2</span>; <span class="comment">// ✅ 更易读（像数学公式空格）</span></span><br></pre></td></tr></table></figure><hr><h3 id="💡-记忆技巧"><a href="#💡-记忆技巧" class="headerlink" title="💡 记忆技巧"></a>💡 <strong>记忆技巧</strong></h3><ol><li><p><strong>关键字避雷口诀</strong>：  </p><blockquote><p>“改名叫int？立刻报错！<br>用switch当变量？电脑翻脸！”  </p></blockquote></li><li><p><strong>空格使用三字经</strong>：  </p><blockquote><p>关键字后必空格，运算符旁可加空，<br>长表达式分段空，就像呼吸要畅通。</p></blockquote></li></ol><hr><h3 id="🛠️-代码美容院（对比案例）"><a href="#🛠️-代码美容院（对比案例）" class="headerlink" title="🛠️ 代码美容院（对比案例）"></a>🛠️ <strong>代码美容院</strong>（对比案例）</h3><p><strong>丑代码</strong> → 诊断报告  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;<span class="type">int</span> x=<span class="number">5</span>;<span class="keyword">if</span>(x&gt;<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;大&quot;</span>);&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>症状</strong>：无空格导致阅读困难，像一段乱码  </p><p><strong>帅代码</strong> → 优化方案  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疗效</strong>：层次分明，像排版精致的文档  </p><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li>能写<code>float char = 3.14;</code>吗？ → ❌ <code>char</code>是关键字  </li><li><code>for(int i=0;;)</code>中间可以不加空格吗？ → ✅ 合法但建议加  </li><li><code>printf(&quot;hello&quot;);</code>需要在哪里加空格？ → 函数名和括号之间<strong>不需要</strong>（但参数内部按需加）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪中温情</title>
      <link href="/2024/12/07/%E9%9B%AA%E4%B8%AD%E6%B8%A9%E6%83%85/"/>
      <url>/2024/12/07/%E9%9B%AA%E4%B8%AD%E6%B8%A9%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h1 id="今日分享"><a href="#今日分享" class="headerlink" title="今日分享"></a>今日分享</h1><p><strong>​在银装素裹的冬夜，我偶遇了一对母子，他们的身影在雪的映衬下显得格外温馨。母亲，一位勤劳的摊贩，她的摊前摆满了香气四溢的鸡锁骨。她带着她的儿子，一个活泼可爱的小男孩，他的眼睛里闪烁着对这个世界的好奇和对母亲的依恋。</strong></p><div style="text-align:center">  <img src="/img_1/91B55A345284EB58E47DC0743FA6AE1A.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>小男孩在雪地里尽情嬉戏，他的身上沾满了洁白的雪花，如同一个小雪人。母亲在忙碌之余，不忘关心儿子，她轻轻地为他拍去身上的雪，那一刹那，母爱的温暖在寒冷的冬夜里显得尤为珍贵。</strong></p><div style="text-align:center">  <img src="/img_1/A6945B877C3A3DA3CFE3CF7589FCB1DE.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>我有幸捕捉到了这温馨的一幕，小男孩在意识到我在拍照时，天真无邪地对母亲说：“妈妈，有人在拍我们。”他的话语中透露出一丝自豪和喜悦。</strong></p><div style="text-align:center">  <img src="/img_1/7AF6681739E006B43924C5B7B5A8462D.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>这两张照片，虽然拍摄时手指几乎冻僵，但它们记录下了这个冬天最温暖的瞬间。它们不仅仅是照片，更是母爱与童真的见证。</strong></p><div style="text-align:center">  <img src="/img_1/91B55A345284EB58E47DC0743FA6AE1A.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>“在这片洁白的雪地里，母爱如同暖阳，温暖着孩子的心。”愿这个冬天，每个人的心中都能感受到这样的温暖。</strong></p><div style="text-align:center">  <img src="/img_1/9E5D33BEB68998800BDE25186AAF14E5.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" >  <img src="/img_1/6134B2C6371C3279BB5DF95ADEC52336.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>​拍摄：码头</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B站被破解，请低调使用</title>
      <link href="/2024/11/29/B%E7%AB%99%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E8%AF%B7%E4%BD%8E%E8%B0%83%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/29/B%E7%AB%99%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E8%AF%B7%E4%BD%8E%E8%B0%83%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>大型企业的软件和网站往往配备了引人注目的标准界面设计。尽管如此，总有用户对这些UI不甚满意，他们追求个性化和新奇体验，希望通过改变界面来获得乐趣和新鲜感。</strong><br><strong>因此，一位技术大佬开发了一款针对B站的美化插件，旨在为用户提供一种全新的B站浏览体验。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：B站美化插件</strong><br><strong>适用设备：电脑</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p><strong>本站为大家提供的是压缩包，解压以后点击<code>Setup</code>即可下载</strong></p><div style="text-align:center">  <img src="\img_1\5C68DCBE3C8E99717155353FF085D9B5.jpg" alt="" style="width:70%;"></div><p><strong>另外，这款名为<code>bewbewly</code>的插件目前在Github，Chrome等插件商店平台上发布</strong><br><strong>使用起来非常方便，下载插件包后不需要进行解压操作。以微软的Edge浏览器为例，只需打开浏览器的“设置”菜单，然后选择“管理扩展”，就可以轻松访问插件管理页面了。</strong></p><div style="text-align:center">  <img src="\img_1\D573BFC7B69346307CE481D648219C40.jpg" alt="" style="width:70%;"></div><p><strong>首先点击开发者人员模式(按<code>F12</code>或者鼠标右键再点击<code>检查</code>),然后把提供的压缩包直接拉入，最后查看插件是否启用即可</strong></p><div style="text-align:center">  <img src="\img_1\FE0584FC6F5B7ECB067D461B0CD3D928.jpg" alt="" style="width:70%;"></div><p><strong>安装好插件以后，进入你的B站，会发现一个全新面貌的B站展现在你的眼前😏</strong></p><div style="text-align:center">  <img src="\img_1\6F25C57341F80B645AC0B89538E81814.jpg" alt="" style="width:70%;"></div><p><strong>这里举一个例子，我们可以通过右上角的按钮，可以很容易的实现在卡片视图和列表视图之间进行切换</strong></p><div style="text-align:center">  <img src="\img_1\64F0DF6D1D6D52B2F6B4C6B6A99847BC.gif" alt="" style="width:70%;"></div><p><strong>功能还有很多，这里就不一个一个进行阐述了，各位可以自行探索😉</strong></p><h1 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h1><p><strong><a href="https://wwso.lanzoub.com/i2qME2azcqbc">https://wwso.lanzoub.com/i2qME2azcqbc</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网盘限速？不存在的</title>
      <link href="/2024/11/22/%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/"/>
      <url>/2024/11/22/%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>在中国，网盘服务领域呈现出多样化的发展趋势，众多网盘品牌如雨后春笋般涌现，包括历史悠久的百度网盘、115网盘、天翼云盘，以及新兴的阿里云盘、夸克网盘和123网盘等。</strong></p><p><strong>然而，用户在使用这些服务时经常遇到一些不便，比如必须登录账户以及下载速度被严重限制等问题。</strong></p><p><strong>为了解决这些问题，一些技术高手开发了多种网盘下载加速工具，这些工具能够显著提升下载速度，让用户能够更充分地利用自己的网络带宽。今天，我将向大家介绍一款这样的工具，它可以帮助用户突破限制，实现高速下载。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：加速下载</strong><br><strong>适用设备：电脑</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p><strong>在使用特定的网盘加速工具前，大家需要先暂时禁用电脑上的防火墙和安全软件，因为这些安全程序可能会误判这些工具为潜在威胁。接着，用户应将下载的压缩文件解压到桌面上。在启动这个旧版本的百度网盘客户端之前，务必确保已经关闭了电脑上所有其他版本的百度网盘，以避免它们之间发生冲突</strong></p><div style="text-align:center">  <img src="\img_1\DB13E5E57BD3E894FB8F62FCCAF70F37.jpg" alt="" style="width:60%;"></div><p><strong>在启动程序后，请耐心等待片刻，随后会出现登录窗口。此时，小伙伴们可以按照常规流程进行登录操作</strong></p><div style="text-align:center">  <img src="\img_1\F32A4CEF7C9677AD9C786394D2BAA00C.jpg" alt="" style="width:60%;"></div><p><strong>登录成功后，请返回到你之前解压的文件夹中。在继续操作之前，这里请确保你的计算机上所有的防火墙和杀毒软件都已经关闭，以避免它们干扰接下来的步骤。然后，右键点击加速补丁程序，并选择“以管理员身份运行”来启动它</strong></p><div style="text-align:center">  <img src="\img_1\50F03DA9F9FDD2187E22FAD2C7179116.jpg" alt="" style="width:60%;">  <img src="\img_1\DCA080102C2751A3882DB9D890331734.jpg" alt="" style="width:60%;"></div><p><strong>打开以后首先点击【恢复】</strong></p><div style="text-align:center">  <img src="\img_1\10F2DC664033E5999356934EA28B4A0A.jpg" alt="" style="width:60%;"></div><p><strong>在登录并确认安全软件已关闭后，就可以在百度网盘内选择一个文件进行下载。开始下载时，可能会发现速度较慢，这是正常现象。如果下载速度变得非常慢，你需要再次打开之前提到的加速补丁程序</strong></p><div style="text-align:center">  <img src="\img_1\D410659ACDB909E0E6BA5AC7DB232F49.jpg" alt="" style="width:60%;"></div><p><strong>这个时候大家再回到刚才的加速补丁，然后再点击【加速】按钮即可</strong></p><div style="text-align:center">  <img src="\img_1\3EE00D53D32D72D227CDCACD2C7A69BE.jpg" alt="" style="width:60%;"></div><p>当你回到下载界面时，会注意到进度条迅速增长，这意味着加速补丁正在起作用。请注意，<strong>这个过程中可能不会显示具体的下载速度，因此你需要通过观察进度条的移动来判断下载进度</strong></p><div style="text-align:center">  <img src="\img_1\FEB68AAD9641BB019E44DD3AE792BFEE.gif" alt="" style="width:60%;"></div>如果发现加速补丁没有效果，建议你检查是否所有的防火墙和杀毒软件都已完全关闭，有时候这些安全软件可能会阻止补丁的正常运行。<p>以上就是整个加速补丁的使用介绍。如果你对此感兴趣，可以尝试下载并按照上述步骤操作</p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="http://pan.poge.pro/d/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8C%85.rar">http://pan.poge.pro/d/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8C%85.rar</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 网盘下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++接口(抽象类)</title>
      <link href="/2024/11/22/C-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2024/11/22/C-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是C++面向对象的最后一节内容，本节内容将会用到前面类的相关知识以及<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.toumatou.cn/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><hr><h1 id="C-接口（抽象类）"><a href="#C-接口（抽象类）" class="headerlink" title="C++ 接口（抽象类）"></a>C++ 接口（抽象类）</h1><p>在 C++ 中，<strong>接口</strong>是一种“<strong>规定一类事物应该具备什么功能</strong>”的方式。可以将接口比作“合同”或“蓝图”，它描述了类的功能和行为，但不关心具体如何实现。</p><p>在 C++ 中，接口通常通过<strong>抽象类（Abstract Class）</strong>来实现。抽象类就像建筑的“蓝图”：它定义了应该做什么，但不告诉你怎么做。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#what-is-an-abstract-class">什么是抽象类？</a></li><li><a href="#why-abstract-classes">为什么需要抽象类？</a></li><li><a href="#rules-for-abstract-classes">抽象类的规则</a></li><li><a href="#use-cases-for-abstract-classes">抽象类的使用场景</a></li><li><a href="#examples-of-abstract-classes">抽象类的实例</a></li><li><a href="#wrong-example">常见错误示例</a></li><li><a href="#comparison-between-abstract-classes-and-interfaces">抽象类与接口的比较</a></li><li><a href="#importance-of-virtual-destructors">虚析构函数的重要性</a></li><li><a href="#summary">总结</a></li></ul><hr><h2 id="what-is-an-abstract-class">什么是抽象类？</h2><p>抽象类是一种<strong>不能直接用来创建对象</strong>的特殊类，主要用来给其他类提供标准或模板。</p><p><strong>关键特性</strong>：</p><ol><li><strong>至少包含一个纯虚函数</strong>：抽象类中至少有一个函数是“纯虚函数”。</li><li><strong>纯虚函数的定义</strong>：纯虚函数是一种特殊的函数，它只有声明，没有实现，写法是<code>= 0</code>。</li></ol><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，定义了一个必须实现的接口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的类<code>Shape</code>就是一个抽象类，<code>getArea()</code>函数只是告诉其他类“你必须提供计算面积的功能”，但并没有实现具体的计算方法。</p><hr><h2 id="why-abstract-classes">为什么需要抽象类？</h2><p>抽象类的主要目的是<strong>定义接口</strong>，而不是实现细节。它告诉子类“你必须做这些事情，但怎么做由你决定”。这样可以：</p><ol><li><strong>统一标准</strong>：确保不同的子类都有一致的功能。</li><li><strong>代码灵活</strong>：子类可以用自己的方式实现这些功能。</li><li><strong>避免错误</strong>：如果某个子类没有实现必要的功能，编译器会报错。</li></ol><h3 id="类比说明"><a href="#类比说明" class="headerlink" title="类比说明"></a>类比说明</h3><p>想象一下，你是一家汽车制造厂的设计师，制定了一份“汽车设计蓝图”（抽象类），规定了汽车必须有发动机、车轮等基本部件，但具体的发动机类型和车轮设计由不同的制造部门负责。这确保了所有汽车都具备基本功能，但具体实现可以多样化。</p><hr><h2 id="rules-for-abstract-classes">抽象类的规则</h2><ul><li><strong>至少包含一个纯虚函数</strong>：抽象类中的函数<code>= 0</code>，表示这个函数是纯虚函数，必须在子类中实现。</li><li><strong>不能直接创建对象</strong>：无法用抽象类创建实例，如果尝试这么做，编译器会报错。</li><li><strong>必须在子类中实现纯虚函数</strong>：子类如果没有实现纯虚函数，也会被当成抽象类，不能实例化。</li></ul><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，子类必须实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 实现纯虚函数</span></span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDimensions</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        width = w;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Shape shape;  // 错误：不能实例化抽象类</span></span><br><span class="line">    Rectangle rect;</span><br><span class="line">    rect.<span class="built_in">setDimensions</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;  <span class="comment">// 输出：Area: 35</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ol><li>抽象类<code>Shape</code>定义了接口<code>getArea()</code>，但没有实现。</li><li>子类<code>Rectangle</code>实现了<code>getArea()</code>，所以它可以创建实例并使用。</li><li>尝试实例化<code>Shape</code>会导致编译错误，确保接口不能被滥用。</li></ol><hr><h2 id="use-cases-for-abstract-classes">抽象类的使用场景</h2><p>抽象类通常用来：</p><ol><li><strong>统一子类功能</strong>：确保所有子类都有某些共同的功能。</li><li><strong>提供灵活性</strong>：允许子类根据自己的需求，用不同的方式实现这些功能。</li><li><strong>扩展系统</strong>：以后可以很容易地添加新的子类，而不会影响现有代码。</li></ol><h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><p>假设你在开发一个图形编辑软件，需要处理多种形状（如矩形、圆形、三角形等）。你可以创建一个抽象类<code>Shape</code>，定义所有形状必须具备的接口，如<code>getArea()</code>和<code>draw()</code>，然后各个具体形状类继承<code>Shape</code>并实现这些接口。</p><hr><h2 id="examples-of-abstract-classes">抽象类的实例</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设我们有一个基类<code>Shape</code>，它代表一个形状，并定义了一个接口<code>getArea()</code>。然后我们用它的两个子类<code>Rectangle</code>（矩形）和<code>Triangle</code>（三角形）分别实现计算面积的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数：定义接口，但不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        width = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚析构函数，确保子类对象被正确销毁</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;  <span class="comment">// 矩形面积公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (width * height) / <span class="number">2</span>;  <span class="comment">// 三角形面积公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rectangle rect;</span><br><span class="line">    Triangle tri;</span><br><span class="line"></span><br><span class="line">    rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">    rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Rectangle Area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">    tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Triangle Area: &quot;</span> &lt;&lt; tri.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试实例化抽象类将导致编译错误</span></span><br><span class="line">    <span class="comment">// Shape shape;  // 错误：无法实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle Area: 35</span><br><span class="line">Triangle Area: 17</span><br></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ol><li>抽象类<code>Shape</code>定义了计算面积的接口<code>getArea()</code>，并且提供了设置宽度和高度的方法。</li><li>子类<code>Rectangle</code>和<code>Triangle</code>分别实现了<code>getArea()</code>，用自己的公式计算面积。</li><li>主程序中通过接口调用<code>getArea()</code>，而不需要关心子类的具体实现。</li></ol><hr><h2 id="wrong-example">常见错误示例</h2><p>为了更好地理解抽象类的限制，来看几个常见的错误示例。</p><h3 id="1-尝试实例化抽象类"><a href="#1-尝试实例化抽象类" class="headerlink" title="1. 尝试实例化抽象类"></a>1. 尝试实例化抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape shape;  <span class="comment">// 错误：无法实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot declare variable ‘shape’ to be of abstract type ‘Shape’</span><br></pre></td></tr></table></figure><h3 id="2-子类未实现所有纯虚函数"><a href="#2-子类未实现所有纯虚函数" class="headerlink" title="2. 子类未实现所有纯虚函数"></a>2. 子类未实现所有纯虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncompleteShape</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="comment">// 未实现 getArea()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IncompleteShape ishape;  <span class="comment">// 错误：IncompleteShape 仍然是抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot declare variable ‘ishape’ to be of abstract type ‘IncompleteShape’</span><br></pre></td></tr></table></figure><hr><h2 id="comparison-between-abstract-classes-and-interfaces">抽象类与接口的比较</h2>虽然 C++ 没有明确的“接口”关键字，但抽象类可以用来实现接口的功能。<ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含成员变量和已实现的成员函数。</li><li>适用于需要共享代码和数据的场景。</li></ul></li><li><p><strong>接口（通过纯虚类实现）</strong>：</p><ul><li>只包含纯虚函数，不包含成员变量。</li><li>适用于仅需要定义行为规范的场景。</li></ul></li></ul><h3 id="示例：接口类"><a href="#示例：接口类" class="headerlink" title="示例：接口类"></a>示例：接口类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IPrintable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPrintable</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> : <span class="keyword">public</span> IPrintable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Printing Document&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="importance-of-virtual-destructors">虚析构函数的重要性</h2><p>在抽象类中定义虚析构函数，确保通过基类指针删除子类对象时，子类的析构函数能够被正确调用，防止资源泄漏。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    ~<span class="built_in">Rectangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Rectangle Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    <span class="keyword">delete</span> shape;  </span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// Rectangle Destructor</span></span><br><span class="line">    <span class="comment">// Shape Destructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Shape</code>的析构函数不是虚函数，删除<code>shape</code>时只会调用<code>Shape</code>的析构函数，导致<code>Rectangle</code>的析构函数未被调用，可能引发资源泄漏。</p><hr><h2 id="summary">总结</h2><p>抽象类在面向对象编程中扮演着重要角色，它提供了一个统一的接口，确保所有子类实现特定的功能。通过使用抽象类，可以：</p><ul><li><strong>强制性</strong>：确保子类实现必要的功能，避免遗漏。</li><li><strong>代码复用</strong>：在抽象类中实现通用功能，子类只需专注于特定部分。</li><li><strong>灵活性和扩展性</strong>：方便添加新功能或子类，而不影响现有代码。</li><li><strong>易于维护</strong>：外界依赖于抽象类提供的接口，内部实现可以灵活变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++数据封装</title>
      <link href="/2024/11/22/C-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"/>
      <url>/2024/11/22/C-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.toumatou.cn/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><h1 id="数据封装（Data-Encapsulation）：将数据安全地锁在盒子里"><a href="#数据封装（Data-Encapsulation）：将数据安全地锁在盒子里" class="headerlink" title="数据封装（Data Encapsulation）：将数据安全地锁在盒子里"></a><strong>数据封装（Data Encapsulation）：将数据安全地锁在盒子里</strong></h1><p>数据封装是面向对象编程（OOP）中的一个核心概念，它不仅可以提高代码的安全性和灵活性，还能使程序更易于维护和理解。为了让这个概念更容易理解，我们可以把数据封装比作“<strong>把数据和操作这些数据的方法放在一个盒子里，锁上盖子，只留一个钥匙孔</strong>”。外界只能通过钥匙孔（也就是类提供的公共方法）来操作盒子里的内容。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cpp-program-structure">C++ 程序的基本构成</a></li><li><a href="#core-concepts-of-encapsulation">数据封装的核心思想</a></li><li><a href="#class-definition-and-access-modifiers">类的定义及访问修饰符</a></li><li><a href="#example">数据封装的具体例子</a></li><li><a href="#difference-between-encapsulation-and-data-hiding">数据封装与数据隐藏的区别</a></li><li><a href="#getter-and-setter">封装与访问器 (Getter) 和修改器 (Setter)</a></li><li><a href="#advantages-of-encapsulation">数据封装的优点</a></li><li><a href="#design-recommendations">设计建议</a></li><li><a href="#real-world-encapsulation-examples">数据封装的现实类比</a></li><li><a href="#summary">总结</a></li></ul><h2 id="cpp-program-structure">C++ 程序的基本构成</h2><p>在深入了解数据封装之前，先回顾一下 C++ 程序的两个基本组成部分：</p><ol><li><strong>程序语句（代码）</strong>：负责执行具体的操作，如计算、输出、存储等。这些操作通常由函数实现。</li><li><strong>程序数据</strong>：程序需要处理的信息，如数字、字符、字符串等。</li></ol><p><strong>数据封装</strong>就是将这两部分<strong>绑定在一起</strong>，将数据和操作数据的代码打包成一个整体。</p><hr><h2 id="core-concepts-of-encapsulation">数据封装的核心思想</h2><h3 id="2-1-绑定数据和方法"><a href="#2-1-绑定数据和方法" class="headerlink" title="2.1 绑定数据和方法"></a><strong>2.1 绑定数据和方法</strong></h3><ul><li><strong>类（Class）</strong>：在 C++ 中，类是实现数据封装的基本单位。它将数据（属性）和操作这些数据的方法（函数）封装在一起。</li><li><strong>成员变量（属性）</strong>：类中的数据部分，用于存储对象的状态。</li><li><strong>成员函数（方法）</strong>：类中的函数部分，用于定义对象的行为。</li></ul><h3 id="2-2-隐藏内部实现"><a href="#2-2-隐藏内部实现" class="headerlink" title="2.2 隐藏内部实现"></a><strong>2.2 隐藏内部实现</strong></h3><ul><li><strong>访问控制符</strong>：通过设置 <code>public</code>、<code>private</code>、<code>protected</code> 等访问控制符，控制外部代码对类成员的访问权限。<ul><li><strong><code>private</code>（私有）</strong>：只能在类的内部访问，外部无法直接访问。</li><li><strong><code>public</code>（公有）</strong>：可以在任何地方访问。</li><li><strong><code>protected</code>（受保护）</strong>：在类内部和派生类中访问，外部无法直接访问。</li></ul></li></ul><h3 id="2-3-通过接口操作数据"><a href="#2-3-通过接口操作数据" class="headerlink" title="2.3 通过接口操作数据"></a><strong>2.3 通过接口操作数据</strong></h3><ul><li><strong>公共接口（钥匙孔）</strong>：类对外提供的 <code>public</code> 方法，外部只能通过这些方法与类交互，无法直接访问内部的 <code>private</code> 数据。</li><li><strong>好处</strong>：<ul><li><strong>安全性</strong>：防止外部代码直接修改内部数据，保护数据完整性。</li><li><strong>灵活性</strong>：可以在方法中添加数据验证、日志记录等功能。</li><li><strong>可维护性</strong>：修改内部实现细节时，不影响外部代码。</li></ul></li></ul><hr><h2 id="class-definition-and-access-modifiers">类的定义及访问修饰符</h2><h3 id="3-1-类的基本结构"><a href="#3-1-类的基本结构" class="headerlink" title="3.1 类的基本结构"></a><strong>3.1 类的基本结构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量和方法</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 受保护的成员变量和方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员变量和方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-示例：一个简单的盒子类"><a href="#3-2-示例：一个简单的盒子类" class="headerlink" title="3.2 示例：一个简单的盒子类"></a><strong>3.2 示例：一个简单的盒子类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置盒子的尺寸</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDimensions</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span> </span>&#123;</span><br><span class="line">        length = len;</span><br><span class="line">        breadth = bre;</span><br><span class="line">        height = hei;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算盒子的体积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>私有成员变量</strong>：<code>length</code>、<code>breadth</code>、<code>height</code>，外部无法直接访问或修改。</li><li><strong>公有成员函数</strong>：<code>setDimensions()</code> 和 <code>getVolume()</code>，提供与外部交互的接口。</li></ul><hr><h2 id="difference-between-encapsulation-and-data-hiding">数据封装与数据隐藏的区别</h2><ul><li><strong>数据封装（Encapsulation）</strong>：将数据和操作数据的方法绑定在一起，形成一个类。</li><li><strong>数据隐藏（Data Hiding）</strong>：通过访问控制符，隐藏类的内部实现细节，只暴露必要的接口。</li></ul><p><strong>总结</strong>：数据封装强调的是将数据和方法封装在一起，数据隐藏强调的是对外部隐藏内部细节。两者共同实现了面向对象编程的封装特性。</p><hr><h2 id="example">数据封装的具体例子</h2><h3 id="5-1-示例代码：加法器类"><a href="#5-1-示例代码：加法器类" class="headerlink" title="5.1 示例代码：加法器类"></a><strong>5.1 示例代码：加法器类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化总和</span></span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">        total = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个数字到总和</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        total += number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> total; <span class="comment">// 总和变量，外部不能直接修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adder a;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">10</span>); <span class="comment">// 通过 addNum 添加数字</span></span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">20</span>);</span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total: &quot;</span> &lt;&lt; a.<span class="built_in">getTotal</span>() &lt;&lt; endl; <span class="comment">// 输出 Total: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total: 60</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><strong>私有成员变量</strong>：<code>total</code>，用于存储总和，外部无法直接访问或修改。</li><li><strong>公有成员函数</strong>：<ul><li><code>addNum(int number)</code>：用于向总和添加数字。</li><li><code>getTotal()</code>：用于获取当前的总和。</li></ul></li><li><strong>好处</strong>：<ul><li><strong>保护性</strong>：防止外部直接修改 <code>total</code>，确保数据的安全性。</li><li><strong>灵活性</strong>：可以在 <code>addNum()</code> 中添加数据验证或其他逻辑，而不影响外部代码。</li></ul></li></ol><hr><h2 id="getter-and-setter">封装与访问器 (Getter) 和修改器 (Setter)</h2><h3 id="6-1-什么是-Getter-和-Setter"><a href="#6-1-什么是-Getter-和-Setter" class="headerlink" title="6.1 什么是 Getter 和 Setter"></a><strong>6.1 什么是 Getter 和 Setter</strong></h3><ul><li><strong>Getter（访问器）</strong>：用于获取私有成员变量的值。</li><li><strong>Setter（修改器）</strong>：用于设置私有成员变量的值，通常包含数据验证。</li></ul><h3 id="6-2-示例代码：学生类"><a href="#6-2-示例代码：学生类" class="headerlink" title="6.2 示例代码：学生类"></a><strong>6.2 示例代码：学生类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string studentName, <span class="type">int</span> studentAge) &#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">        <span class="built_in">setAge</span>(studentAge); <span class="comment">// 使用 Setter 进行数据验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取姓名（Getter）</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年龄（Getter）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改姓名（Setter）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string studentName)</span> </span>&#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄（Setter）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> studentAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentAge &gt; <span class="number">0</span> &amp;&amp; studentAge &lt; <span class="number">120</span>) &#123;</span><br><span class="line">            age = studentAge;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;年龄无效，设置为默认年龄 18。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印学生信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Student 对象</span></span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和修改数据</span></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setName</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setAge</span>(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试设置无效年龄</span></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setAge</span>(<span class="number">-5</span>);</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名: Alice, 年龄: 20</span><br><span class="line">姓名: Bob, 年龄: 22</span><br><span class="line">年龄无效，设置为默认年龄 18。</span><br><span class="line">姓名: Bob, 年龄: 18</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>数据验证</strong>：<code>setAge()</code> 方法中添加了年龄范围的检查，确保数据合法性。</li><li><strong>信息隐藏</strong>：<code>name</code> 和 <code>age</code> 是私有的，外部无法直接访问，只能通过 Getter 和 Setter 方法操作。</li><li><strong>灵活性</strong>：可以在 Setter 方法中添加更多逻辑，如日志记录、通知等。</li></ul><hr><h2 id="advantages-of-encapsulation">数据封装的优点</h2><ol><li><strong>数据隐藏</strong>：防止外部直接访问和修改内部数据，保护对象的状态。</li><li><strong>增强安全性</strong>：通过 Getter 和 Setter，可以在修改数据时进行验证，防止非法输入。</li><li><strong>提高可维护性</strong>：内部实现可以随时更改，而不影响外部代码，只要公共接口保持不变。</li><li><strong>实现抽象</strong>：使用者只需了解如何使用公共接口，无需关心内部实现细节。</li><li><strong>降低耦合度</strong>：外部代码与类的内部实现解耦，提高代码的模块化和可重用性。</li></ol><hr><h2 id="design-recommendations">设计建议</h2><ol><li><strong>将类的成员变量设置为私有（<code>private</code>）</strong>：防止外部直接访问，保护数据完整性。</li><li><strong>通过公共接口（<code>public</code> 方法）操作数据</strong>：提供受控的方式与外部交互，便于添加验证和逻辑控制。</li><li><strong>使用 Getter 和 Setter</strong>：控制对数据的访问和修改，确保数据的合法性和一致性。</li><li><strong>隐藏实现细节</strong>：外部无需知道类的内部如何实现，只需了解如何使用公共接口。</li><li><strong>遵循单一职责原则</strong>：每个类只负责一项功能，保持代码的高内聚性和低耦合性。</li></ol><hr><h2 id="real-world-encapsulation-examples">数据封装的现实类比</h2>### **9.1 银行账户**<ul><li><strong>你可以做的操作</strong>：<ul><li>存款、取款、查询余额。</li></ul></li><li><strong>你无法做的操作</strong>：<ul><li>直接修改银行数据库中的账户余额。</li></ul></li><li><strong>解释</strong>：银行系统将账户余额等敏感数据封装起来，客户只能通过受控的方式（ATM、网上银行）进行操作，确保资金安全。</li></ul><h3 id="9-2-家用电器"><a href="#9-2-家用电器" class="headerlink" title="9.2 家用电器"></a><strong>9.2 家用电器</strong></h3><ul><li><strong>你可以做的操作</strong>：<ul><li>按下按钮打开或关闭设备，调整设置。</li></ul></li><li><strong>你无法做的操作</strong>：<ul><li>直接干涉设备内部的电路或程序。</li></ul></li><li><strong>解释</strong>：设备的内部实现对用户是隐藏的，用户只能通过提供的接口（按钮、遥控器）与设备交互。</li></ul><hr><h2 id="summary">总结</h2><p>数据封装是面向对象编程的重要特性，它通过将数据和操作数据的方法封装在一起，并隐藏内部实现细节，实现了数据的保护和代码的灵活性。</p><ul><li><strong>核心思想</strong>：将数据和方法绑定在一起，隐藏内部细节，只通过公共接口与外界交互。</li><li><strong>实现方式</strong>：使用类和访问控制符，定义私有成员和公有方法。</li><li><strong>优势</strong>：<ul><li>提高安全性，保护数据完整性。</li><li>增强代码的可维护性和可扩展性。</li><li>降低耦合度，实现模块化编程。</li><li>提供数据验证，确保数据合法性。</li></ul></li></ul><p>通过合理运用数据封装，我们可以编写出更健壮、更易于维护的代码，使程序具备更高的质量和灵活性。</p><hr><p><strong>如果你还有任何疑问，或者需要进一步的解释，欢迎随时提问！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据抽象</title>
      <link href="/2024/11/22/C-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
      <url>/2024/11/22/C-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.toumatou.cn/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><h1 id="C-数据抽象：只展示必要的，隐藏复杂的"><a href="#C-数据抽象：只展示必要的，隐藏复杂的" class="headerlink" title="C++ 数据抽象：只展示必要的，隐藏复杂的"></a><strong>C++ 数据抽象：只展示必要的，隐藏复杂的</strong></h1><p><strong>数据抽象</strong>是面向对象编程（OOP）中的一个基本概念，它有助于使程序更易于管理、更安全且更易于理解。核心思想是<strong>只向外界展示对象的必要特性，隐藏内部的实现细节</strong>。这使得类的使用者可以通过简单的接口与其交互，而无需了解其内部工作方式。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul><li><a href="#intro-what-is-abstraction">引言：什么是数据抽象？</a></li><li><a href="#real-life-examples">现实生活中的类比</a></li><li><a href="#cpp-implementation">C++ 中的数据抽象如何实现</a></li><li><a href="#cpp-access-control">C++ 的访问控制特性</a></li><li><a href="#benefits-of-abstraction">数据抽象的好处</a></li><li><a href="#example-bank-account">示例：构建一个简单的银行账户类</a></li><li><a href="#code-analysis">代码解析</a></li><li><a href="#design-strategies">数据抽象的设计策略</a></li><li><a href="#common-errors">常见错误及如何避免</a></li><li><a href="#summary">总结</a></li><li><a href="#Think">最后的思考</a></li></ul><hr><h2 id="intro-what-is-abstraction">引言：什么是数据抽象？</h2><p>在编程中，数据抽象指的是只向外界提供必要的信息，隐藏背景细节。这是一种通过隐藏底层细节来减少编程复杂性和工作量的方法。在 C++ 中，数据抽象是通过类和访问控制符来实现的。</p><hr><h2 id="real-life-examples">现实生活中的类比</h2><p>为了更好地理解数据抽象，我们来看一个现实生活中的例子：<strong>自动售货机</strong>。</p><ul><li><p><strong>你需要知道的：</strong></p><ul><li>投入硬币或纸币。</li><li>按下按钮选择商品。</li><li>取走商品和找零。</li></ul></li><li><p><strong>你不需要知道的：</strong></p><ul><li>机器如何识别货币。</li><li>机械臂如何将商品推到出口。</li><li>内部的库存管理系统如何运作。</li></ul></li></ul><p>自动售货机将复杂的内部流程抽象掉，提供了简单的界面（投币口、按钮和取货口）供你使用。</p><hr><h2 id="cpp-implementation">C++ 中的数据抽象如何实现</h2><p>在 C++ 中，数据抽象是通过<strong>类（class）</strong>来实现的。类将数据和操作数据的函数封装在一起。通过控制对类成员的访问，我们可以隐藏内部的工作方式，只暴露必要的部分。</p><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a><strong>类的结构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员（接口）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员（实现细节）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="cpp-access-control">C++ 的访问控制符</h2><p>访问控制符定义了类成员的访问权限。C++ 提供了三个访问控制符：</p><h3 id="公有成员（public）"><a href="#公有成员（public）" class="headerlink" title="公有成员（public）"></a><strong>公有成员（public）</strong></h3><ul><li><strong>语法：</strong> <code>public:</code></li><li><strong>描述：</strong> 在 <code>public</code> 下声明的成员可以在任何地方访问，只要对象是可见的。</li><li><strong>用途：</strong> 定义类的接口，供外部使用的函数和变量。</li></ul><h3 id="私有成员（private）"><a href="#私有成员（private）" class="headerlink" title="私有成员（private）"></a><strong>私有成员（private）</strong></h3><ul><li><strong>语法：</strong> <code>private:</code></li><li><strong>描述：</strong> 在 <code>private</code> 下声明的成员只能在类的内部访问。</li><li><strong>用途：</strong> 存储内部数据和辅助函数，不希望被外部直接访问。</li></ul><h3 id="受保护成员（protected）"><a href="#受保护成员（protected）" class="headerlink" title="受保护成员（protected）"></a><strong>受保护成员（protected）</strong></h3><ul><li><strong>语法：</strong> <code>protected:</code></li><li><strong>描述：</strong> 在 <code>protected</code> 下声明的成员可以在类内部和派生类中访问，但不能在其他地方访问。</li><li><strong>用途：</strong> 当设计一个类的继承体系，需要子类访问某些但不希望公开的成员时使用。</li></ul><hr><h2 id="benefits-of-abstraction">数据抽象的好处</h2><ol><li><strong>安全性：</strong> 隐藏对象的内部状态，防止未经授权的访问和修改。</li><li><strong>简化：</strong> 用户可以通过简单的接口与对象交互，无需关心复杂的内部逻辑。</li><li><strong>可维护性：</strong> 内部实现的改变不会影响使用该类的代码。</li><li><strong>模块化：</strong> 鼓励关注点分离，使代码更加有组织。</li><li><strong>灵活性：</strong> 允许开发者在不改变外部交互方式的情况下更改内部工作方式。</li></ol><hr><h2 id="example-bank-account">示例：构建一个简单的银行账户类</h2><p>让我们创建一个 <code>BankAccount</code>（银行账户）类，来演示 C++ 中的数据抽象。</p><h3 id="BankAccount-类的规范"><a href="#BankAccount-类的规范" class="headerlink" title="BankAccount 类的规范"></a><strong>BankAccount 类的规范</strong></h3><ul><li><p><strong>公有接口：</strong></p><ul><li><code>deposit(double amount)</code>：存款</li><li><code>withdraw(double amount)</code>：取款</li><li><code>getBalance()</code>：获取余额</li></ul></li><li><p><strong>私有成员：</strong></p><ul><li><code>balance</code>（余额）：用于存储账户余额的变量</li></ul></li></ul><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化账户，默认余额为 0.0</span></span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">double</span> initialBalance = <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialBalance &gt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">            balance = initialBalance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            balance = <span class="number">0.0</span>;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;初始余额无效。已将余额设为 0.0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：存款</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;存款金额必须为正数。\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：取款</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;余额不足。\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;取款金额必须为正数。\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：获取余额</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量：余额</span></span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="使用-BankAccount-类"><a href="#使用-BankAccount-类" class="headerlink" title="使用 BankAccount 类"></a><strong>使用 BankAccount 类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BankAccount <span class="title">myAccount</span><span class="params">(<span class="number">100.0</span>)</span></span>;  <span class="comment">// 创建一个初始余额为 $100 的账户</span></span><br><span class="line"></span><br><span class="line">    myAccount.<span class="built_in">deposit</span>(<span class="number">50.0</span>);       <span class="comment">// 存款 $50</span></span><br><span class="line">    myAccount.<span class="built_in">withdraw</span>(<span class="number">20.0</span>);      <span class="comment">// 取款 $20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前余额: $&quot;</span> &lt;&lt; myAccount.<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myAccount.<span class="built_in">withdraw</span>(<span class="number">150.0</span>);     <span class="comment">// 尝试取款 $150（应当失败）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终余额: $&quot;</span> &lt;&lt; myAccount.<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前余额: $130</span><br><span class="line">余额不足。</span><br><span class="line">最终余额: $130</span><br></pre></td></tr></table></figure><hr><h2 id="code-analysis">代码解析</h2><h3 id="7-1-公有接口"><a href="#7-1-公有接口" class="headerlink" title="7.1 公有接口"></a><strong>7.1 公有接口</strong></h3><ul><li><p><strong>构造函数 <code>BankAccount(double initialBalance = 0.0)</code></strong></p><ul><li>用于初始化账户，允许指定初始余额。</li><li>验证初始余额是否为非负数。</li><li>如果初始余额无效，设置余额为 0.0，并输出错误信息。</li></ul></li><li><p><strong><code>deposit(double amount)</code></strong></p><ul><li>允许用户向账户存款。</li><li>验证存款金额为正数。</li><li>更新余额。</li><li>如果金额无效，输出错误信息。</li></ul></li><li><p><strong><code>withdraw(double amount)</code></strong></p><ul><li>允许用户从账户取款。</li><li>检查取款金额为正数且余额足够。</li><li>如果取款成功，更新余额。</li><li>如果金额无效或余额不足，输出错误信息。</li></ul></li><li><p><strong><code>getBalance() const</code></strong></p><ul><li>返回当前余额。</li><li>使用 <code>const</code>，表示此方法不会修改对象的状态。</li></ul></li></ul><h3 id="7-2-私有成员"><a href="#7-2-私有成员" class="headerlink" title="7.2 私有成员"></a><strong>7.2 私有成员</strong></h3><ul><li><strong><code>double balance</code></strong><ul><li>存储账户的当前余额。</li><li>声明为 <code>private</code>，防止外部代码直接修改。</li><li>确保所有对 <code>balance</code> 的更改都通过受控的方法进行。</li></ul></li></ul><h3 id="7-3-为什么要使用数据抽象？"><a href="#7-3-为什么要使用数据抽象？" class="headerlink" title="7.3 为什么要使用数据抽象？"></a><strong>7.3 为什么要使用数据抽象？</strong></h3><ul><li><p><strong>封装余额：</strong></p><ul><li>通过将 <code>balance</code> 设为私有，防止外部代码将其设置为无效值（例如负数）。</li><li>用户不能直接操作余额，必须通过提供的方法，这些方法包含了必要的验证。</li></ul></li><li><p><strong>受控访问：</strong></p><ul><li>所有对 <code>balance</code> 的操作都通过 <code>deposit</code>、<code>withdraw</code> 和 <code>getBalance</code> 进行。</li><li>确保数据完整性和对象状态的一致性。</li></ul></li><li><p><strong>灵活性：</strong></p><ul><li>如果将来需要更改 <code>balance</code> 的内部表示方式（例如从 <code>double</code> 改为更精确的类型），只要公有接口不变，外部代码就无需修改。</li></ul></li></ul><hr><h2 id="design-strategies">数据抽象的设计策略</h2><ol><li><p><strong>将数据成员设为私有：</strong></p><ul><li>始终将数据成员声明为 <code>private</code> 或 <code>protected</code>。</li><li>防止从类外部直接访问和修改，保护数据完整性。</li></ul></li><li><p><strong>提供公有方法进行交互：</strong></p><ul><li>使用 <code>public</code> 方法提供必要的功能。</li><li>这些方法应包含必要的验证和错误处理。</li><li>保持接口简洁易用。</li></ul></li><li><p><strong>接口与实现分离：</strong></p><ul><li>类的使用者只需与接口（公有方法）交互，无需了解实现细节。</li><li>这允许在不影响外部代码的情况下更改内部实现。</li><li>增强了模块化和可维护性。</li></ul></li><li><p><strong>正确使用 <code>const</code>：</strong></p><ul><li>对于不修改对象状态的方法，使用 <code>const</code> 修饰。</li><li>防止意外修改，提高代码安全性。</li><li>允许在 <code>const</code> 对象上调用这些方法。</li></ul></li><li><p><strong>为接口提供文档：</strong></p><ul><li>为公有方法提供清晰的注释和文档。</li><li>解释方法的功能、参数、返回值以及可能的错误情况。</li><li>提高代码的可读性和可用性。</li></ul></li></ol><hr><h2 id="common-errors">常见错误及如何避免</h2><h3 id="9-1-将数据成员设为公有"><a href="#9-1-将数据成员设为公有" class="headerlink" title="9.1 将数据成员设为公有"></a><strong>9.1 将数据成员设为公有</strong></h3><ul><li><strong>错误：</strong> 将数据成员声明为 <code>public</code>，允许外部代码直接访问和修改。</li><li><strong>问题：</strong> 可能导致数据处于无效状态，难以维护数据完整性。</li><li><strong>解决方案：</strong> 始终将数据成员声明为 <code>private</code> 或 <code>protected</code>，通过受控的公有方法访问。</li></ul><h3 id="9-2-未对输入进行验证"><a href="#9-2-未对输入进行验证" class="headerlink" title="9.2 未对输入进行验证"></a><strong>9.2 未对输入进行验证</strong></h3><ul><li><strong>错误：</strong> 在公有方法中未检查输入，可能导致对象处于无效状态（例如负余额）。</li><li><strong>问题：</strong> 会引发错误和意外行为。</li><li><strong>解决方案：</strong> 在所有修改对象状态的方法中实现输入验证，并提供有意义的错误信息。</li></ul><h3 id="9-3-暴露内部实现"><a href="#9-3-暴露内部实现" class="headerlink" title="9.3 暴露内部实现"></a><strong>9.3 暴露内部实现</strong></h3><ul><li><strong>错误：</strong> 设计的方法暴露或依赖于内部数据结构（例如返回私有成员的指针或引用）。</li><li><strong>问题：</strong> 打破了封装性，可能导致意外的副作用。</li><li><strong>解决方案：</strong> 保持内部实现的隐藏，方法应在更高的抽象层次上操作。</li></ul><h3 id="9-4-忽略-const-的使用"><a href="#9-4-忽略-const-的使用" class="headerlink" title="9.4 忽略 const 的使用"></a><strong>9.4 忽略 <code>const</code> 的使用</strong></h3><ul><li><strong>错误：</strong> 未在适当的地方使用 <code>const</code>，导致方法可能意外修改对象。</li><li><strong>问题：</strong> 可能引发副作用，使代码难以理解。</li><li><strong>解决方案：</strong> 使用 <code>const</code> 标记不修改对象状态的方法，提高代码安全性和清晰度。</li></ul><h3 id="9-5-接口过于复杂"><a href="#9-5-接口过于复杂" class="headerlink" title="9.5 接口过于复杂"></a><strong>9.5 接口过于复杂</strong></h3><ul><li><strong>错误：</strong> 提供过多的公有方法，或暴露不必要的功能。</li><li><strong>问题：</strong> 使类难以使用和理解。</li><li><strong>解决方案：</strong> 保持公有接口的简洁，专注于核心功能。</li></ul><hr><h2 id="summary">总结</h2><ul><li><strong>数据抽象</strong>是面向对象编程中的关键原则，允许开发者通过隐藏内部细节来简化复杂系统。</li><li><strong>类</strong>是 C++ 中实现数据抽象的主要方式，将数据和函数封装在一起。</li><li><strong>访问控制符</strong>（<code>public</code>、<code>private</code>、<code>protected</code>）控制类成员的访问方式，是实现抽象的关键。</li><li><strong>数据抽象的好处</strong>包括提高安全性、简化接口、增强可维护性和灵活性。</li><li><strong>设计策略</strong>包括仔细规划类的接口，将数据成员设为私有，提供公有方法进行必要的交互，以及正确使用 <code>const</code>。</li><li><strong>避免常见错误</strong>，遵循最佳实践，如正确使用访问控制符和输入验证。</li></ul><hr><h2 id="Think">最后的思考</h2><p>理解并有效地实现数据抽象，对于编写健壮、可维护和安全的 C++ 程序至关重要。通过精心设计类，只暴露必要的部分并隐藏其余内容，可以使代码更易于使用，减少错误的可能性。</p><p>在设计类时，始终自问：</p><ul><li><strong>使用者需要知道什么？</strong></li><li><strong>应该隐藏什么以防止误用或意外错误？</strong></li></ul><p>这种思维方式将指导你创建有效的抽象，使你的代码库更加强大，能够适应变化。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="/2024/11/22/C-%E5%A4%9A%E6%80%81/"/>
      <url>/2024/11/22/C-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.toumatou.cn/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><hr><h1 id="C-多态：让对象具备“多种形态”的能力"><a href="#C-多态：让对象具备“多种形态”的能力" class="headerlink" title="C++ 多态：让对象具备“多种形态”的能力"></a><strong>C++ 多态：让对象具备“多种形态”的能力</strong></h1><p><strong>多态</strong>，顾名思义，就是“多种形态”。在 C++ 中，多态是面向对象编程（OOP）的三大特性之一（另两个是封装和继承）。多态使得程序可以使用统一的接口来操纵不同类型的对象，从而实现代码的灵活性和可扩展性。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81">什么是多态？</a></li><li><a href="#2-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5">虚函数的概念</a></li><li><a href="#3-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-vs-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A">动态绑定 vs 静态绑定</a></li><li><a href="#4-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB">纯虚函数与抽象类</a></li><li><a href="#5-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">多态的实现原理</a></li><li><a href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81">为什么要使用多态？</a></li><li><a href="#7-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">使用多态需要注意的问题</a></li><li><a href="#8-%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a><strong>1. 什么是多态？</strong></h2><p>多态是指程序中对象的多种表现形态，具体来说，就是<strong>使用基类指针或引用，在运行时根据对象的实际类型，调用对应的重写方法</strong>。这意味着<strong>同一个函数调用，根据对象类型的不同，会表现出不同的行为</strong>。</p><p>举个生活中的例子：</p><p>假设有一个“动物”这个概念，动物会“发出声音”。不同的动物，发出的声音不同。猫会“喵喵叫”，狗会“汪汪叫”。在程序中，我们可以通过一个统一的接口（如 <code>speak()</code> 方法）来让不同的动物发出各自的声音。</p><hr><h2 id="2-虚函数的概念"><a href="#2-虚函数的概念" class="headerlink" title="2. 虚函数的概念"></a><strong>2. 虚函数的概念</strong></h2><h3 id="2-1-什么是虚函数？"><a href="#2-1-什么是虚函数？" class="headerlink" title="2.1 什么是虚函数？"></a><strong>2.1 什么是虚函数？</strong></h3><p><strong>虚函数</strong>（virtual function）是使用 <code>virtual</code> 关键字声明的成员函数，目的是为了<strong>允许子类重写该函数，并在运行时通过基类指针或引用调用子类的实现</strong>。</p><h3 id="2-2-为什么需要虚函数？"><a href="#2-2-为什么需要虚函数？" class="headerlink" title="2.2 为什么需要虚函数？"></a><strong>2.2 为什么需要虚函数？</strong></h3><p>在基类中，如果某个函数可能会被子类重写，并且你希望通过基类指针调用子类的实现，就需要将该函数声明为虚函数。</p><h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a><strong>2.3 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes a sound.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat meows.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-如何使用"><a href="#2-4-如何使用" class="headerlink" title="2.4 如何使用"></a><strong>2.4 如何使用</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal1 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    Animal* animal2 = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(animal1);  <span class="comment">// 输出：Dog barks.</span></span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(animal2);  <span class="comment">// 输出：Cat meows.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> animal1;</span><br><span class="line">    <span class="keyword">delete</span> animal2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，尽管我们使用的是 <code>Animal*</code> 类型的指针，但实际调用的是 <code>Dog</code> 和 <code>Cat</code> 各自的 <code>speak()</code> 方法。</p><hr><h2 id="3-动态绑定-vs-静态绑定"><a href="#3-动态绑定-vs-静态绑定" class="headerlink" title="3. 动态绑定 vs 静态绑定"></a><strong>3. 动态绑定 vs 静态绑定</strong></h2><h3 id="3-1-静态绑定"><a href="#3-1-静态绑定" class="headerlink" title="3.1 静态绑定"></a><strong>3.1 静态绑定</strong></h3><ul><li><strong>定义</strong>：函数调用在编译时就已经确定，称为<strong>静态绑定</strong>或<strong>早期绑定</strong>。</li><li><strong>特点</strong>：编译器根据对象的静态类型决定调用哪个函数。</li></ul><h3 id="3-2-动态绑定"><a href="#3-2-动态绑定" class="headerlink" title="3.2 动态绑定"></a><strong>3.2 动态绑定</strong></h3><ul><li><strong>定义</strong>：函数调用在运行时根据对象的实际类型来决定，称为<strong>动态绑定</strong>或<strong>晚期绑定</strong>。</li><li><strong>特点</strong>：需要通过基类指针或引用调用虚函数。</li></ul><h3 id="3-3-示例对比"><a href="#3-3-示例对比" class="headerlink" title="3.3 示例对比"></a><strong>3.3 示例对比</strong></h3><p><strong>静态绑定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog dog;</span><br><span class="line">dog.<span class="built_in">speak</span>();  <span class="comment">// 编译时决定调用 Dog::speak()</span></span><br></pre></td></tr></table></figure><p><strong>动态绑定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 运行时决定调用 Dog::speak()</span></span><br></pre></td></tr></table></figure><p>如果 <code>speak()</code> 不是虚函数，那么即使使用基类指针，也会调用 <code>Animal::speak()</code>，这是因为没有动态绑定，函数调用在编译时已经确定。</p><hr><h2 id="4-纯虚函数与抽象类"><a href="#4-纯虚函数与抽象类" class="headerlink" title="4. 纯虚函数与抽象类"></a><strong>4. 纯虚函数与抽象类</strong></h2><h3 id="4-1-纯虚函数"><a href="#4-1-纯虚函数" class="headerlink" title="4.1 纯虚函数"></a><strong>4.1 纯虚函数</strong></h3><ul><li><strong>定义</strong>：没有实现的虚函数，声明时在函数签名后加 <code>= 0</code>。</li><li><strong>目的</strong>：要求派生类必须实现该函数，否则派生类也将是抽象类，无法实例化。</li></ul><h3 id="4-2-抽象类"><a href="#4-2-抽象类" class="headerlink" title="4.2 抽象类"></a><strong>4.2 抽象类</strong></h3><ul><li><strong>定义</strong>：包含纯虚函数的类称为<strong>抽象类</strong>。</li><li><strong>特点</strong>：<ul><li>不能创建抽象类的实例。</li><li>可以包含成员变量和已经实现的函数。</li><li>用于定义接口，供子类继承和实现。</li></ul></li></ul><h3 id="4-3-示例"><a href="#4-3-示例" class="headerlink" title="4.3 示例"></a><strong>4.3 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-4-使用抽象类"><a href="#4-4-使用抽象类" class="headerlink" title="4.4 使用抽象类"></a><strong>4.4 使用抽象类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderShape</span><span class="params">(Shape* shape)</span> </span>&#123;</span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">renderShape</span>(shape1);  <span class="comment">// 输出：Drawing a circle.</span></span><br><span class="line">    <span class="built_in">renderShape</span>(shape2);  <span class="comment">// 输出：Drawing a rectangle.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-多态的实现原理"><a href="#5-多态的实现原理" class="headerlink" title="5. 多态的实现原理"></a><strong>5. 多态的实现原理</strong></h2><h3 id="5-1-虚函数表（V-Table）"><a href="#5-1-虚函数表（V-Table）" class="headerlink" title="5.1 虚函数表（V-Table）"></a><strong>5.1 虚函数表（V-Table）</strong></h3><ul><li><strong>概念</strong>：编译器为每个包含虚函数的类创建一个虚函数表，记录该类的虚函数地址。</li><li><strong>作用</strong>：用于在运行时动态决定调用哪个函数。</li></ul><h3 id="5-2-虚函数指针（V-Ptr）"><a href="#5-2-虚函数指针（V-Ptr）" class="headerlink" title="5.2 虚函数指针（V-Ptr）"></a><strong>5.2 虚函数指针（V-Ptr）</strong></h3><ul><li><strong>概念</strong>：每个对象都有一个隐藏的指针，指向所属类的虚函数表。</li><li><strong>作用</strong>：通过虚函数指针找到虚函数表，从而调用正确的函数实现。</li></ul><h3 id="5-3-调用过程"><a href="#5-3-调用过程" class="headerlink" title="5.3 调用过程"></a><strong>5.3 调用过程</strong></h3><p>当通过基类指针或引用调用虚函数时：</p><ol><li>程序根据对象的虚函数指针找到对应的虚函数表。</li><li>在虚函数表中查找对应函数的地址。</li><li>调用该地址对应的函数实现。</li></ol><h3 id="5-4-示例图解"><a href="#5-4-示例图解" class="headerlink" title="5.4 示例图解"></a><strong>5.4 示例图解</strong></h3><ul><li><p><strong>类结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal</span><br><span class="line">├── speak() [virtual]</span><br><span class="line">↓</span><br><span class="line">Dog : public Animal</span><br><span class="line">    └── speak() [override]</span><br></pre></td></tr></table></figure></li><li><p><strong>对象内存布局</strong></p><ul><li><p><strong>Animal 对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ V-Ptr ] ---&gt; [ Animal V-Table ]</span><br><span class="line">                   ├── speak() --&gt; Animal::speak()</span><br></pre></td></tr></table></figure></li><li><p><strong>Dog 对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ V-Ptr ] ---&gt; [ Dog V-Table ]</span><br><span class="line">                   ├── speak() --&gt; Dog::speak()</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="6-为什么要使用多态？"><a href="#6-为什么要使用多态？" class="headerlink" title="6. 为什么要使用多态？"></a><strong>6. 为什么要使用多态？</strong></h2><h3 id="6-1-代码复用性"><a href="#6-1-代码复用性" class="headerlink" title="6.1 代码复用性"></a><strong>6.1 代码复用性</strong></h3><ul><li><strong>统一接口</strong>：通过基类指针或引用，可以使用同一个函数操作不同类型的对象。</li><li><strong>减少重复代码</strong>：避免为每个子类编写重复的函数调用代码。</li></ul><h3 id="6-2-扩展性"><a href="#6-2-扩展性" class="headerlink" title="6.2 扩展性"></a><strong>6.2 扩展性</strong></h3><ul><li><strong>易于维护和扩展</strong>：添加新的子类无需修改现有代码，只需确保新子类实现了必要的虚函数。</li><li><strong>降低耦合度</strong>：模块之间依赖于抽象的接口，而非具体的实现。</li></ul><h3 id="6-3-灵活性"><a href="#6-3-灵活性" class="headerlink" title="6.3 灵活性"></a><strong>6.3 灵活性</strong></h3><ul><li><strong>运行时决定行为</strong>：程序可以在运行时根据实际对象类型执行不同的操作。</li><li><strong>支持多态容器</strong>：可以创建包含基类指针的容器，存储不同类型的对象。</li></ul><hr><h2 id="7-使用多态需要注意的问题"><a href="#7-使用多态需要注意的问题" class="headerlink" title="7. 使用多态需要注意的问题"></a><strong>7. 使用多态需要注意的问题</strong></h2><h3 id="7-1-析构函数应为虚函数"><a href="#7-1-析构函数应为虚函数" class="headerlink" title="7.1 析构函数应为虚函数"></a><strong>7.1 析构函数应为虚函数</strong></h3><ul><li><p><strong>原因</strong>：当通过基类指针删除子类对象时，如果基类析构函数不是虚函数，可能导致资源未正确释放。</p></li><li><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2-对象切片"><a href="#7-2-对象切片" class="headerlink" title="7.2 对象切片"></a><strong>7.2 对象切片</strong></h3><ul><li><strong>概念</strong>：当将子类对象赋值给基类对象时，子类特有的数据会被“切掉”。</li><li><strong>避免方法</strong>：尽量使用指针或引用来处理对象。</li></ul><h3 id="7-3-性能开销"><a href="#7-3-性能开销" class="headerlink" title="7.3 性能开销"></a><strong>7.3 性能开销</strong></h3><ul><li><strong>动态绑定的成本</strong>：多态机制需要在运行时查找函数地址，略微增加了执行时间和内存开销。</li><li><strong>权衡</strong>：通常，这些开销是可以接受的，不会对性能产生显著影响。</li></ul><h3 id="7-4-虚函数不能是内联函数"><a href="#7-4-虚函数不能是内联函数" class="headerlink" title="7.4 虚函数不能是内联函数"></a><strong>7.4 虚函数不能是内联函数</strong></h3><ul><li><strong>原因</strong>：虚函数在运行时决定调用哪个版本，无法在编译时内联展开。</li></ul><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><p>多态是 C++ 面向对象编程的核心特性之一，它通过虚函数和动态绑定机制，使得程序可以在运行时根据对象的实际类型执行相应的操作。</p><p><strong>多态的优点</strong>：</p><ul><li>提高代码的复用性和可维护性。</li><li>增强程序的扩展性和灵活性。</li><li>使代码更符合面向对象的设计思想。</li></ul><p><strong>使用多态的关键</strong>：</p><ul><li>使用虚函数来允许子类重写基类方法。</li><li>通过基类指针或引用来调用虚函数。</li><li>当需要定义统一接口时，使用纯虚函数和抽象类。</li></ul><hr><p>希望以上内容能够帮助您更深入地理解 C++ 中的多态机制，并在实际编程中有效地应用它。多态虽然概念简单，但在大型项目中能够大大简化代码结构，提高开发效率。</p><p>如果您有任何疑问，或者需要进一步的解释，请随时提问！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吾爱破解大佬的新成果</title>
      <link href="/2024/11/21/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%B0%E6%88%90%E6%9E%9C/"/>
      <url>/2024/11/21/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%B0%E6%88%90%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>今天给大家分享一款非常好用的手机扫描软件，包不会后悔的😏</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：扫描王</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p><strong>软件的主页提供了一些核心功能，包括文档扫描、文本提取、身份证件的扫描以及表格的识别。这些功能都是直接集成在首页上，用户无需进行登录或注册，可以直接点击相应的选项在线使用这些服务</strong></p><div style="text-align:center">  <img src="/img_1/461597BB7A0BC066CD0D31B240D2BDCB.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>这个服务就像是你的个人数字助理，它对扫描有着广泛的“口味”，无论是纸质的还是电子的，都能轻松“消化”。它不仅能把任何东西变成PDF和图像，还能用它的OCR魔法棒一挥，把图片里的文字变活，让它们跳进PDF文件里。就像是给文字做了个“数字复活”，让它们从静态的图像中跳出来，变得可以编辑和复制。这不仅仅是扫描，这是一次文字的“数字化大逃亡”！</strong></p><div style="text-align:center">  <img src="/img_1/9320352FE7BDE691479066B62A57435D.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>这款软件是个多语言高手，能读懂中文、英文、日语和粤语等八种语言的文字，而且读得非常准确。用户只需轻轻一点，就能把识别出来的文字复制走，还能一键转换成Word文档。不仅如此，它还能把内容变成PDF、Word和TXT格式，就像是文字的变形金刚，想变什么格式就变什么格式</strong></p><div style="text-align:center">  <img src="/img_1/70C3B27DF29D0D37D92A53946A89D21E.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>该工具提供PDF转换服务，能够将PDF文件转换成Word、Excel以及图片格式。此外，它还具备PDF文件合并的功能，允许用户将多个PDF文档合并为一个。这项服务在没有电脑可用的情况下，为用户提供了一个便捷的应急解决方案，使得文件处理变得更加灵活和高效</strong></p><div style="text-align:center">  <img src="/img_1/0D98D74DECD28CC0432BECAEF10667E1.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="https://share.feijipan.com/s/a0DHTOoM">https://share.feijipan.com/s/a0DHTOoM</a></strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>想象一下，你手里拿着的不是手机，而是一台时光机，这台时光机能做什么呢？它能带你穿梭到任何文档的深处，提取文字，扫描证件，甚至还能识别表格，就像你有一个隐形的助手在帮你整理文件。不仅如此，它还能让你成为艺术家，AI绘画功能让你的创意飞起来；试卷擦除功能让你重温学生时代的“作弊”梦想（开个玩笑，我们还是诚实的好孩子）；口算批改功能让你瞬间变身数学老师；拍照翻译功能让你成为语言大师；图片修复功能让你成为修复大师。最重要的是，这台“时光机”不收你一分钱，就像是天上掉下来的馅饼，你只需要张嘴吃就行了。所以，别犹豫，拿起你的“时光机”，开始你的扫描之旅吧！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 扫描软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒意深处，春的絮语</title>
      <link href="/2024/11/20/%E5%86%AC/"/>
      <url>/2024/11/20/%E5%86%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="今日分享"><a href="#今日分享" class="headerlink" title="今日分享"></a>今日分享</h1><p><strong>以下是拍摄图</strong></p><p><strong>冬，是万物蛰伏的季节，是大自然孕育新生的前奏。北风轻拂，染尽山河的苍茫，一抹赤红的枫叶与初雪相遇，似乎在低语着冬日悄然降临的讯息。那飘落的雪花，宛如时光的信笺，写满了季节的更迭与生命的诗意。</strong></p><div style="text-align:center">  <img src="/img_1/C5C2E05CE2FD27DECD2203AD5C48418C.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" >  <img src="/img_1/AAAD2D03CAEC17FA767E12470AF9F171.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>寒冷从不是希望的终结，而是希望的酝酿。冰封之下，生命的根脉正悄然积蓄力量。愿你在风雪中坚定前行，于冰冷中守住心底的温暖，去迎接那一场雪中的浪漫。</strong></p><div style="text-align:center">  <img src="/img_1/3382C3B8BC81FB7847B5B5E7CDEDE905.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>冬日是约定，春天是兑现。当雪融化成溪，寒意褪去，一切美好都将在阳光下蓬勃生长。请相信，今天的凛冽终会酝酿出明日的繁华。</strong></p><div style="text-align:center">  <img src="/img_1/8574FF6732FBEF1C2045836B08557343.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 重载运算符和重载函数</title>
      <link href="/2024/11/20/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
      <url>/2024/11/20/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从本节内容开始的内容，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">点击这里</a>重新温习一下,废话不多说，直接进入正题吧！</strong></p><h1 id="C-重载运算符和重载函数"><a href="#C-重载运算符和重载函数" class="headerlink" title="C++ 重载运算符和重载函数"></a>C++ 重载运算符和重载函数</h1><p>想象一下，你有一个多功能的瑞士军刀，每个工具都有自己的特定用途，但它们都藏在同一个刀柄里。在C++中，函数重载和运算符重载就像是这个瑞士军刀，允许你用同一个名字来执行不同的任务，只要你给它不同的“工具”。</p><ol><li><p><strong>函数重载</strong>：</p><ul><li>这就像是你告诉你的瑞士军刀，“当我需要切东西时，给我刀片；当我需要拧螺丝时，给我螺丝刀。”在C++中，你可以有多个同名的函数，但每个函数接受的参数类型或数量不同。比如，你可以有一个<code>print()</code>函数来打印整数，另一个<code>print()</code>函数来打印字符串。</li><li>当你调用<code>print(5)</code>时，编译器知道你想要打印一个整数，所以它会选择接受整数参数的那个<code>print()</code>函数。如果你调用<code>print(&quot;Hello&quot;)</code>，编译器会选择接受字符串参数的那个<code>print()</code>函数。</li></ul></li><li><p><strong>运算符重载</strong>：</p><ul><li>这就像是你对你的瑞士军刀说，“当我用加号时，如果我在加两个数字，就做数学加法；如果我在加两个我自定义的类对象，就按照我告诉你的特殊方式来加。”在C++中，你可以改变大多数内置运算符的行为，让它们也能用于你自定义的类。</li><li>例如，如果你有一个<code>Box</code>类，你可以重载加号运算符来定义两个<code>Box</code>对象相加意味着什么。你可能会决定它意味着把两个盒子的体积相加。</li></ul></li></ol><p><strong>重载决策</strong>：</p><ul><li>当你使用重载的函数或运算符时，编译器需要决定哪个版本是最佳匹配。这就像你对瑞士军刀说，“我要切这个苹果”，军刀就会决定给你刀片而不是螺丝刀。</li><li>编译器通过比较你使用的参数类型和函数或运算符定义中的参数类型来做出决定。这个过程就像是军刀在检查你想要做什么，然后选择最合适的工具。</li></ul><h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在 C++ 中，<strong>函数重载</strong>指的是可以在同一个作用域中定义多个同名函数，但这些函数的参数列表必须不同（包括参数的数量、类型或顺序）。它允许我们使用一个名字来处理不同类型的操作。</p><p><strong>注意</strong>：</p><ul><li>函数重载的区分是基于参数的类型和数量。</li><li><strong>仅通过返回值的不同是不能实现重载的</strong>。</li></ul><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>假如我们有一个需求：输出不同类型的数据，比如整数、浮点数和字符串。每种数据类型需要一个特定的方法去输出，但我们不想使用不同的函数名（比如 <code>printInt()</code>、<code>printFloat()</code> 等），这时候可以使用<strong>函数重载</strong>。</p><p>下面是代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类 printData，包含多个同名函数 print()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 用于输出整数</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于输出浮点数</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于输出字符串</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个 printData 的对象</span></span><br><span class="line">   printData pd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行的结果"><a href="#程序运行的结果" class="headerlink" title="程序运行的结果"></a>程序运行的结果</h3><p>运行上述代码会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整数为: 5</span><br><span class="line">浮点数为: 500.263</span><br><span class="line">字符串为: Hello C++</span><br></pre></td></tr></table></figure><h3 id="程序工作原理的详细解释"><a href="#程序工作原理的详细解释" class="headerlink" title="程序工作原理的详细解释"></a>程序工作原理的详细解释</h3><ol><li><p>**定义类 <code>printData</code>**：</p><ul><li>包含三个同名函数 <code>print()</code>。</li><li>每个函数的参数类型不同：一个接收 <code>int</code> 类型，一个接收 <code>double</code> 类型，一个接收 <code>char[]</code> 类型。</li><li>根据传递给 <code>print()</code> 的参数类型，C++ 编译器会选择调用相应的函数。</li></ul></li><li><p><strong>在 <code>main()</code> 函数中</strong>：</p><ul><li>创建了一个 <code>printData</code> 的对象 <code>pd</code>。</li><li>调用了不同参数版本的 <code>print()</code>：<ul><li>传入整数 <code>5</code>，调用接收 <code>int</code> 类型参数的函数。</li><li>传入浮点数 <code>500.263</code>，调用接收 <code>double</code> 类型参数的函数。</li><li>传入字符串 <code>&quot;Hello C++&quot;</code>，调用接收 <code>char[]</code> 类型参数的函数。</li></ul></li></ul></li></ol><h3 id="为什么函数重载很有用？"><a href="#为什么函数重载很有用？" class="headerlink" title="为什么函数重载很有用？"></a>为什么函数重载很有用？</h3><p>函数重载的好处包括：</p><ol><li><strong>统一接口</strong>：不同的操作共享同一个函数名，提高代码的可读性和易用性。</li><li><strong>自动匹配类型</strong>：根据传递的参数，自动调用对应的函数，无需手动区分函数名。</li><li><strong>避免混乱</strong>：不用为每种操作创建不同的函数名，减少记忆负担。</li></ol><h3 id="函数重载的核心规则"><a href="#函数重载的核心规则" class="headerlink" title="函数重载的核心规则"></a>函数重载的核心规则</h3><ol><li><p>参数列表必须不同，具体包括：</p><ul><li>参数的数量不同。</li><li>参数的类型不同。</li><li>参数的顺序不同（例如 <code>print(int, double)</code> 和 <code>print(double, int)</code> 是可以重载的）。</li></ul></li><li><p><strong>返回值的不同不能作为重载的条件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print</span><span class="params">()</span></span>; <span class="comment">// 错误：仅靠返回值不同，不能区分函数。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="更直观的对比"><a href="#更直观的对比" class="headerlink" title="更直观的对比"></a>更直观的对比</h3><p><strong>不使用重载的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printDouble</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用这些方法时，需要记住不同的函数名，比如 <code>printInt()</code>、<code>printDouble()</code> 等。</p><p><strong>使用重载的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用时只需记住一个名字 <code>print()</code>，编译器根据参数自动调用合适的版本。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>函数重载是 C++ 提供的一种重要功能，用来让函数名称更简洁、统一，同时又支持多种类型的操作。在上面的例子中，<code>print()</code> 方法能够根据参数类型自动选择合适的版本，这是函数重载的核心优势。</p><h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>在 C++ 中，<strong>运算符重载</strong>允许我们为自定义的类定义运算符行为，使得可以像操作基本数据类型（例如整数、浮点数）一样，使用运算符对自定义的对象进行操作。</p><h3 id="1-运算符重载的基本概念"><a href="#1-运算符重载的基本概念" class="headerlink" title="1. 运算符重载的基本概念"></a>1. 运算符重载的基本概念</h3><p>运算符重载实际上是通过定义一个特殊的成员函数或者非成员函数，使得运算符能够适用于我们自定义的类。在 C++ 中，重载运算符的函数名由关键字 <code>operator</code> 加上运算符符号组成。这样做的好处是，运算符可以像普通函数一样处理对象，并实现自定义的行为。</p><h3 id="2-运算符重载的形式"><a href="#2-运算符重载的形式" class="headerlink" title="2. 运算符重载的形式"></a>2. 运算符重载的形式</h3><p>有两种常见的方式来定义运算符重载：</p><ul><li><strong>成员函数重载</strong>：运算符重载是类的成员函数，并且通常只需要一个参数（即右侧操作数）。</li><li><strong>非成员函数重载</strong>：运算符重载是类外部的普通函数，通常需要两个参数（即两个操作数）。</li></ul><h3 id="3-运算符重载实例：加法运算符"><a href="#3-运算符重载实例：加法运算符" class="headerlink" title="3. 运算符重载实例：加法运算符"></a>3. 运算符重载实例：加法运算符</h3><p>假设我们有一个 <code>Box</code> 类，它表示一个长方体。我们希望能够对两个 <code>Box</code> 对象进行加法操作，使得两个长方体的尺寸（长度、宽度、高度）相加，得到一个新的 <code>Box</code> 对象。</p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取长方体的体积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置长方体的长度、宽度和高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123; length = len; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBreadth</span><span class="params">(<span class="type">double</span> bre)</span> </span>&#123; breadth = bre; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> hei)</span> </span>&#123; height = hei; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载加法运算符，用于将两个 Box 对象的尺寸相加</span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b) &#123;</span><br><span class="line">        Box box; <span class="comment">// 新的 Box 对象</span></span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length; <span class="comment">// 加法操作</span></span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">        <span class="keyword">return</span> box; <span class="comment">// 返回新创建的 Box 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth; <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;  <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box Box1, Box2, Box3; <span class="comment">// 创建三个 Box 对象</span></span><br><span class="line">    <span class="type">double</span> volume = <span class="number">0.0</span>; <span class="comment">// 存储体积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Box1 的尺寸</span></span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setLength</span>(<span class="number">6.0</span>);</span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setBreadth</span>(<span class="number">7.0</span>);</span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setHeight</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Box2 的尺寸</span></span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setLength</span>(<span class="number">12.0</span>);</span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setBreadth</span>(<span class="number">13.0</span>);</span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setHeight</span>(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box1 的体积</span></span><br><span class="line">    volume = Box<span class="number">1.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box1: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box2 的体积</span></span><br><span class="line">    volume = Box<span class="number">2.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box2: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Box1 和 Box2 相加，得到 Box3</span></span><br><span class="line">    Box3 = Box1 + Box2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box3 的体积</span></span><br><span class="line">    volume = Box<span class="number">3.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h4><ol><li><p><strong>定义 <code>Box</code> 类：</strong> <code>Box</code> 类有三个私有成员变量：<code>length</code>（长度）、<code>breadth</code>（宽度）和 <code>height</code>（高度）。我们通过公共成员函数 <code>setLength()</code>、<code>setBreadth()</code> 和 <code>setHeight()</code> 来设置它们的值。</p></li><li><p><strong>成员函数 <code>operator+</code>：</strong> 这个函数重载了加法运算符 <code>+</code>，它接受一个 <code>Box</code> 类型的对象 <code>b</code>，并将当前对象（通过 <code>this</code> 指针访问）和 <code>b</code> 的尺寸进行相加。相加的结果存储在一个新的 <code>Box</code> 对象中，并返回这个新的对象。</p></li><li><p><strong>计算体积：</strong> <code>getVolume()</code> 函数返回长方体的体积，即 <code>length * breadth * height</code>。</p></li><li><p><strong>主函数：</strong></p><ul><li>我们创建了三个 <code>Box</code> 对象：<code>Box1</code>、<code>Box2</code> 和 <code>Box3</code>。</li><li>给 <code>Box1</code> 和 <code>Box2</code> 设置了不同的尺寸。</li><li>使用重载的加法运算符将 <code>Box1</code> 和 <code>Box2</code> 相加，得到一个新的 <code>Box3</code>。</li><li>最后输出 <code>Box1</code>、<code>Box2</code> 和 <code>Box3</code> 的体积。</li></ul></li></ol><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Volume of Box1: 210</span><br><span class="line">Volume of Box2: 1560</span><br><span class="line">Volume of Box3: 5400</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Box1</code> 的体积是 <code>6 * 7 * 5 = 210</code>。</li><li><code>Box2</code> 的体积是 <code>12 * 13 * 10 = 1560</code>。</li><li><code>Box3</code> 是 <code>Box1</code> 和 <code>Box2</code> 的尺寸相加，得到的新 Box 的体积是 <code>(6+12) * (7+13) * (5+10) = 18 * 20 * 15 = 5400</code>。</li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>运算符重载让我们能够自定义运算符行为，使得运算符可以对自定义类型的对象进行操作。</li><li>可以通过成员函数或者非成员函数来重载运算符。</li><li>运算符重载可以大大提高代码的可读性和可维护性，尤其是对于复杂的对象操作。</li></ul><h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p><!DOCTYPE html><html><head>    <title>运算符重载</title></head><body>    <h2>可重载的运算符</h2>    <table border="1">        <thead>            <tr>                <th>类别</th>                <th>运算符</th>            </tr>        </thead>        <tbody>            <tr>                <td>双目算术运算符</td>                <td>+ (加)，- (减)，* (乘)，/ (除)，% (取模)</td>            </tr>            <tr>                <td>关系运算符</td>                <td>== (等于)，!= (不等于)，< (小于)，> (大于)，<= (小于等于)，>= (大于等于)</td>            </tr>            <tr>                <td>逻辑运算符</td>                <td>|| (逻辑或)，&& (逻辑与)，! (逻辑非)</td>            </tr>            <tr>                <td>单目运算符</td>                <td>+ (正)，- (负)，* (指针)，& (取地址)</td>            </tr>            <tr>                <td>自增自减运算符</td>                <td>++ (自增)，-- (自减)</td>            </tr>            <tr>                <td>位运算符</td>                <td>| (按位或)，& (按位与)，~ (按位取反)，^ (按位异或)，<< (左移)，>> (右移)</td>            </tr>            <tr>                <td>赋值运算符</td>                <td>=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=</td>            </tr>            <tr>                <td>空间申请与释放</td>                <td>new, delete, new[], delete[]</td>            </tr>            <tr>                <td>其他运算符</td>                <td>() (函数调用)，-> (成员访问)，, (逗号)，[] (下标)</td>            </tr>        </tbody>    </table></body></html><p>下面是不可重载的运算符列表：</p><table>  <tr>    <th>不可重载运算符</th>    <th>描述</th>  </tr>  <tr>    <td>. (点运算符)</td>    <td>成员访问运算符，用于访问对象的成员。</td>  </tr>  <tr>    <td>.* (点星运算符)</td>    <td>成员指针访问运算符，用于通过成员指针访问成员。</td>  </tr>  <tr>    <td>->* (箭头星运算符)</td>    <td>成员指针访问运算符，用于通过成员指针访问成员。</td>  </tr>  <tr>    <td>:: (域运算符)</td>    <td>用于指定某个类或命名空间的成员。</td>  </tr>  <tr>    <td>sizeof (长度运算符)</td>    <td>用于获取数据类型的大小。</td>  </tr>  <tr>    <td>?: (条件运算符)</td>    <td>用于进行条件选择。</td>  </tr>  <tr>    <td># (预处理符号)</td>    <td>用于预处理阶段的宏定义。</td>  </tr></table><h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><table border="1">  <tr>    <th>序号</th>    <th>运算符和实例</th>  </tr>  <tr>    <td>1</td>    <td>一元运算符重载</td>  </tr>  <tr>    <td>2</td>    <td>二元运算符重载</td>  </tr>  <tr>    <td>3</td>    <td>关系运算符重载</td>  </tr>  <tr>    <td>4</td>    <td>输入/输出运算符重载</td>  </tr>  <tr>    <td>5</td>    <td>++ 和 -- 运算符重载</td>  </tr>  <tr>    <td>6</td>    <td>赋值运算符重载</td>  </tr>  <tr>    <td>7</td>    <td>函数调用运算符 () 重载</td>  </tr>  <tr>    <td>8</td>    <td>下标运算符 [] 重载</td>  </tr>  <tr>    <td>9</td>    <td>类成员访问运算符 -> 重载</td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/11/20/C-%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/11/20/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.toumatou.cn/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong></p><h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h1><p>继承是面向对象编程中一个非常重要的概念。通过继承，一个类（称为派生类）可以直接使用另一个类（称为基类）的属性和方法，而无需重新编写。这种方式不仅能重用代码，还能让程序更易扩展和维护。</p><hr><h2 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a><strong>什么是继承？</strong></h2><ol><li><p><strong>基类和派生类：</strong></p><ul><li><strong>基类</strong>：已有的类，其属性和方法可以被其他类继承。</li><li><strong>派生类</strong>：继承自基类的类，它可以拥有基类的所有公开和保护成员，同时还可以定义自己的成员。</li></ul></li><li><p><strong>继承的核心思想：</strong></p><ul><li>基类定义了一些通用的功能或特性。</li><li>派生类可以直接使用这些功能，同时根据需要添加新的功能或特性。</li></ul></li></ol><hr><h2 id="继承的现实类比"><a href="#继承的现实类比" class="headerlink" title="继承的现实类比"></a><strong>继承的现实类比</strong></h2><p>继承可以看作是“<strong>是一种（is-a）关系</strong>”。例如：</p><ul><li>哺乳动物是一种动物。</li><li>狗是一种哺乳动物。</li><li>因此，狗也是一种动物。</li></ul><p>这种逻辑反映在代码中，可以通过继承轻松实现：</p><hr><h2 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a><strong>继承的语法</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基类（父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在吃东西。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在睡觉。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;狗正在汪汪叫。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a><strong>代码解析：</strong></h2><ol><li><p><strong>基类 Animal：</strong></p><ul><li>包含了通用的方法 <code>eat()</code> 和 <code>sleep()</code>，它们适用于所有的动物。</li></ul></li><li><p><strong>派生类 Dog：</strong></p><ul><li>通过 <code>: public Animal</code> 继承了 <code>Animal</code> 类的所有公开成员。</li><li>在 <code>Dog</code> 类中添加了一个新的方法 <code>bark()</code>，用来描述狗特有的行为。</li></ul></li><li><p><strong>使用派生类对象：</strong></p><ul><li>派生类对象既可以使用自己的方法，也可以使用从基类继承的方法。</li></ul></li></ol><hr><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a><strong>实例：</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在吃东西。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在睡觉。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;狗正在汪汪叫。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用继承的方法</span></span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 基类的 eat 方法</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 基类的 sleep 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用派生类自己的方法</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// Dog 类的 bark 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动物正在吃东西。</span><br><span class="line">动物正在睡觉。</span><br><span class="line">狗正在汪汪叫。</span><br></pre></td></tr></table></figure><hr><h2 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a><strong>继承的细节</strong></h2><ol><li><p><strong>访问权限控制：</strong></p><ul><li>使用 <code>public</code> 继承时，基类的 <code>public</code> 成员仍然是派生类的 <code>public</code> 成员。</li><li>使用 <code>private</code> 继承时，基类的成员即使是 <code>public</code>，在派生类中也会变成 <code>private</code>。</li></ul></li><li><p><strong>is-a 关系的本质：</strong></p><ul><li>派生类对象可以看作是基类对象的一种。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">animal-&gt;<span class="built_in">eat</span>();  <span class="comment">// 可以通过基类指针调用基类的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>重载与扩展：</strong></p><ul><li>派生类可以覆盖基类的方法，提供更具体的实现。</li></ul></li></ol><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ul><li>继承是为了实现代码复用和逻辑组织。</li><li>基类提供通用功能，派生类可以直接使用这些功能，同时扩展自己特有的功能。</li><li>继承建立的是一种“<strong>是一种（is-a）</strong>”的关系，比如“狗是一种动物”。</li></ul><h2 id="类的继承详解：基类与派生类"><a href="#类的继承详解：基类与派生类" class="headerlink" title="类的继承详解：基类与派生类"></a>类的继承详解：基类与派生类</h2><p>在编程中，一个类可以从其他类继承，这种机制让我们可以复用代码并增强类的功能。继承关系中，<strong>被继承的类称为“基类”</strong>，<strong>继承的类称为“派生类”</strong>。</p><hr><h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><p>派生类继承基类的数据和函数。定义派生类的格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 访问修饰符 基类名 &#123;</span><br><span class="line">   <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol><li><strong>访问修饰符</strong>（<code>public</code>、<code>protected</code> 或 <code>private</code>）：控制基类成员在派生类中的访问权限。</li><li><strong>默认访问修饰符</strong>：如果没有写访问修饰符，默认是 <code>private</code>。</li></ol><hr><h2 id="一个例子：Shape-和-Rectangle"><a href="#一个例子：Shape-和-Rectangle" class="headerlink" title="一个例子：Shape 和 Rectangle"></a>一个例子：Shape 和 Rectangle</h2><p>假设我们有一个表示形状的基类 <code>Shape</code>，它可以设置宽度和高度；然后，我们定义一个 <code>Rectangle</code> 类继承自 <code>Shape</code>，并添加计算面积的功能。</p><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 设置宽度和高度</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123; width = w; &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123; height = h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;  <span class="comment">// 受保护的成员</span></span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 计算矩形的面积</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (width * height); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Rectangle rect;</span><br><span class="line"></span><br><span class="line">   rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);   <span class="comment">// 设置宽度</span></span><br><span class="line">   rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);  <span class="comment">// 设置高度</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出矩形的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total area: 35</span><br></pre></td></tr></table></figure><hr><h2 id="访问权限与继承规则"><a href="#访问权限与继承规则" class="headerlink" title="访问权限与继承规则"></a>访问权限与继承规则</h2><h3 id="成员访问权限："><a href="#成员访问权限：" class="headerlink" title="成员访问权限："></a>成员访问权限：</h3><p>基类的成员根据访问修饰符分为三类：<code>public</code>、<code>protected</code> 和 <code>private</code>。这会影响派生类和外部类能否访问这些成员。</p><table><thead><tr><th><strong>访问范围</strong></th><th><strong>public</strong></th><th><strong>protected</strong></th><th><strong>private</strong></th></tr></thead><tbody><tr><td><strong>同一个类</strong></td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td><strong>派生类</strong></td><td>可以</td><td>可以</td><td>不可以</td></tr><tr><td><strong>外部类</strong></td><td>可以</td><td>不可以</td><td>不可以</td></tr></tbody></table><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li><code>private</code> 成员只能在基类内部访问，派生类和外部类无法访问。</li><li><code>protected</code> 成员可以被派生类访问，但不能被外部类直接访问。</li><li><code>public</code> 成员任何地方都可以访问。</li></ul><h3 id="访问修饰符对派生类的影响："><a href="#访问修饰符对派生类的影响：" class="headerlink" title="访问修饰符对派生类的影响："></a>访问修饰符对派生类的影响：</h3><p>基类的访问修饰符在派生类中继承的访问权限，取决于派生类的定义方式：</p><table><thead><tr><th><strong>派生方式</strong></th><th><strong>基类 public 成员</strong></th><th><strong>基类 protected 成员</strong></th><th><strong>基类 private 成员</strong></th></tr></thead><tbody><tr><td><code>public</code></td><td>保持 public</td><td>保持 protected</td><td>不可访问</td></tr><tr><td><code>protected</code></td><td>降为 protected</td><td>保持 protected</td><td>不可访问</td></tr><tr><td><code>private</code></td><td>降为 private</td><td>降为 private</td><td>不可访问</td></tr></tbody></table><hr><h2 id="特殊情况：派生类中不能继承的内容"><a href="#特殊情况：派生类中不能继承的内容" class="headerlink" title="特殊情况：派生类中不能继承的内容"></a>特殊情况：派生类中不能继承的内容</h2><p>即使派生类继承了基类的大部分内容，但以下几种特殊情况除外：</p><ol><li><strong>基类的构造函数、析构函数和拷贝构造函数</strong>：这些函数不能被派生类直接继承。</li><li><strong>基类的运算符重载函数</strong>：例如，重载的 <code>operator+</code>，派生类不会直接继承。</li><li><strong>基类的友元函数</strong>：友元函数只对声明它们的类开放，不会被派生类直接继承。</li></ol><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><strong>继承让代码复用更高效</strong>：基类定义通用的功能，派生类在此基础上扩展。</li><li><strong>控制访问权限</strong>：通过访问修饰符确保数据的安全性。</li><li><strong>继承有例外</strong>：构造函数等特殊成员无法继承，需要在派生类中重新定义。</li></ul><blockquote><p>这个机制强大而灵活，是面向对象编程的重要特性！</p></blockquote><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>想象一下，我们有一个家族，基类就像是家族中的长辈，而派生类则是晚辈。长辈的财产和技能可以传给晚辈，但是传给的方式不同，晚辈对这些财产和技能的拥有和使用方式也会有所不同。</p><ol><li><p><strong>公有继承（public）</strong>：</p><ul><li>这就像是长辈公开宣布：“我所有的财产和技能，我的孩子们都可以自由使用。”在这种情况下，如果一个类（我们称之为子类）是从另一个公开的类（基类）继承来的，那么基类中所有公开的成员（比如财产和技能）在子类中也是公开的，可以被外界直接访问。同时，基类中的保护成员（比如一些只有家族内部才能使用的技能）在子类中也保持保护状态，只能被家族内部（也就是子类及其派生类）访问。</li></ul></li><li><p><strong>保护继承（protected）</strong>：</p><ul><li>这就像是长辈说：“我有一些财产和技能，只允许我的孩子们使用，外人不能直接使用，但我的孩子们可以自由地使用。”在保护继承中，基类中的公开和保护成员都会变成子类的保护成员。这意味着这些成员不能被外界直接访问，但是可以在子类及其派生类中被访问。</li></ul></li><li><p><strong>私有继承（private）</strong>：</p><ul><li>这就像是长辈说：“我有一些东西，只留给我的孩子们，而且他们也只能自己使用，不能给外人用，也不能让他们的孩子（也就是孙子辈）使用。”在私有继承中，基类中的公开和保护成员都会变成子类的私有成员。这意味着这些成员只能在子类内部使用，不能被外界或子类的派生类访问。</li></ul></li></ol><p>总结一下，继承类型决定了基类的成员在派生类中的可见性和可访问性。公有继承让基类的成员在派生类中保持原有的访问级别；保护继承将基类的成员都变为派生类的保护成员；私有继承则将基类的成员变为派生类的私有成员。在实际编程中，公有继承是最常用的，因为它允许派生类最大程度地利用基类的功能，同时也保持了灵活性。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="什么是多继承？"><a href="#什么是多继承？" class="headerlink" title="什么是多继承？"></a>什么是多继承？</h3><p>多继承指的是一个子类可以同时继承多个父类，从而获得这些父类的属性和方法。在 C++ 中，允许通过多继承来创建更强大的类。这种特性可以通过以下语法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt; &lt;基类名<span class="number">1</span>&gt;, &lt;继承方式<span class="number">2</span>&gt; &lt;基类名<span class="number">2</span>&gt;, …</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类内容&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>继承方式</strong>可以是 <code>public</code>、<code>protected</code> 或 <code>private</code>，它决定了从父类继承过来的成员在子类中的访问权限。</li><li><strong>基类名</strong>是父类的名字。</li><li>多个父类之间用逗号分隔。</li></ul><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>假设我们要设计一个程序，涉及计算矩形的面积，并估算将矩形涂上油漆的总花费。这种情况下，可以通过多继承实现如下功能：</p><ol><li>**一个基类 <code>Shape</code>**：用来保存矩形的宽度和高度，并提供设置宽高的方法。</li><li>**另一个基类 <code>PaintCost</code>**：用来计算油漆的花费。</li><li>**派生类 <code>Rectangle</code>**：同时继承自 <code>Shape</code> 和 <code>PaintCost</code>，可以直接使用这两个基类的功能，并添加自己的功能，比如计算面积。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 Shape：处理形状的宽和高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">int</span> height; <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost：计算油漆的总花费</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>; <span class="comment">// 每平方米花费 $70</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类 Rectangle：继承 Shape 和 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> width * height; <span class="comment">// 计算矩形的面积</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置矩形的宽和高</span></span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 计算矩形的面积</span></span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出油漆总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行的结果"><a href="#程序运行的结果" class="headerlink" title="程序运行的结果"></a>程序运行的结果</h3><p>当运行上述代码时，会输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total area: 35</span><br><span class="line">Total paint cost: $2450</span><br></pre></td></tr></table></figure><h3 id="详细解释代码的逻辑"><a href="#详细解释代码的逻辑" class="headerlink" title="详细解释代码的逻辑"></a>详细解释代码的逻辑</h3><ol><li><p><strong><code>Shape</code> 类的功能</strong>：</p><ul><li>它包含两个成员变量：<code>width</code> 和 <code>height</code>，分别表示矩形的宽度和高度。</li><li>提供了两个公共方法：<code>setWidth(int w)</code> 和 <code>setHeight(int h)</code>，用来设置宽度和高度的值。</li></ul></li><li><p><strong><code>PaintCost</code> 类的功能</strong>：</p><ul><li>包含一个方法 <code>getCost(int area)</code>，它接受面积作为参数，并返回涂上油漆的总费用。</li><li>每平方米油漆的费用为 <code>$70</code>。</li></ul></li><li><p><strong><code>Rectangle</code> 类的功能</strong>：</p><ul><li>它继承了 <code>Shape</code> 和 <code>PaintCost</code>，因此可以直接使用 <code>Shape</code> 类的方法（如 <code>setWidth</code> 和 <code>setHeight</code>），以及 <code>PaintCost</code> 类的方法（如 <code>getCost</code>）。</li><li>它还定义了一个自己的方法 <code>getArea()</code>，用来计算矩形的面积。</li></ul></li><li><p><strong><code>main()</code> 函数的执行流程</strong>：</p><ul><li>创建一个 <code>Rectangle</code> 对象 <code>Rect</code>。</li><li>调用 <code>setWidth(5)</code> 和 <code>setHeight(7)</code>，设置矩形的宽度为 5、高度为 7。</li><li>调用 <code>getArea()</code> 方法，计算矩形的面积为 ( 5 \times 7 &#x3D; 35 )。</li><li>调用 <code>getCost(area)</code>，计算油漆费用为 ( 35 \times 70 &#x3D; 2450 )。</li><li>最终输出面积和总费用。</li></ul></li></ol><h3 id="为什么多继承很有用？"><a href="#为什么多继承很有用？" class="headerlink" title="为什么多继承很有用？"></a>为什么多继承很有用？</h3><p>在本例中，通过继承 <code>Shape</code> 和 <code>PaintCost</code>，<code>Rectangle</code> 类不需要重新定义宽度、高度的管理方法或油漆费用的计算逻辑，这样可以减少代码的重复，同时增加了代码的可读性和可维护性。这种功能组合的方式是多继承的一个典型应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类&amp;对象</title>
      <link href="/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从本节内容开始，我将分享一些关于C++面向对象的知识，这部分的内容，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">点击这里</a>重新温习一下,废话不多说，直接进入正题吧！</strong></p><h1 id="C-类＆对象"><a href="#C-类＆对象" class="headerlink" title="C++ 类＆对象"></a>C++ 类＆对象</h1><p><strong>C++ 是在 C 语言基础上增加了面向对象编程的功能，其中 <strong>类</strong> 是 C++ 的核心概念。你可以把类理解成一种自定义的“蓝图”或者“模板”，用来描述一类对象的特性（数据）和能力（功能）。类里面的变量叫“成员变量”，负责保存数据，而函数叫“成员函数”，用来定义这些对象可以做的事情。有了类，就能很方便地创建多个“长得一样”的对象。</strong></p><h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h2><p>在 C++ 中，<strong>类（class）</strong> 是一种用来组织数据和行为的结构。定义一个类就像是在创建一个蓝图，告诉程序我们要描述一个什么样的东西（数据）以及它可以做些什么（操作）。理解类的定义会让你轻松上手面向对象编程。</p><h3 id="如何定义一个类？"><a href="#如何定义一个类？" class="headerlink" title="如何定义一个类？"></a><strong>如何定义一个类？</strong></h3><ol><li><p><strong>关键字 <code>class</code>：</strong><br>使用 <code>class</code> 关键字告诉程序我们要定义一个类。</p></li><li><p><strong>类名：</strong><br>给类起一个有意义的名字，就像给变量取名一样。</p></li><li><p><strong>花括号 <code>&#123;&#125;</code>：</strong><br>用 <code>&#123;&#125;</code> 包围住类的内容，内容包括：</p><ul><li><strong>成员变量（属性）</strong>：用来存储对象的特性或数据。</li><li><strong>成员函数（方法）</strong>：用来描述对象的行为或操作。</li></ul></li><li><p><strong>访问权限（<code>public</code>）：</strong><br>在类中，数据和函数可以有不同的访问权限，比如 <code>public</code>、<code>private</code> 和 <code>protected</code>。其中：</p><ul><li>**<code>public</code>**：外部代码可以访问这些成员。</li><li>**<code>private</code>**：外部代码无法直接访问这些成员（稍后会详细说明）。</li></ul></li></ol><h3 id="举个例子：定义一个盒子类"><a href="#举个例子：定义一个盒子类" class="headerlink" title="举个例子：定义一个盒子类"></a><strong>举个例子：定义一个盒子类</strong></h3><p>以下是一个简单的类定义，用来描述一个盒子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="细节解析："><a href="#细节解析：" class="headerlink" title="细节解析："></a><strong>细节解析：</strong></h4><ol><li><p><strong>类名 <code>Box</code>：</strong></p><ul><li>这个类名表示我们要定义的是“盒子”。</li><li>以后我们可以用这个类创建具体的“盒子对象”。</li></ul></li><li><p><strong><code>public</code> 访问权限：</strong></p><ul><li>在 <code>public</code> 下定义的变量是<strong>公开的</strong>，也就是说，外部代码可以直接访问这些变量。</li><li>如果不写 <code>public</code>，默认情况下，类的成员是 <code>private</code>，外部代码将无法直接访问它们。</li></ul></li><li><p><strong>成员变量：</strong></p><ul><li><code>length</code>、<code>breadth</code> 和 <code>height</code> 是盒子的属性，它们描述了盒子的长度、宽度和高度。</li><li>它们的数据类型是 <code>double</code>，表示这些属性可以存储带小数的数字。</li></ul></li></ol><h3 id="类是蓝图，对象是实物"><a href="#类是蓝图，对象是实物" class="headerlink" title="类是蓝图，对象是实物"></a><strong>类是蓝图，对象是实物</strong></h3><p>定义类之后，你可以通过类来创建实际的对象。比如，<code>Box</code> 类是一个蓝图，而对象就是你用这个蓝图制作出的具体“盒子”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Box myBox;  <span class="comment">// 创建一个盒子对象</span></span><br><span class="line">myBox.length = <span class="number">10.5</span>;  <span class="comment">// 给盒子对象的长度赋值</span></span><br><span class="line">myBox.breadth = <span class="number">5.5</span>;  <span class="comment">// 给盒子对象的宽度赋值</span></span><br><span class="line">myBox.height = <span class="number">3.2</span>;   <span class="comment">// 给盒子对象的高度赋值</span></span><br></pre></td></tr></table></figure><p>通过这种方式，<code>myBox</code> 成为了一个具体的盒子，它有了自己的长、宽、高。</p><h3 id="总结：类的作用"><a href="#总结：类的作用" class="headerlink" title="总结：类的作用"></a><strong>总结：类的作用</strong></h3><ol><li><strong>定义属性</strong>：类中包含的变量（如 <code>length</code>、<code>breadth</code>、<code>height</code>）用于存储对象的数据。</li><li><strong>定义行为</strong>：类中还可以包含函数，描述对象可以完成哪些动作（这里暂时未涉及函数）。</li><li><strong>灵活性</strong>：通过类，你可以方便地创建多个对象，每个对象可以有自己独特的数据。</li></ol><blockquote><p>类的核心是将数据和操作封装在一起，使得程序更加模块化和易于维护。</p></blockquote><h2 id="C-定义对象"><a href="#C-定义对象" class="headerlink" title="C++定义对象"></a>C++定义对象</h2><p>在 C++ 中，<strong>对象（object）</strong> 是类的具体实现。类就像一张设计图，而对象就是根据设计图实际“生产”出来的东西。通过对象，我们可以操作和使用类中定义的属性和方法。</p><p>下面，我们一步步来理解如何创建对象、如何操作对象的成员，以及如何通过实例加深理解。</p><hr><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a><strong>1. 创建对象</strong></h3><p>要创建一个对象，就像声明一个变量一样简单。假设我们有一个类 <code>Box</code>，可以这样声明对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;  <span class="comment">// 创建一个类型为 Box 的对象 Box1</span></span><br><span class="line">Box Box2;  <span class="comment">// 创建一个类型为 Box 的对象 Box2</span></span><br></pre></td></tr></table></figure><p>每个对象都有自己的独立数据。换句话说，<code>Box1</code> 和 <code>Box2</code> 是两个不同的盒子，它们可以有不同的长度、宽度和高度。</p><hr><h3 id="2-访问对象的成员"><a href="#2-访问对象的成员" class="headerlink" title="2. 访问对象的成员"></a><strong>2. 访问对象的成员</strong></h3><h4 id="直接访问公共成员"><a href="#直接访问公共成员" class="headerlink" title="直接访问公共成员"></a><strong>直接访问公共成员</strong></h4><p>类的公共成员（<code>public</code>）可以通过 <strong>点操作符（<code>.</code>）</strong> 来访问和操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box<span class="number">1.l</span>ength = <span class="number">6.0</span>;  <span class="comment">// 设置 Box1 的长度为 6.0</span></span><br><span class="line">Box<span class="number">1.</span>breadth = <span class="number">7.0</span>; <span class="comment">// 设置 Box1 的宽度为 7.0</span></span><br><span class="line">Box<span class="number">1.</span>height = <span class="number">5.0</span>;  <span class="comment">// 设置 Box1 的高度为 5.0</span></span><br></pre></td></tr></table></figure><h4 id="通过成员函数访问成员"><a href="#通过成员函数访问成员" class="headerlink" title="通过成员函数访问成员"></a><strong>通过成员函数访问成员</strong></h4><p>有时候，我们会用成员函数来设置和获取对象的属性。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box<span class="number">1.</span><span class="built_in">set</span>(<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">5.0</span>);  <span class="comment">// 调用 set 函数一次性设置 Box1 的长宽高</span></span><br><span class="line"><span class="type">double</span> volume = Box<span class="number">1.</span><span class="built_in">get</span>();  <span class="comment">// 调用 get 函数获取 Box1 的体积</span></span><br></pre></td></tr></table></figure><p>这种方式不仅简洁，还能让我们在函数中添加额外的逻辑，比如检查输入值是否合法。</p><hr><h3 id="3-实例代码解析"><a href="#3-实例代码解析" class="headerlink" title="3. 实例代码解析"></a><strong>3. 实例代码解析</strong></h3><p>下面是一个完整的例子，我们结合类和对象来计算多个盒子的体积。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">()</span></span>;                 <span class="comment">// 计算体积</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span>;  <span class="comment">// 设置盒子的长宽高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;  <span class="comment">// 返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span> </span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box Box1, Box2, Box3;  <span class="comment">// 创建 3 个 Box 对象</span></span><br><span class="line">    <span class="type">double</span> volume = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接设置 Box1 的属性</span></span><br><span class="line">    Box<span class="number">1.l</span>ength = <span class="number">6.0</span>;</span><br><span class="line">    Box<span class="number">1.</span>breadth = <span class="number">7.0</span>;</span><br><span class="line">    Box<span class="number">1.</span>height = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接设置 Box2 的属性</span></span><br><span class="line">    Box<span class="number">2.l</span>ength = <span class="number">12.0</span>;</span><br><span class="line">    Box<span class="number">2.</span>breadth = <span class="number">13.0</span>;</span><br><span class="line">    Box<span class="number">2.</span>height = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出 Box1 和 Box2 的体积</span></span><br><span class="line">    volume = Box<span class="number">1.l</span>ength * Box<span class="number">1.</span>breadth * Box<span class="number">1.</span>height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    volume = Box<span class="number">2.l</span>ength * Box<span class="number">2.</span>breadth * Box<span class="number">2.</span>height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 set 和 get 方法设置 Box3 的属性并获取体积</span></span><br><span class="line">    Box<span class="number">3.</span><span class="built_in">set</span>(<span class="number">16.0</span>, <span class="number">8.0</span>, <span class="number">12.0</span>);</span><br><span class="line">    volume = Box<span class="number">3.</span><span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box3 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积：210</span><br><span class="line">Box2 的体积：1560</span><br><span class="line">Box3 的体积：1536</span><br></pre></td></tr></table></figure><hr><h3 id="4-细节说明"><a href="#4-细节说明" class="headerlink" title="4. 细节说明"></a><strong>4. 细节说明</strong></h3><h4 id="成员函数的作用"><a href="#成员函数的作用" class="headerlink" title="成员函数的作用"></a><strong>成员函数的作用</strong></h4><ul><li><code>set()</code> 函数：用来一次性设置盒子的长度、宽度和高度。</li><li><code>get()</code> 函数：用来计算盒子的体积。</li></ul><p>这两个函数的好处是可以让代码更规范、更清晰，同时也能避免直接操作数据成员可能带来的错误。</p><h4 id="为什么要用点操作符（-）？"><a href="#为什么要用点操作符（-）？" class="headerlink" title="为什么要用点操作符（.）？"></a><strong>为什么要用点操作符（<code>.</code>）？</strong></h4><p>点操作符 <code>.</code> 的作用是连接对象和它的成员（属性或函数）。例如：</p><ul><li><code>Box1.length</code> 表示访问 <code>Box1</code> 的长度属性。</li><li><code>Box3.get()</code> 表示调用 <code>Box3</code> 的 <code>get()</code> 函数。</li></ul><h4 id="关于访问权限："><a href="#关于访问权限：" class="headerlink" title="关于访问权限："></a><strong>关于访问权限：</strong></h4><ul><li><strong>公共成员（<code>public</code>）</strong>：<ul><li>例如 <code>length</code>、<code>breadth</code>、<code>height</code>，可以直接通过对象访问。</li></ul></li><li><strong>私有成员（<code>private</code>）</strong>：<ul><li>私有成员不能直接访问，通常需要通过函数（如 <code>set()</code> 和 <code>get()</code>）来间接操作。</li></ul></li></ul><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ol><li><strong>对象是类的具体实例</strong>：<ul><li>类是设计图，对象是根据设计图创建的实际东西。</li></ul></li><li><strong>访问对象的成员</strong>：<ul><li>通过点操作符直接访问公共成员。</li><li>通过成员函数间接访问私有或公共成员。</li></ul></li><li><strong>使用成员函数的优势</strong>：<ul><li>更加安全、规范，能够控制数据的合法性。</li></ul></li><li><strong>分离定义和实现</strong>：<ul><li>在类中声明函数，在类外实现函数，有助于让代码结构更清晰。</li></ul></li></ol><h2 id="类＆对象详解"><a href="#类＆对象详解" class="headerlink" title="类＆对象详解"></a>类＆对象详解</h2><h3 id="C-类与对象深入理解"><a href="#C-类与对象深入理解" class="headerlink" title="C++ 类与对象深入理解"></a>C++ 类与对象深入理解</h3><p>C++ 的类和对象不仅包括我们之前学到的基础知识，还有许多高级概念。这些概念可以帮助我们更高效、更灵活地编写代码。下面是一些重要的类和对象相关概念的通俗解释和用途。</p><h4 id="C-类与对象相关概念总结"><a href="#C-类与对象相关概念总结" class="headerlink" title="C++ 类与对象相关概念总结"></a><strong>C++ 类与对象相关概念总结</strong></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>描述（通俗易懂的解释）</strong></th></tr></thead><tbody><tr><td><strong>类成员函数</strong></td><td>类中的函数称为成员函数，它是用来操作类中数据的函数。它们就像工具，帮助你操作和处理类的属性，比如设置值或计算结果。</td></tr><tr><td><strong>类访问修饰符</strong></td><td>类的属性和函数可以设置为：<br>- <code>public</code>：可以被外部直接访问。<br>- <code>private</code>：只能在类内部使用，外部不能直接访问。<br>- <code>protected</code>：继承时的特殊访问方式。</td></tr><tr><td><strong>构造函数 &amp; 析构函数</strong></td><td>构造函数是在创建对象时自动调用的特殊函数，用于初始化对象的属性。<br>析构函数则是在对象被销毁时调用，用于清理资源。它们是一对让对象创建和销毁更方便的函数。</td></tr><tr><td><strong>拷贝构造函数</strong></td><td>拷贝构造函数用于用一个已有的对象来创建新的对象，就像“克隆”一样。比如将对象 A 的值赋给对象 B 时会调用拷贝构造函数。</td></tr><tr><td><strong>友元函数</strong></td><td>友元函数是类的“朋友”，它可以访问类的私有和受保护成员。虽然它不是类的成员，但它能帮助实现更复杂的操作。</td></tr><tr><td><strong>内联函数</strong></td><td>内联函数是编译器直接把函数代码插入到调用点，省去了函数调用的开销，适合用在短小的函数上。</td></tr><tr><td><strong>this 指针</strong></td><td>每个对象都有一个特殊指针 <code>this</code>，它指向对象本身。通过 <code>this</code> 指针可以访问或操作当前对象的属性。</td></tr><tr><td><strong>指向类的指针</strong></td><td>类的指针就像指向结构体的指针一样。它允许你通过指针访问对象的属性和方法，适合处理动态创建的对象或需要共享对象的情况。</td></tr><tr><td><strong>静态成员</strong></td><td>静态成员属于整个类而不是某个对象。静态变量可以被所有对象共享，静态函数可以在没有对象的情况下调用。比如计数器、全局配置等。</td></tr></tbody></table><hr><h4 id="深入理解概念：举例说明"><a href="#深入理解概念：举例说明" class="headerlink" title="深入理解概念：举例说明"></a><strong>深入理解概念：举例说明</strong></h4><h5 id="1-类成员函数"><a href="#1-类成员函数" class="headerlink" title="1. 类成员函数"></a><strong>1. 类成员函数</strong></h5><p>类的成员函数用于操作类的属性，例如设置值和获取值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 公共成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123;  <span class="comment">// 成员函数</span></span><br><span class="line">        length = len;  <span class="comment">// 设置长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;  <span class="comment">// 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> length;  <span class="comment">// 获取长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-类访问修饰符"><a href="#2-类访问修饰符" class="headerlink" title="2. 类访问修饰符"></a><strong>2. 类访问修饰符</strong></h5><p>控制类成员的访问权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 私有变量，外部无法直接访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123;  <span class="comment">// 公共函数，用于设置 length</span></span><br><span class="line">        length = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;  <span class="comment">// 公共函数，用于获取 length</span></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-构造函数-析构函数"><a href="#3-构造函数-析构函数" class="headerlink" title="3. 构造函数 &amp; 析构函数"></a><strong>3. 构造函数 &amp; 析构函数</strong></h5><p>构造函数和析构函数会自动执行，无需手动调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>() &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象被创建！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Box</span>() &#123;  <span class="comment">// 析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象被销毁！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a><strong>4. 拷贝构造函数</strong></h5><p>通过已有对象创建新对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> len) : <span class="built_in">length</span>(len) &#123;&#125;  <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> Box&amp; obj) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        length = obj.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-静态成员"><a href="#5-静态成员" class="headerlink" title="5. 静态成员"></a><strong>5. 静态成员</strong></h5><p>静态成员变量和函数属于整个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="built_in">Box</span>() &#123; count++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Box::count = <span class="number">0</span>;  <span class="comment">// 初始化静态变量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50MB大小的黑科技</title>
      <link href="/2024/11/16/50MB%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
      <url>/2024/11/16/50MB%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>在我的的手机里有个超级英雄——工具箱类app，它就像是手机里的瑞士军刀，啥都能干，把那些偶尔才用一次的“独行侠”软件都给比下去了。😏</strong></p><p><strong>说到这个，不得不提“一个木函”，这个下载量破千万的大佬，用起来简直就像吃了德芙一样顺滑。但是，时间这把杀猪刀，不仅让人变老，也让软件变“贵”了。一个木函开始收费了，而且价格还不便宜，让人心疼钱包。</strong></p><p><strong>于是，一群用户开始了一场“逃离木函”的大逃亡，他们四处寻找新的避风港，希望找到一个既能省钱又能省心的新伙伴。这场景，简直就像是一部手机应用界的《泰坦尼克号》，只不过这次，冰山是付费墙，而救生艇是其他免费的替代软件。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：小尼工具箱</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p><strong>这款工具箱app简直就是安卓手机的“瑞士军刀”Plus版，它把你想要的所有小工具都塞进了一个应用里，就像是手机界的“多啦A梦”口袋，应有尽有，简直是全能战士。</strong></p><p><strong>而且，这个宝贝是完全免费的，没有任何使用限制，就像是一个慷慨的圣诞老人，给你一大堆礼物，却不要求你唱一首圣诞歌作为交换。安装后，你就能立刻开始使用，方便得就像是找到了遥控器，一键开启懒人模式。</strong></p><p><strong>用这款软件，你可以根据自己的需求，像点菜一样挑选功能，它就是你的私人订制“手机大厨”，为你的手机生活增添无限风味。这不仅仅是一个应用，这是你手机上的“生活小能手”，让你的手机生活更加多姿多彩，就像是给手机装上了“智慧的翅膀”，飞得更高，玩得更嗨！😋</strong></p><div style="text-align:center">  <img src="/img_2/E9BAE44C56853501A9C792F9A0C2E17C.jpg" alt="主页面" ></div><p><strong>这款应用里有个超酷的功能，叫做视频短片解析器，它就像是视频界的“变形金刚”，能处理视频也能搞定图片。这个功能有三个强大的解析通道，就像是三头六臂的哪吒，让用户能够轻松拿到视频封面图。更棒的是，它还能把视频下载成1080P的高清版，清晰得就像是你亲眼所见，画质确实很不错😊</strong></p><div style="text-align:center">  <img src="/img_2/842B3DEB54D50E65B7C6A916459D5190.jpg" alt="" ></div><p><strong>甚至还有内置音乐下载功能，资源很齐全，大家懂的都懂😏</strong></p><div style="text-align:center">  <img src="/img_2/33E293ACB7E723E92422477F9038976F.jpg" alt="" ></div><p><strong>这款软件里头，壁纸资源多得就像个宝藏库，有十几种分类任你挑，还能用搜索功能精准定位到你的“心动壁纸”。每张壁纸都是高清大图，质量杠杠的，而且你想保存多少就保存多少，无限制</strong></p><p><strong>但这款软件的本事可不止这些，它还有一大堆实用功能，就像个多功能的瑞士军刀。不过，有些功能因为一些原因，咱们这里就不多说了，免得说多了都是泪。有兴趣的朋友们，不妨亲自下载来试试，探索一下这个软件的奥秘，说不定会有意想不到的惊喜等着你!</strong></p><div style="text-align:center">  <img src="/img_2/501326FD62944FA191451DBD80476F68.jpg" alt="" ></div><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="https://wwso.lanzoub.com/iVv6v2f1a0gf">https://wwso.lanzoub.com/iVv6v2f1a0gf</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数据结构</title>
      <link href="/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容是<code>C++ 基础教程</code>的最后一部分，对于这一节的内容，看不懂也没关系，等大家学习数据结构以后再来看就能够懂了。说说之后的安排吧，这一节内容结束以后，我将会分享更加深入的知识，也就是<code>C++ 面向对象</code>的相关内容，对于<code>C++ 基础教程</code>这一部分的内容如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C++ 数据结构"></a>C++ 数据结构</h1><p>在 C++ 中，数据结构是用来组织和管理数据的重要工具。C++ 提供了从简单到复杂的多种数据结构，既包括基础的数组、结构体，也包括强大的 STL（Standard Template Library）容器，如 <code>vector</code>、<code>map</code> 等。这些数据结构各有优缺点，适合不同的场景。以下是对这些数据结构的详细介绍。</p><hr><h2 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a><strong>1. 数组（Array）</strong></h2><h3 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a><strong>什么是数组？</strong></h3><p>数组是一组存储相同类型数据的连续内存块，可以通过索引访问元素。数组的大小在声明时固定，不能动态改变。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>连续存储</strong>：所有元素在内存中是连续分布的。</li><li><strong>固定大小</strong>：声明时确定大小，运行时无法更改。</li><li><strong>快速访问</strong>：通过索引直接访问元素，时间复杂度为 O(1)。</li><li><strong>适用场景</strong>：适合存储已知大小的同类型数据集合。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 定义一个整型数组</span></span><br><span class="line">cout &lt;&lt; arr[<span class="number">0</span>]; <span class="comment">// 输出第一个元素 1</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10</span>;    <span class="comment">// 修改第三个元素为 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>访问速度快（随机访问 O(1)）。  </li><li>内存紧凑。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法动态调整大小。  </li><li>插入和删除效率低（需要移动元素）。</li></ul></li></ul><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数值统计（如存储分数列表）。</li><li>固定大小的矩阵或表格。</li></ul><hr><h2 id="2-结构体（Struct）"><a href="#2-结构体（Struct）" class="headerlink" title="2. 结构体（Struct）"></a><strong>2. 结构体（Struct）</strong></h2><h3 id="什么是结构体？"><a href="#什么是结构体？" class="headerlink" title="什么是结构体？"></a><strong>什么是结构体？</strong></h3><p>结构体是一种自定义数据类型，可以将不同类型的数据组合在一起。它可以看作是“迷你数据库”，用来描述某些实体或对象。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>可以组合多种数据类型。</li><li>成员变量可以是基本类型或复杂类型。</li><li>提供基本的封装，但功能有限。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">cout &lt;&lt; p.name &lt;&lt; endl; <span class="comment">// 输出 &quot;Alice&quot;</span></span><br><span class="line">p.age = <span class="number">30</span>; <span class="comment">// 修改年龄</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>逻辑清晰，适合组织复杂数据。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不支持继承和多态，功能比类弱。</li></ul></li></ul><h3 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>用于表示实体对象，如学生、员工等。</li></ul><hr><h2 id="3-类（Class）"><a href="#3-类（Class）" class="headerlink" title="3. 类（Class）"></a><strong>3. 类（Class）</strong></h2><h3 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a><strong>什么是类？</strong></h3><p>类是面向对象编程的核心，可以定义数据（成员变量）和行为（成员函数）。与结构体类似，但功能更强大，支持继承、多态、封装等特性。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>成员变量默认是私有的（<code>private</code>）。</li><li>支持方法、构造函数、析构函数等。</li><li>支持继承和多态。</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">printInfo</span>(); <span class="comment">// 输出: Name: Bob, Age: 30</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>功能强大，适合大型项目。</li></ul></li><li><strong>缺点</strong>：  <ul><li>开发复杂度较高。</li></ul></li></ul><h3 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>面向对象设计中，如实现用户类、产品类等。</li></ul><hr><h2 id="4-链表（Linked-List）"><a href="#4-链表（Linked-List）" class="headerlink" title="4. 链表（Linked List）"></a><strong>4. 链表（Linked List）</strong></h2><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a><strong>什么是链表？</strong></h3><p>链表是一种动态数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：可以在运行时动态调整大小。</li><li><strong>高效插入&#x2F;删除</strong>：在链表头部或尾部操作的时间复杂度为 O(1)。</li><li><strong>线性查找</strong>：访问某个元素需要从头开始查找，时间复杂度为 O(n)。</li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;            <span class="comment">// 链表头指针</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// 新节点</span></span><br><span class="line">head = newNode;                  <span class="comment">// 将新节点插入链表</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态大小，插入&#x2F;删除效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>查找效率低，随机访问效率远不如数组。</li></ul></li></ul><h3 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数据流处理。</li><li>实现队列、栈等动态数据结构。</li></ul><hr><h2 id="5-栈（Stack）"><a href="#5-栈（Stack）" class="headerlink" title="5. 栈（Stack）"></a><strong>5. 栈（Stack）</strong></h2><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a><strong>什么是栈？</strong></h3><p>栈是一种后进先出（LIFO）的数据结构，像“弹簧盒”，只能从顶部插入和删除。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>只能操作栈顶元素。</li><li>插入和删除的时间复杂度为 O(1)。</li></ul><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);       <span class="comment">// 压栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">s.<span class="built_in">pop</span>();         <span class="comment">// 弹栈</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>操作简单，效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不能随机访问。</li></ul></li></ul><h3 id="典型应用-4"><a href="#典型应用-4" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>递归调用栈。</li><li>表达式求值。</li></ul><hr><h2 id="6-队列（Queue）"><a href="#6-队列（Queue）" class="headerlink" title="6. 队列（Queue）"></a><strong>6. 队列（Queue）</strong></h2><h3 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a><strong>什么是队列？</strong></h3><p>队列是一种先进先出（FIFO）的数据结构，像排队的队伍。</p><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>从队尾插入元素，从队头删除元素。</li><li>时间复杂度为 O(1)。</li></ul><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);        <span class="comment">// 入队</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>(); <span class="comment">// 输出 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();          <span class="comment">// 出队</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>按顺序处理数据，适合任务调度等场景。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法随机访问。</li></ul></li></ul><h3 id="典型应用-5"><a href="#典型应用-5" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>任务调度。</li><li>广度优先搜索（BFS）。</li></ul><hr><h2 id="7-动态数组（Vector）"><a href="#7-动态数组（Vector）" class="headerlink" title="7. 动态数组（Vector）"></a><strong>7. 动态数组（Vector）</strong></h2><h3 id="什么是动态数组？"><a href="#什么是动态数组？" class="headerlink" title="什么是动态数组？"></a><strong>什么是动态数组？</strong></h3><p><code>vector</code> 是 C++ 标准库提供的动态数组实现，可以根据需要自动扩展大小。</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：内存不足时会自动扩容。</li><li><strong>随机访问</strong>：支持通过索引访问元素，时间复杂度为 O(1)。</li></ul><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; v[<span class="number">0</span>]; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态调整大小，使用方便。</li></ul></li><li><strong>缺点</strong>：  <ul><li>插入&#x2F;删除中间元素效率较低。</li></ul></li></ul><h3 id="典型应用-6"><a href="#典型应用-6" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>动态增长的数据集合。</li></ul><hr><h2 id="8-哈希表（Hash-Table）"><a href="#8-哈希表（Hash-Table）" class="headerlink" title="8. 哈希表（Hash Table）"></a><strong>8. 哈希表（Hash Table）</strong></h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a><strong>什么是哈希表？</strong></h3><p>哈希表是一种通过键值对存储数据的结构，使用哈希函数快速定位元素。</p><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>快速操作</strong>：查找、插入和删除的时间复杂度为 O(1)。</li><li><strong>无序存储</strong>：元素存储顺序不固定。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">hashTable[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; hashTable[<span class="string">&quot;apple&quot;</span>]; <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>高效查找和操作。</li></ul></li><li><strong>缺点</strong>：  <ul><li>可能发生哈希冲突。</li></ul></li></ul><h3 id="典型应用-7"><a href="#典型应用-7" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>实现键值对存储，如字典。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>数据结构</th><th>特点</th><th>典型场景</th></tr></thead><tbody><tr><td>数组（Array）</td><td>连续存储，固定大小，快速随机访问</td><td>固定大小的数据集合</td></tr><tr><td>结构体（Struct）</td><td>组合不同类型的数据</td><td>实体对象描述</td></tr><tr><td>类（Class）</td><td>支持面向对象编程，封装数据与行为</td><td>复杂对象建模</td></tr><tr><td>链表（Linked List）</td><td>动态大小，高效插入&#x2F;删除，但查找效率低</td><td>数据流，动态数据集合</td></tr><tr><td>栈（Stack）</td><td>后进先出，操作简单</td><td>表达式求值，递归处理</td></tr><tr><td>队列（Queue）</td><td>先进先出，适合按顺序处理数据</td><td>任务调度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ vector容器</title>
      <link href="/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-vector容器"><a href="#C-vector容器" class="headerlink" title="C++ vector容器"></a>C++ vector容器</h1><p>在 C++ 中，<code>vector</code> 是一种非常强大的数据结构，它和数组类似，但功能更灵活。<strong>它是一个可以动态调整大小的数组</strong>，不需要你手动管理内存，是 C++ 标准模板库（STL）的一部分。</p><p>如果你需要一个可以自动扩展的数组来存储数据，<code>vector</code> 是你的首选。</p><hr><h2 id="为什么用-vector-而不是数组？"><a href="#为什么用-vector-而不是数组？" class="headerlink" title="为什么用 vector 而不是数组？"></a><strong>为什么用 <code>vector</code> 而不是数组？</strong></h2><p>数组虽然可以存储元素，但有几个缺点：</p><ol><li><strong>固定大小</strong>：数组在创建时必须指定大小，无法动态扩展或缩小。</li><li><strong>手动管理内存</strong>：如果需要动态数组，你必须手动分配和释放内存，容易出错。</li><li><strong>功能有限</strong>：数组没有直接提供添加、删除、查找等功能。</li></ol><p>而 <code>vector</code> 可以解决这些问题：</p><ul><li><strong>动态大小</strong>：<code>vector</code> 可以根据需要自动增长或缩小。</li><li><strong>连续存储</strong>：<code>vector</code> 的元素存储在连续的内存中，因此访问速度快。</li><li><strong>灵活接口</strong>：提供了丰富的操作方法，如添加、删除、清空等。</li></ul><hr><h2 id="如何使用-vector？"><a href="#如何使用-vector？" class="headerlink" title="如何使用 vector？"></a><strong>如何使用 <code>vector</code>？</strong></h2><h3 id="1-引入头文件"><a href="#1-引入头文件" class="headerlink" title="1. 引入头文件"></a>1. <strong>引入头文件</strong></h3><p>要使用 <code>vector</code>，必须包含 <code>&lt;vector&gt;</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="2-创建-vector"><a href="#2-创建-vector" class="headerlink" title="2. 创建 vector"></a>2. <strong>创建 <code>vector</code></strong></h3><p>创建 <code>vector</code> 和声明普通变量一样简单。</p><h4 id="示例：创建一个存储整数的-vector"><a href="#示例：创建一个存储整数的-vector" class="headerlink" title="示例：创建一个存储整数的 vector"></a>示例：创建一个存储整数的 <code>vector</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector; <span class="comment">// 创建一个空的整数向量</span></span><br></pre></td></tr></table></figure><h4 id="示例：创建时指定大小"><a href="#示例：创建时指定大小" class="headerlink" title="示例：创建时指定大小"></a>示例：创建时指定大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，初始值为默认值（0）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，每个元素初始值为10</span></span><br></pre></td></tr></table></figure><h4 id="示例：使用列表初始化"><a href="#示例：使用列表初始化" class="headerlink" title="示例：使用列表初始化"></a>示例：使用列表初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 创建一个包含元素1, 2, 3, 4, 5的向量</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-向-vector-添加元素"><a href="#3-向-vector-添加元素" class="headerlink" title="3. 向 vector 添加元素"></a>3. <strong>向 <code>vector</code> 添加元素</strong></h3><p>使用 <code>push_back</code> 方法，可以在 <code>vector</code> 的末尾添加元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">push_back</span>(<span class="number">7</span>); <span class="comment">// 向向量末尾添加元素7</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-访问-vector-中的元素"><a href="#4-访问-vector-中的元素" class="headerlink" title="4. 访问 vector 中的元素"></a>4. <strong>访问 <code>vector</code> 中的元素</strong></h3><p>你可以通过两种方式访问元素：</p><ul><li>**下标操作符 <code>[]</code>**：直接通过下标访问元素（从 0 开始计数）。</li><li><strong><code>at()</code> 方法</strong>：更安全的访问方法，会检查下标是否合法。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = myVector[<span class="number">0</span>];      <span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="type">int</span> y = myVector.<span class="built_in">at</span>(<span class="number">1</span>);   <span class="comment">// 获取第二个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-获取-vector-的大小"><a href="#5-获取-vector-的大小" class="headerlink" title="5. 获取 vector 的大小"></a>5. <strong>获取 <code>vector</code> 的大小</strong></h3><p>使用 <code>size()</code> 方法可以得到 <code>vector</code> 中的元素数量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = myVector.<span class="built_in">size</span>(); <span class="comment">// 获取向量大小</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-遍历-vector"><a href="#6-遍历-vector" class="headerlink" title="6. 遍历 vector"></a>6. <strong>遍历 <code>vector</code></strong></h3><p>你可以用多种方式遍历 <code>vector</code>：</p><h4 id="方法-1：普通-for-循环"><a href="#方法-1：普通-for-循环" class="headerlink" title="方法 1：普通 for 循环"></a>方法 1：普通 for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-2：迭代器"><a href="#方法-2：迭代器" class="headerlink" title="方法 2：迭代器"></a>方法 2：迭代器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-3：范围循环（推荐）"><a href="#方法-3：范围循环（推荐）" class="headerlink" title="方法 3：范围循环（推荐）"></a>方法 3：范围循环（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">    std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-删除元素"><a href="#7-删除元素" class="headerlink" title="7. 删除元素"></a>7. <strong>删除元素</strong></h3><p>使用 <code>erase()</code> 方法可以删除某个位置的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">// 删除第三个元素（下标为2）</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-清空-vector"><a href="#8-清空-vector" class="headerlink" title="8. 清空 vector"></a>8. <strong>清空 <code>vector</code></strong></h3><p>使用 <code>clear()</code> 方法可以清空 <code>vector</code> 中的所有元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">clear</span>(); <span class="comment">// 清空向量</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a><strong>完整实例</strong></h2><p>以下代码展示了如何创建一个 <code>vector</code>，添加、访问、删除、清空元素，并输出其内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到向量中</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问第一个和第二个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; myVector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; myVector.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取向量大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第三个元素</span></span><br><span class="line">    myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的向量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector after erasing: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空向量</span></span><br><span class="line">    myVector.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector after clearing: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Elements in the vector: 3 7 11 5</span><br><span class="line">First element: 3</span><br><span class="line">Second element: 7</span><br><span class="line">Size of the vector: 4</span><br><span class="line">Elements in the vector after erasing: 3 7 5</span><br><span class="line">Size of the vector after clearing: 0</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong><code>vector</code> 是一个动态数组</strong>，可以根据需要自动扩展或缩小。</li><li>使用方便：<ul><li>添加元素：<code>push_back()</code></li><li>删除元素：<code>erase()</code></li><li>访问元素：<code>[]</code> 或 <code>at()</code></li><li>遍历：普通循环、迭代器、范围循环。</li></ul></li><li><strong>适用场景</strong>：<ul><li>需要动态调整大小的数组。</li><li>需要频繁在末尾添加或移除元素。</li><li>需要高效的随机访问操作。</li></ul></li></ol><p><code>vector</code> 是 C++ 开发中最常用的容器之一，简单易用且功能强大，几乎可以胜任所有需要动态数组的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 结构体(struct)</title>
      <link href="/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/"/>
      <url>/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-结构体-struct"><a href="#C-结构体-struct" class="headerlink" title="C++ 结构体(struct)"></a>C++ 结构体(struct)</h1><p>在C++中，<strong>结构体（<code>struct</code>）</strong> 是一种非常有用的数据类型，它可以把多种类型的数据组合在一起，形成一个整体。简单来说，<strong>结构体就是一个容器，可以存放不同类型的变量，这些变量称为结构体的“成员”</strong>。</p><hr><h2 id="为什么需要结构体？"><a href="#为什么需要结构体？" class="headerlink" title="为什么需要结构体？"></a><strong>为什么需要结构体？</strong></h2><p>假设我们要管理一本书的信息，比如：</p><ul><li><strong>标题（Title）</strong>：比如《C++ 教程》</li><li><strong>作者（Author）</strong>：比如“张三”</li><li><strong>类别（Subject）</strong>：比如“编程”</li><li><strong>编号（Book ID）</strong>：比如“12345”</li></ul><p>这些属性的数据类型是不同的：</p><ul><li>标题和作者是<strong>字符串</strong>，</li><li>编号是<strong>整数</strong>。</li></ul><p>如果用普通的变量来存储这些信息，代码会变得杂乱无章：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string title1 = <span class="string">&quot;C++ 教程&quot;</span>;</span><br><span class="line">string author1 = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">string subject1 = <span class="string">&quot;编程&quot;</span>;</span><br><span class="line"><span class="type">int</span> bookID1 = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure><p>每增加一本书，就需要定义四个变量，管理起来非常麻烦。<br><strong>结构体</strong>解决了这个问题：它允许我们把这些相关的数据组合起来，作为一个整体来管理。</p><hr><h2 id="如何定义结构体？"><a href="#如何定义结构体？" class="headerlink" title="如何定义结构体？"></a><strong>如何定义结构体？</strong></h2><p>用 <code>struct</code> 关键字来定义结构体，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StructName</span> &#123;</span><br><span class="line">    DataType MemberName1; <span class="comment">// 第一个成员</span></span><br><span class="line">    DataType MemberName2; <span class="comment">// 第二个成员</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，定义一个用于表示“书籍”的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Book</code></strong> 是结构体类型的名字。</li><li>结构体里包含的成员有：<code>title</code>、<code>author</code>、<code>subject</code> 和 <code>book_id</code>。</li></ul><hr><h2 id="如何使用结构体？"><a href="#如何使用结构体？" class="headerlink" title="如何使用结构体？"></a><strong>如何使用结构体？</strong></h2><p>定义了结构体后，可以用它来创建“结构体变量”，表示具体的对象（如一本书）：</p><h3 id="1-创建结构体变量"><a href="#1-创建结构体变量" class="headerlink" title="1. 创建结构体变量"></a><strong>1. 创建结构体变量</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book book1, book2;</span><br></pre></td></tr></table></figure><p>上面创建了两个结构体变量 <code>book1</code> 和 <code>book2</code>，分别表示两本书。</p><h3 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2. 访问结构体成员"></a><strong>2. 访问结构体成员</strong></h3><p>结构体的成员可以通过 <strong><code>.</code> 运算符</strong> 来访问或赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book<span class="number">1.</span>book_id = <span class="number">12345</span>;               <span class="comment">// 设置编号</span></span><br><span class="line"><span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);     <span class="comment">// 设置标题</span></span><br><span class="line">cout &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;         <span class="comment">// 输出标题</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整示例：存储并输出两本书的信息"><a href="#完整示例：存储并输出两本书的信息" class="headerlink" title="完整示例：存储并输出两本书的信息"></a><strong>完整示例：存储并输出两本书的信息</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串处理函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个书的结构体变量</span></span><br><span class="line">    Book book1, book2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第一本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第二本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>author, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>subject, <span class="string">&quot;前端开发&quot;</span>);</span><br><span class="line">    book<span class="number">2.</span>book_id = <span class="number">12346</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第一本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书标题: &quot;</span> &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书作者: &quot;</span> &lt;&lt; book<span class="number">1.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书类别: &quot;</span> &lt;&lt; book<span class="number">1.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书编号: &quot;</span> &lt;&lt; book<span class="number">1.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第二本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书标题: &quot;</span> &lt;&lt; book<span class="number">2.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书作者: &quot;</span> &lt;&lt; book<span class="number">2.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书类别: &quot;</span> &lt;&lt; book<span class="number">2.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书编号: &quot;</span> &lt;&lt; book<span class="number">2.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一本书标题: C++ 教程</span><br><span class="line">第一本书作者: 张三</span><br><span class="line">第一本书类别: 编程</span><br><span class="line">第一本书编号: 12345</span><br><span class="line">第二本书标题: CSS 教程</span><br><span class="line">第二本书作者: 李四</span><br><span class="line">第二本书类别: 前端开发</span><br><span class="line">第二本书编号: 12346</span><br></pre></td></tr></table></figure><hr><h2 id="结构体的高级用法"><a href="#结构体的高级用法" class="headerlink" title="结构体的高级用法"></a><strong>结构体的高级用法</strong></h2><h3 id="1-结构体作为函数参数"><a href="#1-结构体作为函数参数" class="headerlink" title="1. 结构体作为函数参数"></a><strong>1. 结构体作为函数参数</strong></h3><p>可以把结构体传递给函数，用来操作结构体成员数据。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，打印书的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题: &quot;</span> &lt;&lt; book.title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作者: &quot;</span> &lt;&lt; book.author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类别: &quot;</span> &lt;&lt; book.subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; book.book_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book1;</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printBook</span>(book1); <span class="comment">// 调用函数打印书的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-指针操作结构体"><a href="#2-指针操作结构体" class="headerlink" title="2. 指针操作结构体"></a><strong>2. 指针操作结构体</strong></h3><p>用指针操作结构体变量，可以通过 <code>-&gt;</code> 运算符访问成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Book book1;</span><br><span class="line">Book* bookPtr = &amp;book1; <span class="comment">// 定义一个指向 book1 的指针</span></span><br><span class="line"></span><br><span class="line">bookPtr-&gt;book_id = <span class="number">12345</span>; <span class="comment">// 通过指针设置编号</span></span><br><span class="line">cout &lt;&lt; bookPtr-&gt;book_id; <span class="comment">// 通过指针获取编号</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-结构体中添加构造函数"><a href="#3-结构体中添加构造函数" class="headerlink" title="3. 结构体中添加构造函数"></a><strong>3. 结构体中添加构造函数</strong></h3><p>像类一样，结构体也可以有构造函数，用来初始化数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    string subject;</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Book</span>(string t, string a, string s, <span class="type">int</span> id)</span><br><span class="line">        : <span class="built_in">title</span>(t), <span class="built_in">author</span>(a), <span class="built_in">subject</span>(s), <span class="built_in">book_id</span>(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="function">Book <span class="title">book1</span><span class="params">(<span class="string">&quot;C++ 教程&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;编程&quot;</span>, <span class="number">12345</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a><strong>结构体和类的区别</strong></h2><ul><li><p><strong>默认访问权限不同</strong>：</p><ul><li><code>struct</code> 的成员默认是 <strong>public</strong>。</li><li><code>class</code> 的成员默认是 <strong>private</strong>。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>结构体</strong>：用于简单数据的封装，比如存储图书信息、学生信息等。</li><li><strong>类</strong>：用于更复杂的场景，比如需要继承、封装和多态的情况下。</li></ul></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ol><li><strong>结构体</strong> 是一种用户自定义的数据类型，用来把不同类型的数据组合成一个整体。</li><li>结构体可以用来管理复杂的数据，比如图书馆的书籍、学生的成绩等。</li><li>可以通过 <strong><code>.</code> 运算符</strong> 访问成员，也可以通过 <strong><code>-&gt;</code> 运算符</strong> 用指针访问。</li><li>结构体支持函数传参、构造函数、指针操作等高级用法。</li><li>和类类似，但结构体更轻量，适合简单的数据封装任务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本的输入输出</title>
      <link href="/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a>C++ 基本的输入输出</h1><p><strong>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</strong><br><strong>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</strong></p><p><strong>在C++中，有一些专门用来处理输入输出的头文件，它们让我们能够与用户交互，或处理文件。以下是最常用的输入输出头文件以及它们的用途：</strong></p><hr><h2 id="头文件及作用"><a href="#头文件及作用" class="headerlink" title="头文件及作用"></a>头文件及作用</h2><ol><li><p><strong><code>&lt;iostream&gt;</code></strong><br>提供 <strong>标准输入输出功能</strong>，例如用 <code>cin</code> 从键盘输入数据，<code>cout</code> 在屏幕输出数据。</p></li><li><p><strong><code>&lt;iomanip&gt;</code></strong><br>提供 <strong>格式化输出功能</strong>，比如设置小数点精度、对齐输出等操作，常用函数有 <code>setw</code> 和 <code>setprecision</code>。</p></li><li><p><strong><code>&lt;fstream&gt;</code></strong><br>提供 <strong>文件读写功能</strong>，用于从文件中读取数据或向文件写入数据。</p></li></ol><hr><h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a><strong>标准输出流（<code>cout</code>）</strong></h2><ul><li><p><strong><code>cout</code></strong> 用来在屏幕输出内容，通常和 <code>&lt;&lt;</code>（流插入运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出内容是：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出内容是：Hello C++</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&lt;&lt;</code> 操作符会根据变量类型自动选择适合的输出格式。</li><li><code>endl</code> 用于换行，相当于 <code>\n</code>，并且刷新输出缓冲区。</li></ul></li></ul><hr><h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a><strong>标准输入流（<code>cin</code>）</strong></h2><ul><li><p><strong><code>cin</code></strong> 用来从键盘输入数据，通常和 <code>&gt;&gt;</code>（流提取运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入您的名称： &quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;您的名称是：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行过程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入您的名称： cplusplus</span><br><span class="line">您的名称是： cplusplus</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&gt;&gt;</code> 会根据变量的类型读取输入数据。</li><li>如果需要输入多个数据，可以像这样使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a><strong>标准错误流（<code>cerr</code>）</strong></h2><ul><li><strong><code>cerr</code></strong> 用来输出错误消息，特点是 <strong>不经过缓冲，直接输出</strong>，适合需要立即显示的错误信息。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;错误信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a><strong>标准日志流（<code>clog</code>）</strong></h2><ul><li><strong><code>clog</code></strong> 用来输出日志信息，和 <code>cerr</code> 不同的是，<strong>它是缓冲的</strong>，日志信息会先存入缓冲区，等缓冲区满了或刷新时才会输出。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    clog &lt;&lt; <span class="string">&quot;日志信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><strong><code>cout</code></strong>: 用于正常输出，比如结果或普通信息。</li><li><strong><code>cin</code></strong>: 用于从键盘输入数据。</li><li><strong><code>cerr</code></strong>: 用于立即输出错误信息，适合显示错误日志。</li><li><strong><code>clog</code></strong>: 用于输出普通日志信息，会经过缓冲区，适合较少实时性的消息。</li></ol><p>尽管在小程序中 <code>cout</code>、<code>cerr</code> 和 <code>clog</code> 的区别不明显，但在复杂系统中，合理区分这些流有助于调试和维护代码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 日期＆时间</title>
      <link href="/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/"/>
      <url>/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-日期＆时间"><a href="#C-日期＆时间" class="headerlink" title="C++ 日期＆时间"></a>C++ 日期＆时间</h1><p>在C++编程中，我们可以通过标准库来操作日期和时间，但它没有专门的“日期类型”。取而代之的是通过结构和函数来处理。这些功能是从C语言继承而来的，需要使用 <code>&lt;ctime&gt;</code> 头文件。</p><p>C++ 提供了几种与时间相关的类型和结构：</p><ul><li><strong><code>time_t</code></strong>: 用于存储系统时间，表示从1970年1月1日开始的秒数。</li><li><strong><code>tm</code></strong>: 是一个结构体，用来表示更详细的日期和时间信息，比如年、月、日、时、分、秒等。</li></ul><h2 id="tm结构体长什么样？"><a href="#tm结构体长什么样？" class="headerlink" title="tm结构体长什么样？"></a><code>tm</code>结构体长什么样？</h2><p><code>tm</code> 是一个保存日期和时间信息的结构，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围 0-11（0表示1月）</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 从 1900 年起的年数（比如2024年对应值为124）</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围 0-6（0表示星期日）</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 是否是夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见日期和时间的操作函数"><a href="#常见日期和时间的操作函数" class="headerlink" title="常见日期和时间的操作函数"></a>常见日期和时间的操作函数</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>time()</code></td><td>获取当前时间（从1970年到现在的秒数）</td></tr><tr><td><code>localtime()</code></td><td>将时间转换为本地时间，并返回 <code>tm</code> 结构</td></tr><tr><td><code>gmtime()</code></td><td>将时间转换为 UTC 时间（格林威治时间），返回 <code>tm</code> 结构</td></tr><tr><td><code>ctime()</code></td><td>将时间转换为可读的字符串，比如 <code>Mon Jan 1 12:34:56 2024</code></td></tr><tr><td><code>asctime()</code></td><td>将 <code>tm</code> 结构转换为字符串形式</td></tr><tr><td><code>difftime()</code></td><td>计算两个时间点的秒差</td></tr><tr><td><code>strftime()</code></td><td>自定义格式化输出时间</td></tr></tbody></table><hr><h2 id="实例1：获取当前日期和时间"><a href="#实例1：获取当前日期和时间" class="headerlink" title="实例1：获取当前日期和时间"></a>实例1：获取当前日期和时间</h2><p>以下代码演示如何获取并打印系统的当前时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="type">char</span>* dt = <span class="built_in">ctime</span>(&amp;now); <span class="comment">// 转换为字符串形式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tm *gmtm = <span class="built_in">gmtime</span>(&amp;now); <span class="comment">// 转换为 UTC 时间</span></span><br><span class="line">    dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地日期和时间：Sat Nov 16 15:35:21 2024</span><br><span class="line">UTC 日期和时间：Sat Nov 16 07:35:21 2024</span><br></pre></td></tr></table></figure><hr><h2 id="实例2：格式化日期和时间"><a href="#实例2：格式化日期和时间" class="headerlink" title="实例2：格式化日期和时间"></a>实例2：格式化日期和时间</h2><p>使用 <code>tm</code> 结构可以详细访问时间信息，比如年、月、日等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    tm *ltm = <span class="built_in">localtime</span>(&amp;now); <span class="comment">// 转换为本地时间结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间的各个组成部分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1970到现在经过的秒数：&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年: &quot;</span> &lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;月: &quot;</span> &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;日: &quot;</span> &lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;时间: &quot;</span> &lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1970到现在经过的秒数：1737093321</span><br><span class="line">当前时间：</span><br><span class="line">年: 2024</span><br><span class="line">月: 11</span><br><span class="line">日: 16</span><br><span class="line">时间: 15:35:21</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li><strong><code>time_t</code></strong> 是一个简单的整数类型，用来表示时间戳。</li><li><strong><code>tm</code></strong> 是一个更复杂的结构，用来处理年月日等详细信息。</li><li>我们可以通过函数（如 <code>localtime</code> 或 <code>gmtime</code>）来获取和转换时间，然后打印出想要的格式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/2024/11/16/C-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/11/16/C-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="什么是引用？"><a href="#什么是引用？" class="headerlink" title="什么是引用？"></a>什么是引用？</h2><p>在 C++ 中，<strong>引用</strong> 就是变量的另一个名字（别名）。<br>可以把它理解成一个“昵称”：通过这个昵称，和直接用变量名字效果是一样的，操作的都是同一个数据。<br>一旦给变量起了这个“昵称”，就不能再改了，引用会一直绑定在这个变量上。</p><hr><h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><p>虽然引用和指针都能用来间接访问变量的内容，但它们有以下重要区别：</p><ol><li><p><strong>引用必须合法</strong>：  </p><ul><li>引用在创建时，必须绑定到一个有效的变量。  </li><li>指针可以为空（指向 <code>NULL</code>），或者在以后指向其他变量。</li></ul></li><li><p><strong>绑定不可更改</strong>：  </p><ul><li>引用一旦和某个变量绑定，就不能改为绑定其他变量。  </li><li>指针可以随时指向其他变量。</li></ul></li><li><p><strong>必须初始化</strong>：  </p><ul><li>引用在创建时，必须立刻绑定到某个变量。  </li><li>指针可以在创建时不赋值，稍后再初始化。</li></ul></li></ol><hr><h2 id="如何创建引用？"><a href="#如何创建引用？" class="headerlink" title="如何创建引用？"></a>如何创建引用？</h2><p>想象变量是贴在内存位置上的标签，引用就是这个标签的第二个名字。<br>用法很简单，直接用符号 <code>&amp;</code> 创建一个引用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">17</span>;  <span class="comment">// 定义一个变量 i</span></span><br><span class="line"><span class="type">int</span>&amp; r = i;  <span class="comment">// 给 i 起了一个别名 r</span></span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>r</code> 是变量 <code>i</code> 的引用。</li><li>无论是用 <code>i</code> 还是用 <code>r</code>，操作的都是同一个数据。</li></ul><hr><h2 id="一个完整例子"><a href="#一个完整例子" class="headerlink" title="一个完整例子"></a>一个完整例子</h2><p>来看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明简单变量</span></span><br><span class="line">    <span class="type">int</span> i;        <span class="comment">// 一个整型变量</span></span><br><span class="line">    <span class="type">double</span> d;     <span class="comment">// 一个 double 型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明引用变量</span></span><br><span class="line">    <span class="type">int</span>&amp; r = i;   <span class="comment">// r 是 i 的引用</span></span><br><span class="line">    <span class="type">double</span>&amp; s = d; <span class="comment">// s 是 d 的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 i 和 d 赋值</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    d = <span class="number">11.7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过变量名和引用名访问值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i: &quot;</span> &lt;&lt; i &lt;&lt; endl;         <span class="comment">// 直接用 i</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i reference: &quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="comment">// 用引用 r</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d: &quot;</span> &lt;&lt; d &lt;&lt; endl;         <span class="comment">// 直接用 d</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d reference: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// 用引用 s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 5</span><br><span class="line">Value of i reference: 5</span><br><span class="line">Value of d: 11.7</span><br><span class="line">Value of d reference: 11.7</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p><strong><code>int&amp; r = i;</code></strong>  </p><ul><li>这里 <code>r</code> 是变量 <code>i</code> 的别名。之后，无论是通过 <code>r</code> 还是通过 <code>i</code> 修改值，结果都是一样的，因为它们指向同一块内存。</li></ul></li><li><p><strong><code>double&amp; s = d;</code></strong>  </p><ul><li>这里 <code>s</code> 是变量 <code>d</code> 的别名，类似上面。</li></ul></li></ul><p><strong>总结</strong>：引用就是变量的另一个名字，引用名和变量名操作的是同一个值。</p><hr><h2 id="引用的两个重要用法"><a href="#引用的两个重要用法" class="headerlink" title="引用的两个重要用法"></a>引用的两个重要用法</h2><ol><li><p><strong>引用作为函数参数</strong>  </p><ul><li>在函数参数中使用引用，可以让函数直接操作传入的变量，而不是创建一个副本。  </li><li>这种方法既高效，又可以避免不必要的数据拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);  <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 输出 a: 10, b: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>swap</code> 函数的参数是引用，因此可以直接修改 <code>a</code> 和 <code>b</code> 的值，而不需要返回值。</li></ul></li><li><p><strong>引用作为函数返回值</strong>  </p><ul><li>可以从函数中返回一个引用，这样可以直接操作返回的值，而不需要拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];  <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">getReference</span>(numbers, <span class="number">1</span>) = <span class="number">50</span>;  <span class="comment">// 修改数组的第二个元素</span></span><br><span class="line">    cout &lt;&lt; numbers[<span class="number">1</span>] &lt;&lt; endl;     <span class="comment">// 输出 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>getReference</code> 返回的是数组元素的引用，因此可以直接修改数组内容，而不需要拷贝数据。</li></ul></li></ol><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><p><strong>什么是引用？</strong><br>引用是变量的另一个名字（昵称），操作引用就等于操作变量本身。</p></li><li><p><strong>引用有什么用？</strong>  </p><ul><li>减少不必要的数据拷贝，提高效率。</li><li>让代码更简洁，比如用在函数参数或返回值中。</li></ul></li><li><p><strong>引用和指针的区别？</strong>  </p><ul><li>引用更安全，因为它不能是空引用，且绑定后不能改变。</li><li>指针更灵活，因为它可以为空，也可以随时指向其他变量。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针</title>
      <link href="/2024/11/16/C-%E6%8C%87%E9%92%88/"/>
      <url>/2024/11/16/C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容我们将正式进入指针的学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><p>C++ 中的 <strong>指针</strong> 就像一个“地址簿”，它记录了存储某个值的“房子”（内存位置）的地址。学习指针是 C++ 编程的重要部分，因为它不仅可以让你写出更高效的代码，还能完成像 <strong>动态内存分配</strong> 这样的高级操作，这些是没有指针无法实现的。</p><h3 id="什么是地址？"><a href="#什么是地址？" class="headerlink" title="什么是地址？"></a>什么是地址？</h3><p>每个变量（比如 <code>int</code>、<code>char</code> 等）在计算机的内存中都占据一个“房子”（内存位置）。这个房子有自己的“地址”，就像你家的门牌号一样，唯一且能指引我们找到这个变量存储在哪里。</p><p>在 C++ 中，可以使用符号 <code>&amp;</code>（取地址符）来获取变量的地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1;         <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">char</span> var2[<span class="number">10</span>];    <span class="comment">// 定义一个字符数组</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出的地址是什么？"><a href="#输出的地址是什么？" class="headerlink" title="输出的地址是什么？"></a>输出的地址是什么？</h3><p>当这段代码运行时，会输出类似下面的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 变量的地址： 0xbfebd5c0</span><br><span class="line">var2 变量的地址： 0xbfebd5b6</span><br></pre></td></tr></table></figure><p>这些看起来像一串奇怪的数字（比如 <code>0xbfebd5c0</code>），其实是计算机给变量分配的“内存地址”。通过这些地址，程序可以快速找到变量的位置，访问或者操作它的值。</p><h3 id="更通俗的比喻"><a href="#更通俗的比喻" class="headerlink" title="更通俗的比喻"></a>更通俗的比喻</h3><p>假设你的内存是一个巨大的公寓楼，每个房间都有一个房号（内存地址）：</p><ul><li><code>var1</code> 是住在某个房间的小明，他的房间号是 <code>0xbfebd5c0</code>。</li><li><code>var2</code> 是住在另一个房间的小红，她的房间号是 <code>0xbfebd5b6</code>。</li></ul><p>如果你想找小明或小红，只需要知道他们的房间号（地址），然后直接去找就可以了。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>变量</strong> 是房间里的住户。</li><li><strong>内存地址</strong> 是房间号。</li><li>用 <code>&amp;</code> 可以查到变量住在哪个房间（内存地址）。</li></ul><p>指针就是“记住房间号”的一种方式，后面你会学习如何用指针操作变量的值，让编程更加灵活和高效！</p><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针是一个变量，存放着另一个变量的“地址”（类似于一个门牌号）。通过这个门牌号，我们可以找到并操作那个变量。<br>想象一下，一个指针就像地图上的标记，指向某个具体位置（变量所在的内存地址）。</p><hr><h3 id="如何声明一个指针？"><a href="#如何声明一个指针？" class="headerlink" title="如何声明一个指针？"></a>如何声明一个指针？</h3><p>在 C++ 中，声明指针的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><strong><code>type</code></strong> 是指针指向的变量类型，比如 <code>int</code>、<code>float</code> 等。</li><li><strong><code>*</code></strong> 告诉编译器这个变量是一个指针，而不是普通变量。</li><li><strong><code>var-name</code></strong> 是指针变量的名称。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">// 一个整型指针</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">// 一个 double 型指针</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">// 一个浮点型指针</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">// 一个字符型指针</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>*</code> 在这里的作用是“定义指针”，而不是数学中的乘号。</p><hr><h3 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h3><p>指针的主要操作可以分为以下几步：</p><ol><li><strong>定义指针变量</strong>：告诉编译器，你要存储某个变量的地址。</li><li><strong>存储地址到指针变量</strong>：通过取地址符 <code>&amp;</code>，获取变量的内存地址，并存储到指针中。</li><li><strong>访问地址对应的值</strong>：通过解引用符 <code>*</code>，获取指针指向的变量的值。</li></ol><hr><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们通过一个简单的程序来说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">20</span>;    <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">int</span> *ip;         <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"></span><br><span class="line">    ip = &amp;var;       <span class="comment">// 将 var 的地址赋值给指针 ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出存储在指针 ip 中的地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span> &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of var variable: 20</span><br><span class="line">Address stored in ip variable: 0xbfc601ac</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure><hr><h3 id="程序的核心解释"><a href="#程序的核心解释" class="headerlink" title="程序的核心解释"></a>程序的核心解释</h3><ol><li><p><strong><code>int var = 20;</code></strong><br>定义一个整数变量，值为 20。</p></li><li><p><strong><code>int *ip;</code></strong><br>定义了一个指针变量 <code>ip</code>，它可以存储一个整数变量的地址。</p></li><li><p><strong><code>ip = &amp;var;</code></strong><br>使用取地址符 <code>&amp;</code>，获取变量 <code>var</code> 的地址，并存储到指针 <code>ip</code> 中。<br>此时，<code>ip</code> 的值就是 <code>var</code> 在内存中的地址。</p></li><li><p><strong>输出指针指向的值</strong><br>使用解引用符 <code>*ip</code>，可以通过指针访问变量 <code>var</code> 的值。<br>也就是说，<code>*ip</code> 等价于 <code>var</code>。</p></li></ol><hr><h3 id="指针的本质"><a href="#指针的本质" class="headerlink" title="指针的本质"></a>指针的本质</h3><p>无论指针指向的是整数、浮点数还是字符，<strong>指针的实际值都是内存地址</strong>（一个十六进制数）。<br>指针的类型（比如 <code>int*</code> 或 <code>char*</code>）是为了告诉编译器，指针指向的变量是什么类型，从而正确操作。</p><hr><h3 id="C-中的一些指针概念"><a href="#C-中的一些指针概念" class="headerlink" title="C++ 中的一些指针概念"></a>C++ 中的一些指针概念</h3><table><thead><tr><th><strong>概念</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>空指针</strong></td><td>指向“空地址”的指针（<code>NULL</code>）。如果指针未初始化，最好设为 NULL，避免意外使用。</td></tr><tr><td><strong>指针运算</strong></td><td>可以对指针做加减法（比如指向下一个元素）。</td></tr><tr><td><strong>指针与数组</strong></td><td>数组的名称本质上是一个指向数组第一个元素的指针。</td></tr><tr><td><strong>指针数组</strong></td><td>数组可以存储多个指针，称为“指针数组”。</td></tr><tr><td><strong>指向指针的指针</strong></td><td>一个指针可以指向另一个指针，称为“二级指针”或“指向指针的指针”。</td></tr><tr><td><strong>传递指针给函数</strong></td><td>通过指针传参，可以直接操作原始数据，而不是拷贝数据。</td></tr><tr><td><strong>从函数返回指针</strong></td><td>函数可以返回一个指针，指向局部变量、静态变量或动态分配的内存。</td></tr></tbody></table><hr><h3 id="通俗总结"><a href="#通俗总结" class="headerlink" title="通俗总结"></a>通俗总结</h3><ol><li><p><strong>指针是什么？</strong><br>它是“一个变量的地址”。</p></li><li><p><strong>指针能干什么？</strong>  </p><ul><li>指向一个变量，间接操作它的值。</li><li>动态管理内存（比如数组的大小可以运行时确定）。</li></ul></li><li><p><strong>如何理解指针？</strong>  </p><ul><li>想象成地图上的标记：指针记录了某个地点（变量）的地址。通过标记，我们可以访问这个地点的内容。</li></ul></li><li><p><strong>为什么要用指针？</strong><br>指针让代码更高效，可以节省内存，快速定位变量，实现复杂的数据结构（如链表、树等）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串</title>
      <link href="/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><p><em><strong>C 风格字符串</strong></em><br><strong>C++ 引入的 string 类类型</strong></p><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a><strong>C风格字符串</strong></h2><p>在 C 和 C++ 中，字符串实际上是用来存放文字或字符的一种特殊的 <strong>字符数组</strong>，并在最后加上一个 **特殊符号 <code>\0</code>**（表示字符串结束）。我们称这种字符串为 <strong>C 风格字符串</strong>。</p><hr><h3 id="字符串的本质：字符数组"><a href="#字符串的本质：字符数组" class="headerlink" title="字符串的本质：字符数组"></a><strong>字符串的本质：字符数组</strong></h3><ul><li>就像一个储物柜，里面每个格子存放一个字符。</li><li>字符串的末尾会有一个 **隐藏的结束符 <code>\0</code>**，告诉程序「字符串到这里就结束了」。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>site</code> 是一个字符数组，包含：</p><ul><li><strong>6 个字符</strong>：<code>R</code>、<code>U</code>、<code>N</code>、<code>O</code>、<code>O</code>、<code>B</code></li><li><strong>1 个结束符</strong>：<code>&#39;\0&#39;</code></li></ul><p>储存结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位置：  [0]  [1]  [2]  [3]  [4]  [5]  [6]</span><br><span class="line">字符：  &#x27;R&#x27;  &#x27;U&#x27;  &#x27;N&#x27;  &#x27;O&#x27;  &#x27;O&#x27;  &#x27;B&#x27;  &#x27;\0&#x27;</span><br></pre></td></tr></table></figure><p>因为有 <code>\0</code>，字符串的大小比字符数多 1。</p><hr><h3 id="字符串的简化写法"><a href="#字符串的简化写法" class="headerlink" title="字符串的简化写法"></a><strong>字符串的简化写法</strong></h3><p>你可以用更简单的方式直接初始化字符串，程序会自动在末尾加上 <code>\0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>等同于</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>所以 <code>site</code> 中存储的内容依然是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;RUNOOB\0&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串的打印"><a href="#字符串的打印" class="headerlink" title="字符串的打印"></a><strong>字符串的打印</strong></h3><p>在 C++ 中，<code>cout</code> 遇到字符串时，会从第一个字符开始输出，一直到碰到 <code>\0</code> 结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;网站名: &quot;</span> &lt;&lt; site &lt;&lt; endl; <span class="comment">// 输出 &quot;RUNOOB&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网站名: RUNOOB</span><br></pre></td></tr></table></figure><hr><h3 id="常用的字符串操作函数"><a href="#常用的字符串操作函数" class="headerlink" title="常用的字符串操作函数"></a><strong>常用的字符串操作函数</strong></h3><p>C++ 提供了一些常用的函数来操作 C 风格字符串，这些函数都在 <code>&lt;cstring&gt;</code> 头文件中。</p><h3 id="1-strcpy：字符串复制"><a href="#1-strcpy：字符串复制" class="headerlink" title="1. strcpy：字符串复制"></a><strong>1. <code>strcpy</code>：字符串复制</strong></h3><p>把一个字符串复制到另一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(str2, str1); <span class="comment">// 把 str1 的内容复制到 str2</span></span><br><span class="line">cout &lt;&lt; str2;       <span class="comment">// 输出：runoob</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-strcat：字符串拼接"><a href="#2-strcat：字符串拼接" class="headerlink" title="2. strcat：字符串拼接"></a><strong>2. <code>strcat</code>：字符串拼接</strong></h3><p>把一个字符串追加到另一个字符串的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2); <span class="comment">// 拼接：str1 = &quot;runoobgoogle&quot;</span></span><br><span class="line">cout &lt;&lt; str1;       <span class="comment">// 输出：runoobgoogle</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-strlen：字符串长度"><a href="#3-strlen：字符串长度" class="headerlink" title="3. strlen：字符串长度"></a><strong>3. <code>strlen</code>：字符串长度</strong></h3><p>计算字符串的长度（不包括 <code>\0</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 长度是 6</span></span><br><span class="line">cout &lt;&lt; len;           <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-strcmp：字符串比较"><a href="#4-strcmp：字符串比较" class="headerlink" title="4. strcmp：字符串比较"></a><strong>4. <code>strcmp</code>：字符串比较</strong></h3><p>比较两个字符串的大小：</p><ul><li>如果相等，返回 <code>0</code></li><li>如果第一个字符串比第二个小，返回负值</li><li>如果第一个字符串比第二个大，返回正值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2); <span class="comment">// 返回正值，因为 &quot;runoob&quot; &gt; &quot;google&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-strchr：查找字符"><a href="#5-strchr：查找字符" class="headerlink" title="5. strchr：查找字符"></a><strong>5. <code>strchr</code>：查找字符</strong></h3><p>在字符串中查找某个字符的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strchr</span>(str, <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 找到 &#x27;n&#x27;，返回其地址</span></span><br><span class="line">cout &lt;&lt; *pos;                <span class="comment">// 输出：n</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-strstr：查找子字符串"><a href="#6-strstr：查找子字符串" class="headerlink" title="6. strstr：查找子字符串"></a><strong>6. <code>strstr</code>：查找子字符串</strong></h3><p>在字符串中查找某个子字符串的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoobgoogle&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strstr</span>(str1, str2); <span class="comment">// 找到 &quot;google&quot;，返回其地址</span></span><br><span class="line">cout &lt;&lt; pos;                    <span class="comment">// 输出：google</span></span><br></pre></td></tr></table></figure><hr><h3 id="完整示例：操作-C-风格字符串"><a href="#完整示例：操作-C-风格字符串" class="headerlink" title="完整示例：操作 C 风格字符串"></a><strong>完整示例：操作 C 风格字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串操作函数头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制 str1 到 str3</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;复制后 str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接 str2 到 str1</span></span><br><span class="line">    <span class="built_in">strcat</span>(str1, str2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后 str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算 str1 的长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 长度: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制后 str3: runoob</span><br><span class="line">拼接后 str1: runoobgoogle</span><br><span class="line">str1 长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="C-的-string-类（现代方式）"><a href="#C-的-string-类（现代方式）" class="headerlink" title="C++ 的 string 类（现代方式）"></a><strong>C++ 的 <code>string</code> 类（现代方式）</strong></h2><p>C++ 提供了 <code>string</code> 类，操作字符串更简单，推荐使用：</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制字符串</span></span><br><span class="line">    string str3 = str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接字符串</span></span><br><span class="line">    str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取长度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;长度: &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str3: runoob</span><br><span class="line">拼接后: runoobgoogle</span><br><span class="line">长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ul><li><strong>C 风格字符串</strong>：用字符数组实现，需注意 <code>\0</code> 结束符。</li><li><strong>字符串操作函数</strong>：如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 提供基本功能。</li><li><strong>C++ <code>string</code> 类</strong>：更现代化，更灵活，推荐在 C++ 中使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数组</title>
      <link href="/2024/11/16/C-%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h1><p>C++ 中的数组可以看作是一个「容器」，专门用来存储一组相同类型的数据，就像一个排成一列的储物柜。每个储物柜都有一个编号（索引），你可以通过这个编号来取出或者放入对应位置的数据。</p><h3 id="用通俗的例子来理解："><a href="#用通俗的例子来理解：" class="headerlink" title="用通俗的例子来理解："></a>用通俗的例子来理解：</h3><p>假设你有 100 本书，不想给每本书都取个名字（比如 book1、book2、book3… book100），这会非常麻烦。这时，你可以用一个「书架」（数组），把这些书按照顺序摆放在书架上，然后给每本书一个位置编号，比如：</p><ul><li>第一本书在位置 <code>0</code>，第二本书在位置 <code>1</code>，以此类推。</li></ul><p>在 C++ 里，你可以通过「书架名字 + 编号」直接访问书的位置，比如：</p><ul><li><code>books[0]</code> 就是第 1 本书。</li><li><code>books[99]</code> 就是第 100 本书。</li></ul><h3 id="数组的本质："><a href="#数组的本质：" class="headerlink" title="数组的本质："></a>数组的本质：</h3><ol><li><strong>连续的存储空间</strong>：就像这些书在书架上是紧挨着摆放的，每个位置依次存储数据。</li><li><strong>索引从 0 开始</strong>：C++ 习惯用 <code>0</code> 表示第一个位置。</li><li><strong>方便操作</strong>：你只需要知道位置编号，就能快速找到书（数据）。</li></ol><h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><p>数组是把一堆同类数据放到一个「共享的容器」里，用编号（索引）来区分每个数据，既节省了管理多个变量的麻烦，也让操作更高效。</p><h2 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1. 声明数组"></a><strong>1. 声明数组</strong></h2><p>数组是用来存储一组数据的，就像一本多格笔记本，每个格子都可以用来记数据。要告诉电脑这个数组需要存储什么类型的数据（比如数字或文字）以及需要多少格（大小）。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><strong><code>double</code></strong> 表示每个格子存放小数。</li><li><strong><code>balance</code></strong> 是这个数组的名字。</li><li><strong><code>[10]</code></strong> 表示有 10 个格子。</li></ul><p><strong>想象一下：</strong><br>你有一个存放 10 个数字的储物柜，每个柜子大小都一样，按顺序编号：<code>0</code> 到 <code>9</code>。</p><hr><h2 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2. 初始化数组"></a><strong>2. 初始化数组</strong></h2><p><strong>方式 1：逐个存放</strong><br>就像你一格一格手动往柜子里放东西：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">0</span>] = <span class="number">1000.0</span>;</span><br><span class="line">balance[<span class="number">1</span>] = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// 依次放入其他值...</span></span><br></pre></td></tr></table></figure><p><strong>方式 2：一次性存放</strong><br>如果你已经知道每格要存什么，可以一次性写完：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这就像直接打包好了 5 件东西，放进 5 个柜子。</p><p><strong>省略大小：</strong><br>如果你不想提前指定柜子数量，C++ 会根据数据的个数自动分配大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-访问数组中的数据"><a href="#3-访问数组中的数据" class="headerlink" title="3. 访问数组中的数据"></a><strong>3. 访问数组中的数据</strong></h2><p>你可以通过柜子的编号（索引）取出或修改里面的东西，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;  <span class="comment">// 改变第 5 个柜子的值为 50.0</span></span><br><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>]; <span class="comment">// 获取第 10 个柜子的值</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>柜子编号从 <strong>0</strong> 开始。</li><li>如果数组大小是 <code>10</code>，最后一个柜子的编号是 <code>9</code>。</li></ul><hr><h2 id="4-使用数组举例"><a href="#4-使用数组举例" class="headerlink" title="4. 使用数组举例"></a><strong>4. 使用数组举例</strong></h2><p>以下程序会创建一个数组 <code>n</code>，存储从 <code>100</code> 开始的 10 个数字，并输出它们的值：</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">// 创建一个大小为 10 的整数数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给数组的每个柜子存值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">// 每个柜子的值 = 编号 + 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组中的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Element\tValue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; n[j] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element    Value</span><br><span class="line">0          100</span><br><span class="line">1          101</span><br><span class="line">2          102</span><br><span class="line">3          103</span><br><span class="line">4          104</span><br><span class="line">5          105</span><br><span class="line">6          106</span><br><span class="line">7          107</span><br><span class="line">8          108</span><br><span class="line">9          109</span><br></pre></td></tr></table></figure><hr><h2 id="5-更高级的数组概念"><a href="#5-更高级的数组概念" class="headerlink" title="5. 更高级的数组概念"></a><strong>5. 更高级的数组概念</strong></h2><table><thead><tr><th><strong>概念</strong></th><th><strong>通俗解释</strong></th></tr></thead><tbody><tr><td><strong>多维数组</strong></td><td>就像一个表格或一个盒子，可以存储二维或多维的数据。比如二维数组就像一个 Excel 表格，有行和列。</td></tr><tr><td><strong>指向数组的指针</strong></td><td>数组的名字本身就是一个指向第一个格子的「地址」。这就像你有一个地图，可以用地图快速找到第一个储物柜。</td></tr><tr><td><strong>传递数组给函数</strong></td><td>你可以把整个数组传递给函数，就像把储物柜的地图交给别人，让他们根据地图找到所有东西。</td></tr><tr><td><strong>从函数返回数组</strong></td><td>函数也可以返回一个数组，就像别人帮你装满东西后，把一个新的储物柜还给你。</td></tr></tbody></table><hr><h2 id="小总结：-1"><a href="#小总结：-1" class="headerlink" title="小总结："></a>小总结：</h2><ol><li><strong>声明</strong>：定义一个装东西的储物柜（数组），指定它能装什么类型、装多少。</li><li><strong>初始化</strong>：往柜子里放东西，可以逐个放，也可以一次性全放。</li><li><strong>访问</strong>：通过编号（索引）取柜子里的东西或改它的值。</li><li><strong>进阶用法</strong>：数组还可以做更多复杂的操作，比如作为表格、多维容器、或通过函数共享数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数字</title>
      <link href="/2024/11/16/C-%E6%95%B0%E5%AD%97/"/>
      <url>/2024/11/16/C-%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数字"><a href="#C-数字" class="headerlink" title="C++数字"></a>C++数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 <a href="https://blog.toumatou.cn/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">C++ 数据类型</a>一节中讨论过。</p><h2 id="1-定义数字"><a href="#1-定义数字" class="headerlink" title="1. 定义数字"></a><strong>1. 定义数字</strong></h2><p>在 C++ 中，我们可以定义多种类型的数字，具体的数字类型取决于数值的大小和精度。下面是常用的数字类型：</p><ul><li>**<code>short</code>**：用于存储较小的整数（通常为 2 字节）。</li><li>**<code>int</code>**：用于存储整数（通常为 4 字节）。</li><li>**<code>long</code>**：用于存储较大的整数（通常为 4 或 8 字节，取决于平台）。</li><li>**<code>float</code>**：用于存储单精度浮点数，通常用于存储小数（4 字节）。</li><li>**<code>double</code>**：用于存储双精度浮点数，通常用于存储精度较高的小数（8 字节）。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种类型的数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;     <span class="comment">// 小整数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1000</span>;     <span class="comment">// 整数</span></span><br><span class="line">    <span class="type">long</span> l = <span class="number">1000000</span>; <span class="comment">// 大整数</span></span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>; <span class="comment">// 单精度小数</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">30949.374</span>; <span class="comment">// 双精度小数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数字值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short  s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int    i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long   l: &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float  f: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double d: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short  s: 10</span><br><span class="line">int    i: 1000</span><br><span class="line">long   l: 1000000</span><br><span class="line">float  f: 230.47</span><br><span class="line">double d: 30949.4</span><br></pre></td></tr></table></figure><h2 id="2-数学运算"><a href="#2-数学运算" class="headerlink" title="2. 数学运算"></a><strong>2. 数学运算</strong></h2><p>C++ 提供了很多内置的数学函数，可以帮助我们做各种数学计算。要使用这些函数，我们需要引入 <code>&lt;cmath&gt;</code> 头文件。</p><p>以下是一些常见的数学函数：</p><ul><li>**<code>cos(double)</code>**：计算角度的余弦值。</li><li>**<code>sin(double)</code>**：计算角度的正弦值。</li><li>**<code>tan(double)</code>**：计算角度的正切值。</li><li>**<code>log(double)</code>**：计算参数的自然对数。</li><li>**<code>pow(double, double)</code>**：计算第一个数的第二个数次方（幂运算）。</li><li>**<code>sqrt(double)</code>**：计算平方根。</li><li>**<code>abs(int)</code>**：计算整数的绝对值。</li><li>**<code>fabs(double)</code>**：计算浮点数的绝对值。</li><li>**<code>floor(double)</code>**：向下取整，返回小于或等于给定数字的最大整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  <span class="comment">// 引入数学库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1000</span>;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数学函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sin(d): &quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;        <span class="comment">// 计算正弦</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;abs(i): &quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;        <span class="comment">// 计算绝对值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;floor(d): &quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;    <span class="comment">// 向下取整</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sqrt(f): &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;      <span class="comment">// 计算平方根</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pow(d, 2): &quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 计算平方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sin(d): -0.634939</span><br><span class="line">abs(i): 1000</span><br><span class="line">floor(d): 200</span><br><span class="line">sqrt(f): 15.1812</span><br><span class="line">pow(d, 2): 40149.7</span><br></pre></td></tr></table></figure><h2 id="3-随机数生成"><a href="#3-随机数生成" class="headerlink" title="3. 随机数生成"></a><strong>3. 随机数生成</strong></h2><p>在一些应用场景中，我们需要生成随机数。C++ 提供了 <code>rand()</code> 函数来生成伪随机数，但需要注意的是，<code>rand()</code> 每次程序运行时生成的随机数是固定的，类似于一个固定的序列。为了让每次生成的随机数不同，我们可以使用 <code>srand()</code> 函数设置随机数种子。</p><p>通常，<code>srand()</code> 的参数是当前的系统时间，这样每次运行程序时，生成的随机数都不相同。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">// 引入时间库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 引入随机数库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子为当前时间</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并输出 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        j = <span class="built_in">rand</span>();  <span class="comment">// 获取一个随机数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">随机数： 1748144778</span><br><span class="line">随机数： 630873888</span><br><span class="line">随机数： 2134540646</span><br><span class="line">随机数： 219404170</span><br><span class="line">随机数： 902129458</span><br><span class="line">随机数： 920445370</span><br><span class="line">随机数： 1319072661</span><br><span class="line">随机数： 257938873</span><br><span class="line">随机数： 1256201101</span><br><span class="line">随机数： 580322989</span><br></pre></td></tr></table></figure><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>C++ 中可以定义不同类型的数字（如整数、浮点数等）来存储不同类型的数值。</li><li>通过引入 <code>&lt;cmath&gt;</code> 库，我们可以使用 C++ 提供的丰富数学函数来进行各种数学运算。</li><li>通过 <code>rand()</code> 和 <code>srand()</code> 函数，我们可以生成随机数并控制随机数序列的不同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数</title>
      <link href="/2024/11/16/C-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/11/16/C-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将正式进入函数的相关学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="https://blog.toumatou.cn/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p><strong>在C++中，函数就像是一个小助手，它负责完成一个特定的任务。你可以把一段代码想象成是一个小助手，当你需要它的时候，就可以召唤它来帮你做事，而不需要每次都从头开始写这段代码。</strong></p><p><strong>每个C++程序至少会有一个主函数，也就是<code>main()</code>函数，它是程序的起点。但是，你还可以定义更多的函数来帮助你完成不同的任务。</strong></p><p><strong>函数声明就像是给小助手起个名字，告诉计算机它叫什么，能帮你做什么，以及你需要给它什么信息（参数）。函数定义则是真正告诉计算机这个小助手具体应该怎么做。</strong></p><p><strong>C++标准库就像是一个有很多小助手的团队，它们已经准备好了，你可以直接召唤它们来帮你做事，比如<code>strcat()</code>可以把两个字符串连在一起，<code>memcpy()</code>可以帮你复制一段内存。</strong></p><p><strong>函数还有其他的名字，比如方法、子例程或者程序，它们都是做同样的事情：帮你完成任务。</strong></p><p><strong>总结一下，函数就是一段可以重复使用的代码，它负责完成一个特定的任务。你可以通过声明和定义来创建自己的函数，也可以使用C++标准库中已经定义好的函数。这样可以让你的程序更加整洁和高效。</strong></p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><strong>函数的定义</strong></h2><p>一个函数的基本结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组成部分：</strong></p><ul><li><strong>返回类型（Return Type）：</strong> 指定函数完成任务后返回的数据类型。如果函数不返回任何值，使用 <code>void</code>。</li><li><strong>函数名（Function Name）：</strong> 函数的标识符，用于调用函数。</li><li><strong>参数列表（Parameter List）：</strong> 函数接受的输入，类似占位符。在调用函数时，实际参数的值会传递给这些参数。参数可以有多个，也可以没有。</li><li><strong>函数体（Function Body）：</strong> 包含实现函数功能的代码块。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个数中较大的一个</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><strong>函数声明</strong></h2><p>函数声明告诉编译器函数的名称和如何调用它，实际的函数体可以在别处定义。</p><p><strong>格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure><p>参数名在函数声明中是可选的，只要指定类型即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><strong>调用函数</strong></h2><p>当我们需要使用函数时，通过函数名和参数来调用它。</p><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取较大的值</span></span><br><span class="line">    ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最大值是：&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是：200</span><br></pre></td></tr></table></figure><hr><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h2><p>函数可以通过参数接受输入，有三种传递参数的方式：</p><ol><li><strong>值传递（Pass by Value）：</strong> 将实际参数的值复制一份传递给函数。函数内对参数的修改不会影响实际参数。</li><li><strong>指针传递（Pass by Pointer）：</strong> 将实际参数的地址传递给函数。函数可以通过指针修改实际参数的值。</li><li><strong>引用传递（Pass by Reference）：</strong> 传递参数的引用，函数内对参数的修改会直接影响实际参数。</li></ol><p><strong>注意：</strong> 默认情况下，C++ 使用值传递。</p><hr><h2 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a><strong>参数的默认值</strong></h2><p>函数参数可以有默认值，如果在调用函数时未提供该参数的值，将使用默认值。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个参数</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个参数，b 使用默认值</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总和是：300</span><br><span class="line">总和是：120</span><br></pre></td></tr></table></figure><hr><h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a><strong>Lambda 函数与表达式</strong></h2><p>C++11 引入了匿名函数，称为 Lambda 函数或 Lambda 表达式。它们使您可以在代码中定义简短的内联函数。</p><p><strong>基本形式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[capture]（捕获列表）：</strong> 指定哪些外部变量可以在 Lambda 中使用。</li><li><strong>(参数列表)：</strong> Lambda 接受的参数。</li><li><strong>返回类型（可选）：</strong> 如果编译器无法推断返回类型，可以显式指定。</li><li><strong>函数体：</strong> Lambda 执行的代码。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的比较函数</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br></pre></td></tr></table></figure><p><strong>无参数的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不接受参数的 Lambda</span></span><br><span class="line"><span class="keyword">auto</span> increment = [] &#123; ++global_x; &#125;;</span><br></pre></td></tr></table></figure><p><strong>指定返回类型的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定返回类型</span></span><br><span class="line"><span class="keyword">auto</span> sum = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    <span class="keyword">return</span> z + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="捕获列表（Capture-List）"><a href="#捕获列表（Capture-List）" class="headerlink" title="捕获列表（Capture List）"></a><strong>捕获列表（Capture List）</strong></h2><p>Lambda 可以捕获其所在作用域的变量，有多种方式：</p><ul><li><strong>[]：</strong> 不捕获任何变量。尝试使用外部变量会导致错误。</li><li><strong>[x, &amp;y]：</strong> 捕获 <code>x</code> 的值，捕获 <code>y</code> 的引用。</li><li><strong>[&amp;]：</strong> 引用捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&#x3D;]：</strong> 值捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&amp;, x]：</strong> 引用捕获除 <code>x</code> 之外的所有变量，<code>x</code> 值捕获。</li><li><strong>[&#x3D;, &amp;z]：</strong> 值捕获除 <code>z</code> 之外的所有变量，<code>z</code> 引用捕获。</li></ul><p><strong>注意使用 <code>this</code> 指针：</strong></p><ul><li><p>对于 <code>[=]</code> 或 <code>[&amp;]</code>，<code>this</code> 指针会被自动捕获，可直接使用成员变量和函数。</p></li><li><p>对于 <code>[]</code>，如果需要使用 <code>this</code>，必须显式捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++判断</title>
      <link href="/2024/11/16/C-%E5%88%A4%E6%96%AD/"/>
      <url>/2024/11/16/C-%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习判断的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明不白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C++判断"></a>C++判断</h1><p>在编程中，判断结构就像是做选择题。程序员需要设定一些问题（条件），然后告诉计算机：</p><ol><li>如果问题的答案是肯定的（条件为真），那么计算机应该做什么（执行哪些语句）。</li><li>如果问题的答案是否定的（条件为假），那么计算机可以做什么（执行哪些语句，这部分是可选的）。</li></ol><p>简单来说，判断结构就是让计算机根据条件来决定下一步做什么的一种方法。这就像是我们日常生活中做决定的过程：如果天气好，我们就去公园；如果天气不好，我们就待在家里。在编程中，我们用代码来实现这样的逻辑。</p><p><strong>在 C++ 编程语言中，判断语句就是用来根据条件来决定代码如何执行的一种方式。以下是几种判断语句，用简单的方式解释它们的功能：</strong></p><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. <strong>if 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时，执行一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就会显示“a 比 b 大”。如果条件不成立，就什么也不做。</em></li></ul><hr><h2 id="2-if…else-语句"><a href="#2-if…else-语句" class="headerlink" title="2. if…else 语句"></a>2. <strong>if…else 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时执行一段代码，否则执行另一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 不比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就输出第一句话；否则，输出第二句话。</em></li></ul><hr><h2 id="3-嵌套-if-语句"><a href="#3-嵌套-if-语句" class="headerlink" title="3. 嵌套 if 语句"></a>3. <strong>嵌套 if 语句</strong></h2><ul><li><strong>功能：</strong> 如果需要多个条件，可以把一个 <code>if</code> 放到另一个 <code>if</code> 里面。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 最大&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，同时 <code>b</code> 比 <code>c</code> 大，就输出“a 最大”。</em></li></ul><hr><h2 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4. switch 语句"></a>4. <strong>switch 语句</strong></h2><ul><li><strong>功能：</strong> 检查一个变量的值，并根据值执行不同的代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>grade</code> 是 <code>&#39;A&#39;</code>，就显示“优秀”；如果是 <code>&#39;B&#39;</code>，就显示“良好”；其他情况显示“其他”。</em></li></ul><hr><h2 id="5-嵌套-switch-语句"><a href="#5-嵌套-switch-语句" class="headerlink" title="5. 嵌套 switch 语句"></a>5. <strong>嵌套 switch 语句</strong></h2><ul><li><strong>功能：</strong> 可以在一个 <code>switch</code> 语句里嵌套另一个 <code>switch</code>，用于复杂的判断。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">        <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;大狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他动物&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>animal</code> 是 <code>&#39;dog&#39;</code> 并且 <code>size</code> 是 <code>&#39;big&#39;</code>，就输出“大狗”。</em></li></ul><hr><h2 id="6-条件运算符"><a href="#6-条件运算符" class="headerlink" title="6. 条件运算符 (? :)"></a>6. <strong>条件运算符 (<code>? :</code>)</strong></h2><ul><li><strong>功能：</strong> 用于替代简单的 <code>if...else</code>，结构更紧凑。</li><li><strong>格式：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 真值 : 假值;</span><br></pre></td></tr></table></figure></li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 大于 <code>b</code>，就把 <code>a</code> 的值赋给 <code>max</code>；否则，把 <code>b</code> 的值赋给 <code>max</code>。</em></li></ul><hr><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><ul><li><code>if</code> 和 <code>if...else</code>：判断一件事情是否成立。</li><li>嵌套 <code>if</code> 和 <code>switch</code>：用于处理多个条件。</li><li><code>switch</code>：更适合检查一个变量的多种可能值。</li><li>条件运算符：用最短的方式写简单的判断，通常用在赋值或输出语句里。</li></ul><p><strong>这样解释是不是更清晰？ 😊</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环</title>
      <link href="/2024/11/16/C-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2024/11/16/C-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习循环的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p><strong>在编程中，我们经常会遇到需要重复做同一件事情的情况。通常，代码是按照顺序一行一行执行的：先执行第一行，然后是第二行，以此类推。但是，有时候我们想让某段代码重复执行多次，而不是只执行一次。这时候，就需要用到编程语言提供的控制结构，它们可以让代码的执行路径变得更加灵活和复杂。</strong><br><strong>简单来说，控制结构就像是代码的“交通规则”，它们告诉我们代码应该如何“行驶”。在C++中，有几种常用的控制结构可以帮助我们实现代码的重复执行，比如循环。循环就像是设置了“循环播放”模式，让某段代码可以按照我们指定的次数或者条件，一遍又一遍地执行。</strong><br><strong>通过使用循环，我们可以更高效地处理重复的任务，而不需要手动复制粘贴大量的代码。这样不仅可以节省时间，还可以减少错误，让代码更加简洁和易于维护。</strong></p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><hr><h3 id="循环类型-1"><a href="#循环类型-1" class="headerlink" title="循环类型"></a><strong>循环类型</strong></h3><p>在编程中，<strong>循环</strong>用于重复执行一段代码，直到满足某个条件为止。C++ 提供了几种常用的循环结构，让我们来一一了解它们。</p><h4 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a><strong>1. <code>while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>while</code> 循环会在<strong>每次执行循环体之前</strong>，先检查一个条件。如果条件为真（<code>true</code>），就执行循环体的代码；如果条件为假（<code>false</code>），就结束循环。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体（要重复执行的代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环会从 <code>i = 0</code> 开始，每次输出 <code>i</code> 的值，然后将 <code>i</code> 加 1，直到 <code>i</code> 不小于 5。</p></li></ul><h4 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a><strong>2. <code>for</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>for</code> 循环适合在你<strong>知道要循环多少次</strong>的情况下使用。它把循环变量的初始化、条件判断和更新都放在一行，便于管理。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环与上面的 <code>while</code> 循环功能相同，但写法更紧凑。</p></li></ul><h4 id="3-do-while-循环"><a href="#3-do-while-循环" class="headerlink" title="3. do...while 循环"></a><strong>3. <code>do...while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>do...while</code> 循环会<strong>先执行一次</strong>循环体，然后再检查条件是否满足。这意味着即使条件一开始为假，循环体也会执行一次。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：即使 <code>i</code> 一开始就不小于 5，循环体也会执行一次。</p></li></ul><h4 id="4-嵌套循环"><a href="#4-嵌套循环" class="headerlink" title="4. 嵌套循环"></a><strong>4. 嵌套循环</strong></h4><ul><li><p><strong>基本概念</strong>：你可以在一个循环内部再放入一个循环，称为<strong>嵌套循环</strong>。这在需要遍历多维数据时非常有用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：外层循环控制 <code>i</code>，内层循环控制 <code>j</code>，总共会输出 6 组组合。</p></li></ul><hr><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a><strong>循环控制语句</strong></h3><p>有时候，我们需要在循环过程中改变正常的执行流程，比如提前结束循环或跳过某次循环。C++ 提供了以下控制语句。</p><h4 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1. break 语句"></a><strong>1. <code>break</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>break</code> 用于<strong>立即退出</strong>所在的循环或 <code>switch</code> 语句，程序会继续执行循环或 <code>switch</code> 后面的代码。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环在 <code>i</code> 等于 5 时，会提前结束，不再继续循环。</p></li></ul><h4 id="2-continue-语句"><a href="#2-continue-语句" class="headerlink" title="2. continue 语句"></a><strong>2. <code>continue</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>continue</code> 用于<strong>跳过当前循环的剩余代码</strong>，立即开始下一次循环的判断。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过当前循环，i == 2 时不执行下面的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：当 <code>i</code> 等于 2 时，<code>continue</code> 会跳过 <code>cout</code>，因此不会输出 <code>i = 2</code>。</p></li></ul><h4 id="3-goto-语句"><a href="#3-goto-语句" class="headerlink" title="3. goto 语句"></a><strong>3. <code>goto</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>goto</code> 可以无条件地<strong>跳转</strong>到程序中标记的位置。但由于它可能导致代码难以阅读和维护，一般<strong>不推荐使用</strong>。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">start:</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">goto</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这段代码使用 <code>goto</code> 模拟了一个循环。</p></li></ul><hr><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a><strong>无限循环</strong></h3><ul><li><p><strong>基本概念</strong>：如果循环的条件永远为真，那么循环将永远执行下去，这就是<strong>无限循环</strong>。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This loop will run forever.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>for</code> 循环的三个部分（初始化、条件、更新）都可以省略，如果条件部分被省略，默认视为真，所以循环会无限执行。</p></li><li><p><strong>注意</strong>：在实际编程中，需要确保有机制能跳出无限循环，比如在循环体内使用 <code>break</code>，或者在某种条件下退出。否则，程序可能会卡住。</p></li><li><p><strong>终止无限循环的方法</strong>：在命令行环境下，可以按 <code>Ctrl + C</code> 终止程序的执行。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符</title>
      <link href="/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习运算符的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++运算符"></a>C++运算符</h1><p>在C++编程中，运算符就像是数学中的加减乘除符号，它们告诉计算机执行特定的操作。C++提供了很多这样的符号，我们可以将它们分为几大类：</p><ol><li><p><strong>算术运算符</strong>：就像我们在数学课上学的那样，用来做加法（+）、减法（-）、乘法（*）、除法（&#x2F;）等计算的符号。</p></li><li><p><strong>关系运算符</strong>：这些符号用来比较两个值，比如看一个值是否大于（&gt;）、小于（&lt;）、等于（&#x3D;&#x3D;）另一个值。</p></li><li><p><strong>逻辑运算符</strong>：这些符号用来处理真（true）或假（false）的情况，比如“并且”（&amp;&amp;）表示两个条件都必须为真，结果才为真；“或者”（||）表示只要有一个条件为真，结果就为真。</p></li><li><p><strong>位运算符</strong>：这些符号在二进制层面上操作数据，比如将两个数的二进制表示进行“与”（&amp;）、“或”（|）操作。</p></li><li><p><strong>赋值运算符</strong>：这个符号（&#x3D;）用来给变量赋值，比如将一个值赋给一个变量。</p></li><li><p><strong>杂项运算符</strong>：还有一些其他的符号，比如访问对象成员的点（.）运算符，或者取地址的与（&amp;）运算符。</p></li></ol><p>接下来的内容会详细解释这些运算符是如何工作的，帮助你更好地理解如何在C++中使用它们。简而言之，运算符就是编程语言中的“动词”，它们告诉计算机要执行什么样的操作。</p><p><strong>在学习 C++ 编程时，我们经常需要使用各种运算符来进行计算和逻辑判断。下面，我们来解释一下这些常见的运算符。</strong></p><hr><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h2><p>这些运算符用于基本的数学计算，就像我们日常生活中的加减乘除。</p><ul><li><p><strong><code>+</code> 加号</strong>：把两个数相加。</p><p>例子：<code>A + B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，那么结果是 <strong>30</strong>。</p></li><li><p><strong><code>-</code> 减号</strong>：从第一个数中减去第二个数。</p><p>例子：<code>A - B</code>，结果是 <strong>-10</strong>。</p></li><li><p><strong><code>*</code> 乘号</strong>：把两个数相乘。</p><p>例子：<code>A * B</code>，结果是 <strong>200</strong>。</p></li><li><p><strong><code>/</code> 除号</strong>：用第一个数除以第二个数。</p><p>例子：<code>B / A</code>，结果是 <strong>2</strong>。</p></li><li><p><strong><code>%</code> 取模</strong>：求两个整数相除的余数。</p><p>例子：<code>B % A</code>，结果是 <strong>0</strong>。</p></li><li><p><strong><code>++</code> 自增</strong>：把变量的值增加 1。</p><p>例子：<code>A++</code>，如果 <code>A</code> 原本是 10，执行后变为 <strong>11</strong>。</p></li><li><p><strong><code>--</code> 自减</strong>：把变量的值减少 1。</p><p>例子：<code>A--</code>，执行后 <code>A</code> 变为 <strong>9</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl; <span class="comment">// 输出 31</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a - b = &quot;</span> &lt;&lt; a - b &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; a * b &lt;&lt; endl; <span class="comment">// 输出 210</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a / b = &quot;</span> &lt;&lt; a / b &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a % b = &quot;</span> &lt;&lt; a % b &lt;&lt; endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++ = &quot;</span> &lt;&lt; c++ &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 11</span></span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c-- = &quot;</span> &lt;&lt; c-- &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><p>这些运算符用于比较两个值之间的大小关系，结果是 <strong>真（true）</strong> 或 <strong>假（false）</strong>。</p><ul><li><p><strong><code>==</code> 等于</strong>：判断两个值是否相等。</p><p>例子：<code>A == B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，结果为 <strong>false</strong>。</p></li><li><p><strong><code>!=</code> 不等于</strong>：判断两个值是否不相等。</p><p>例子：<code>A != B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;</code> 大于</strong>：判断左边的值是否大于右边的值。</p><p>例子：<code>A &gt; B</code>，结果为 <strong>false</strong>。</p></li><li><p><strong><code>&lt;</code> 小于</strong>：判断左边的值是否小于右边的值。</p><p>例子：<code>A &lt; B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;=</code> 大于等于</strong>：判断左边的值是否大于或等于右边的值。</p></li><li><p><strong><code>&lt;=</code> 小于等于</strong>：判断左边的值是否小于或等于右边的值。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt;= b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于或等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b &gt;= a)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b 大于或等于 a&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h2><p>这些运算符用于连接多个条件，形成更复杂的逻辑判断。</p><ul><li><p><strong><code>&amp;&amp;</code> 逻辑与</strong>：当 <strong>两个条件都为真</strong>，结果才为真。</p><p>例子：<code>(A &amp;&amp; B)</code>，只有当 <code>A</code> 和 <code>B</code> 都为真，结果才为 <strong>true</strong>。</p></li><li><p><strong><code>||</code> 逻辑或</strong>：当 <strong>至少一个条件为真</strong>，结果为真。</p><p>例子：<code>(A || B)</code>，只要 <code>A</code> 或 <code>B</code> 其中一个为真，结果就是 <strong>true</strong>。</p></li><li><p><strong><code>!</code> 逻辑非</strong>：对条件取反，<strong>真变假，假变真</strong>。</p><p>例子：<code>!(A &amp;&amp; B)</code>，如果 <code>(A &amp;&amp; B)</code> 为真，取反后结果为 <strong>false</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a || b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 或 b 至少一个为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(a &amp;&amp; b))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真（取反后为真）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h2><p>位运算符用于直接操作二进制位，常用于底层编程或性能优化。</p><ul><li><p><strong><code>&amp;</code> 按位与</strong>：对应位都为 1，结果才为 1。</p></li><li><p><strong><code>|</code> 按位或</strong>：对应位只要有一个为 1，结果就是 1。</p></li><li><p><strong><code>^</code> 按位异或</strong>：对应位不同，结果为 1，相同为 0。</p></li><li><p><strong><code>~</code> 按位取反</strong>：把每一位都取反，0 变 1，1 变 0。</p></li><li><p><strong><code>&lt;&lt;</code> 左移</strong>：把二进制位向左移动，右边补 0。</p></li><li><p><strong><code>&gt;&gt;</code> 右移</strong>：把二进制位向右移动，左边根据符号位补 0 或 1。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>; <span class="comment">// 二进制：0011 1100</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>; <span class="comment">// 二进制：0000 1101</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = a &amp; b; <span class="comment">// 12，二进制：0000 1100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &amp; b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a | b; <span class="comment">// 61，二进制：0011 1101</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a | b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a ^ b; <span class="comment">// 49，二进制：0011 0001</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a ^ b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = ~a; <span class="comment">// 对 a 取反</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~a = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 左移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &lt;&lt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &gt;&gt; <span class="number">2</span>; <span class="comment">// 右移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &gt;&gt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h2><p>这些运算符用于给变量赋值，并可以结合其他操作。</p><ul><li><p><strong><code>=</code> 赋值</strong>：把右边的值赋给左边的变量。</p><p>例子：<code>c = a + b</code>。</p></li><li><p><strong><code>+=</code> 加且赋值</strong>：<code>c += a</code> 等同于 <code>c = c + a</code>。</p></li><li><p><strong><code>-=</code> 减且赋值</strong>：<code>c -= a</code> 等同于 <code>c = c - a</code>。</p></li><li><p><strong><code>*=</code> 乘且赋值</strong>：<code>c *= a</code> 等同于 <code>c = c * a</code>。</p></li><li><p><strong><code>/=</code> 除且赋值</strong>：<code>c /= a</code> 等同于 <code>c = c / a</code>。</p></li><li><p><strong><code>%=</code> 取模且赋值</strong>：<code>c %= a</code> 等同于 <code>c = c % a</code>。</p></li><li><p><strong><code>&lt;&lt;=</code> 左移且赋值</strong>：<code>c &lt;&lt;= 2</code> 等同于 <code>c = c &lt;&lt; 2</code>。</p></li><li><p><strong><code>&gt;&gt;=</code> 右移且赋值</strong>：<code>c &gt;&gt;= 2</code> 等同于 <code>c = c &gt;&gt; 2</code>。</p></li><li><p><strong><code>&amp;=</code> 按位与且赋值</strong>：<code>c &amp;= 2</code> 等同于 <code>c = c &amp; 2</code>。</p></li><li><p><strong><code>^=</code> 按位异或且赋值</strong>：<code>c ^= 2</code> 等同于 <code>c = c ^ 2</code>。</p></li><li><p><strong><code>|=</code> 按位或且赋值</strong>：<code>c |= 2</code> 等同于 <code>c = c | 2</code>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c += a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c += a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    c -= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c -= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c *= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c *= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 441</span></span><br><span class="line"></span><br><span class="line">    c /= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c /= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c = <span class="number">200</span>;</span><br><span class="line">    c %= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c %= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &lt;&lt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 44</span></span><br><span class="line"></span><br><span class="line">    c &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &gt;&gt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &amp;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &amp;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    c ^= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c ^= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    c |= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c |= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a><strong>其他运算符</strong></h2><ul><li><p><strong><code>sizeof</code> 求大小</strong>：返回数据类型或变量所占的字节数。</p><p>例子：<code>sizeof(int)</code> 返回 <strong>4</strong>。</p></li><li><p><strong><code>?:</code> 条件运算符（三目运算符）</strong>：根据条件返回不同的值。</p><p>例子：<code>int max = (a &gt; b) ? a : b;</code>，如果 <code>a &gt; b</code> 为真，<code>max</code> 等于 <code>a</code>，否则等于 <code>b</code>。</p></li><li><p><strong><code>,</code> 逗号运算符</strong>：可以在一行中执行多个表达式，返回最后一个表达式的值。</p></li><li><p><strong><code>.</code> 和 <code>-&gt;</code> 成员访问运算符</strong>：用于访问对象或指针的成员。</p><p>例子：<code>object.member</code>，<code>pointer-&gt;member</code>。</p></li><li><p><strong><code>(type)</code> 类型转换</strong>：将一个值转换为指定的类型。</p><p>例子：<code>int x = (int)3.14;</code>，<code>x</code> 的值为 <strong>3</strong>。</p></li><li><p><strong><code>&amp;</code> 取地址运算符</strong>：获取变量的内存地址。</p><p>例子：<code>int *p = &amp;a;</code>，<code>p</code> 指向 <code>a</code> 的地址。</p></li><li><p><strong><code>*</code> 指针解引用运算符</strong>：访问指针所指向的变量的值。</p><p>例子：<code>int value = *p;</code>，<code>value</code> 等于 <code>p</code> 所指向的变量的值。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++存储类</title>
      <link href="/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
      <url>/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-存储类型"><a href="#C-存储类型" class="headerlink" title="C++存储类型"></a>C++存储类型</h1><hr><h2 id="什么是存储类？"><a href="#什么是存储类？" class="headerlink" title="什么是存储类？"></a>什么是存储类？</h2><p>存储类决定了变量或函数的<strong>作用范围</strong>（在哪里可以访问）和<strong>生命周期</strong>（何时创建、何时销毁）。在C++中，存储类的关键字会放在变量或函数类型的前面，用来改变它们的默认行为。</p><hr><h3 id="C-中常见的存储类说明符"><a href="#C-中常见的存储类说明符" class="headerlink" title="C++中常见的存储类说明符"></a>C++中常见的存储类说明符</h3><p>以下是C++存储类关键字的通俗解释：</p><h4 id="1-auto（自动存储期，默认行为）"><a href="#1-auto（自动存储期，默认行为）" class="headerlink" title="1. auto（自动存储期，默认行为）"></a>1. <strong>auto</strong>（自动存储期，默认行为）</h4><ul><li><strong>定义</strong>：这是C++的默认存储类说明符，通常可以省略不写。它表示变量的生命周期仅限于它所在的块（如函数内部）。</li><li><strong>特点</strong>：<ul><li>变量会在块结束时自动销毁。</li><li>在C++11后，<code>auto</code>更多用于自动推导变量类型，而不是存储类。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量，块结束后自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-register（寄存器变量）"><a href="#2-register（寄存器变量）" class="headerlink" title="2. register（寄存器变量）"></a>2. <strong>register</strong>（寄存器变量）</h4><ul><li><strong>定义</strong>：建议编译器将变量存储在CPU寄存器中以提高访问速度。</li><li><strong>特点</strong>：<ul><li>在现代C++中（C++11及以后），<code>register</code>已经被废弃，编译器会自动优化变量的存储。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是建议存储在寄存器中的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="3-static（静态存储期）"><a href="#3-static（静态存储期）" class="headerlink" title="3. static（静态存储期）"></a>3. <strong>static</strong>（静态存储期）</h4><ul><li><strong>定义</strong>：表示变量的生命周期贯穿整个程序的运行期。</li><li><strong>特点</strong>：<ul><li><strong>函数内部的static变量</strong>：只初始化一次，函数多次调用时会保留上次的值。</li><li><strong>全局变量或函数的static</strong>：限制变量或函数只能在当前文件中使用。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count;  <span class="comment">// 多次调用会保留上次的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-extern（外部链接）"><a href="#4-extern（外部链接）" class="headerlink" title="4. extern（外部链接）"></a>4. <strong>extern</strong>（外部链接）</h4><ul><li><strong>定义</strong>：声明全局变量或函数，可以跨多个文件使用。</li><li><strong>特点</strong>：<ul><li><code>extern</code>告诉编译器变量或函数是在别的文件中定义的。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar; <span class="comment">// 引用 file1.cpp 中的变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="5-mutable（可变成员变量）"><a href="#5-mutable（可变成员变量）" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong>mutable</strong>（可变成员变量）</h4><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，也允许修改这个变量。</li><li><strong>特点</strong>：<ul><li>通常用于需要在<code>const</code>成员函数中更新的变量，比如缓存或计数器。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// counter 可以在 const 函数中修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="6-thread-local（线程局部存储期，C-11-引入）"><a href="#6-thread-local（线程局部存储期，C-11-引入）" class="headerlink" title="6. thread_local（线程局部存储期，C++11 引入）"></a>6. <strong>thread_local</strong>（线程局部存储期，C++11 引入）</h4><ul><li><strong>定义</strong>：表示每个线程都有变量的独立副本，变量的生命周期与线程一致。</li><li><strong>特点</strong>：<ul><li>适合多线程编程中需要每个线程独立数据的场景。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>; <span class="comment">// 每个线程都有自己的 threadVar</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h3><p>以下代码展示了不同存储类的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar; <span class="comment">// 全局变量，默认是 extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> localVar = <span class="number">10</span>;  <span class="comment">// 局部变量，块结束后销毁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">20</span>; <span class="comment">// 静态变量，函数多次调用保留值</span></span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">30</span>; <span class="comment">// 每个线程有独立的变量副本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">mutable</span> <span class="type">int</span> mutableVar; <span class="comment">// 可变变量，即使对象是 const 也可以修改</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            mutableVar = <span class="number">50</span>; <span class="comment">// 合法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><table><thead><tr><th><strong>关键字</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>默认存储类，生命周期随块结束，现代C++更多用于类型推导。</td></tr><tr><td><code>register</code></td><td>提示编译器优化变量存储（C++11后废弃）。</td></tr><tr><td><code>static</code></td><td>生命周期贯穿整个程序，但作用范围受限。</td></tr><tr><td><code>extern</code></td><td>允许跨文件共享全局变量或函数。</td></tr><tr><td><code>mutable</code></td><td>允许修改<code>const</code>对象的成员变量。</td></tr><tr><td><code>thread_local</code></td><td>每个线程有独立变量副本，生命周期与线程一致（C++11后引入）。</td></tr></tbody></table><hr><h2 id="常见存储类及其用途"><a href="#常见存储类及其用途" class="headerlink" title="常见存储类及其用途"></a>常见存储类及其用途</h2><h3 id="1-auto（自动推导类型）"><a href="#1-auto（自动推导类型）" class="headerlink" title="1. auto（自动推导类型）"></a>1. <strong><code>auto</code>（自动推导类型）</strong></h3><ul><li><strong>定义</strong>：自动根据初始化的值推断变量的类型。</li><li><strong>特点</strong>：<ul><li>省去了手动写类型的麻烦。</li><li>适合用在复杂类型的变量上，比如迭代器。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;     <span class="comment">// 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">3.14</span>;   <span class="comment">// 推断为 double</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 推断为 const char*</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-register（寄存器变量，C-11后已废弃）"><a href="#2-register（寄存器变量，C-11后已废弃）" class="headerlink" title="2. register（寄存器变量，C++11后已废弃）"></a>2. <strong><code>register</code>（寄存器变量，C++11后已废弃）</strong></h3><ul><li><strong>定义</strong>：建议将变量存储在CPU寄存器中，以便快速访问。</li><li><strong>特点</strong>：<ul><li>提高访问速度，适合频繁使用的变量。</li><li>在现代编译器中，<code>register</code>的效果已被优化算法替代。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提示编译器将 i 存储在寄存器中</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-static（静态变量）"><a href="#3-static（静态变量）" class="headerlink" title="3. static（静态变量）"></a>3. <strong><code>static</code>（静态变量）</strong></h3><ul><li><strong>定义</strong>：变量的生命周期贯穿程序始终，无论它在局部还是全局作用域。</li><li><strong>特点</strong>：<ul><li><strong>局部静态变量</strong>：函数内部的<code>static</code>变量只初始化一次，值会在函数调用之间保留。</li><li><strong>全局静态变量</strong>：只能在当前文件中使用，其他文件无法访问。</li><li><strong>类静态变量</strong>：类中所有对象共享一个静态变量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="4-extern（外部变量）"><a href="#4-extern（外部变量）" class="headerlink" title="4. extern（外部变量）"></a>4. <strong><code>extern</code>（外部变量）</strong></h3><ul><li><strong>定义</strong>：声明一个全局变量或函数，使其在多个文件之间共享。</li><li><strong>特点</strong>：<ul><li>通常用于跨文件访问变量或函数。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sharedVar = <span class="number">42</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sharedVar; <span class="comment">// 引用 file1 中的变量</span></span><br><span class="line">std::cout &lt;&lt; sharedVar;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="5-mutable（可变成员变量）-1"><a href="#5-mutable（可变成员变量）-1" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong><code>mutable</code>（可变成员变量）</strong></h3><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>特点</strong>：<ul><li>通常用于缓存、计数器等需要在<code>const</code>上下文中改变状态的场景。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-thread-local（线程本地存储，C-11引入）"><a href="#6-thread-local（线程本地存储，C-11引入）" class="headerlink" title="6. thread_local（线程本地存储，C++11引入）"></a>6. <strong><code>thread_local</code>（线程本地存储，C++11引入）</strong></h3><ul><li><strong>定义</strong>：每个线程都有一个独立的变量副本，线程之间互不干扰。</li><li><strong>特点</strong>：<ul><li>适用于多线程编程。</li><li>每个线程的<code>thread_local</code>变量在线程结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    threadVar = id; <span class="comment">// 每个线程有独立的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h3><table><thead><tr><th><strong>存储类</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>自动推断变量类型，简化复杂类型的声明。</td></tr><tr><td><code>register</code></td><td>提示频繁使用的变量（现代C++中已废弃）。</td></tr><tr><td><code>static</code></td><td>保留局部变量值、限制全局变量访问范围、类成员共享变量。</td></tr><tr><td><code>extern</code></td><td>跨文件共享全局变量和函数。</td></tr><tr><td><code>mutable</code></td><td>在<code>const</code>对象中允许修改成员变量（如缓存或计数器）。</td></tr><tr><td><code>thread_local</code></td><td>线程安全，每个线程都有独立的变量副本。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++修饰符类型</title>
      <link href="/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.toumatou.cn/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-修饰符类型"><a href="#C-修饰符类型" class="headerlink" title="C++修饰符类型"></a>C++修饰符类型</h1><hr><h2 id="什么是修饰符类型？"><a href="#什么是修饰符类型？" class="headerlink" title="什么是修饰符类型？"></a>什么是修饰符类型？</h2><p>修饰符是用来调整变量的存储范围和行为的关键字。例如：</p><ul><li>变量是否能存储负数？</li><li>变量的存储范围是更大还是更小？</li></ul><p>C++ 提供了多个修饰符来满足不同的需求</p><hr><h3 id="常见修饰符"><a href="#常见修饰符" class="headerlink" title="常见修饰符"></a>常见修饰符</h3><ol><li><p><strong>signed（有符号）</strong></p><ul><li>变量可以存储正数和负数。</li><li><strong>默认情况下</strong>，整型变量（<code>int</code>）都是有符号的，所以<code>int</code>和<code>signed int</code>是一样的。</li></ul></li><li><p><strong>unsigned（无符号）</strong></p><ul><li>变量只能存储正数。</li><li>因为没有负数，存储范围扩大了一倍（范围从0开始）。</li></ul></li><li><p><strong>short（短整型）</strong></p><ul><li>比<code>int</code>的存储范围更小，通常用来节省存储空间。</li></ul></li><li><p><strong>long（长整型）</strong></p><ul><li>比<code>int</code>的存储范围更大，适合表示更大的数字。</li><li><strong>C++11</strong> 增加了<code>long long</code>，存储范围比<code>long</code>还要大。</li></ul></li><li><p><strong>float（单精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度较低。</li></ul></li><li><p><strong>double（双精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度比<code>float</code>更高。</li></ul></li><li><p><strong>bool（布尔类型）</strong></p><ul><li>只有两个值：<code>true</code>和<code>false</code>，常用于条件判断。</li></ul></li><li><p><strong>char（字符类型）</strong></p><ul><li>用来存储单个字符，比如<code>&#39;a&#39;</code>。</li></ul></li><li><p><strong>wchar_t（宽字符类型）</strong></p><ul><li>用来存储Unicode字符，可以表示多国语言的字符。</li></ul></li></ol><hr><h3 id="修饰符的组合"><a href="#修饰符的组合" class="headerlink" title="修饰符的组合"></a>修饰符的组合</h3><ul><li><p>修饰符可以组合使用，例如：</p><ul><li><code>unsigned long int</code>：无符号长整型。</li><li><code>short unsigned int</code>：无符号短整型。</li></ul></li><li><p><strong>简写方式</strong>：</p><ul><li>省略<code>int</code>是允许的，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> num1 = <span class="number">10</span>; <span class="comment">// 无符号整型变量</span></span><br><span class="line"><span class="type">short</span> num2 = <span class="number">5</span>;     <span class="comment">// 短整型变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="示例-1：普通变量的定义"><a href="#示例-1：普通变量的定义" class="headerlink" title="示例 1：普通变量的定义"></a>示例 1：普通变量的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>;    <span class="comment">// 有符号整型，值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>;   <span class="comment">// 无符号整型，值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> num3 = <span class="number">10</span>;          <span class="comment">// 短整型，值为 10</span></span><br><span class="line"><span class="type">long</span> num4 = <span class="number">100000</span>;       <span class="comment">// 长整型，值为 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num5 = <span class="number">10000000000</span>; <span class="comment">// 长长整型，值为 10000000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.14f</span>;         <span class="comment">// 单精度浮点数，值为 3.14</span></span><br><span class="line"><span class="type">double</span> e = <span class="number">2.71828</span>;       <span class="comment">// 双精度浮点数，值为 2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;         <span class="comment">// 布尔值，表示真</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;            <span class="comment">// 字符，值为 &#x27;A&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> wideChar = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 宽字符，值为 &#x27;你&#x27;</span></span><br></pre></td></tr></table></figure><hr><h4 id="示例-2：有符号和无符号的区别"><a href="#示例-2：有符号和无符号的区别" class="headerlink" title="示例 2：有符号和无符号的区别"></a>示例 2：有符号和无符号的区别</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> i;          <span class="comment">// 有符号短整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// 无符号短整型</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">50000</span>; <span class="comment">// 无符号变量 j 存储 50000</span></span><br><span class="line">    i = j;     <span class="comment">// i 将 j 的位模式解释为有符号数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j; <span class="comment">// 输出 -15536 和 50000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>j</code>存储的值是<code>50000</code>，它的二进制表示不会改变。</li><li>当将<code>j</code>的值赋给<code>i</code>时，二进制位模式被解释为有符号数，因此显示为<code>-15536</code>。</li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>有符号（signed）</strong>：可以存储正数和负数。</li><li><strong>无符号（unsigned）</strong>：只能存储正数，存储范围更大。</li><li><strong>short 和 long</strong>：分别表示更小或更大的整型范围。</li><li><strong>float 和 double</strong>：用于存储小数，<code>double</code>的精度更高。</li><li><strong>bool 和 char</strong>：布尔值表示真&#x2F;假，字符表示单个字符。</li><li><strong>wchar_t</strong>：表示Unicode字符。<br>通过修饰符，C++ 能够更灵活地定义变量类型，适应不同的存储需求。</li></ul><h2 id="C-中的类型限定符"><a href="#C-中的类型限定符" class="headerlink" title="C++中的类型限定符"></a>C++中的类型限定符</h2><hr><h3 id="什么是类型限定符？"><a href="#什么是类型限定符？" class="headerlink" title="什么是类型限定符？"></a>什么是类型限定符？</h3><p>类型限定符是C++中的关键字，用来给变量或函数添加额外的“行为限制”或“说明”。它们可以改变变量的默认行为，使其更适应特定需求。</p><hr><h3 id="常见的类型限定符"><a href="#常见的类型限定符" class="headerlink" title="常见的类型限定符"></a>常见的类型限定符</h3><table><thead><tr><th><strong>限定符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><code>const</code></td><td>表示变量是<strong>常量</strong>，定义后它的值不能被修改。</td></tr><tr><td><code>volatile</code></td><td>告诉编译器，这个变量的值可能会被外部（如硬件或其他线程）改变，因此不能对它的访问进行优化。</td></tr><tr><td><code>restrict</code></td><td><strong>仅在C99标准中</strong>：表示一个指针是访问它所指向对象的唯一方式，用于优化指针操作。</td></tr><tr><td><code>mutable</code></td><td>用于修饰类的成员变量，即使类对象是<code>const</code>的，也允许修改这个变量。</td></tr><tr><td><code>static</code></td><td>表示变量是静态的，它的生命周期贯穿整个程序，并且作用范围有限。</td></tr><tr><td><code>register</code></td><td>提示编译器将变量存储在CPU寄存器中，以提高访问速度（实际效果由编译器决定）。</td></tr></tbody></table><hr><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><h4 id="1-const（常量）"><a href="#1-const（常量）" class="headerlink" title="1. const（常量）"></a>1. <strong><code>const</code>（常量）</strong></h4><ul><li>定义后变量的值不能被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// NUM 是一个常量，不能被改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;NUM; <span class="comment">// ptr 是指向常量的指针，指针所指向的值不能修改</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li><code>NUM</code>是一个固定的值，就像刻在石头上的数字，无法更改。</li><li><code>ptr</code>是指向这块石头的指针，你可以看它，但不能刻字。</li></ul></li></ul><hr><h4 id="2-volatile（易变变量）"><a href="#2-volatile（易变变量）" class="headerlink" title="2. volatile（易变变量）"></a>2. <strong><code>volatile</code>（易变变量）</strong></h4><ul><li>告诉编译器，这个变量的值可能会在程序以外被修改（如硬件或多线程）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// num 的值可能会被硬件改变</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>这个变量是一个随时可能“被动”变化的数字，比如硬件设备传回来的数据。</li></ul></li></ul><hr><h4 id="3-mutable（可变成员变量）"><a href="#3-mutable（可变成员变量）" class="headerlink" title="3. mutable（可变成员变量）"></a>3. <strong><code>mutable</code>（可变成员变量）</strong></h4><ul><li>修饰类成员变量时，即使对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// 允许修改 value_，即使这个函数是 const 的</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_; <span class="comment">// value_ 是可变的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>一个“特别许可”的变量，即使在“禁止修改”的情况下，也可以被改变。</li></ul></li></ul><hr><h4 id="4-static（静态变量）"><a href="#4-static（静态变量）" class="headerlink" title="4. static（静态变量）"></a>4. <strong><code>static</code>（静态变量）</strong></h4><ul><li>静态变量的生命周期贯穿整个程序，作用范围却受限。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 的值在整个程序中保留</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>静态变量就像一个“长期储存”的数据，即使函数结束，它的值也会保留。</li></ul></li></ul><hr><h4 id="5-register（寄存器变量）"><a href="#5-register（寄存器变量）" class="headerlink" title="5. register（寄存器变量）"></a>5. <strong><code>register</code>（寄存器变量）</strong></h4><ul><li>建议编译器将变量存储在CPU的寄存器中，以提高访问速度（是否采纳由编译器决定）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提示编译器将 num 存储在寄存器中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>把一个变量放在“最快的储物柜”里，方便程序快速访问。</li></ul></li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li>**<code>const</code>**：值不能改动，就像固定的规则。</li><li>**<code>volatile</code>**：值可能会被外部修改，比如实时更新的数据。</li><li>**<code>mutable</code>**：给特别变量的“修改许可”。</li><li>**<code>static</code>**：数据长期有效，即使函数多次调用也保留值。</li><li>**<code>register</code>**：请求把变量放到“快速通道”，提高访问速度。<br>可以看出，这些限定符让C++中的变量更灵活、更高效地适应不同的需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常量</title>
      <link href="/2024/11/16/C-%E5%B8%B8%E9%87%8F/"/>
      <url>/2024/11/16/C-%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C++常量"></a>C++常量</h1><p>在C++编程语言中，常量指的是那些一旦被设定就不能再改变的值，它们就像是被冻结的数据，始终保持不变。这些值就像是直接写在代码里的字面量，比如数字、字母或者特定的文本。</p><p>常量可以是各种基本数据类型，包括：</p><ol><li><strong>整型数字</strong>：比如整数123。</li><li><strong>浮点数字</strong>：比如带有小数点的数字3.14。</li><li><strong>字符</strong>：单个字母或符号，比如’A’或’#’。</li><li><strong>字符串</strong>：一系列字符组成的文本，比如”Hello, World!”。</li><li><strong>布尔值</strong>：只有两个可能的值，true（真）或false（假）。</li></ol><p><strong>注意：常量和变量类似，但关键的区别在于常量一旦被赋予一个值，这个值就不能被改变。这意味着，如果你在程序中声明了一个常量，你就必须在声明时给它一个值，并且在程序的其余部分，这个值是不可更改的。这样的设计可以帮助避免在程序运行过程中意外改变重要的数据，确保程序的稳定性和可靠性。</strong></p><hr><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><ul><li><p><strong>定义</strong>：整数常量是没有小数部分的数字，可以是十进制、八进制或十六进制。</p></li><li><p><strong>进制表示</strong>：</p><ul><li><strong>十进制</strong>：直接写数字，比如 <code>85</code>。</li><li><strong>八进制</strong>：以 <code>0</code> 开头，比如 <code>0213</code>。</li><li><strong>十六进制</strong>：以 <code>0x</code> 或 <code>0X</code> 开头，比如 <code>0x4B</code>。</li></ul></li><li><p><strong>后缀</strong>：整数常量可以带后缀，表示类型：</p><ul><li><code>U</code>：无符号整数（Unsigned）。</li><li><code>L</code>：长整数（Long）。</li><li>顺序不重要，比如 <code>30U</code> 和 <code>30u</code> 都可以。</li></ul></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的十进制整数</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">// 合法的无符号整数</span></span><br><span class="line"><span class="number">0xFeeL</span>      <span class="comment">// 合法的十六进制长整数</span></span><br><span class="line"><span class="number">07</span>8         <span class="comment">// 非法：8 不是八进制数字</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">// 非法：不能重复后缀</span></span><br></pre></td></tr></table></figure><hr><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><ul><li><strong>定义</strong>：浮点常量是带小数点的数，或者用科学计数法表示的数。</li><li><strong>表示方式</strong>：<ul><li><strong>小数形式</strong>：同时包含整数部分和小数部分，比如 <code>3.14</code>。</li><li><strong>指数形式</strong>：用 <code>e</code> 或 <code>E</code> 表示，比如 <code>314E-2</code>（等于 3.14）。</li></ul></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>小数形式必须包含整数或小数部分，比如 <code>3.</code> 或 <code>.141</code>。</li><li>指数形式必须包含 <code>e</code> 或 <code>E</code>，后面跟一个指数值。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的小数形式</span></span><br><span class="line"><span class="number">314159E-5L</span>    <span class="comment">// 合法的指数形式</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法：缺少指数</span></span><br><span class="line">.e55          <span class="comment">// 非法：缺少整数部分</span></span><br></pre></td></tr></table></figure><hr><h2 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h2><ul><li><strong>定义</strong>：布尔常量只有两个值，用于表示“真”和“假”：<ul><li><code>true</code>：表示“真”。</li><li><code>false</code>：表示“假”。</li></ul></li><li><strong>注意</strong>：虽然 <code>true</code> 和 <code>false</code> 在底层分别表示 <code>1</code> 和 <code>0</code>，但我们不应该直接把它们当成数字使用。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> isComplete = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><ul><li><strong>定义</strong>：字符常量是用单引号包裹的单个字符，比如 <code>&#39;a&#39;</code>。</li><li><strong>宽字符</strong>：<ul><li>如果以 <code>L</code> 开头（如 <code>L&#39;x&#39;</code>），则表示宽字符，存储在 <code>wchar_t</code> 类型变量中。</li></ul></li><li><strong>窄字符</strong>：<ul><li>普通字符（如 <code>&#39;x&#39;</code>）存储在 <code>char</code> 类型变量中。</li></ul></li></ul><h4 id="特殊字符（转义序列）："><a href="#特殊字符（转义序列）：" class="headerlink" title="特殊字符（转义序列）："></a>特殊字符（转义序列）：</h4><ul><li><strong>转义字符</strong>：用反斜杠 <code>\</code> 开头，表示特殊含义的字符。</li><li><strong>常见转义字符</strong>：<table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td><code>\\</code></td><td>反斜杠 <code>\</code></td></tr><tr><td><code>\&#39;</code></td><td>单引号 <code>&#39;</code></td></tr><tr><td><code>\&quot;</code></td><td>双引号 <code>&quot;</code></td></tr><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\r</code></td><td>回车符</td></tr></tbody></table></li></ul><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello\tWorld\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><ul><li><strong>定义</strong>：字符串常量是用双引号<code>&quot;&quot;</code>包裹的一段文本内容。</li><li><strong>组成</strong>：它可以包含普通字符、特殊字符（通过转义序列如<code>\n</code>表示换行）以及通用字符（如Unicode字符）。</li></ul><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>如何表示字符串</strong>：  </p><ul><li>只需要用双引号包裹内容，例如：<code>&quot;Hello, World!&quot;</code>。</li><li>字符串中可以包含字母、数字、符号，以及通过转义序列表示的特殊字符。</li></ul></li><li><p><strong>分行显示字符串</strong>：  </p><ul><li>如果字符串太长，可以使用反斜杠<code>\</code>将其分成多行书写，但显示时仍会显示为一行。</li></ul></li></ol><hr><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码展示了如何使用字符串常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个普通的字符串常量</span></span><br><span class="line">    string greeting = <span class="string">&quot;hello, runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting &lt;&lt; endl;  <span class="comment">// 输出字符串并换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个分行的字符串常量</span></span><br><span class="line">    string greeting2 = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">                       runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting2 &lt;&lt; endl;  <span class="comment">// 显示为一行输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob</span><br><span class="line">hello, runoob</span><br></pre></td></tr></table></figure><hr><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><code>greeting</code>是一个普通的字符串，直接赋值并输出。</li><li><code>greeting2</code>使用了反斜杠<code>\</code>来分行写字符串，但显示时仍为一行，因为<code>\</code>只是告诉编译器“这是一行字符串，书写上分为了多行”。</li></ol><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>整数常量</strong>：表示整数，可以加后缀指定类型，支持十进制、八进制和十六进制。</li><li><strong>浮点常量</strong>：表示带小数的数，支持小数形式和指数形式。</li><li><strong>布尔常量</strong>：表示逻辑上的真或假，分别为 <code>true</code> 和 <code>false</code>。</li><li><strong>字符常量</strong>：用单引号表示单个字符，支持转义字符表示特殊符号。</li><li><strong>字符串常量</strong>是用双引号括起来的文本。</li><li>如果字符串太长，可以用反斜杠<code>\</code>进行分行，输出时仍显示为一行。</li><li>字符串可以包含特殊字符，比如<code>\n</code>表示换行符，<code>\t</code>表示制表符。</li></ul><p>以下是对“定义常量”更通俗易懂的解释：</p><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li>如前面所说，<strong>常量</strong>是值在程序运行过程中<strong>不会改变</strong>的变量。</li><li>在C++中，我们可以通过两种简单的方法定义常量：<ol><li>使用<code>#define</code>预处理器。</li><li>使用<code>const</code>关键字。</li></ol></li></ul><hr><h3 id="方法一：使用-define预处理器"><a href="#方法一：使用-define预处理器" class="headerlink" title="方法一：使用#define预处理器"></a>方法一：使用<code>#define</code>预处理器</h3><ul><li><code>#define</code> 是一种直接替换文本的工具，在编译前会将程序中所有出现的标识符替换为指定的值。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10  <span class="comment">// 定义常量 LENGTH 为 10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  5   <span class="comment">// 定义常量 WIDTH 为 5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// 定义换行符常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li>程序运行前，所有的<code>LENGTH</code>都会被替换为<code>10</code>，<code>WIDTH</code>会被替换为<code>5</code>，<code>NEWLINE</code>会被替换为换行符。</li><li><code>#define</code>没有类型约束，是一种简单直接的方法。</li></ul><hr><h3 id="方法二：使用const关键字"><a href="#方法二：使用const关键字" class="headerlink" title="方法二：使用const关键字"></a>方法二：使用<code>const</code>关键字</h3><ul><li><code>const</code> 是一种更严格的方式，用于定义带类型的常量。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">10</span>;  <span class="comment">// 定义一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">5</span>;    <span class="comment">// 定义另一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 定义换行符常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><ul><li>使用<code>const</code>定义的常量有类型约束，更加安全。</li><li><code>const</code>可以直接参与类型检查，这对大型程序更有帮助。</li></ul><hr><h3 id="哪种方式更好？"><a href="#哪种方式更好？" class="headerlink" title="哪种方式更好？"></a>哪种方式更好？</h3><ul><li><p>**<code>#define</code>**：</p><ul><li>优点：简单直接，没有类型约束。</li><li>缺点：在大型项目中，缺乏类型检查，可能会引发难以追踪的错误。</li></ul></li><li><p>**<code>const</code>**：</p><ul><li>优点：具有类型约束，更加安全；现代C++中更推荐使用。</li><li>缺点：相较于<code>#define</code>，书写稍显繁琐。</li></ul></li></ul><hr><h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><ul><li>通常，我们会将常量的名字用<strong>大写字母</strong>表示，这样可以让代码更容易阅读和维护。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SPEED = <span class="number">120</span>;  <span class="comment">// 推荐的命名方式</span></span><br></pre></td></tr></table></figure>通过以上两种方式，你可以选择适合自己需求的方式来定义常量。对于现代C++程序，推荐优先使用<code>const</code>关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量作用域</title>
      <link href="/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量作用域的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型的相关知识，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.toumatou.cn/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>这里温故一下</strong></p><h1 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++变量作用域"></a>C++变量作用域</h1><h3 id="1-变量的定义位置"><a href="#1-变量的定义位置" class="headerlink" title="1. 变量的定义位置"></a>1. 变量的定义位置</h3><p>在C++中，根据变量定义的位置，变量可以分为以下几类：</p><ul><li><strong>局部变量</strong>：在函数或代码块中声明的变量，只能在该函数或块中使用。</li><li><strong>形式参数</strong>：函数的参数，它是函数调用时用来接收外部传入数据的变量。</li><li><strong>全局变量</strong>：在所有函数之外声明的变量，可以在整个程序中使用。</li></ul><hr><h3 id="2-什么是作用域？"><a href="#2-什么是作用域？" class="headerlink" title="2. 什么是作用域？"></a>2. 什么是作用域？</h3><p>作用域是一个变量可以被访问的“范围”或“区域”。根据变量的定义位置，它的作用域可以分为以下几种：</p><h4 id="（1）局部作用域"><a href="#（1）局部作用域" class="headerlink" title="（1）局部作用域"></a>（1）局部作用域</h4><ul><li><strong>定义位置</strong>：在函数内部声明。</li><li><strong>特点</strong>：<ul><li>只能在函数内部访问，函数外部无法使用。</li><li>每次调用函数时，局部变量都会被创建；函数结束后，局部变量会被销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）全局作用域"><a href="#（2）全局作用域" class="headerlink" title="（2）全局作用域"></a>（2）全局作用域</h4><ul><li><strong>定义位置</strong>：在所有函数之外。</li><li><strong>特点</strong>：<ul><li>全局变量可以被程序中的任何函数访问。</li><li>全局变量在程序启动时创建，程序结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// x 是全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 可以访问全局变量 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）块作用域"><a href="#（3）块作用域" class="headerlink" title="（3）块作用域"></a>（3）块作用域</h4><ul><li><strong>定义位置</strong>：在代码块 <code>&#123;&#125;</code> 内部。</li><li><strong>特点</strong>：<ul><li>只能在块内部访问，块外部无法使用。</li><li>每次执行代码块时，块作用域的变量都会被创建，执行完后销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>; <span class="comment">// x 是块作用域变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）类作用域"><a href="#（4）类作用域" class="headerlink" title="（4）类作用域"></a>（4）类作用域</h4><ul><li><strong>定义位置</strong>：在类的内部。</li><li><strong>特点</strong>：<ul><li>类作用域的变量可以被类的所有成员函数访问。</li><li>它的生命周期与类的对象相同。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// x 是类作用域的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        x = value; <span class="comment">// 可以访问类的变量 x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-特殊情况：变量重名"><a href="#3-特殊情况：变量重名" class="headerlink" title="3. 特殊情况：变量重名"></a>3. 特殊情况：变量重名</h3><p>如果在内部作用域中声明的变量与外部作用域中的变量同名，内部作用域的变量会覆盖外部作用域的变量。</p><ul><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">50</span>; <span class="comment">// 全局变量 x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 局部变量 x，覆盖了全局变量 x</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>局部变量</strong>：在函数或代码块中声明，只能在内部使用。</li><li><strong>全局变量</strong>：在所有函数之外声明，可以在程序的任何地方使用。</li><li><strong>块作用域变量</strong>：在 <code>&#123;&#125;</code> 中声明，只能在块内部使用。</li><li><strong>类作用域变量</strong>：在类内部声明，可以被类的所有成员函数使用。</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><hr><h3 id="什么是局部变量？"><a href="#什么是局部变量？" class="headerlink" title="什么是局部变量？"></a>什么是局部变量？</h3><ul><li>局部变量是<strong>在函数或代码块内部声明的变量</strong>，它们的作用范围仅限于声明它们的那个函数或代码块。</li><li>当函数执行结束时，局部变量就会被销毁。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a, b, c; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>a</code>, <code>b</code>, <code>c</code> 是局部变量，它们只能在<code>main()</code>函数中使用。</li><li>当程序运行到<code>return 0;</code>时，<code>a</code>, <code>b</code>, <code>c</code>会被销毁，无法在<code>main()</code>之外访问。</li></ul><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="什么是全局变量？"><a href="#什么是全局变量？" class="headerlink" title="什么是全局变量？"></a>什么是全局变量？</h3><ul><li>全局变量是在<strong>所有函数之外</strong>定义的变量。</li><li>它们的作用范围是整个程序，可以在任何函数中使用。</li><li>全局变量在程序开始时创建，在程序结束时销毁。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    g = a + b;  <span class="comment">// 赋值给全局变量 g</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>g</code>是全局变量，<code>a</code>和<code>b</code>是局部变量。</li><li><code>g</code>可以被程序中的任何函数访问，比如<code>main()</code>。</li></ul><hr><h3 id="局部变量和全局变量同名时的情况"><a href="#局部变量和全局变量同名时的情况" class="headerlink" title="## 局部变量和全局变量同名时的情况"></a>## 局部变量和全局变量同名时的情况</h3><ul><li>如果局部变量和全局变量同名，在函数内部使用的是局部变量，<strong>局部变量会覆盖全局变量的值</strong>。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>全局变量<code>g</code>的值是<code>20</code>，但在<code>main()</code>函数中，局部变量<code>g</code>的值是<code>10</code>。</li><li>当程序运行到<code>cout &lt;&lt; g;</code>时，优先使用局部变量<code>g</code>，所以输出是<code>10</code>。</li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li><p><strong>局部变量</strong>：</p><ul><li>定义在函数或代码块内部。</li><li>只能在声明它的地方使用，离开作用域就无法访问。</li><li>在函数结束时销毁。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li>定义在所有函数外部。</li><li>作用范围是整个程序，任何函数都可以访问。</li><li>在程序运行期间一直存在。</li></ul></li></ul><h2 id="局部变量和全局变量的初始化"><a href="#局部变量和全局变量的初始化" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h2><hr><h3 id="局部变量和全局变量的初始化-1"><a href="#局部变量和全局变量的初始化-1" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h3><h4 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h4><ul><li>局部变量是定义在函数或代码块内部的变量。</li><li><strong>特点</strong>：<ul><li>局部变量<strong>不会自动初始化</strong>，如果没有赋值，变量的值是随机的，可能会导致意外的结果。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 局部变量未初始化</span></span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li>全局变量是定义在所有函数之外的变量。</li><li><strong>特点</strong>：<ul><li>全局变量<strong>会自动初始化</strong>，默认值取决于数据类型：<table><thead><tr><th><strong>数据类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td><code>int</code></td><td>0</td></tr><tr><td><code>char</code></td><td><code>&#39;\0&#39;</code></td></tr><tr><td><code>float</code></td><td>0.0</td></tr><tr><td><code>double</code></td><td>0.0</td></tr><tr><td>指针</td><td><code>NULL</code></td></tr></tbody></table></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;  <span class="comment">// 全局变量自动初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>块作用域指的是在代码块 <code>&#123;&#125;</code> 内部定义的变量，这些变量只在该块内有效。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 外部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 块作用域变量，覆盖外部变量 a</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;块变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">块变量: 20</span><br><span class="line">外部变量: 10</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>在块 <code>&#123;&#125;</code> 内部声明的变量 <code>a</code> 是一个新的变量，覆盖了外部变量 <code>a</code>。</li><li>块执行完后，内部变量 <code>a</code> 被销毁，外部变量 <code>a</code> 重新生效。</li></ul><hr><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>类作用域指的是在类中声明的变量，这些变量属于类，可以被类的所有成员函数访问。</p><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> class_var;  <span class="comment">// 类作用域变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类变量并初始化</span></span><br><span class="line"><span class="type">int</span> MyClass::class_var = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类变量: &quot;</span> &lt;&lt; MyClass::class_var &lt;&lt; std::endl;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类变量: 30</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>class_var</code> 是类的一个静态变量，属于整个类，而不是某个对象。</li><li>使用类名和作用域解析符号 <code>::</code> 可以直接访问它，无需创建类的实例。</li></ul><hr><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><ol><li><strong>局部变量</strong>：需要手动初始化；仅在函数或代码块内有效。</li><li><strong>全局变量</strong>：自动初始化；在整个程序中都可访问。</li><li><strong>块作用域</strong>：块内的变量会覆盖外部变量，块结束后自动销毁。</li><li><strong>类作用域</strong>：类中的变量可以通过类名访问，生命周期与类相关。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人新作</title>
      <link href="/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/"/>
      <url>/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>看到这个标题想必大家也知晓今天的内容是什么了😏，没错，今天我带来的是我的新作，一首纯音乐，歌名叫做《Sunrise》。由于github不支持超过100MB的文件，所以我上传的视频只是部分内容，如果有想要看完整内容的小伙伴，可以通过文章底部的链接下载哦~</strong><br><strong>废话不多说，开始吧！</strong><br><strong>自制歌曲：Sunrise</strong><br><strong>音频制作与处理：码头</strong><br><strong>后期：码头</strong><br><strong>工具：</strong><br><strong>音频制作：Fruity Loops Studio</strong><br><strong>音频处理：Adobe Audition</strong><br><strong>图片：Photoshop</strong><br><strong>动画特效：Adobe After Effects</strong><br><strong>剪辑：Adobe Premiere Pro</strong></p><h1 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h1><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p><strong>以下是音频文件。温馨提示：戴上耳机效果更佳哦！😋</strong><br><audio controls><br>    <source src="/music/Sunrise.wav" type="audio/wav"><br>    您的浏览器不支持 audio 元素。<br></audio></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><strong>以下是视频文件，与上面一样，戴上耳机效果更佳！</strong><br><video controls><br>  <source src="/video/20241115182839517.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA">https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA</a></strong><br><strong>提取码:yb77</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量类型</title>
      <link href="/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++变量类型"></a>C++变量类型</h1><p>在程序中，<strong>变量</strong>就是存储数据的容器。它们是程序可以操作的存储位置，每个变量都有一个名字和特定的数据类型。</p><hr><h3 id="变量类型的作用"><a href="#变量类型的作用" class="headerlink" title="变量类型的作用"></a>变量类型的作用</h3><ul><li><strong>变量类型</strong>定义了：<ol><li><strong>占用的内存大小和布局</strong>：不同类型的数据需要不同大小的内存空间。</li><li><strong>可以存储的值范围</strong>：例如，整数型不能存储小数，布尔型只能存储 <code>true</code> 或 <code>false</code>。</li><li><strong>适用的运算</strong>：变量类型决定了哪些运算符可以对它们进行操作。</li></ol></li></ul><hr><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ol><li><strong>可以使用的字符</strong>：变量名可以由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线（_）</strong>组成。</li><li><strong>开头限制</strong>：变量名必须以<strong>字母</strong>或<strong>下划线</strong>开头，不能以数字开头。</li><li><strong>区分大小写</strong>：C++ 是<strong>区分大小写</strong>的语言，所以 <code>Var</code> 和 <code>var</code> 是两个不同的变量名。</li><li><strong>建议使用有意义的名称</strong>：例如，用 <code>age</code> 表示年龄，比用 <code>a</code> 更直观。</li></ol><hr><h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>C++ 中有多种变量类型，每种类型适用于不同种类的数据，例如：</p><ul><li><strong>整数型</strong>存储整数。</li><li><strong>浮点型</strong>存储小数。</li><li><strong>字符型</strong>存储单个字符。</li><li><strong>布尔型</strong>存储逻辑值（<code>true</code> 或 <code>false</code>）。</li></ul><p>在后续章节中，我们将具体介绍这些变量类型的使用和特点！</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Data Types Description</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>Data Types Description</h2><table>    <tr>        <th>类型</th>        <th>描述</th>    </tr>    <tr>        <td>bool</td>        <td>布尔类型，存储值 true 或 false，占用 1 个字节。</td>    </tr>    <tr>        <td>char</td>        <td>字符类型，用于存储 ASCII 字符，通常占用 1 个字节。</td>    </tr>    <tr>        <td>int</td>        <td>整数类型，通常用于存储普通整数，通常占用 4 个字节。</td>    </tr>    <tr>        <td>float</td>        <td>单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。</td>    </tr>    <tr>        <td>double</td>        <td>双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。</td>    </tr>    <tr>        <td>void</td>        <td>表示类型的缺失。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。</td>    </tr></table></body></html><h2 id="C-中的变量类型"><a href="#C-中的变量类型" class="headerlink" title="C++中的变量类型"></a>C++中的变量类型</h2><p>在 C++ 中，你可以定义各种类型的变量来存储不同种类的数据，以下是常见的几种类型：</p><h3 id="整数类型-Integer-Types"><a href="#整数类型-Integer-Types" class="headerlink" title="整数类型 (Integer Types)"></a>整数类型 (Integer Types)</h3><ul><li><strong>int</strong>：存储整数，通常占用 4 个字节。</li><li><strong>short</strong>：存储较小的整数，通常占用 2 个字节。</li><li><strong>long</strong>：存储较大的整数，通常占用 4 个字节。</li><li><strong>long long</strong>：存储更大的整数，通常占用 8 个字节。</li></ul><h3 id="浮点类型-Floating-Point-Types"><a href="#浮点类型-Floating-Point-Types" class="headerlink" title="浮点类型 (Floating-Point Types)"></a>浮点类型 (Floating-Point Types)</h3><ul><li><strong>float</strong>：存储单精度浮点数（带小数的数），通常占用 4 个字节。</li><li><strong>double</strong>：存储双精度浮点数，精度比 <code>float</code> 高，通常占用 8 个字节。</li><li><strong>long double</strong>：存储更高精度的浮点数，字节数依编译器和系统而不同。</li></ul><h3 id="字符类型-Character-Types"><a href="#字符类型-Character-Types" class="headerlink" title="字符类型 (Character Types)"></a>字符类型 (Character Types)</h3><ul><li><strong>char</strong>：存储一个字符，通常占用 1 个字节。</li><li><strong>wchar_t</strong>：存储宽字符（用于表示更复杂的字符），占用 2 或 4 个字节。</li><li><strong>char16_t</strong>：存储 16 位 Unicode 字符，占用 2 个字节。</li><li><strong>char32_t</strong>：存储 32 位 Unicode 字符，占用 4 个字节。</li></ul><h3 id="布尔类型-Boolean-Type"><a href="#布尔类型-Boolean-Type" class="headerlink" title="布尔类型 (Boolean Type)"></a>布尔类型 (Boolean Type)</h3><ul><li><strong>bool</strong>：存储布尔值，只能是 <code>true</code> 或 <code>false</code>。</li></ul><h3 id="枚举类型-Enumeration-Types"><a href="#枚举类型-Enumeration-Types" class="headerlink" title="枚举类型 (Enumeration Types)"></a>枚举类型 (Enumeration Types)</h3><ul><li><strong>enum</strong>：定义一组命名的整数常量，通常用来表示具有多个固定值的变量。</li></ul><h3 id="指针类型-Pointer-Types"><a href="#指针类型-Pointer-Types" class="headerlink" title="指针类型 (Pointer Types)"></a>指针类型 (Pointer Types)</h3><ul><li><strong>type</strong>*：存储指向某个类型变量的地址。</li></ul><h3 id="数组类型-Array-Types"><a href="#数组类型-Array-Types" class="headerlink" title="数组类型 (Array Types)"></a>数组类型 (Array Types)</h3><ul><li><strong>type[] 或 type[size]：</strong>存储多个相同类型的元素。</li></ul><h3 id="结构体类型-Structure-Types"><a href="#结构体类型-Structure-Types" class="headerlink" title="结构体类型 (Structure Types)"></a>结构体类型 (Structure Types)</h3><ul><li><strong>struct</strong>：存储多个不同类型的数据（可以是整数、字符等的组合）。</li></ul><h3 id="类类型-Class-Types"><a href="#类类型-Class-Types" class="headerlink" title="类类型 (Class Types)"></a>类类型 (Class Types)</h3><ul><li><strong>class</strong>：存储具有属性和方法的自定义数据类型。</li></ul><h3 id="共用体类型-Union-Types"><a href="#共用体类型-Union-Types" class="headerlink" title="共用体类型 (Union Types)"></a>共用体类型 (Union Types)</h3><ul><li><strong>union</strong>：存储多种类型的数据，但它们共享同一块内存空间，这意味着同一时刻只能存储其中一种类型。</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>C++ 标准规定了这些类型的最小大小，但实际占用的字节数可能会因为编译器或计算机架构的不同而有所差异。例如，<code>int</code> 在许多现代计算机上占用 4 字节，<code>long</code> 有时占用 8 字节。</li><li>了解这些变量类型及其占用内存的特点有助于更好地管理程序中的数据和内存。</li></ul><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++中的变量定义"></a>C++中的变量定义</h2><p>在 C++ 中，<strong>变量定义</strong>是指告诉编译器在内存中为变量分配空间，并指定变量的数据类型。</p><h3 id="变量定义的基本形式："><a href="#变量定义的基本形式：" class="headerlink" title="变量定义的基本形式："></a>变量定义的基本形式：</h3><p>定义一个变量时，需要指定它的数据类型和变量的名称，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><p>这里，<code>type</code> 是你要定义的变量的数据类型，例如 <code>int</code>（整数）、<code>char</code>（字符）等，<code>variable_list</code> 是你要定义的变量名，多个变量名用逗号分隔。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;   <span class="comment">// 定义了三个整数变量 i, j, k</span></span><br><span class="line"><span class="type">char</span> c, ch;     <span class="comment">// 定义了两个字符变量 c 和 ch</span></span><br><span class="line"><span class="type">float</span> f, salary; <span class="comment">// 定义了两个浮点数变量 f 和 salary</span></span><br><span class="line"><span class="type">double</span> d;       <span class="comment">// 定义了一个双精度浮点数变量 d</span></span><br></pre></td></tr></table></figure><p>这行代码表示在内存中为 <code>i</code>、<code>j</code>、<code>k</code>、<code>c</code>、<code>ch</code>、<code>f</code>、<code>salary</code> 和 <code>d</code> 这些变量分配空间，并且每个变量的类型已经被明确指定。</p><h3 id="变量初始化："><a href="#变量初始化：" class="headerlink" title="变量初始化："></a>变量初始化：</h3><p>你可以在定义变量时，给它们一个初始值，这叫做<strong>初始化</strong>。格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;    <span class="comment">// 定义并初始化了两个整数变量 d 和 f</span></span><br><span class="line">byte z = <span class="number">22</span>;         <span class="comment">// 定义并初始化了一个名为 z 的变量</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>;        <span class="comment">// 定义了一个字符变量 x，其值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>这里，<code>d</code> 被初始化为 3，<code>f</code> 被初始化为 5，<code>z</code> 被初始化为 22，而 <code>x</code> 被初始化为字符 <code>&#39;x&#39;</code>。</p><h3 id="未初始化的变量："><a href="#未初始化的变量：" class="headerlink" title="未初始化的变量："></a>未初始化的变量：</h3><p>如果你定义变量时没有给它们初始值，那么对于<strong>静态存储持续时间的变量</strong>，它们会被自动初始化为 0（空值）；而对于<strong>局部变量</strong>，它们没有初始值，可能包含不确定的值，这样的变量会被称为“未定义值”。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>变量定义时，你要指定数据类型和变量名。</li><li>可以在定义时给变量初始化一个值。</li><li>如果没有初始化，静态变量会被自动初始化为 0，而其他变量没有初始值。</li></ul><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++中的变量声明"></a>C++中的变量声明</h2><p>在 C++ 中，<strong>变量声明</strong>告诉编译器你将在某个地方使用某个变量，但不需要在此时提供变量的具体内容。简单来说，声明只是告诉编译器“这个变量存在”。而<strong>变量定义</strong>则是真正分配内存空间并给变量赋值的过程。</p><h3 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h3><p>声明一个变量时，使用<code>extern</code>关键字告诉编译器该变量在其他地方定义，不需要在当前代码中重复定义。声明的目的是为了让编译器知道该变量的类型和名称，以便在编译时不会出错。</p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> type variable_name;</span><br></pre></td></tr></table></figure><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;   <span class="comment">// 声明了 a 和 b，表示它们将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c;      <span class="comment">// 声明了 c，表示它将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> f;    <span class="comment">// 声明了 f，表示它将在其他地方定义</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 变量定义和初始化</span></span><br><span class="line">  <span class="type">int</span> a, b;         <span class="comment">// 定义变量 a 和 b</span></span><br><span class="line">  <span class="type">int</span> c;            <span class="comment">// 定义变量 c</span></span><br><span class="line">  <span class="type">float</span> f;          <span class="comment">// 定义变量 f</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;   <span class="comment">// 输出 c 的值</span></span><br><span class="line"></span><br><span class="line">  f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl;   <span class="comment">// 输出 f 的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>我们在代码的开头声明了<code>a</code>、<code>b</code>、<code>c</code>和<code>f</code>这几个变量，告诉编译器它们将在其他地方定义。</li><li>然后，在<code>main</code>函数中，我们实际上定义了这些变量并初始化了它们。</li></ul><h3 id="重要注意点："><a href="#重要注意点：" class="headerlink" title="重要注意点："></a>重要注意点：</h3><ol><li><strong>声明</strong>：只是告诉编译器变量存在，不会分配内存。例如，<code>extern int a;</code> 声明了变量<code>a</code>，但它没有给<code>a</code>分配内存。</li><li><strong>定义</strong>：才会为变量分配内存，并且可以给它一个初始值。例如，<code>int a = 10;</code> 会定义变量<code>a</code>，并给它分配内存和初始值。</li><li><strong>多个声明，单次定义</strong>：你可以在多个地方声明同一个变量，但只应该在一个地方定义它。定义时会分配内存并赋值。</li></ol><h3 id="类似函数声明："><a href="#类似函数声明：" class="headerlink" title="类似函数声明："></a>类似函数声明：</h3><p>就像变量声明一样，函数也可以先声明再定义。你可以在程序的其他地方声明一个函数，而函数的定义可以放在程序的任何位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">func</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数<code>func</code>先声明，在<code>main</code>函数中调用它，实际的定义可以放在程序的任何地方。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>变量声明</strong>只是告诉编译器变量存在，并不分配内存。</li><li><strong>变量定义</strong>才会分配内存，并可以赋初值。</li><li><strong>函数声明</strong>告诉编译器函数存在，函数的实际实现可以在其他地方。</li></ul><h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues）"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>在 C++ 中，<strong>左值</strong>（Lvalue）和 <strong>右值</strong>（Rvalue）是两种不同类型的表达式，它们的区别在于是否可以被赋值，以及它们代表的内存位置。</p><h3 id="左值（Lvalue）："><a href="#左值（Lvalue）：" class="headerlink" title="左值（Lvalue）："></a>左值（Lvalue）：</h3><ul><li><strong>定义</strong>：左值表示一个可以出现在赋值符号（&#x3D;）左边的表达式，通常是一个可以定位到内存地址的对象。</li><li><strong>特点</strong>：左值表示一个存储位置，可以对其进行赋值，因为它表示内存中的一个具体位置。</li><li><strong>例子</strong>：变量、数组元素、解引用的指针等都是左值。例如，<code>g = 20;</code> 中的 <code>g</code> 是左值，因为它可以接受赋值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;  <span class="comment">// g 是左值</span></span><br><span class="line">g = <span class="number">30</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="右值（Rvalue）："><a href="#右值（Rvalue）：" class="headerlink" title="右值（Rvalue）："></a>右值（Rvalue）：</h3><ul><li><strong>定义</strong>：右值通常是一个没有明确内存地址的表达式。它表示一个临时的值或常量，通常只出现在赋值符号的右边。</li><li><strong>特点</strong>：右值不能出现在赋值符号的左边，因为它没有可以存储的内存位置，不能被赋值。</li><li><strong>例子</strong>：常量、字面值、表达式的计算结果（如 <code>10 + 5</code>）等都是右值。例如，<code>10 = 20;</code> 是非法的，因为 <code>10</code> 是右值，不能作为赋值的左边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能出现在赋值符号的左边</span></span><br></pre></td></tr></table></figure><h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul><li><strong>左值</strong>：可以出现在赋值符号的左边，表示一个可以被修改的内存位置（如变量）。</li><li><strong>右值</strong>：只能出现在赋值符号的右边，表示一个临时的、无法修改的值（如常量或表达式的结果）。</li></ul><p><strong>正确的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// a 是左值，10 是右值</span></span><br><span class="line">a = <span class="number">20</span>;       <span class="comment">// 可以对 a（左值）赋值</span></span><br></pre></td></tr></table></figure><p><strong>错误的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能作为赋值的左边</span></span><br></pre></td></tr></table></figure><p>通过这种方式，你可以理解左值是可以被赋值和修改的存储位置，而右值则是一次性的值，不能直接进行赋值。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的关键字（保留字）完整介绍</title>
      <link href="/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        body {            text-align: left; /* 使整个页面内容居中 */        }        table {            margin: 0 auto; /* 使表格在页面中居中 */            border-collapse: collapse;            font-weight: bold; /* 字体加粗 */        }        th, td {            border: 1px solid #ddd;            padding: 8px;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>保留字(关键字)</h2><p>C++系统中预定义的、在语言或编译系统的实现中具有特殊含义的单词:</p><table>    <tr>        <td>if</td>        <td>else</td>        <td>while</td>        <td>signed</td>        <td>throw</td>        <td>union</td>        <td>this</td>    </tr>    <tr>        <td>int</td>        <td>char</td>        <td>double</td>        <td>unsigned</td>        <td>const</td>        <td>goto</td>        <td>virtual</td>    </tr>    <tr>        <td>for</td>        <td>float</td>        <td>break</td>        <td>auto</td>        <td>class</td>        <td>operator</td>        <td>case</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>typedef</td>        <td>static</td>        <td>friend</td>        <td>template</td>        <td>default</td>    </tr>    <tr>        <td>new</td>        <td>void</td>        <td>register</td>        <td>extern</td>        <td>return</td>        <td>enum</td>        <td>inline</td>    </tr>    <tr>        <td>try</td>        <td>short</td>        <td>continue</td>        <td>sizeof</td>        <td>switch</td>        <td>private</td>        <td>protected</td>    </tr>    <tr>        <td>asm</td>        <td>while</td>        <td>catch</td>        <td>delete</td>        <td>public</td>        <td>volatile</td>        <td>struct</td>    </tr></table></body></html><p><strong>以下是对上述C++关键字的解释：</strong></p><hr><h3 id="1-asm（汇编指令）"><a href="#1-asm（汇编指令）" class="headerlink" title="1. asm（汇编指令）"></a>1. <strong>asm（汇编指令）</strong></h3><ul><li><code>asm</code>允许在C++程序中直接嵌入汇编代码。  </li><li>用法场景：需要执行底层硬件相关的指令时，可以使用它。</li></ul><hr><h3 id="2-auto（自动存储类型）"><a href="#2-auto（自动存储类型）" class="headerlink" title="2. auto（自动存储类型）"></a>2. <strong>auto（自动存储类型）</strong></h3><ul><li><code>auto</code>用来声明变量的存储类型是“自动的”，这意味着变量的生命周期受限于它所在的代码块（比如函数、循环等）。  </li><li>通常可以省略，因为这是默认行为。</li></ul><hr><h3 id="3-bool（布尔类型）"><a href="#3-bool（布尔类型）" class="headerlink" title="3. bool（布尔类型）"></a>3. <strong>bool（布尔类型）</strong></h3><ul><li><code>bool</code>表示“真或假”的值。  </li><li>有两个有效值：<code>true</code>（真）和<code>false</code>（假）。  </li><li>示例：<code>bool isActive = true;</code>  </li><li>在条件判断中很常用，比如<code>if</code>语句。</li></ul><hr><h3 id="4-break（跳出语句）"><a href="#4-break（跳出语句）" class="headerlink" title="4. break（跳出语句）"></a>4. <strong>break（跳出语句）</strong></h3><ul><li><code>break</code>用于终止循环或退出<code>switch</code>语句。  </li><li>当程序遇到<code>break</code>时，会直接跳到代码块的外面继续执行。  </li><li>示例：在<code>for</code>循环中提前停止迭代。</li></ul><hr><h3 id="5-case（条件分支）"><a href="#5-case（条件分支）" class="headerlink" title="5. case（条件分支）"></a>5. <strong>case（条件分支）</strong></h3><ul><li><code>case</code>用在<code>switch</code>语句中，表示不同的条件。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-catch（异常捕获）"><a href="#6-catch（异常捕获）" class="headerlink" title="6. catch（异常捕获）"></a>6. <strong>catch（异常捕获）</strong></h3><ul><li><code>catch</code>和<code>try</code>配合使用，用于处理程序运行时的异常。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-char（字符类型）"><a href="#7-char（字符类型）" class="headerlink" title="7. char（字符类型）"></a>7. <strong>char（字符类型）</strong></h3><ul><li><code>char</code>表示一个字符，比如字母或符号。  </li><li>数据范围是0到255，对应ASCII码表的值。  </li><li>示例：<code>char letter = &#39;A&#39;;</code></li></ul><hr><h3 id="8-class（类）"><a href="#8-class（类）" class="headerlink" title="8. class（类）"></a>8. <strong>class（类）</strong></h3><ul><li><code>class</code>是C++面向对象编程的核心，用来定义对象的模板或蓝图。  </li><li>类中可以包含属性和方法，用于模拟现实世界中的事物。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string brand;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 驾驶行为</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-const（常量）"><a href="#9-const（常量）" class="headerlink" title="9. const（常量）"></a>9. <strong><code>const</code>（常量）</strong></h3><ul><li><p><code>const</code>表示“不可更改”。  </p></li><li><p>用<code>const</code>修饰的变量或对象，其值在程序运行中不能被改变。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// pi 是一个常量，不能修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数</strong>：<br>如果<code>const</code>修饰一个函数，则该函数不能修改外部变量，也不能调用非<code>const</code>函数。<br>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// getValue不能修改任何变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：<br>相较于<code>#define</code>，<code>const</code>不仅可以定义常量，还具有类型检查功能，使用更安全。</p></li></ul><hr><h3 id="10-const-cast（类型转换运算符）"><a href="#10-const-cast（类型转换运算符）" class="headerlink" title="10. const_cast（类型转换运算符）"></a>10. <strong><code>const_cast</code>（类型转换运算符）</strong></h3><ul><li><p><code>const_cast</code>用来去除<code>const</code>属性，允许对原本不可修改的对象进行更改。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* px = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x); <span class="comment">// 去掉 x 的 const 性质</span></span><br><span class="line">*px = <span class="number">100</span>;                     <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：使用<code>const_cast</code>需要小心，错误的使用可能导致程序未定义行为。</p></li></ul><hr><h3 id="11-continue（跳过当前循环）"><a href="#11-continue（跳过当前循环）" class="headerlink" title="11. continue（跳过当前循环）"></a>11. <strong><code>continue</code>（跳过当前循环）</strong></h3><ul><li><p><code>continue</code>用在循环中，跳过本次循环剩下的代码，直接开始下一次循环。  </p></li><li><p><strong>与<code>break</code>的区别</strong>：  </p><ul><li><code>break</code>会结束整个循环。</li><li><code>continue</code>只跳过当前循环的后续部分，继续执行下一次循环。</li></ul></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过 i == 2 的情况</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 3 4</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="12-default（默认分支）"><a href="#12-default（默认分支）" class="headerlink" title="12. default（默认分支）"></a>12. <strong><code>default</code>（默认分支）</strong></h3><ul><li><p><code>default</code>是<code>switch</code>语句中的默认分支。  </p></li><li><p>当所有的<code>case</code>条件都不满足时，执行<code>default</code>部分的代码。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 5&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 8&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：x is something else</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>default</code>是可选的，可以没有。</p></li></ul><hr><h3 id="13-delete（释放内存）"><a href="#13-delete（释放内存）" class="headerlink" title="13. delete（释放内存）"></a>13. <strong><code>delete</code>（释放内存）</strong></h3><ul><li><code>delete</code>用于释放通过<code>new</code>关键字动态分配的内存空间。</li><li>释放的对象可以是单个变量或数组，但必须与分配时的形式匹配。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 动态分配一个整数</span></span><br><span class="line"><span class="keyword">delete</span> ptr;             <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 动态分配一个数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：释放内存后不能再次使用，否则会导致“悬空指针”。</li></ul><hr><h3 id="14-do（循环结构）"><a href="#14-do（循环结构）" class="headerlink" title="14. do（循环结构）"></a>14. <strong><code>do</code>（循环结构）</strong></h3><ul><li><code>do</code>是<code>do-while</code>循环的一部分，与<code>while</code>循环类似，但它<strong>至少执行一次循环体</strong>，因为条件是在循环体执行之后才检查的。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i is 0</span><br><span class="line">i is 1</span><br><span class="line">i is 2</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="15-double（双精度浮点数）"><a href="#15-double（双精度浮点数）" class="headerlink" title="15. double（双精度浮点数）"></a>15. <strong><code>double</code>（双精度浮点数）</strong></h3><ul><li><code>double</code>是C++中表示浮点数的一种数据类型，用于存储带小数点的数值，精度比<code>float</code>更高。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi is &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li>通常用于需要更高精度的数学计算。</li></ul><hr><h3 id="16-dynamic-cast（动态类型转换）"><a href="#16-dynamic-cast（动态类型转换）" class="headerlink" title="16. dynamic_cast（动态类型转换）"></a>16. <strong><code>dynamic_cast</code>（动态类型转换）</strong></h3><ul><li><code>dynamic_cast</code>用于在运行时将基类指针或引用转换为派生类指针或引用，确保类型安全。</li><li>适用于有<strong>继承关系</strong>的类之间的转换。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 必须有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion successful!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：<ul><li>如果转换失败，返回<code>nullptr</code>（对于指针）或抛出异常（对于引用）。</li></ul></li></ul><hr><h3 id="17-else（条件分支）"><a href="#17-else（条件分支）" class="headerlink" title="17. else（条件分支）"></a>17. <strong><code>else</code>（条件分支）</strong></h3><ul><li><code>else</code>和<code>if</code>配合使用，用于处理<code>if</code>条件为<code>false</code>时的操作。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is non-positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is positive</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="18"><li><strong>enum（枚举）</strong><br><code>enum</code>（枚举）类型用于定义一组固定的值，值的选择只能在这些预定义的选项中进行。例如，你可以使用枚举类型来表示一周的七天，每天对应一个固定的值：<code>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</code>。每个枚举值都代表一个常量，确保只能选择这些特定的值。</li></ol><hr><ol start="19"><li><strong>explicit（显式的）</strong><br><code>explicit</code>关键字的作用是“禁止单参数构造函数”在自动类型转换中被使用。简单来说，它防止编译器在进行类型转换时，自动将一个类型转换成这个构造函数的类型。例如，某些容器类型的构造函数可能接收一个数字作为初始大小，如果没有<code>explicit</code>，那么编译器可能会错误地将一个整数自动转换成容器类型。通过显式标记构造函数，可以避免这种自动转换。</li></ol><hr><ol start="20"><li><strong>export（导出）</strong><br>当你想访问其他代码文件中的变量或对象时，如果是普通类型（如基本数据类型、结构体或类），可以使用<code>extern</code>来引用。但是对于模板类型（如模板类或模板函数），你需要使用<code>export</code>来声明它们。在这种情况下，<code>export</code>告诉编译器这些模板是为了在其他文件中使用而被定义的。</li></ol><hr><ol start="21"><li><strong>extern（外部的）</strong><br><code>extern</code>关键字用于声明一个变量或函数是“外部链接”的，意思是它在其他文件中可以被访问和使用。这意味着这个变量或函数并没有在当前文件中定义，而是在程序的其他部分定义的。使用<code>extern</code>声明的变量或函数会在程序开始时分配空间，结束时释放。它们的定义应该出现在其他文件或同一文件的其他地方。如果要使用其他语言编写的代码，可以用<code>extern &quot;C&quot;</code>来声明，指明用C语言的方式进行链接。</li></ol><hr><ol start="22"><li><strong>false（假的）</strong><br><code>false</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“假”。它等价于整数类型中的0。在C++中，<code>bool</code>类型的变量可以是<code>true</code>（真）或<code>false</code>（假）。</li></ol><hr><ol start="23"><li><strong>float（浮点数）</strong><br><code>float</code>是C++中的一种数据类型，用于表示小数（浮点数）。它的精度比<code>double</code>低，适用于对精度要求不高的情况。比如，如果你只需要表示一位小数，使用<code>float</code>可以节省内存。</li></ol><hr><ol start="24"><li><strong>for（循环）</strong><br><code>for</code>是C++中的一种循环结构，用来反复执行一段代码，直到满足特定的条件为止。通常用于已知需要循环多少次的场景。例如，遍历数组或从1加到10。</li></ol><hr><ol start="25"><li><strong>friend（友元）</strong><br><code>friend</code>关键字用来声明友元关系，它允许其他函数或类访问当前类的私有（<code>private</code>）和保护（<code>protected</code>）成员。通过友元，某些函数或类可以直接操作本应隐藏的成员，从而提高效率或简化代码。友元可以是函数、类或特定的成员函数。</li></ol><hr><ol start="26"><li><strong>goto（转到）</strong><br><code>goto</code>是C++中的一种语句，用于跳转到程序中的另一个位置。虽然它可以改变程序的执行流，但通常不推荐使用，因为它会让程序的逻辑变得混乱。现代编程中，常用其他控制流结构（如<code>for</code>、<code>while</code>、<code>if</code>等）来替代<code>goto</code>。</li></ol><hr><ol start="27"><li><strong>if（如果）</strong><br><code>if</code>是C++中的条件语句，用于判断某个条件是否为真。如果条件为真，程序就会执行相应的代码块；如果为假，则跳过这个代码块。它是实现程序决策和分支逻辑的基础。</li></ol><hr><ol start="28"><li><strong>inline（内联函数）</strong><br><code>inline</code>用于定义内联函数，即编译器在调用该函数时，将函数的代码直接插入调用处，而不是进行常规的函数调用。内联函数通常很小，且频繁调用，使用<code>inline</code>可以提高程序执行效率，减少函数调用的开销。</li></ol><hr><ol start="29"><li><strong>int（整型）</strong><br><code>int</code>是C++中的基本数据类型，用来表示整数（没有小数的数）。它的范围通常较小，比<code>long</code>类型的整数范围要窄一些。</li></ol><hr><ol start="30"><li><strong>long（长整型）</strong><br><code>long</code>是C++中的另一种整型数据类型，用来表示比<code>int</code>类型范围更大的整数。它可以存储更大的数值。</li></ol><hr><ol start="31"><li><strong>mutable（易变的）</strong><br><code>mutable</code>是C++中的一个特殊关键字，通常用于类中的成员变量。它允许即使在<code>const</code>函数中，也可以修改被声明为<code>mutable</code>的成员变量。换句话说，它让类的常量成员函数能够修改某些成员变量，这通常用于需要记录某些信息但又不能改变对象状态的情况。</li></ol><hr><ol start="32"><li><strong>namespace（命名空间）</strong><br><code>namespace</code>用于组织和区分类。它是一种比类更大的组织结构，允许你将不同的类、函数等进行分组，避免命名冲突。你可以把它看作一个容器，帮助管理代码。</li></ol><hr><ol start="33"><li><strong>new（新建）</strong><br><code>new</code>是C++中的一个运算符，用于动态创建对象。它会在内存中为对象分配空间，并返回指向该对象的指针。也就是说，<code>new</code>会返回一个指向新创建对象的指针。</li></ol><hr><ol start="34"><li><strong>operator（操作符）</strong><br><code>operator</code>用于操作符重载，它让你可以为C++中的操作符（比如加号、减号等）定义自定义的行为。通过操作符重载，你可以让这些操作符在你的类对象上起作用。</li></ol><hr><ol start="35"><li><strong>private（私有的）</strong><br><code>private</code>是C++中的访问控制符之一，表示一个类的成员（如变量和函数）只能在该类的内部或者其友元类中访问。外部代码不能直接访问这些私有成员。</li></ol><hr><ol start="36"><li><strong>protected（受保护的）</strong><br><code>protected</code>也是C++中的访问控制符之一。被<code>protected</code>标记的成员只能在当前类、派生类（继承的类）以及友元类中访问。外部代码无法直接访问这些受保护的成员。</li></ol><hr><ol start="37"><li><strong>public（公有的）</strong><br><code>public</code>是C++中的访问控制符之一，表示一个类的成员可以被任何代码访问。它没有访问限制，可以在类的外部直接访问这些公有成员。</li></ol><hr><ol start="38"><li><strong>register（寄存器）</strong><br><code>register</code>是C++中的一个关键字，表示请求编译器将某个变量存放在CPU的寄存器中（而不是内存中），以提高访问速度。这个优化仅适用于局部变量，但在现代编译器中，它通常会根据实际情况自动优化，因此在32位编译器中作用较小。</li></ol><hr><ol start="39"><li><strong>reinterpret_cast（重新解释转换）</strong><br><code>reinterpret_cast</code>是C++中的一种类型转换，它可以把一个类型转换成完全不同的另一个类型。例如，它可以把指针转换成整数，或者把整数转换成指针。它的作用是直接重解释数据的二进制表示，而不考虑数据的实际类型，因此需要谨慎使用。</li></ol><hr><ol start="40"><li><strong>return（返回）</strong><br><code>return</code>关键字用于从函数中返回一个值，并结束函数的执行。一旦程序执行到<code>return</code>语句，函数会立即返回结果，之后的代码不会再执行。</li></ol><hr><ol start="41"><li><strong>short（短整型）</strong><br><code>short</code>是C++中的一种整型数据类型，用于表示比<code>int</code>类型范围小的整数。它占用的内存空间比<code>int</code>小，适用于存储较小范围的整数。</li></ol><hr><ol start="42"><li><strong>signed（有符号）</strong><br><code>signed</code>表示数字类型（如整型）是有符号的，也就是说它可以表示正数和负数。与之相对的是<code>unsigned</code>，即无符号类型，表示只有正数和零。大多数数值类型默认就是<code>signed</code>，所以通常不需要显式声明。</li></ol><hr><ol start="43"><li><strong>sizeof（大小）</strong><br><code>sizeof</code>是一个运算符，用来获取数据类型占用的内存大小（以字节为单位）。由于不同系统和编译器可能会有不同的内存分配，使用<code>sizeof</code>可以确保程序的可移植性。</li></ol><hr><ol start="44"><li><strong>static（静态的）</strong><br><code>static</code>关键字用于声明静态变量或静态函数。静态变量在程序开始时分配内存，并且在程序结束时释放。它的作用范围限于定义它的文件或类，在其他文件中不可访问。对于类的静态成员，它是由类的所有实例共享的，所有对象共享同一个静态变量。静态成员变量必须在类外部进行初始化。</li></ol><p>好的，下面是这些概念的更简洁易懂的解释：</p><hr><ol start="45"><li><strong>static_cast（静态转换）</strong><br><code>static_cast</code>是C++中的一种类型转换方式，它把表达式转换为指定的类型。它没有运行时的类型检查，所以开发者需要确保转换是安全的。常见的用法包括：</li></ol><ul><li><strong>类层次转换</strong>：在继承关系中，可以将子类指针&#x2F;引用转换为基类类型（安全），也可以把基类转换为子类（不安全，因为没有检查）。</li><li><strong>基本类型转换</strong>：在不同基本类型之间转换，比如<code>int</code>转换为<code>char</code>或枚举类型。  </li><li><strong>空指针转换</strong>：可以将空指针转换为其他类型的空指针。</li><li><strong>转换为<code>void</code>类型</strong>：可以将任何类型转换为<code>void</code>，用于不返回任何内容。</li></ul><p>需要注意的是，<code>static_cast</code>无法移除<code>const</code>、<code>volatile</code>或<code>__unaligned</code>属性。</p><hr><ol start="46"><li><strong>struct（结构体）</strong><br><code>struct</code>是C++中用于定义结构体的一种数据类型，与<code>class</code>类似，但与C语言兼容。它可以用来定义面向对象的程序，且所有成员默认是公有的（<code>public</code>），在实现上类似于<code>class</code>。</li></ol><hr><ol start="47"><li><strong>switch（选择）</strong><br><code>switch</code>是C++中的一种条件语句，用于在多个可能的分支中选择执行一条。它的用法类似于<code>if-else</code>链，但更简洁。<code>switch</code>的条件表达式必须是整型（如<code>int</code>或<code>char</code>）。<code>switch</code>语句通常包括一个可选的<code>default</code>分支，以处理没有匹配的情况。</li></ol><hr><ol start="48"><li><strong>template（模板）</strong><br><code>template</code>是C++中实现泛型编程的关键字。通过模板，可以定义适用于多种数据类型的通用函数或类，使代码更灵活、可重用。</li></ol><hr><ol start="49"><li><strong>this</strong><br><code>this</code>是C++中的一个指针，用于指向当前对象，也就是正在调用该成员函数的对象本身。通过<code>this</code>，对象可以访问它自己的数据成员和其他成员函数。</li></ol><hr><ol start="50"><li><strong>throw（抛出）</strong><br><code>throw</code>关键字用于C++中的异常处理。当程序遇到错误情况时，可以使用<code>throw</code>来抛出一个异常，通知调用者出错。<code>throw</code>的值可以是任意类型的异常对象。</li></ol><hr><ol start="51"><li><strong>true（真的）</strong><br><code>true</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“真”，等价于整数的非零值。布尔类型<code>bool</code>的值可以是<code>true</code>或<code>false</code>。</li></ol><hr><ol start="52"><li><strong>try（尝试）</strong><br><code>try</code>是C++异常处理机制的一部分。它用于包围可能会抛出异常的代码块，并与<code>catch</code>语句搭配使用，以捕获并处理异常。</li></ol><hr><ol start="53"><li><strong>typedef（类型定义）</strong><br><code>typedef</code>用于为已有数据类型创建一个新的别名。例如，可以用<code>typedef</code>给<code>int</code>类型取一个新的名字。这样可以使代码更易读，但并不会创建新的数据类型。</li></ol><hr><ol start="54"><li><strong>typeid</strong><br><code>typeid</code>用于在运行时获得某个对象或指针的实际类型（比如某个指针或引用指向的派生类型），常用于了解继承关系中的具体类型信息。</li></ol><hr><ol start="55"><li><strong>typename（类型名）</strong><br><code>typename</code>关键字告诉编译器，某个名称代表的是一种类型。主要用于模板代码中，以便让编译器正确地理解该名称的含义，尤其当该名称嵌套在其他类型中或依赖于模板参数时。</li></ol><hr><ol start="56"><li><strong>union（联合体）</strong><br><code>union</code>是一种数据结构，允许存储不同类型的数据，但同一时刻只存储一种。所有成员共享同一段内存，大小取决于最大的数据成员。这与<code>enum</code>不同，<code>enum</code>只能用于整数类型。</li></ol><hr><ol start="57"><li><strong>unsigned（无符号）</strong><br><code>unsigned</code>表示无符号类型，只能存储非负数。与<code>signed</code>（有符号）相对，<code>unsigned</code>省去了负数部分，使得同样的空间可以存储更大的正数。</li></ol><hr><ol start="58"><li><strong>using</strong><br><code>using</code>用于简化命名空间的引用。通过<code>using</code>声明，可以直接使用某命名空间的内容，而不必每次都写命名空间前缀。</li></ol><hr><ol start="59"><li><strong>virtual（虚函数）</strong><br><code>virtual</code>用于实现多态性，允许在基类中声明虚函数，从而可以在派生类中实现不同的行为。这样，通过基类指针或引用调用函数时，会执行派生类中的实际实现。</li></ol><hr><ol start="60"><li><strong>void（空）</strong><br><code>void</code>是一种特殊类型，表示“没有类型”或“空”。它可以用于：</li></ol><ul><li><strong>函数返回类型</strong>：表示函数不返回值。</li><li><strong>函数参数</strong>：表示没有参数传入。</li><li><strong>指针类型</strong>：<code>void*</code>表示一个通用指针，可以指向任意类型的数据。</li></ul><hr><ol start="61"><li><strong>volatile（易变的）</strong><br><code>volatile</code>用于标记变量的值可能会随时被系统或其他进程修改，防止编译器对它进行优化。常用于异步处理，如中断程序中涉及的变量。</li></ol><hr><ol start="62"><li><strong>wchar_t（宽字符）</strong><br><code>wchar_t</code>是一种数据类型，用于表示宽字符（即多字节字符）。每个<code>wchar_t</code>占用两个字节，适合表示Unicode字符，例如汉字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据类型</title>
      <link href="/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.toumatou.cn/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h1><p><strong>在编写程序时，我们经常需要用到变量来保存各种信息。变量其实是内存中的一块空间，用来存储特定的数据。创建变量时，计算机会根据变量的类型，分配合适大小的内存，并决定存储的数据格式。</strong></p><p>不同的数据类型可以用来保存不同种类的信息，比如：  </p><ul><li><strong>字符类型</strong>：用来存储单个字符，比如<code>&#39;A&#39;</code>。  </li><li><strong>宽字符类型</strong>：用于存储多字节字符，比如Unicode字符。  </li><li><strong>整数类型</strong>：用来存储整数，比如<code>10</code>或<code>-5</code>。  </li><li><strong>浮点数类型</strong>：用来存储小数，比如<code>3.14</code>。  </li><li><strong>双精度浮点数类型</strong>：精度更高的小数，比如<code>3.1415926</code>。  </li><li><strong>布尔类型</strong>：用来存储<code>true</code>（真）或<code>false</code>（假）。</li></ul><p>操作系统会根据变量的类型，确定分配多少内存以及如何处理存储的数据。这样，可以更高效地利用系统资源并保证数据正确存储。</p><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>数据类型和关键字</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>数据类型和关键字</h2><table>    <tr>        <th>类型</th>        <th>关键字</th>    </tr>    <tr>        <td>布尔型</td>        <td>bool</td>    </tr>    <tr>        <td>字符型</td>        <td>char</td>    </tr>    <tr>        <td>整型</td>        <td>int</td>    </tr>    <tr>        <td>浮点型</td>        <td>float</td>    </tr>    <tr>        <td>双浮点型</td>        <td>double</td>    </tr>    <tr>        <td>无类型</td>        <td>void</td>    </tr>    <tr>        <td>宽字符型</td>        <td>wchar_t</td>    </tr></table></body></html><p><code>wchar_t</code> 其实是通过定义类型别名实现的，具体是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>这意味着，<code>wchar_t</code> 实际上占用的空间和 <code>short int</code> 一样，通常是 2 个字节。</p><p>C++ 中的一些基本数据类型可以通过修饰符来修改它们的属性，包括：</p><ul><li><strong>signed</strong>：表示带符号（可以是正数或负数，默认情况下大多数整数类型是带符号的）。</li><li><strong>unsigned</strong>：表示无符号，只能是正数。</li><li><strong>short</strong>：表示短整型，通常占用比 <code>int</code> 更少的内存（通常是 2 个字节）。</li><li><strong>long</strong>：表示长整型，通常占用比 <code>int</code> 更多的内存（通常是 8 个字节）。</li></ul><p>不同的数据类型在内存中占用的空间（字节数）会有所不同，而且它们能存储的最大值和最小值也会根据系统有所不同。通常情况下，1 字节等于 8 位。</p><h3 id="默认情况下："><a href="#默认情况下：" class="headerlink" title="默认情况下："></a>默认情况下：</h3><ul><li><code>int</code>、<code>short</code>、<code>long</code> 类型都是带符号的（<code>signed</code>），可以表示负数和正数。</li></ul><h3 id="关于-long-int-和-int-的大小："><a href="#关于-long-int-和-int-的大小：" class="headerlink" title="关于 long int 和 int 的大小："></a>关于 <code>long int</code> 和 <code>int</code> 的大小：</h3><ul><li>在一些早期的编译器中，<code>long int</code> 占 4 个字节，<code>int</code> 占 2 个字节。但是现代的 C&#x2F;C++ 标准已经兼容这种设定，通常在较新的系统中，<code>long int</code> 占 8 个字节，<code>int</code> 占 4 个字节。<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Data Types and Ranges</title>  <style>      table {          width: 100%;          border-collapse: collapse;      }      th, td {          border: 1px solid #ddd;          padding: 8px;          text-align: left;      }      th {          background-color: #add8e6; /* 浅蓝色背景 */          color: #000; /* 文本颜色，可以根据需要调整 */      }  </style></head><body></li></ul><h2>Data Types and Ranges</h2><table>    <tr>        <th>类型</th>        <th>位</th>        <th>范围</th>    </tr>    <tr>        <td>char</td>        <td>1个字节</td>        <td>-128到127或者0到255</td>    </tr>    <tr>        <td>unsigned char</td>        <td>1个字节</td>        <td>0到255</td>    </tr>    <tr>        <td>signed char</td>        <td>1个字节</td>        <td>-128到127</td>    </tr>    <tr>        <td>int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>unsigned int</td>        <td>4个字节</td>        <td>0到4294967295</td>    </tr>    <tr>        <td>signed int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>unsigned short int</td>        <td>2个字节</td>        <td>0到65,535</td>    </tr>    <tr>        <td>signed short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>signed long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>unsigned long int</td>        <td>8个字节</td>        <td>0到18,446,744,073,709,551,615</td>    </tr>    <tr>        <td>float</td>        <td>4个字节</td>        <td>精度型占4个字节(32位)内存空间,+/-3.4e+/-38(~7个数字)</td>    </tr>    <tr>        <td>double</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,+/-1.7e+/-308(~15个数字)</td>    </tr>    <tr>        <td>long long</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,表示-9,223,372,036,854,775,807到9,223,372,036,854,775,807的范围</td>    </tr>    <tr>        <td>long double</td>        <td>16个字节</td>        <td>长双精度型16个字节(128位)内存空间,可提供18-19位有效数字。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>2或4个字节</td>        <td>1个宽字符</td>    </tr></table></body></html><h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>在 C++ 中，<code>typedef</code> 关键字可以用来给已有的类型起一个新的名字。这相当于创建一个类型的别名，让代码更清晰或者更方便。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原类型 新名字;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>如果想给 <code>int</code> 类型起一个新名字 <code>feet</code>，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet;</span><br></pre></td></tr></table></figure><p>从现在起，<code>feet</code> 就和 <code>int</code> 完全等价，表示同一种类型。比如下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance; <span class="comment">// 等同于 int distance;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>distance</code> 是一个整型变量，但通过 <code>feet</code> 这个名字，它更直观地表示变量的意义，比如“表示距离”。这让代码更容易阅读和理解。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>枚举类型（<code>enumeration</code>）是 C++ 中一种用户自定义的数据类型，用来定义一组固定的值。它非常适合表示只有有限可能取值的变量。通过枚举，可以为变量列举出所有合法值，变量的取值范围就被限制在这些列举的值中。</strong></p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举用关键字 <code>enum</code> 定义，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; </span><br><span class="line">    标识符<span class="number">1</span>[=整型常数], </span><br><span class="line">    标识符<span class="number">2</span>[=整型常数], </span><br><span class="line">    ...</span><br><span class="line">    标识符n[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>如果没有为标识符赋值（即省略 <code>=整型常数</code>），枚举会默认从 0 开始，后续值依次加 1。</li><li>也可以为部分或全部标识符指定具体的值。未指定的标识符会自动比前一个值大 1。</li></ul><h3 id="示例-1：默认值"><a href="#示例-1：默认值" class="headerlink" title="示例 1：默认值"></a>示例 1：默认值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125;; <span class="comment">// red=0, green=1, blue=2</span></span><br><span class="line">color c;  <span class="comment">// 定义变量 c，类型为 color</span></span><br><span class="line">c = blue; <span class="comment">// c 的值为 blue（等价于 2）</span></span><br></pre></td></tr></table></figure><h3 id="示例-2：自定义值"><a href="#示例-2：自定义值" class="headerlink" title="示例 2：自定义值"></a>示例 2：自定义值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;; <span class="comment">// red=0, green=5, blue=6</span></span><br><span class="line">color c = green;  <span class="comment">// c 的值为 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>red</code> 的值为 0。</li><li><code>green</code> 的值被设置为 5。</li><li><code>blue</code> 自动被赋值为 6，因为它比前一个值大 1。</li></ul><h3 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h3><ol><li><strong>代码更易读</strong>：通过枚举名称表达变量的意义（如 <code>red</code> 和 <code>green</code>）。</li><li><strong>更安全</strong>：变量的取值被限制在定义的枚举值范围内，避免了非法值的出现。</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换是指将一种数据类型的值转换成另一种数据类型的值。在 C++ 中，主要有四种类型转换方式：<strong>静态转换、动态转换、常量转换</strong>和<strong>重新解释转换</strong>。下面我们用更简单的语言解释这些转换方式。</p><hr><h3 id="1-静态转换（Static-Cast）"><a href="#1-静态转换（Static-Cast）" class="headerlink" title="1. 静态转换（Static Cast）"></a>1. <strong>静态转换（Static Cast）</strong></h3><ul><li><strong>作用</strong>：在编译时，将一种类型强制转换成另一种类型。</li><li><strong>特点</strong>：没有运行时检查，所以如果转换不合理，可能会导致程序运行时出错。</li><li><strong>用途</strong>：通常用在类型之间有一定相似性的场景，比如 <code>int</code> 和 <code>float</code> 的转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 把 int 类型的值转换为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-动态转换（Dynamic-Cast）"><a href="#2-动态转换（Dynamic-Cast）" class="headerlink" title="2. 动态转换（Dynamic Cast）"></a>2. <strong>动态转换（Dynamic Cast）</strong></h3><ul><li><strong>作用</strong>：在运行时将基类的指针或引用转换为派生类的指针或引用。</li><li><strong>特点</strong>：会进行运行时类型检查，如果转换不合法，会返回空指针或抛出异常。</li><li><strong>用途</strong>：主要用于带有<strong>继承关系的类</strong>之间的指针或引用转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 转换成派生类指针</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-常量转换（Const-Cast）"><a href="#3-常量转换（Const-Cast）" class="headerlink" title="3. 常量转换（Const Cast）"></a>3. <strong>常量转换（Const Cast）</strong></h3><ul><li><strong>作用</strong>：用于移除变量的 <code>const</code> 属性，允许对其进行修改。</li><li><strong>特点</strong>：只能去掉 <code>const</code>，不会改变数据类型。</li><li><strong>用途</strong>：在特定场景下需要修改 <code>const</code> 修饰的变量时使用。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;  <span class="comment">// 一个常量</span></span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 将 const int 转换为普通 int</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-重新解释转换（Reinterpret-Cast）"><a href="#4-重新解释转换（Reinterpret-Cast）" class="headerlink" title="4. 重新解释转换（Reinterpret Cast）"></a>4. <strong>重新解释转换（Reinterpret Cast）</strong></h3><ul><li><strong>作用</strong>：直接将一种类型的值按二进制格式解释为另一种类型。</li><li><strong>特点</strong>：不做任何检查，可能会导致未定义行为。</li><li><strong>用途</strong>：通常用于需要对内存内容重新解释的场景（如底层编程）。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 强行把 int 的内存解释为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th><strong>转换方式</strong></th><th><strong>特点</strong></th><th><strong>主要用途</strong></th></tr></thead><tbody><tr><td><strong>静态转换</strong></td><td>编译时转换，无运行时检查</td><td>类型相似的普通数据类型转换（如 <code>int</code> 转 <code>float</code>）</td></tr><tr><td><strong>动态转换</strong></td><td>运行时检查，安全但速度稍慢</td><td>基类与派生类之间的指针或引用转换</td></tr><tr><td><strong>常量转换</strong></td><td>去掉 <code>const</code> 属性，只修改可变性</td><td>修改 <code>const</code> 变量的值</td></tr><tr><td><strong>重新解释转换</strong></td><td>直接按内存内容重新解释类型，不安全</td><td>内存地址、类型的低级转换（如底层硬件编程）</td></tr></tbody></table><p>需要注意的是，<strong>尽量避免不必要的类型转换</strong>，特别是动态转换和重新解释转换，因为它们可能引发潜在的问题或性能损耗。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.toumatou.cn/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/">面向对象与面向过程</a>，本节我将正式开始讲解关于C++的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>C++ 程序可以看作是由一组对象组成的，每个对象都有自己的特性和行为。这些对象通过互相调用方法来交流。现在让我们用简单的方式理解一下<strong>类</strong>、<strong>对象</strong>、<strong>方法</strong>和<strong>实例变量</strong>。</p><ol><li><p><strong>对象</strong>  </p><ul><li>对象就像是生活中的实物，它既有特性，也有行为。  <ul><li>比如：一只狗。  <ul><li><strong>特性</strong>：颜色（白色）、名字（小白）、品种（牧羊犬）。  </li><li><strong>行为</strong>：摇尾巴、叫、吃东西。</li></ul></li><li><strong>在程序中，对象是根据类创建出来的“实例”。</strong></li></ul></li></ul></li><li><p><strong>类</strong>  </p><ul><li>类可以看作是创建对象的“设计图”或者“模板”。  <ul><li>比如，“狗”这个类就描述了所有狗的共性（颜色、名字、品种）和它们可以做的事（摇尾巴、叫、吃东西）。  </li><li><strong>具体的狗（如小白、小黑）就是从这个类生成的对象。</strong></li></ul></li></ul></li><li><p><strong>方法</strong>  </p><ul><li>方法就是对象可以执行的“动作”或者“功能”。  <ul><li>对狗来说，方法可以是“叫”（bark()）、“吃”（eat()）。  </li><li><strong>方法中包含程序逻辑，定义了对象可以做的事情。</strong></li></ul></li></ul></li><li><p><strong>实例变量</strong>  </p><ul><li>实例变量是对象的“特性值”，每个对象都有自己的值。  <ul><li>比如，狗类中可能有变量“颜色”、“名字”。小白的颜色是白色，名字是“小白”；而小黑的颜色是黑色，名字是“小黑”。这些特性值存储在实例变量中，决定了对象的状态。</li></ul></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把类比作“模板”，对象是根据模板创建的“具体实例”，方法定义了对象的“行为”，而实例变量存储了对象的“特性值”。通过这种方式，我们可以用编程模拟真实世界中的事物和它们之间的交互。</p><h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h1><p>让我们看一段简单的代码，可以输出单词 Hello World</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来我们讲解一下这个程序:</strong></p><ol><li><p><strong>头文件 <code>&lt;iostream&gt;</code></strong>  </p><ul><li><code>&lt;iostream&gt;</code> 是一个标准库，提供输入输出功能。  </li><li>在这个程序中，它允许我们使用 <code>cout</code> 输出信息到屏幕上。</li></ul></li><li><p><strong><code>using namespace std;</code></strong>  </p><ul><li>告诉编译器我们要使用标准命名空间 <code>std</code>。  </li><li>这样，我们可以直接写 <code>cout</code> 而不用每次都写成 <code>std::cout</code>。</li></ul></li><li><p><strong>单行注释 <code>//</code></strong>  </p><ul><li>以 <code>//</code> 开头的部分是注释，它的作用是让程序员记录说明，编译器会忽略这些内容。  </li><li>比如 <code>// main() 是程序的开始</code>，是为了帮助人类理解程序的结构。</li></ul></li><li><p><strong>主函数 <code>int main()</code></strong>  </p><ul><li><code>main()</code> 是程序的入口点，每个 C++ 程序都需要这个函数。  </li><li>程序从这里开始运行。</li></ul></li><li><p><strong>输出语句 <code>cout &lt;&lt; &quot;Hello World&quot;;</code></strong>  </p><ul><li><code>cout</code> 是 C++ 用来输出信息到屏幕的工具。  </li><li>这句代码会在屏幕上打印 <code>Hello World</code>。</li></ul></li><li><p><strong><code>return 0;</code></strong>  </p><ul><li>这句话的意思是：程序运行结束，并返回一个值 <code>0</code> 给系统。  </li><li>在 C++ 中，返回 <code>0</code> 通常表示程序正常结束。</li></ul></li></ol><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤:</p><ol><li><p><strong>编写代码</strong>  </p><ul><li>打开一个文本编辑器，比如记事本或代码编辑器（如 VS Code、Sublime Text）。  </li><li>将前面写好的代码粘贴进去。</li></ul></li><li><p><strong>保存文件</strong>  </p><ul><li>将文件保存为 <code>hello.cpp</code>（扩展名必须是 <code>.cpp</code>，表示这是一个 C++ 程序）。</li></ul></li><li><p><strong>打开命令提示符</strong>  </p><ul><li>在 Windows 系统中，可以通过按下 <code>Win + R</code>，输入 <code>cmd</code> 打开命令提示符。  </li><li>使用 <code>cd</code> 命令进入保存 <code>hello.cpp</code> 文件的文件夹。<br>例如，如果文件在桌面上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编译代码</strong>  </p><ul><li>输入以下命令，按下回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure></li><li>如果代码没有错误，编译器会生成一个可执行文件，默认命名为 <code>a.exe</code>（在 Windows 中）或 <code>a.out</code>（在 Linux&#x2F;macOS 中）。</li></ul></li><li><p><strong>运行程序</strong>  </p><ul><li>在命令提示符中输入以下命令，运行生成的可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.exe    <span class="comment"># Windows 系统</span></span><br><span class="line">./a.out  <span class="comment"># Linux/macOS 系统</span></span><br></pre></td></tr></table></figure></li><li>你将看到屏幕上显示 <code>Hello World</code>。</li></ul></li></ol><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li><strong>什么是编译？</strong><br>编译是将我们写的 C++ 代码转换成机器能理解的二进制文件（可执行文件）的过程。  </li><li><strong>为什么需要编译？</strong><br>计算机只能理解二进制代码，因此必须先将源代码“翻译”成计算机语言，才能运行。<br>通过以上步骤，你的第一个 C++ 程序就成功运行了！</li></ul><h2 id="C-中的分号-语句块"><a href="#C-中的分号-语句块" class="headerlink" title="C++ 中的分号 &amp; 语句块"></a>C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束</p><h3 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h3><ol><li><p><strong>分号是语句结束的标志</strong>：  </p><ul><li>每条C++语句都需要以分号结尾，用来告诉编译器“这句话结束了”。</li><li>你可以把分号看成是句号，表示一个完整的逻辑结束。</li></ul></li><li><p><strong>示例</strong>：<br>下面是三条独立的语句，每条语句都以分号结束：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;         <span class="comment">// 把 y 的值赋给 x</span></span><br><span class="line">y = y + <span class="number">1</span>;     <span class="comment">// y 加 1 后赋值给 y</span></span><br><span class="line"><span class="built_in">add</span>(x, y);     <span class="comment">// 调用函数 add，把 x 和 y 作为参数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="语句块的作用"><a href="#语句块的作用" class="headerlink" title="语句块的作用"></a>语句块的作用</h3><ol><li><p><strong>语句块是逻辑上的一组代码</strong>：  </p><ul><li>使用大括号 <code>&#123;&#125;</code> 将多条语句包裹在一起，这些语句作为一个整体，通常用于函数、条件语句、循环等结构中。</li></ul></li><li><p><strong>示例</strong>：<br>下面是一个语句块，它包含两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 返回值 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同一行的多个语句"><a href="#同一行的多个语句" class="headerlink" title="同一行的多个语句"></a>同一行的多个语句</h3><ol><li><p><strong>C++ 不限制每行只能写一条语句</strong>：  </p><ul><li>你可以在同一行放置多条语句，只要每条语句以分号结束即可。</li></ul></li><li><p><strong>示例</strong>：<br>以下两种写法是等价的：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y; y = y + <span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>分号</strong>：是C++的语句结束符，必须添加。</li><li><strong>语句块</strong>：是一组用大括号 <code>&#123;&#125;</code> 包裹的语句，用于逻辑上的分组。</li><li><strong>多语句</strong>：C++允许多条语句写在一行，只需确保用分号分隔即可。<br>通过这些规则，你可以更灵活地组织代码。</li></ul><h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用于命名变量、函数、类等的符号，用来帮助程序员在代码中识别不同的内容。下面是一些详细解释：</p><ol><li><p><strong>命名规则</strong>：</p><ul><li>标识符必须以字母（A-Z或a-z）或下划线（_）开头。</li><li>后面可以跟字母、数字（0-9）或下划线的组合。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能包含特殊字符，如 <code>@</code>、<code>&amp;</code>、<code>%</code> 等。</li><li>C++ 区分大小写，也就是说 <code>apple</code> 和 <code>Apple</code> 是两个不同的标识符。</li></ul></li><li><p><strong>有效的标识符示例</strong>：</p><ul><li><code>mohd</code>, <code>zara</code>, <code>move_name</code>, <code>a_123</code>, <code>_temp</code> 等，符合规则。<br>通过这些规则，C++ 程序员可以创建各种命名来组织代码，使代码更有条理。</li></ul></li></ol><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h2><p>下面出了一些在 C++ 中的保留字，这些保留字不能作为常量名、变量名或其他标识符名称。<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>C++ Keywords</h2><table>    <tr>        <td>asm</td>        <td>else</td>        <td>new</td>        <td>this</td>    </tr>    <tr>        <td>auto</td>        <td>enum</td>        <td>operator</td>        <td>throw</td>    </tr>    <tr>        <td>bool</td>        <td>explicit</td>        <td>private</td>        <td>true</td>    </tr>    <tr>        <td>break</td>        <td>export</td>        <td>protected</td>        <td>try</td>    </tr>    <tr>        <td>case</td>        <td>extern</td>        <td>public</td>        <td>typedef</td>    </tr>    <tr>        <td>catch</td>        <td>false</td>        <td>register</td>        <td>typeid</td>    </tr>    <tr>        <td>char</td>        <td>float</td>        <td>reinterpret_cast</td>        <td>typename</td>    </tr>    <tr>        <td>class</td>        <td>for</td>        <td>return</td>        <td>union</td>    </tr>    <tr>        <td>const</td>        <td>friend</td>        <td>short</td>        <td>unsigned</td>    </tr>    <tr>        <td>const_cast</td>        <td>goto</td>        <td>signed</td>        <td>using</td>    </tr>    <tr>        <td>continue</td>        <td>if</td>        <td>sizeof</td>        <td>virtual</td>    </tr>    <tr>        <td>default</td>        <td>inline</td>        <td>static</td>        <td>void</td>    </tr>    <tr>        <td>delete</td>        <td>int</td>        <td>static_cast</td>        <td>volatile</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>struct</td>        <td>wchar_t</td>    </tr>    <tr>        <td>double</td>        <td>mutable</td>        <td>switch</td>        <td>while</td>    </tr>    <tr>        <td>dynamic_cast</td>        <td>namespace</td>        <td>template</td>        <td></td>    </tr></table></body></html><p>若要查看完整关键字介绍可查阅：<a href="https://blog.toumatou.cn/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">C++ 的关键字（保留字）完整介绍</a></p><h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><h3 id="什么是三字符组？"><a href="#什么是三字符组？" class="headerlink" title="什么是三字符组？"></a>什么是三字符组？</h3><p>三字符组是用三个特定字符组合来表示其他字符的一种方法，通常以??开头。这是早期为了解决一些键盘上缺少特定字符的问题而设计的。虽然现代编译器和键盘已经不需要这个功能，但它仍然是C++标准的一部分。</p><h3 id="三字符组的常用替换规则"><a href="#三字符组的常用替换规则" class="headerlink" title="三字符组的常用替换规则"></a>三字符组的常用替换规则</h3><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>字符替换表</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>字符替换表</h2><table>    <tr>        <th>三字符组</th>        <th>替换</th>    </tr>    <tr>        <td>??=</td>        <td>#</td>    </tr>    <tr>        <td>??/</td>        <td>\</td>    </tr>    <tr>        <td>??'</td>        <td>^</td>    </tr>    <tr>        <td>??(</td>        <td>[</td>    </tr>    <tr>        <td>??)</td>        <td>]</td>    </tr>    <tr>        <td>??!</td>        <td>|</td>    </tr>    <tr>        <td>??&lt;</td>        <td>{</td>    </tr>    <tr>        <td>??&gt;</td>        <td>}</td>    </tr>    <tr>        <td>??-</td>        <td>~</td>    </tr></table></body></html><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用三字符组代替常规符号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> ??! std::endl;  <span class="comment">// ??! 替换成 |</span></span><br><span class="line">    <span class="type">int</span> arr??(<span class="number">3</span>??) = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">// ??( 和 ??) 替换成 [ 和 ]</span></span><br><span class="line">    std::cout &lt;&lt; arr??(<span class="number">0</span>??) &lt;&lt; std::endl;       <span class="comment">// 输出数组第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="三字符组的注意事项"><a href="#三字符组的注意事项" class="headerlink" title="三字符组的注意事项"></a>三字符组的注意事项</h3><p><strong>特殊情况避免替换</strong>：</p><p>如果你需要在字符串、字符常量或者注释中保留两个连续的问号，而不被自动替换，可以用以下方式：<br>转义序列：”???“。<br>字符串拼接：”??””?”。</p><p><strong>现代编译器支持：</strong></p><p>Microsoft Visual C++：从2010版开始，默认不再支持三字符组。如果需要启用，可以使用命令行选项&#x2F;Zc:trigraphs。<br>GCC编译器：仍支持三字符组，但会提示编译警告，表明这种用法已经过时。</p><h3 id="为什么了解三字符组？"><a href="#为什么了解三字符组？" class="headerlink" title="为什么了解三字符组？"></a>为什么了解三字符组？</h3><p>虽然三字符组在现代开发中极少使用，但在维护一些古老的代码时可能会遇到。这是一个有趣的历史遗留特性，了解它有助于更全面地理解C++语言的设计。</p><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><p>以下是对“C++ 中的空格”更通俗易懂的解释：</p><h3 id="空白行和空格"><a href="#空白行和空格" class="headerlink" title="空白行和空格"></a>空白行和空格</h3><ol><li><p><strong>空白行</strong>：只有空格或注释的行称为“空白行”。C++ 编译器会自动忽略这些行，它们不会影响代码运行。</p></li><li><p><strong>空格的作用</strong>：</p><ul><li>空格不仅指空白符，还包括制表符（Tab）、换行符和注释，它们都属于“空白符号”。</li><li>空格帮助编译器区分不同部分，比如在<code>int age;</code>这行代码中，<code>int</code>和<code>age</code>之间需要空格，这样编译器才能知道<code>int</code>是数据类型，<code>age</code>是变量名。</li></ul></li><li><p><strong>代码的可读性</strong>：</p><ul><li>在一些地方，空格不是必需的，比如在 <code>fruit = apples + oranges;</code> 中，<code>fruit</code> 和 <code>=</code> 之间不强制要求空格，但适当添加空格可以让代码更清晰，便于阅读。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>空格让代码更易读，帮助编译器识别代码中的不同部分。虽然有些地方空格不是必须的，但为了让代码更美观，推荐合理使用空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与面向过程</title>
      <link href="/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从现在开始我将正式开始分享一些C++程序的讲解，相信大家对于C语言并不陌生，我们接下来需要去学习的C++这个编程语言也跟C语言有关系，但是它与C语言有很大的区别，本节内容不会有代码的讲解，作为一个引文的作用，目的在于让大家认识到C++与C语言的区别，或者说面向对象程序设计语言与面向过程程序设计语言的区别，以便于之后更好的去理解代码、语法等等</strong></p><h1 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h1><h2 id="一-面向过程-OOP"><a href="#一-面向过程-OOP" class="headerlink" title="一.面向过程(OOP)"></a>一.面向过程(OOP)</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p><strong>面向过程是一种以步骤为核心的编程方式，逻辑比较线性。可以理解为<u>以完成任务为目标</u>，通过一系列有序的指令来操作数据，逐步完成任务。我们来具体谈谈：</strong></p><h4 id="游戏中的面向过程"><a href="#游戏中的面向过程" class="headerlink" title="游戏中的面向过程"></a>游戏中的面向过程</h4><p><strong>设想我们要设计一个战斗游戏，有以下角色和功能：</strong></p><p><strong>角色：玩家、怪物</strong><br><strong>功能：攻击、逃跑、升级</strong></p><p><strong>在面向过程的思维中，我们可以按照以下步骤实现：</strong></p><p><strong>1.定义玩家的属性：生命值、攻击力、防御力</strong><br><strong>2.定义怪物的属性：生命值、攻击力、防御力</strong><br><strong>3.编写函数：</strong><br><strong>玩家攻击函数——playerAttackMonster()：玩家攻击怪物，怪物的生命值减少</strong><br><strong>怪物攻击函数——monsterAttackPlayer()：怪物攻击玩家，玩家的生命值减少</strong><br><strong>升级函数——upgradePlayer()：玩家升级时提升攻击力和防御力</strong><br><strong>4.游戏逻辑：通过调用这些函数来实现游戏流程，如玩家攻击、怪物攻击、玩家升级等</strong>。<br><strong>我们可以看到，<u>游戏的主要逻辑由一系列的函数组成，这些函数一个接一个地执行</u></strong></p><p><strong>所以可以得到面向过程的特点：</strong><br><strong>1.步骤清晰：逐步执行代码，如先定义角色，再实现攻击功能</strong><br><strong>2.数据分散：每个角色的数据和行为都是分开的，玩家和怪物的属性、函数不相关</strong><br><strong>3.适合小型项目：如果游戏简单，面向过程的逻辑非常直观</strong></p><p><strong>但这也带来了面向过程的劣势：</strong><br><strong>1.代码重复：不同的角色可能要定义相似的属性（如生命值、攻击力等）</strong><br><strong>2.维护困难：如果要新增一个角色，如“弓箭手”，需要增加很多函数和属性，工作量增加</strong></p><h2 id="二-面向对象-POP"><a href="#二-面向对象-POP" class="headerlink" title="二.面向对象(POP)"></a>二.面向对象(POP)</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向对象是一种以数据和行为组合为核心的编程方式，结构较为模块化。它强调将数据和操作结合在一起，通过“类”和“对象”将复杂的任务组织为独立的模块，还是以游戏为例：</strong></p><h4 id="游戏中的面向对象"><a href="#游戏中的面向对象" class="headerlink" title="游戏中的面向对象"></a>游戏中的面向对象</h4><p><strong>在面向对象的思维中，我们可以通过创建类来封装角色和行为：</strong></p><p><strong>1.定义一个“玩家”类（Player）：</strong><br><strong>属性：生命值、攻击力、防御力等</strong><br><strong>方法：攻击怪物（attack()）、升级（levelUp()）</strong></p><p><strong>2.继承和扩展：</strong><br><strong>如果有不同类型的玩家角色，比如战士（Warrior）、法师（Mage），我们可以让Warrior和Mage继承Player类，这样它们就自动拥有了生命值、攻击力等属性和攻击、升级等方法</strong><br><strong>我们可以为Warrior增加“近战攻击”方法（meleeAttack()），为Mage增加“施法”方法（castSpell()），这样每种角色都有独特的行为，而不需要重复编写基础属性</strong></p><p><strong>3.怪物类（Monster）：</strong><br><strong>我们也可以定义一个Monster类，包含怪物的生命值和攻击力</strong><br><strong>通过定义方法如attackPlayer()，实现怪物对玩家的攻击</strong></p><p><strong>4.道具类（Item）：</strong><br><strong>还可以定义道具类，包含道具名称、效果等属性</strong><br><strong>比如药水类可以恢复玩家的生命值，而武器类可以提升玩家的攻击力</strong></p><p><strong>从上面的例子我们不难看出面向过程的特点：</strong><br><strong>1.模块化：每个类都包含属性和行为，Player类中的方法直接操作Player的数据，怪物则自成一体</strong><br><strong>2.继承性：Warrior、Mage继承自Player，只需扩展各自的特性，而无需重复代码</strong><br><strong>3.封装性：属性和行为封装在类内，外部代码无需关心具体实现，只需调用方法</strong><br><strong>4.扩展性：可以轻松添加新角色或功能，如增加“弓箭手”类，继承Player类，扩展新技能，不影响已有代码</strong></p><h2 id="三-面向对象-vs-面向过程：对比分析"><a href="#三-面向对象-vs-面向过程：对比分析" class="headerlink" title="三.面向对象 vs. 面向过程：对比分析"></a>三.面向对象 vs. 面向过程：对比分析</h2><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><strong>1.面向对象是对面向过程的进一步抽象，结构上更清晰，适合管理复杂系统</strong><br><strong>2.二者的基本逻辑相同，但面向对象在逻辑结构和扩展性上更优</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>1.核心思维：面向过程以步骤和流程为主，逐步实现目标。面向对象通过类和对象组织代码，模块化更高</strong><br><strong>2.代码结构：面向过程的代码较分散，面向对象将数据和操作结合，封装在类中，结构更紧密</strong><br><strong>3.适用场景：面向过程适合简单、线性逻辑；面向对象适合复杂系统，方便维护和扩展</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>通过面向对象编程，我们可以更轻松地在游戏中管理不同角色、怪物、道具的行为和状态。这种模块化的设计方式不仅让代码更易读，还使得后续扩展和维护更加简单。在C++中，面向对象为我们提供了丰富的表达能力，从而使游戏设计更具灵活性和扩展性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站 www.______.com😏</title>
      <link href="/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>先问大家一个问题：大家的浏览器收藏夹里面有多少好东西呢？😋</strong></p><p><strong>我收藏夹里藏着不少“古董级”的宝贝网站，就像那些被遗忘在阁楼角落里的旧玩具，虽然不常拿出来玩，但偶尔翻出来，总能发现一些意想不到的乐趣。这些网站可能平时默默无闻，但说不定在某个无聊的下午，它们就能给你带来惊喜，让你的浏览器收藏夹不再是“尘封的记忆”，而是“宝藏的宝库”。那么，这次我为大家带来了哪些新奇有趣的网站呢？让我们一起来看看，说不定能发现一些被我们忽略的“隐藏版”乐趣哦！</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p><strong>使用设备：电脑</strong><br><strong>获取方式：文章底部(每一个推荐网站的底部)</strong></p><h3 id="1-懒盘搜索——聚合搜索神器"><a href="#1-懒盘搜索——聚合搜索神器" class="headerlink" title="1. 懒盘搜索——聚合搜索神器"></a>1. 懒盘搜索——聚合搜索神器</h3><p><strong>这是一个非常好用的网盘搜索工具，包括音乐、电影、动漫、小说等等内容都能搜索到</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120117.png" alt="主页面" >  <img src="/img_2/QQ截图20241111120126.png" alt="聚合搜索界面" ></div><p><strong>电影搜索</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120237.png" alt="电影搜素" ></div><p><strong>学习资源</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120246.png" alt="学习资源" >  <img src="/img_2/QQ截图20241111121051.png" alt="学习资源" ></div><h4 id="懒盘搜索官网链接：https-www-lzpan-com"><a href="#懒盘搜索官网链接：https-www-lzpan-com" class="headerlink" title="懒盘搜索官网链接：https://www.lzpan.com/"></a>懒盘搜索官网链接：<a href="https://www.lzpan.com/">https://www.lzpan.com/</a></h4><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p><strong>虫部落是一个集结了海量资源的搜索平台。在这里，你能找到的资源大多是通过网盘链接分享的。只要你拥有相应的网盘账户，轻轻一点，就能迅速将资源保存到你的网盘中，然后直接下载，方便快捷</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111121454.png" alt="主页面" >  <img src="/img_2/QQ截图20241111121853.png" alt="部分内容" >  <img src="/img_2/QQ截图20241111121916.png" alt="部分内容" ></div><p><strong>这个平台就像是一个资源宝库，让寻找各类资料变得轻而易举。它极大地简化了我的日常搜索任务，让我能够快速获取所需资源，真是一个值得向大家推荐的实用工具</strong></p><h4 id="虫部落官网链接：http-www-chongbuluo-com"><a href="#虫部落官网链接：http-www-chongbuluo-com" class="headerlink" title="虫部落官网链接：http://www.chongbuluo.com/"></a>虫部落官网链接：<a href="http://www.chongbuluo.com/">http://www.chongbuluo.com/</a></h4><h3 id="3-考研百科网"><a href="#3-考研百科网" class="headerlink" title="3.考研百科网"></a>3.考研百科网</h3><p><strong>这个平台致力于为准备考研的学生提供全方位的支持，让他们能够提前掌握所需的学习资源和准备工作。该平台划分为四个核心板块，分别是考研入门知识、考研流程指导、考研目标规划和备考技巧建议</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111122642.png" alt="主页面" >  <img src="/img_2/QQ截图20241111122656.png" alt="部分内容" ></div><p><strong>这个网站提供了非常全面的资源，我就不在这里一一列举了。正在准备考研或者有意向考研的朋友们，可以查看下面的图表，或者直接访问这个网站来获取更多信息</strong></p><h4 id="考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk"><a href="#考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk" class="headerlink" title="考研百科官网链接：https://yz.chsi.com.cn/yzzt/kybk"></a>考研百科官网链接：<a href="https://yz.chsi.com.cn/yzzt/kybk">https://yz.chsi.com.cn/yzzt/kybk</a></h4><h3 id="一键抠图——在线图片处理神器"><a href="#一键抠图——在线图片处理神器" class="headerlink" title="一键抠图——在线图片处理神器"></a>一键抠图——在线图片处理神器</h3><p><strong>一键抠图是一个卓越的网络图像编辑工具，它提供了众多的图片处理功能，包括但不限于图像抠图、证件照制作、照片修复、文件格式转换、全面编辑以及图片裁剪等，这些功能全面覆盖了日常工作中可能遇到的图像编辑需求</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111123156.png" alt="主页面" ></div><p><strong>抠图功能使用起来非常简单便捷，即使是初学者也能快速掌握。用户只需选择相应的功能，上传图片，系统便会自动进行识别并提取图片中的核心元素，整个过程轻松无压力</strong><br><video controls><br>  <source src="/img_2/bandicam 2024-11-11 12-34-06-243.mp4" type="video/mp4"><br></video></p><h4 id="一键抠图官网链接：https-www-yijiankoutu-com"><a href="#一键抠图官网链接：https-www-yijiankoutu-com" class="headerlink" title="一键抠图官网链接：https://www.yijiankoutu.com/"></a>一键抠图官网链接：<a href="https://www.yijiankoutu.com/">https://www.yijiankoutu.com/</a></h4><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，我们每个人的周围其实都有着不少宝贵的资源，无论是知识、技能、人脉还是物质条件。这些资源就像是我们生活中的宝藏，等待着我们去发掘和利用。不要害怕去探索和尝试，因为每一次的尝试都可能开启新的可能性。让我们勇敢地迈出步伐，用开放的心态去学习，用智慧的眼光去发现，用创新的思维去整合。记住，善于利用身边的资源，不仅能帮助我们解决问题，还能让我们在成长的道路上走得更远。所以，请用好每一份资源，让它们成为我们成功的助力！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
            <tag> 宝藏网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对不住了，Steam！Steam 游戏发烧友必备😏</title>
      <link href="/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/"/>
      <url>/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>说到 Steam，那可是游戏爱好者心中的圣地，就像图书馆之于书虫，糖果店之于小朋友，那是一个应有尽有，让人眼花缭乱的地方。你想要最新的 3A 大作？没问题！在线游戏？小菜一碟！但问题是，这些游戏可不是免费派发的糖果，你得先掏腰包才能把它们领回家</strong><br><strong>如果你偶尔心血来潮，买一两个游戏，那钱包还能勉强保持微笑。但如果你是个游戏收藏家，那可就得小心了，你的钱包可能会因为过度兴奋而 “心脏病发作”</strong><br><strong>当然，如果游戏能让你爱不释手，那花点钱也值了。但最怕的就是，你花了钱，结果发现这游戏跟你八字不合，那可真是让人哭笑不得</strong><br><strong>所以，今天给大家介绍一个神奇的游戏下载盒子，它能让你在 Steam 的海洋里畅游，而不用掏空你的口袋。这可不是普通的盒子，它能让你免费享受那些让人垂涎三尺的游戏大餐。这就好比你走进了一家自助餐厅，却发现老板说：“今天免费，随便吃！” 这等好事，你怎能错过呢？</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：游戏盒子 (game box)</strong><br><strong>使用设备：电脑</strong><br><strong>软件大小：130.04MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p><strong>软件已经出了新版本，但是大家不需要进行更新，我觉得这个版本也是没啥问题，并且也是可以正常使用的，大家想更新的也可以选择更新试试看！然后大家也是能看到内置了超多的游戏资源～</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-41-37-709.mp4" type="video/mp4"><br></video></p><h3 id="游戏搜索"><a href="#游戏搜索" class="headerlink" title="游戏搜索"></a>游戏搜索</h3><p><strong>软件支持直接搜索，你可以通过搜索游戏并下载，下方也是有内置各种分类可供选择，可以在不同类别里发掘自己喜欢的游戏</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-43-08-343.mp4" type="video/mp4"><br></video></p><h3 id="安装路径与下载"><a href="#安装路径与下载" class="headerlink" title="安装路径与下载"></a>安装路径与下载</h3><p><strong>软件提供了一系列精彩的游戏资源，包括许多高品质的 3A 级作品。在开始下载之前，需要先登录天翼云网盘 (免费注册的)，再通过设置选项来指定下载和安装的位置，这样可以确保一切顺利进行。只需点击界面右上角的 “设置” 图标，就可以轻松地自定义您的下载和安装路径了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-04-45-737.mp4" type="video/mp4"><br></video></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p><strong>安装的方式也简单，找到自己喜欢的游戏后，点击安装按钮，然后选择游戏的版本号即可一键下载安装该游戏了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-12-23-001.mp4" type="video/mp4"><br></video></p><h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><strong>测试了一下游戏的下载速度，非常不错，开发大佬优化了下载速度，可以让大家快速的下载完成</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-15-17-955.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>通过网盘分享的文件：gamebox.exe</strong><br><strong>链接: <a href="https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg">https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg</a></strong><br><strong>提取码: e5sa</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>对于这些无私地提供免费软件的开发者们，我们应当怀有敬意和感激之情，向他们致敬🫡</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的歌曲</title>
      <link href="/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是我最近这段时间做的曲子，偏励志的歌曲，希望大家能够喜欢</strong></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="以下是歌词"><a href="#以下是歌词" class="headerlink" title="以下是歌词"></a>以下是歌词</h3><p><strong>歌名：Step By step</strong></p><p><strong>In the race of life, we take our place,</strong><br><strong>With hopes aflame, in this timeless chase.</strong><br><strong>Through storms we walk, lessons deep and wise,</strong><br><strong>With each dawn’s light, a new dream arises.</strong></p><p><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we claim the prize,</strong><br><strong>Eyes set forward, on dreams that rise.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step</strong><br><strong>Step by step</strong><br><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we’ll mark our way.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step, beyond the fear,</strong><br><strong>Through shadows cast, our way is clear.is clear</strong><br><strong>Step by step, we’re redefined,</strong><br><strong>Into a strength of heart and mind.</strong></p><p><strong>Lift your gaze, the world awaits,</strong><br><strong>The dawn of dreams, through future gates.</strong><br><strong>Step by step, we’ll mark our way,</strong><br><strong>Leaving echoes in history’s sway.</strong></p><h3 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h3><video controls>  <source src="/img_1/bandicam 2024-11-09 21-43-51-757.mp4" type="video/mp4"></video><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>进化是万物的自然法则 ，不问因由、不辨方向，只因适应便是生存的唯一。【成长】却是内心深处的觉醒，为更坚定的信念，心向未来，带着无悔的初心启程。 在探索中我们成长，不再因未知而迷茫，在风雨中我们成长，所有的挑战都将迎刃而解，跌倒的站起 ，彷徨的找到归途，仰望那片无际的星空，成长的力量化为无形的支柱，筑起我们心中坚不可摧的信念，成为那份无论何时都不曾动摇的守望！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以使用到下架的音乐软件</title>
      <link href="/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在这个快节奏的世界里，音乐无疑是我们心灵的慰藉，它如同一股清泉，滋润着我们的灵魂。今天想与大家分享的，不仅仅是一款音乐软件，而是一段音乐旅程的开始。这是一款简约而不简单的音乐应用。🙂</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：酷狗概念版</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：124.33MB</strong><br><strong>获取方式：文章底部</strong></p><div style="text-align:center">  <img src="/img_1/55CF549DC97727664019811146FF1E35.jpg" alt="主页面" ></div><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p><strong>想象一下，当你在繁忙的日常中寻找一丝宁静，这款软件就像是一位老朋友，静静地等待你的召唤。它的界面相对于其它几个平台的软件较为简洁，操作直观，只需轻轻一点，就能带你进入音乐的海洋。</strong></p><div style="text-align:center">  <img src="/img_1/5D3400BE1891D4531BD075F73B1F69E2.jpg" alt="播放界面" style="width:50%;">  <img src="/img_1/8BC982518DF64AE8D876DA37D4E8F6D1.jpg" alt="播放界面" style="width:50%;"></div><p><strong>与其他音乐平台相比，这款软件的独特之处在于它的“音乐故事”功能。在这里，每一首歌曲都不仅仅是旋律的堆砌，它们背后的故事，如同珍珠般串联起来，让你在聆听的同时，也能感受到音乐的深度与温度。</strong></p><p><strong>官方还更新了开屏画面，各位可以按照下面的方式去根据自己喜欢的风格壁纸设置</strong></p><div style="text-align:center">  <img src="/img_1/83885ACB3D60D33140B471BD706C4A9A.jpg" alt="" >  <img src="/img_1/1100F28525ACE1DC8B3B740DFFEF4C3A.jpg" alt="效果展示" style="width:50%;"></div><p><strong>值得一提的是这个软件的好处在于，每日都可以领取一日的VIP，只需要看五秒的广告，理论上可以一直不收费的听下去，这绝对是白嫖党的福利😀!</strong></p><div style="text-align:center">  <img src="/img_1/0C8331419A6D582631E22F5406EA3CF6.jpg" alt="" style="width:50%;">  <img src="/img_1/C92DEA934D74627728C5CF99FFA655FC.jpg" alt="" style="width:50%;"></div><p><strong>各位音乐爱好者们，如果你渴望在音乐的世界里寻找一份纯粹，那么这款软件定会是你的不二之选。让我们一起，随着音符跳跃，随着旋律起舞，不要错过这场音乐的盛宴。😆</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA">https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA</a></strong> <br><strong>提取码:iay2</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星际之舞：宇宙的诗篇</title>
      <link href="/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/img_1/9E0BE8E969CAC462282B28BDB3DF1AFE.jpg" alt="马头星云"></p><h3 id="星河璀璨"><a href="#星河璀璨" class="headerlink" title="星河璀璨"></a>星河璀璨</h3><p>  <strong>在浩瀚无垠的宇宙中，每一个星系都是一个独特的存在，它们以自己的方式讲述着宇宙的故事。 这张图片捕捉到了一个遥远星系的壮丽景象，它的中心散发出耀眼的光芒，仿佛是宇宙的灯塔，指引着迷失在星际间的旅者</strong></p><div style="text-align:center">  <img src="/img_1/7318400BB81BE3610CB7C214222D802A.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="旋舞银河"><a href="#旋舞银河" class="headerlink" title="旋舞银河"></a>旋舞银河</h3><p><strong>星系的旋臂如同宇宙的舞者，优雅地旋转着，上面点缀着无数的恒星，每一颗都在以自己的生命节奏闪烁。这些恒星的诞生、演化和死亡，构成了宇宙生命的交响曲。而那些暗淡的尘埃和气体，则是新恒星的摇篮，孕育着未来的光明</strong></p><div style="text-align:center">  <img src="/img_1/F872DED84FC80417240DFAA73466AD77.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/C880F01E01FF0D0849D9AFBB44BA7CA6.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="微光感悟"><a href="#微光感悟" class="headerlink" title="微光感悟"></a>微光感悟</h3><p> <strong>在这片星海中，我们不仅看到了宇宙的壮丽，也感受到了自己的渺小。然而，正是这种渺小，让我们对宇宙的探索充满了无限的好奇和渴望。每一次对星空的凝视，都是对未知的一次致敬，也是对人类探索精神的一次肯定。</strong></p><div style="text-align:center">  <img src="/img_1/34E6F253E9EB266011351DBB9C2F2082.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/39DC3EE370E1BC8F31E5739ED3707C34.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="远征"><a href="#远征" class="headerlink" title="远征"></a>远征</h3><p> <strong>每一颗星星都可能是一个新世界的开始。在这个无尽的宇宙之旅中，我们都是勇敢的探险者，追寻着知识的光，照亮前行的路。</strong></p><div style="text-align:center">  <img src="/img_1/CAA771D7E2B3AE60CE7475CD17304335.jpg" alt="拍摄＆后期 By 码头"></div><p><strong>自己拍摄的图，分享给大家，希望每个人都可以在自己的追寻的道路上走的足够远，成为有所建树的人😃</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款好用的音乐软件</title>
      <link href="/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在数字时代的浪潮中，音乐软件如同璀璨的星辰，点缀着我们的生活。今天我要向大家介绍的，是一款与众不同的音乐应用，它以其独特的魅力，悄然走进了我们的世界</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：速悦音乐</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：31.01MB</strong><br><strong>获取方式：文章底部</strong></p><p><strong>这款音乐软件如同一股清新的风，吹散了繁琐的注册登录流程(你可以不需要注册或登录就可以直接使用)，让你无需任何门槛，甚至可以下载音乐，即可直接沉浸在音乐的海洋中。它的首界面，简洁至极，如同一张白纸，等待着你用指尖的魔法，绘制出属于自己的音乐天地</strong></p><div style="text-align:center">  <img src="/img_1/488C7C60ED9CA57D5F062D06E558EBC5.jpg" alt="主页面" >  <img src="/img_1/42F2AA03FF2EF5FB741F2B8A6BADF78D.jpg" alt="播放界面" style="width:50%;" ></div><p><strong>顺带一提，下载音乐只需要分享就可以下载了(你可以不直接分享，点击分享按钮，再退出就好了，不过为了支持原作者，建议还是分享一下吧😁)，具体操作如下图</strong></p><div style="text-align:center">  <img src="/img_1/CA1AA8F8B40A78F3E4CD9932426B3C99.gif" alt="播放界面" ></div><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>不仅如此，这款软件还赋予了你无限的创造力。你可以根据自己的喜好，自定义界面，让每一次打开应用，都成为一场视觉与听觉的双重盛宴。无论是色彩的搭配，还是布局的调整，都能随心所欲，打造出一个完全属于你的音乐空间</strong><br><strong>你也可以设置界面是否为深色模式，以及背景的模糊度和透明度等，具体参照下图，这里就不再演示，可自行探索</strong></p><div style="text-align:center">  <img src="/img_1/7F3CFD25EB3A4E1502F4330A748F859C.jpg" alt="主题切换演示" >  <img src="/img_1/11259F93D8B82874CE5AE29E1C52F5D5.jpg" alt="这是我的主题" style="width:50%;" ></div><p><strong>朋友们，如果你厌倦了复杂的操作，渴望一份简单而纯粹的音乐体验，那么这款软件无疑是你的最佳选择。让我们一起，在这个小小的屏幕上，探索无限的音乐世界，享受那份只属于你的宁静与自由</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg">https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg</a></strong><br><strong>提取码:nt24</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>在我们国内不缺乏一些好用的音乐软甲，但很可惜的是，由于动了别人的蛋糕，难免会遭受排挤，诸如歌词适配，洛雪等老牌软件也未能幸免，想要找到一款好用的软件实属不易，但仍然有许多为爱发电的大佬开发的软件依旧在坚挺，向他们致敬🫡！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><p><strong>在此之前，我们先来聊聊递归的思想</strong><br><strong>递归是计算的基本思想之一，想象一下，你是一个老师，要解释什么是“递归”，你可能会说：“递归就是我给你们举的例子，这个例子就是递归的一个实例。” 这就是递归的本质：用递归自身来解释递归</strong></p><h2 id="递归的工作原理"><a href="#递归的工作原理" class="headerlink" title="递归的工作原理"></a>递归的工作原理</h2><p><strong>递归的工作原理可以想象成俄罗斯套娃，每个娃娃里面都有一个更小的娃娃，直到最小的那个。在编程中，这就像是函数A调用自己A，函数A又调用自己A，如此继续，直到达到最小的娃娃（也就是递归的基本情况），然后开始一层层解开，直到回到最初的那个函数A</strong><br><strong>再换一个例子，想象一下，你正在爬楼梯，每爬一阶，你就离顶层更近一步。递归也是这样，每次函数调用自己时，都会更接近基本情况（base case），也就是递归结束的条件</strong></p><h2 id="递归的两个关键部分"><a href="#递归的两个关键部分" class="headerlink" title="递归的两个关键部分"></a>递归的两个关键部分</h2><p><strong>1.基本情况（Base Case）：这是递归停止的条件，就像最小的俄罗斯套娃，没有更小的娃娃了。或则说，类似于你爬到顶层，就不再爬了在编程中，这通常是最简单的问题，可以直接解决，不需要进一步递归</strong><br><strong>递推关系（Recursive Case）：这是函数如何调用自己的部分，每次调用都应该让问题更接近基本情况</strong></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><h3 id="1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120"><a href="#1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120" class="headerlink" title="1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120"></a>1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120</h3><p>以下是C语言的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为0或1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回n乘以(n-1)的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u 的阶乘是 %llu\n&quot;</span>, num, factorial(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><p><strong>斐波那契数列是这样的数列：0, 1, 1, 2, 3, 5, 8, 13, …，其中每个数是前两个数的和。</strong></p><p>以下是C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 基本情况：如果n为0，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为1，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回前两个斐波那契数的和</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, num, fibonacci(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>递归在编程中是一种强大的编程技术，它通过函数自我调用来解决问题。在使用递归时，确保有明确的基本情况和递推关系，这样可以避免无限递归和栈溢出的问题。希望这些例子能帮助你理解递归的概念和应用</strong></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><strong>通过上面的例子你应该大致理解了递归的思想了，那么接下来我们回到本次要讲的正题————二叉树的遍历。相信学数据结构的同学对它一定不陌生！二叉树的遍历是按照某种规则，依次访问二叉树中的每个节点，每个节点只访问一次。主要有三种遍历方式：先序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）</strong></p><h2 id="先序遍历（Preorder-Traversal）"><a href="#先序遍历（Preorder-Traversal）" class="headerlink" title="先序遍历（Preorder Traversal）"></a>先序遍历（Preorder Traversal）</h2><p><strong>定义：先访问根节点，然后遍历左子树，最后遍历右子树</strong>。<br><strong>递归算法：访问根节点，然后对左子树和右子树递归执行先序遍历。</strong><br><strong>非递归算法：使用栈来模拟递归过程。首先将根节点入栈，然后循环执行以下步骤：弹出栈顶节点，访问它，然后将它的右子节点和左子节点依次入栈（注意顺序，先右后左）</strong></p><p><strong>假设我们有如下的二叉树：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于先序遍历，简单来说就是指按照“根节点 -&gt; 左子树 -&gt; 右子树”的顺序访问二叉树的每个节点,以下是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它打印根节点的值，然后递归地遍历左子树和右子树</strong><br><strong>遍历下来的结果就是：1, 2, 4, 5, 3</strong></p><p><strong>接下来是非递归的遍历算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode* node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.push(node-&gt;right); <span class="comment">// 先右后左，保持顺序</span></span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将根节点压入栈中，然后循环直到栈为空。在每次循环中，它弹出栈顶节点，访问它，然后将右子节点和左子节点依次压入栈中，所以遍历下来的结果就是：非递归遍历结果：1, 2, 4, 5, 3</strong></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>定义：先遍历左子树，然后访问根节点，最后遍历右子树</strong><br><strong>递归算法：对左子树递归执行中序遍历，访问根节点，然后对右子树递归执行中序遍历</strong><br><strong>非递归算法：使用栈来模拟递归过程。从根节点开始，将节点依次入栈直到到达最左节点，然后访问它并转向右子节点，重复此过程</strong></p><p><strong>还是上述的二叉树为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对与中序遍历便是指按照“左子树 -&gt; 根节点 -&gt; 右子树”的顺序访问二叉树的每个节点，以下是递归算法得的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    inOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树，打印根节点的值，然后递归地遍历右子树,所以遍历的结果便是：4, 2, 5, 1, 3</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它弹出栈顶节点，访问它，并转向其右子节点,所以遍历出来的结果便是：4, 2, 5, 1, 3</strong></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>定义：先遍历左子树，然后遍历右子树，最后访问根节点</strong><br><strong>递归算法：对左子树和右子树递归执行后序遍历，然后访问根节点</strong><br><strong>非递归算法：使用两个栈来模拟递归过程。第一个栈用于遍历，第二个栈用于反转遍历顺序。将根节点入第一个栈，然后循环执行以下步骤：从第一个栈中弹出节点并将其入第二个栈，然后将其子节点依次入第一个栈（注意顺序，先右后左）。当第一个栈为空时，从第二个栈中弹出节点并访问它们</strong></p><p><strong>二叉树例子同上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历便是指按照“左子树 -&gt; 右子树 -&gt; 根节点”的顺序访问二叉树的每个节点，接下来是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    postOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树和右子树，然后打印根节点的值，所以遍历出来的结果是：4, 5, 2, 6, 7, 3, 1</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right == <span class="literal">NULL</span> || current-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            prev = current;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它检查栈顶节点的右子节点是否为空或者是否已经访问过。如果是，它弹出栈顶节点，访问它，并更新prev节点。否则，它转向栈顶节点的右子节点,所以运行出来的结果便是：4, 5, 2, 6, 7, 3, 1</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>递归方法：直观，易于实现，但可能遇到栈溢出的问题</strong><br><strong>非递归方法：使用栈或队列来模拟递归过程，可以避免栈溢出的问题，但实现相对复杂</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，学习编程可能会在一开始感到有些挑战，但请记住，每个编程高手都是从基础开始，一步一个脚印走过来的。递归是编程中一个非常强大的工具，一旦你掌握了它，很多复杂的问题都会变得简单起来。记住，每个人的学习速度都是不同的，不要和别人比较，而是和昨天的自己比较。只要你们保持耐心和热情，不断练习，很快就能掌握递归的。加油，你们可以做到的！😉</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF算法与KMP算法</title>
      <link href="/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊数据结构中两种在字符串中寻找子串的方法：暴力匹配（BF算法）和KMP算法。<strong>这两种方法都像是在玩一个“找茬”游戏</strong>，目的是在一个大字符串（我们称之为主串）中找到一个小字符串（我们称之为模式串）出现的位置。</p><p>我们先举一个例子：<br><strong>假设主串为 “ababcabcacbab”，模式串为 “abcac”</strong></p><h2 id="暴力匹配（BF算法）"><a href="#暴力匹配（BF算法）" class="headerlink" title="暴力匹配（BF算法）"></a>暴力匹配（BF算法）</h2><p><strong>BF算法，也称为暴力匹配算法，是一种简单的字符串匹配方法。它的基本思想是从主串的每一个字符开始，逐个与模式串的字符进行比较，直到找到匹配的字符或比较完整个模式串。如果模式串中有某个字符不匹配，BF算法会回溯到主串的下一个字符重新开始匹配。想象一下，你手上有一张小图片（模式串），你想在一个巨大的画布（主串）上找到这张图片。使用暴力匹配的方法，你会从画布的最左边开始，试着把小图片的每个角对准画布上的每个点，看看是否能完全匹配。如果不匹配，你就向右移动一点，再试一次。这个过程会一直重复，直到你找到匹配的地方，或者把整个画布都试一遍。</strong></p><p><strong>原理</strong><br><strong>1.从主串的第一个字符开始，与模式串的第一个字符进行比较。</strong><br><strong>2.如果相等，则继续比较主串和模式串的下一个字符。</strong><br><strong>3.如果不相等，则主串指针回溯到上次匹配的首位的下一位，模式串指针回到开头，重新开始匹配。</strong><br><strong>4.重复上述过程，直到找到匹配的子串或主串遍历完毕。</strong></p><p>以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; S[i + j] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = BF(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h2><p><strong>KMP算法是一种改进的字符串匹配算法。它通过预处理模式串，构建部分匹配表（next数组），在匹配过程中利用已经匹配的信息，避免重复比较，从而提高匹配效率。KMP算法更聪明一些。它在开始全面搜索之前，会先研究一下小图片（模式串），找出一些特征，这样在大画布（主串）上搜索时，就能跳过一些明显不需要检查的地方。这就像是你记住了小图片的一些特征，然后在大画布上快速地找到可能匹配的地方。</strong></p><p><strong>KMP算法的核心是预处理模式串，创建一个“部分匹配表”，这个表告诉我们，当某个位置不匹配时，我们应该跳到模式串的哪个位置继续比较.</strong></p><p><strong>原理</strong><br><strong>1.预处理模式串，构建next数组。next数组记录了模式串中每个位置的最长相等前后缀的长度。</strong><br><strong>2.在匹配过程中，当遇到不匹配时，利用next数组跳过已经匹配的部分，避免回溯。</strong></p><p>还是刚才的例子，以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    computeNext(T, next);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = KMP(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p><strong>BF算法：简单易懂，但效率较低，时间复杂度为 O(n⋅m)</strong><br><strong>KMP算法：通过预处理模式串，利用next数组避免重复比较，提高匹配效率，时间复杂度为O(n+m)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
