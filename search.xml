<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2024/11/15/C++/%E5%88%9D%E5%A7%8BC/"/>
      <url>/2024/11/15/C++/%E5%88%9D%E5%A7%8BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="./%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B.md">面向对象与面向过程</a>，本节我将正式开始讲解关于C++的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>C++ 程序可以看作是由一组对象组成的，每个对象都有自己的特性和行为。这些对象通过互相调用方法来交流。现在让我们用简单的方式理解一下<strong>类</strong>、<strong>对象</strong>、<strong>方法</strong>和<strong>实例变量</strong>。</p><ol><li><p><strong>对象</strong>  </p><ul><li>对象就像是生活中的实物，它既有特性，也有行为。  <ul><li>比如：一只狗。  <ul><li><strong>特性</strong>：颜色（白色）、名字（小白）、品种（牧羊犬）。  </li><li><strong>行为</strong>：摇尾巴、叫、吃东西。</li></ul></li><li><strong>在程序中，对象是根据类创建出来的“实例”。</strong></li></ul></li></ul></li><li><p><strong>类</strong>  </p><ul><li>类可以看作是创建对象的“设计图”或者“模板”。  <ul><li>比如，“狗”这个类就描述了所有狗的共性（颜色、名字、品种）和它们可以做的事（摇尾巴、叫、吃东西）。  </li><li><strong>具体的狗（如小白、小黑）就是从这个类生成的对象。</strong></li></ul></li></ul></li><li><p><strong>方法</strong>  </p><ul><li>方法就是对象可以执行的“动作”或者“功能”。  <ul><li>对狗来说，方法可以是“叫”（bark()）、“吃”（eat()）。  </li><li><strong>方法中包含程序逻辑，定义了对象可以做的事情。</strong></li></ul></li></ul></li><li><p><strong>实例变量</strong>  </p><ul><li>实例变量是对象的“特性值”，每个对象都有自己的值。  <ul><li>比如，狗类中可能有变量“颜色”、“名字”。小白的颜色是白色，名字是“小白”；而小黑的颜色是黑色，名字是“小黑”。这些特性值存储在实例变量中，决定了对象的状态。</li></ul></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把类比作“模板”，对象是根据模板创建的“具体实例”，方法定义了对象的“行为”，而实例变量存储了对象的“特性值”。通过这种方式，我们可以用编程模拟真实世界中的事物和它们之间的交互。</p><h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h1><p>让我们看一段简单的代码，可以输出单词 Hello World</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来我们讲解一下这个程序:</strong></p><ol><li><p><strong>头文件 <code>&lt;iostream&gt;</code></strong>  </p><ul><li><code>&lt;iostream&gt;</code> 是一个标准库，提供输入输出功能。  </li><li>在这个程序中，它允许我们使用 <code>cout</code> 输出信息到屏幕上。</li></ul></li><li><p><strong><code>using namespace std;</code></strong>  </p><ul><li>告诉编译器我们要使用标准命名空间 <code>std</code>。  </li><li>这样，我们可以直接写 <code>cout</code> 而不用每次都写成 <code>std::cout</code>。</li></ul></li><li><p><strong>单行注释 <code>//</code></strong>  </p><ul><li>以 <code>//</code> 开头的部分是注释，它的作用是让程序员记录说明，编译器会忽略这些内容。  </li><li>比如 <code>// main() 是程序的开始</code>，是为了帮助人类理解程序的结构。</li></ul></li><li><p><strong>主函数 <code>int main()</code></strong>  </p><ul><li><code>main()</code> 是程序的入口点，每个 C++ 程序都需要这个函数。  </li><li>程序从这里开始运行。</li></ul></li><li><p><strong>输出语句 <code>cout &lt;&lt; &quot;Hello World&quot;;</code></strong>  </p><ul><li><code>cout</code> 是 C++ 用来输出信息到屏幕的工具。  </li><li>这句代码会在屏幕上打印 <code>Hello World</code>。</li></ul></li><li><p><strong><code>return 0;</code></strong>  </p><ul><li>这句话的意思是：程序运行结束，并返回一个值 <code>0</code> 给系统。  </li><li>在 C++ 中，返回 <code>0</code> 通常表示程序正常结束。</li></ul></li></ol><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤:</p><ol><li><p><strong>编写代码</strong>  </p><ul><li>打开一个文本编辑器，比如记事本或代码编辑器（如 VS Code、Sublime Text）。  </li><li>将前面写好的代码粘贴进去。</li></ul></li><li><p><strong>保存文件</strong>  </p><ul><li>将文件保存为 <code>hello.cpp</code>（扩展名必须是 <code>.cpp</code>，表示这是一个 C++ 程序）。</li></ul></li><li><p><strong>打开命令提示符</strong>  </p><ul><li>在 Windows 系统中，可以通过按下 <code>Win + R</code>，输入 <code>cmd</code> 打开命令提示符。  </li><li>使用 <code>cd</code> 命令进入保存 <code>hello.cpp</code> 文件的文件夹。<br>例如，如果文件在桌面上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编译代码</strong>  </p><ul><li>输入以下命令，按下回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure></li><li>如果代码没有错误，编译器会生成一个可执行文件，默认命名为 <code>a.exe</code>（在 Windows 中）或 <code>a.out</code>（在 Linux&#x2F;macOS 中）。</li></ul></li><li><p><strong>运行程序</strong>  </p><ul><li>在命令提示符中输入以下命令，运行生成的可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.exe    <span class="comment"># Windows 系统</span></span><br><span class="line">./a.out  <span class="comment"># Linux/macOS 系统</span></span><br></pre></td></tr></table></figure></li><li>你将看到屏幕上显示 <code>Hello World</code>。</li></ul></li></ol><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li><strong>什么是编译？</strong><br>编译是将我们写的 C++ 代码转换成机器能理解的二进制文件（可执行文件）的过程。  </li><li><strong>为什么需要编译？</strong><br>计算机只能理解二进制代码，因此必须先将源代码“翻译”成计算机语言，才能运行。<br>通过以上步骤，你的第一个 C++ 程序就成功运行了！</li></ul><h2 id="C-中的分号-语句块"><a href="#C-中的分号-语句块" class="headerlink" title="C++ 中的分号 &amp; 语句块"></a>C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束</p><h3 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h3><ol><li><p><strong>分号是语句结束的标志</strong>：  </p><ul><li>每条C++语句都需要以分号结尾，用来告诉编译器“这句话结束了”。</li><li>你可以把分号看成是句号，表示一个完整的逻辑结束。</li></ul></li><li><p><strong>示例</strong>：<br>下面是三条独立的语句，每条语句都以分号结束：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;         <span class="comment">// 把 y 的值赋给 x</span></span><br><span class="line">y = y + <span class="number">1</span>;     <span class="comment">// y 加 1 后赋值给 y</span></span><br><span class="line"><span class="built_in">add</span>(x, y);     <span class="comment">// 调用函数 add，把 x 和 y 作为参数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="语句块的作用"><a href="#语句块的作用" class="headerlink" title="语句块的作用"></a>语句块的作用</h3><ol><li><p><strong>语句块是逻辑上的一组代码</strong>：  </p><ul><li>使用大括号 <code>&#123;&#125;</code> 将多条语句包裹在一起，这些语句作为一个整体，通常用于函数、条件语句、循环等结构中。</li></ul></li><li><p><strong>示例</strong>：<br>下面是一个语句块，它包含两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 返回值 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同一行的多个语句"><a href="#同一行的多个语句" class="headerlink" title="同一行的多个语句"></a>同一行的多个语句</h3><ol><li><p><strong>C++ 不限制每行只能写一条语句</strong>：  </p><ul><li>你可以在同一行放置多条语句，只要每条语句以分号结束即可。</li></ul></li><li><p><strong>示例</strong>：<br>以下两种写法是等价的：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y; y = y + <span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>分号</strong>：是C++的语句结束符，必须添加。</li><li><strong>语句块</strong>：是一组用大括号 <code>&#123;&#125;</code> 包裹的语句，用于逻辑上的分组。</li><li><strong>多语句</strong>：C++允许多条语句写在一行，只需确保用分号分隔即可。<br>通过这些规则，你可以更灵活地组织代码。</li></ul><h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用于命名变量、函数、类等的符号，用来帮助程序员在代码中识别不同的内容。下面是一些详细解释：</p><ol><li><p><strong>命名规则</strong>：</p><ul><li>标识符必须以字母（A-Z或a-z）或下划线（_）开头。</li><li>后面可以跟字母、数字（0-9）或下划线的组合。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能包含特殊字符，如 <code>@</code>、<code>&amp;</code>、<code>%</code> 等。</li><li>C++ 区分大小写，也就是说 <code>apple</code> 和 <code>Apple</code> 是两个不同的标识符。</li></ul></li><li><p><strong>有效的标识符示例</strong>：</p><ul><li><code>mohd</code>, <code>zara</code>, <code>move_name</code>, <code>a_123</code>, <code>_temp</code> 等，符合规则。<br>通过这些规则，C++ 程序员可以创建各种命名来组织代码，使代码更有条理。</li></ul></li></ol><h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><h3 id="什么是三字符组？"><a href="#什么是三字符组？" class="headerlink" title="什么是三字符组？"></a>什么是三字符组？</h3><p>三字符组是用三个特定字符组合来表示其他字符的一种方法，通常以??开头。这是早期为了解决一些键盘上缺少特定字符的问题而设计的。虽然现代编译器和键盘已经不需要这个功能，但它仍然是C++标准的一部分。</p><h3 id="三字符组的常用替换规则"><a href="#三字符组的常用替换规则" class="headerlink" title="三字符组的常用替换规则"></a>三字符组的常用替换规则</h3><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>字符替换表</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>字符替换表</h2><table>    <tr>        <th>三字符组</th>        <th>替换</th>    </tr>    <tr>        <td>??=</td>        <td>#</td>    </tr>    <tr>        <td>??/</td>        <td>\</td>    </tr>    <tr>        <td>??'</td>        <td>^</td>    </tr>    <tr>        <td>??(</td>        <td>[</td>    </tr>    <tr>        <td>??)</td>        <td>]</td>    </tr>    <tr>        <td>??!</td>        <td>|</td>    </tr>    <tr>        <td>??&lt;</td>        <td>{</td>    </tr>    <tr>        <td>??&gt;</td>        <td>}</td>    </tr>    <tr>        <td>??-</td>        <td>~</td>    </tr></table></body></html><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用三字符组代替常规符号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> ??! std::endl;  <span class="comment">// ??! 替换成 |</span></span><br><span class="line">    <span class="type">int</span> arr??(<span class="number">3</span>??) = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">// ??( 和 ??) 替换成 [ 和 ]</span></span><br><span class="line">    std::cout &lt;&lt; arr??(<span class="number">0</span>??) &lt;&lt; std::endl;       <span class="comment">// 输出数组第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="三字符组的注意事项"><a href="#三字符组的注意事项" class="headerlink" title="三字符组的注意事项"></a>三字符组的注意事项</h3><p><strong>特殊情况避免替换</strong>：</p><p>如果你需要在字符串、字符常量或者注释中保留两个连续的问号，而不被自动替换，可以用以下方式：<br>转义序列：”???“。<br>字符串拼接：”??””?”。</p><p><strong>现代编译器支持：</strong></p><p>Microsoft Visual C++：从2010版开始，默认不再支持三字符组。如果需要启用，可以使用命令行选项&#x2F;Zc:trigraphs。<br>GCC编译器：仍支持三字符组，但会提示编译警告，表明这种用法已经过时。</p><h3 id="为什么了解三字符组？"><a href="#为什么了解三字符组？" class="headerlink" title="为什么了解三字符组？"></a>为什么了解三字符组？</h3><p>虽然三字符组在现代开发中极少使用，但在维护一些古老的代码时可能会遇到。这是一个有趣的历史遗留特性，了解它有助于更全面地理解C++语言的设计。</p><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><p>以下是对“C++ 中的空格”更通俗易懂的解释：</p><h3 id="空白行和空格"><a href="#空白行和空格" class="headerlink" title="空白行和空格"></a>空白行和空格</h3><ol><li><p><strong>空白行</strong>：只有空格或注释的行称为“空白行”。C++ 编译器会自动忽略这些行，它们不会影响代码运行。</p></li><li><p><strong>空格的作用</strong>：</p><ul><li>空格不仅指空白符，还包括制表符（Tab）、换行符和注释，它们都属于“空白符号”。</li><li>空格帮助编译器区分不同部分，比如在<code>int age;</code>这行代码中，<code>int</code>和<code>age</code>之间需要空格，这样编译器才能知道<code>int</code>是数据类型，<code>age</code>是变量名。</li></ul></li><li><p><strong>代码的可读性</strong>：</p><ul><li>在一些地方，空格不是必需的，比如在 <code>fruit = apples + oranges;</code> 中，<code>fruit</code> 和 <code>=</code> 之间不强制要求空格，但适当添加空格可以让代码更清晰，便于阅读。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>空格让代码更易读，帮助编译器识别代码中的不同部分。虽然有些地方空格不是必须的，但为了让代码更美观，推荐合理使用空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与面向过程</title>
      <link href="/2024/11/11/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/11/C++/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从现在开始我将正式开始分享一些C++程序的讲解，相信大家对于C语言并不陌生，我们接下来需要去学习的C++这个编程语言也跟C语言有关系，但是它与C语言有很大的区别，本节内容不会有代码的讲解，作为一个引文的作用，目的在于让大家认识到C++与C语言的区别，或者说面向对象程序设计语言与面向过程程序设计语言的区别，以便于之后更好的去理解代码、语法等等</strong></p><h1 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h1><h2 id="一-面向过程-OOP"><a href="#一-面向过程-OOP" class="headerlink" title="一.面向过程(OOP)"></a>一.面向过程(OOP)</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p><strong>面向过程是一种以步骤为核心的编程方式，逻辑比较线性。可以理解为<u>以完成任务为目标</u>，通过一系列有序的指令来操作数据，逐步完成任务。我们来具体谈谈：</strong></p><h4 id="游戏中的面向过程"><a href="#游戏中的面向过程" class="headerlink" title="游戏中的面向过程"></a>游戏中的面向过程</h4><p><strong>设想我们要设计一个战斗游戏，有以下角色和功能：</strong></p><p><strong>角色：玩家、怪物</strong><br><strong>功能：攻击、逃跑、升级</strong></p><p><strong>在面向过程的思维中，我们可以按照以下步骤实现：</strong></p><p><strong>1.定义玩家的属性：生命值、攻击力、防御力</strong><br><strong>2.定义怪物的属性：生命值、攻击力、防御力</strong><br><strong>3.编写函数：</strong><br><strong>玩家攻击函数——playerAttackMonster()：玩家攻击怪物，怪物的生命值减少</strong><br><strong>怪物攻击函数——monsterAttackPlayer()：怪物攻击玩家，玩家的生命值减少</strong><br><strong>升级函数——upgradePlayer()：玩家升级时提升攻击力和防御力</strong><br><strong>4.游戏逻辑：通过调用这些函数来实现游戏流程，如玩家攻击、怪物攻击、玩家升级等</strong>。<br><strong>我们可以看到，<u>游戏的主要逻辑由一系列的函数组成，这些函数一个接一个地执行</u></strong></p><p><strong>所以可以得到面向过程的特点：</strong><br><strong>1.步骤清晰：逐步执行代码，如先定义角色，再实现攻击功能</strong><br><strong>2.数据分散：每个角色的数据和行为都是分开的，玩家和怪物的属性、函数不相关</strong><br><strong>3.适合小型项目：如果游戏简单，面向过程的逻辑非常直观</strong></p><p><strong>但这也带来了面向过程的劣势：</strong><br><strong>1.代码重复：不同的角色可能要定义相似的属性（如生命值、攻击力等）</strong><br><strong>2.维护困难：如果要新增一个角色，如“弓箭手”，需要增加很多函数和属性，工作量增加</strong></p><h2 id="二-面向对象-POP"><a href="#二-面向对象-POP" class="headerlink" title="二.面向对象(POP)"></a>二.面向对象(POP)</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向对象是一种以数据和行为组合为核心的编程方式，结构较为模块化。它强调将数据和操作结合在一起，通过“类”和“对象”将复杂的任务组织为独立的模块，还是以游戏为例：</strong></p><h4 id="游戏中的面向对象"><a href="#游戏中的面向对象" class="headerlink" title="游戏中的面向对象"></a>游戏中的面向对象</h4><p><strong>在面向对象的思维中，我们可以通过创建类来封装角色和行为：</strong></p><p><strong>1.定义一个“玩家”类（Player）：</strong><br><strong>属性：生命值、攻击力、防御力等</strong><br><strong>方法：攻击怪物（attack()）、升级（levelUp()）</strong></p><p><strong>2.继承和扩展：</strong><br><strong>如果有不同类型的玩家角色，比如战士（Warrior）、法师（Mage），我们可以让Warrior和Mage继承Player类，这样它们就自动拥有了生命值、攻击力等属性和攻击、升级等方法</strong><br><strong>我们可以为Warrior增加“近战攻击”方法（meleeAttack()），为Mage增加“施法”方法（castSpell()），这样每种角色都有独特的行为，而不需要重复编写基础属性</strong></p><p><strong>3.怪物类（Monster）：</strong><br><strong>我们也可以定义一个Monster类，包含怪物的生命值和攻击力</strong><br><strong>通过定义方法如attackPlayer()，实现怪物对玩家的攻击</strong></p><p><strong>4.道具类（Item）：</strong><br><strong>还可以定义道具类，包含道具名称、效果等属性</strong><br><strong>比如药水类可以恢复玩家的生命值，而武器类可以提升玩家的攻击力</strong></p><p><strong>从上面的例子我们不难看出面向过程的特点：</strong><br><strong>1.模块化：每个类都包含属性和行为，Player类中的方法直接操作Player的数据，怪物则自成一体</strong><br><strong>2.继承性：Warrior、Mage继承自Player，只需扩展各自的特性，而无需重复代码</strong><br><strong>3.封装性：属性和行为封装在类内，外部代码无需关心具体实现，只需调用方法</strong><br><strong>4.扩展性：可以轻松添加新角色或功能，如增加“弓箭手”类，继承Player类，扩展新技能，不影响已有代码</strong></p><h2 id="三-面向对象-vs-面向过程：对比分析"><a href="#三-面向对象-vs-面向过程：对比分析" class="headerlink" title="三.面向对象 vs. 面向过程：对比分析"></a>三.面向对象 vs. 面向过程：对比分析</h2><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><strong>1.面向对象是对面向过程的进一步抽象，结构上更清晰，适合管理复杂系统</strong><br><strong>2.二者的基本逻辑相同，但面向对象在逻辑结构和扩展性上更优</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>1.核心思维：面向过程以步骤和流程为主，逐步实现目标。面向对象通过类和对象组织代码，模块化更高</strong><br><strong>2.代码结构：面向过程的代码较分散，面向对象将数据和操作结合，封装在类中，结构更紧密</strong><br><strong>3.适用场景：面向过程适合简单、线性逻辑；面向对象适合复杂系统，方便维护和扩展</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>通过面向对象编程，我们可以更轻松地在游戏中管理不同角色、怪物、道具的行为和状态。这种模块化的设计方式不仅让代码更易读，还使得后续扩展和维护更加简单。在C++中，面向对象为我们提供了丰富的表达能力，从而使游戏设计更具灵活性和扩展性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站 www.______.com😏</title>
      <link href="/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>先问大家一个问题：大家的浏览器收藏夹里面有多少好东西呢？😋</strong></p><p><strong>我收藏夹里藏着不少“古董级”的宝贝网站，就像那些被遗忘在阁楼角落里的旧玩具，虽然不常拿出来玩，但偶尔翻出来，总能发现一些意想不到的乐趣。这些网站可能平时默默无闻，但说不定在某个无聊的下午，它们就能给你带来惊喜，让你的浏览器收藏夹不再是“尘封的记忆”，而是“宝藏的宝库”。那么，这次我为大家带来了哪些新奇有趣的网站呢？让我们一起来看看，说不定能发现一些被我们忽略的“隐藏版”乐趣哦！</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p><strong>使用设备：电脑</strong><br><strong>获取方式：文章底部(每一个推荐网站的底部)</strong></p><h3 id="1-懒盘搜索——聚合搜索神器"><a href="#1-懒盘搜索——聚合搜索神器" class="headerlink" title="1. 懒盘搜索——聚合搜索神器"></a>1. 懒盘搜索——聚合搜索神器</h3><p><strong>这是一个非常好用的网盘搜索工具，包括音乐、电影、动漫、小说等等内容都能搜索到</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120117.png" alt="主页面" >  <img src="/img_2/QQ截图20241111120126.png" alt="聚合搜索界面" ></div><p><strong>电影搜索</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120237.png" alt="电影搜素" ></div><p><strong>学习资源</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120246.png" alt="学习资源" >  <img src="/img_2/QQ截图20241111121051.png" alt="学习资源" ></div><h4 id="懒盘搜索官网链接：https-www-lzpan-com"><a href="#懒盘搜索官网链接：https-www-lzpan-com" class="headerlink" title="懒盘搜索官网链接：https://www.lzpan.com/"></a>懒盘搜索官网链接：<a href="https://www.lzpan.com/">https://www.lzpan.com/</a></h4><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p><strong>虫部落是一个集结了海量资源的搜索平台。在这里，你能找到的资源大多是通过网盘链接分享的。只要你拥有相应的网盘账户，轻轻一点，就能迅速将资源保存到你的网盘中，然后直接下载，方便快捷</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111121454.png" alt="主页面" >  <img src="/img_2/QQ截图20241111121853.png" alt="部分内容" >  <img src="/img_2/QQ截图20241111121916.png" alt="部分内容" ></div><p><strong>这个平台就像是一个资源宝库，让寻找各类资料变得轻而易举。它极大地简化了我的日常搜索任务，让我能够快速获取所需资源，真是一个值得向大家推荐的实用工具</strong></p><h4 id="虫部落官网链接：http-www-chongbuluo-com"><a href="#虫部落官网链接：http-www-chongbuluo-com" class="headerlink" title="虫部落官网链接：http://www.chongbuluo.com/"></a>虫部落官网链接：<a href="http://www.chongbuluo.com/">http://www.chongbuluo.com/</a></h4><h3 id="3-考研百科网"><a href="#3-考研百科网" class="headerlink" title="3.考研百科网"></a>3.考研百科网</h3><p><strong>这个平台致力于为准备考研的学生提供全方位的支持，让他们能够提前掌握所需的学习资源和准备工作。该平台划分为四个核心板块，分别是考研入门知识、考研流程指导、考研目标规划和备考技巧建议</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111122642.png" alt="主页面" >  <img src="/img_2/QQ截图20241111122656.png" alt="部分内容" ></div><p><strong>这个网站提供了非常全面的资源，我就不在这里一一列举了。正在准备考研或者有意向考研的朋友们，可以查看下面的图表，或者直接访问这个网站来获取更多信息</strong></p><h4 id="考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk"><a href="#考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk" class="headerlink" title="考研百科官网链接：https://yz.chsi.com.cn/yzzt/kybk"></a>考研百科官网链接：<a href="https://yz.chsi.com.cn/yzzt/kybk">https://yz.chsi.com.cn/yzzt/kybk</a></h4><h3 id="一键抠图——在线图片处理神器"><a href="#一键抠图——在线图片处理神器" class="headerlink" title="一键抠图——在线图片处理神器"></a>一键抠图——在线图片处理神器</h3><p><strong>一键抠图是一个卓越的网络图像编辑工具，它提供了众多的图片处理功能，包括但不限于图像抠图、证件照制作、照片修复、文件格式转换、全面编辑以及图片裁剪等，这些功能全面覆盖了日常工作中可能遇到的图像编辑需求</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111123156.png" alt="主页面" ></div><p><strong>抠图功能使用起来非常简单便捷，即使是初学者也能快速掌握。用户只需选择相应的功能，上传图片，系统便会自动进行识别并提取图片中的核心元素，整个过程轻松无压力</strong><br><video controls><br>  <source src="/img_2/bandicam 2024-11-11 12-34-06-243.mp4" type="video/mp4"><br></video></p><h4 id="一键抠图官网链接：https-www-yijiankoutu-com"><a href="#一键抠图官网链接：https-www-yijiankoutu-com" class="headerlink" title="一键抠图官网链接：https://www.yijiankoutu.com/"></a>一键抠图官网链接：<a href="https://www.yijiankoutu.com/">https://www.yijiankoutu.com/</a></h4><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，我们每个人的周围其实都有着不少宝贵的资源，无论是知识、技能、人脉还是物质条件。这些资源就像是我们生活中的宝藏，等待着我们去发掘和利用。不要害怕去探索和尝试，因为每一次的尝试都可能开启新的可能性。让我们勇敢地迈出步伐，用开放的心态去学习，用智慧的眼光去发现，用创新的思维去整合。记住，善于利用身边的资源，不仅能帮助我们解决问题，还能让我们在成长的道路上走得更远。所以，请用好每一份资源，让它们成为我们成功的助力！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
            <tag> 宝藏网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对不住了，Steam！Steam 游戏发烧友必备😏</title>
      <link href="/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/"/>
      <url>/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>说到 Steam，那可是游戏爱好者心中的圣地，就像图书馆之于书虫，糖果店之于小朋友，那是一个应有尽有，让人眼花缭乱的地方。你想要最新的 3A 大作？没问题！在线游戏？小菜一碟！但问题是，这些游戏可不是免费派发的糖果，你得先掏腰包才能把它们领回家</strong><br><strong>如果你偶尔心血来潮，买一两个游戏，那钱包还能勉强保持微笑。但如果你是个游戏收藏家，那可就得小心了，你的钱包可能会因为过度兴奋而 “心脏病发作”</strong><br><strong>当然，如果游戏能让你爱不释手，那花点钱也值了。但最怕的就是，你花了钱，结果发现这游戏跟你八字不合，那可真是让人哭笑不得</strong><br><strong>所以，今天给大家介绍一个神奇的游戏下载盒子，它能让你在 Steam 的海洋里畅游，而不用掏空你的口袋。这可不是普通的盒子，它能让你免费享受那些让人垂涎三尺的游戏大餐。这就好比你走进了一家自助餐厅，却发现老板说：“今天免费，随便吃！” 这等好事，你怎能错过呢？</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：游戏盒子 (game box)</strong><br><strong>使用设备：电脑</strong><br><strong>软件大小：130.04MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p><strong>软件已经出了新版本，但是大家不需要进行更新，我觉得这个版本也是没啥问题，并且也是可以正常使用的，大家想更新的也可以选择更新试试看！然后大家也是能看到内置了超多的游戏资源～</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-41-37-709.mp4" type="video/mp4"><br></video></p><h3 id="游戏搜索"><a href="#游戏搜索" class="headerlink" title="游戏搜索"></a>游戏搜索</h3><p><strong>软件支持直接搜索，你可以通过搜索游戏并下载，下方也是有内置各种分类可供选择，可以在不同类别里发掘自己喜欢的游戏</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-43-08-343.mp4" type="video/mp4"><br></video></p><h3 id="安装路径与下载"><a href="#安装路径与下载" class="headerlink" title="安装路径与下载"></a>安装路径与下载</h3><p><strong>软件提供了一系列精彩的游戏资源，包括许多高品质的 3A 级作品。在开始下载之前，需要先登录天翼云网盘 (免费注册的)，再通过设置选项来指定下载和安装的位置，这样可以确保一切顺利进行。只需点击界面右上角的 “设置” 图标，就可以轻松地自定义您的下载和安装路径了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-04-45-737.mp4" type="video/mp4"><br></video></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p><strong>安装的方式也简单，找到自己喜欢的游戏后，点击安装按钮，然后选择游戏的版本号即可一键下载安装该游戏了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-12-23-001.mp4" type="video/mp4"><br></video></p><h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><strong>测试了一下游戏的下载速度，非常不错，开发大佬优化了下载速度，可以让大家快速的下载完成</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-15-17-955.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>通过网盘分享的文件：gamebox.exe</strong><br><strong>链接: <a href="https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg">https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg</a></strong><br><strong>提取码: e5sa</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>对于这些无私地提供免费软件的开发者们，我们应当怀有敬意和感激之情，向他们致敬🫡</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的歌曲</title>
      <link href="/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是我最近这段时间做的曲子，偏励志的歌曲，希望大家能够喜欢</strong></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="以下是歌词"><a href="#以下是歌词" class="headerlink" title="以下是歌词"></a>以下是歌词</h3><p><strong>歌名：Step By step</strong></p><p><strong>In the race of life, we take our place,</strong><br><strong>With hopes aflame, in this timeless chase.</strong><br><strong>Through storms we walk, lessons deep and wise,</strong><br><strong>With each dawn’s light, a new dream arises.</strong></p><p><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we claim the prize,</strong><br><strong>Eyes set forward, on dreams that rise.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step</strong><br><strong>Step by step</strong><br><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we’ll mark our way.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step, beyond the fear,</strong><br><strong>Through shadows cast, our way is clear.is clear</strong><br><strong>Step by step, we’re redefined,</strong><br><strong>Into a strength of heart and mind.</strong></p><p><strong>Lift your gaze, the world awaits,</strong><br><strong>The dawn of dreams, through future gates.</strong><br><strong>Step by step, we’ll mark our way,</strong><br><strong>Leaving echoes in history’s sway.</strong></p><h3 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h3><video controls>  <source src="/img_1/bandicam 2024-11-09 21-43-51-757.mp4" type="video/mp4"></video><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>进化是万物的自然法则 ，不问因由、不辨方向，只因适应便是生存的唯一。【成长】却是内心深处的觉醒，为更坚定的信念，心向未来，带着无悔的初心启程。 在探索中我们成长，不再因未知而迷茫，在风雨中我们成长，所有的挑战都将迎刃而解，跌倒的站起 ，彷徨的找到归途，仰望那片无际的星空，成长的力量化为无形的支柱，筑起我们心中坚不可摧的信念，成为那份无论何时都不曾动摇的守望！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以使用到下架的音乐软件</title>
      <link href="/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在这个快节奏的世界里，音乐无疑是我们心灵的慰藉，它如同一股清泉，滋润着我们的灵魂。今天想与大家分享的，不仅仅是一款音乐软件，而是一段音乐旅程的开始。这是一款简约而不简单的音乐应用。🙂</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：酷狗概念版</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：124.33MB</strong><br><strong>获取方式：文章底部</strong></p><div style="text-align:center">  <img src="/img_1/55CF549DC97727664019811146FF1E35.jpg" alt="主页面" ></div><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p><strong>想象一下，当你在繁忙的日常中寻找一丝宁静，这款软件就像是一位老朋友，静静地等待你的召唤。它的界面相对于其它几个平台的软件较为简洁，操作直观，只需轻轻一点，就能带你进入音乐的海洋。</strong></p><div style="text-align:center">  <img src="/img_1/5D3400BE1891D4531BD075F73B1F69E2.jpg" alt="播放界面" style="width:50%;">  <img src="/img_1/8BC982518DF64AE8D876DA37D4E8F6D1.jpg" alt="播放界面" style="width:50%;"></div><p><strong>与其他音乐平台相比，这款软件的独特之处在于它的“音乐故事”功能。在这里，每一首歌曲都不仅仅是旋律的堆砌，它们背后的故事，如同珍珠般串联起来，让你在聆听的同时，也能感受到音乐的深度与温度。</strong></p><p><strong>官方还更新了开屏画面，各位可以按照下面的方式去根据自己喜欢的风格壁纸设置</strong></p><div style="text-align:center">  <img src="/img_1/83885ACB3D60D33140B471BD706C4A9A.jpg" alt="" >  <img src="/img_1/1100F28525ACE1DC8B3B740DFFEF4C3A.jpg" alt="效果展示" style="width:50%;"></div><p><strong>值得一提的是这个软件的好处在于，每日都可以领取一日的VIP，只需要看五秒的广告，理论上可以一直不收费的听下去，这绝对是白嫖党的福利😀!</strong></p><div style="text-align:center">  <img src="/img_1/0C8331419A6D582631E22F5406EA3CF6.jpg" alt="" style="width:50%;">  <img src="/img_1/C92DEA934D74627728C5CF99FFA655FC.jpg" alt="" style="width:50%;"></div><p><strong>各位音乐爱好者们，如果你渴望在音乐的世界里寻找一份纯粹，那么这款软件定会是你的不二之选。让我们一起，随着音符跳跃，随着旋律起舞，不要错过这场音乐的盛宴。😆</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA">https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA</a></strong> <br><strong>提取码:iay2</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星际之舞：宇宙的诗篇</title>
      <link href="/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/img_1/9E0BE8E969CAC462282B28BDB3DF1AFE.jpg" alt="马头星云"></p><h3 id="星河璀璨"><a href="#星河璀璨" class="headerlink" title="星河璀璨"></a>星河璀璨</h3><p>  <strong>在浩瀚无垠的宇宙中，每一个星系都是一个独特的存在，它们以自己的方式讲述着宇宙的故事。 这张图片捕捉到了一个遥远星系的壮丽景象，它的中心散发出耀眼的光芒，仿佛是宇宙的灯塔，指引着迷失在星际间的旅者</strong></p><div style="text-align:center">  <img src="/img_1/7318400BB81BE3610CB7C214222D802A.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="旋舞银河"><a href="#旋舞银河" class="headerlink" title="旋舞银河"></a>旋舞银河</h3><p><strong>星系的旋臂如同宇宙的舞者，优雅地旋转着，上面点缀着无数的恒星，每一颗都在以自己的生命节奏闪烁。这些恒星的诞生、演化和死亡，构成了宇宙生命的交响曲。而那些暗淡的尘埃和气体，则是新恒星的摇篮，孕育着未来的光明</strong></p><div style="text-align:center">  <img src="/img_1/F872DED84FC80417240DFAA73466AD77.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/C880F01E01FF0D0849D9AFBB44BA7CA6.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="微光感悟"><a href="#微光感悟" class="headerlink" title="微光感悟"></a>微光感悟</h3><p> <strong>在这片星海中，我们不仅看到了宇宙的壮丽，也感受到了自己的渺小。然而，正是这种渺小，让我们对宇宙的探索充满了无限的好奇和渴望。每一次对星空的凝视，都是对未知的一次致敬，也是对人类探索精神的一次肯定。</strong></p><div style="text-align:center">  <img src="/img_1/34E6F253E9EB266011351DBB9C2F2082.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/39DC3EE370E1BC8F31E5739ED3707C34.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="远征"><a href="#远征" class="headerlink" title="远征"></a>远征</h3><p> <strong>每一颗星星都可能是一个新世界的开始。在这个无尽的宇宙之旅中，我们都是勇敢的探险者，追寻着知识的光，照亮前行的路。</strong></p><div style="text-align:center">  <img src="/img_1/CAA771D7E2B3AE60CE7475CD17304335.jpg" alt="拍摄＆后期 By 码头"></div><p><strong>自己拍摄的图，分享给大家，希望每个人都可以在自己的追寻的道路上走的足够远，成为有所建树的人😃</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款好用的音乐软件</title>
      <link href="/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在数字时代的浪潮中，音乐软件如同璀璨的星辰，点缀着我们的生活。今天我要向大家介绍的，是一款与众不同的音乐应用，它以其独特的魅力，悄然走进了我们的世界</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：速悦音乐</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：31.01MB</strong><br><strong>获取方式：文章底部</strong></p><p><strong>这款音乐软件如同一股清新的风，吹散了繁琐的注册登录流程(你可以不需要注册或登录就可以直接使用)，让你无需任何门槛，甚至可以下载音乐，即可直接沉浸在音乐的海洋中。它的首界面，简洁至极，如同一张白纸，等待着你用指尖的魔法，绘制出属于自己的音乐天地</strong></p><div style="text-align:center">  <img src="/img_1/488C7C60ED9CA57D5F062D06E558EBC5.jpg" alt="主页面" >  <img src="/img_1/42F2AA03FF2EF5FB741F2B8A6BADF78D.jpg" alt="播放界面" style="width:50%;" ></div><p><strong>顺带一提，下载音乐只需要分享就可以下载了(你可以不直接分享，点击分享按钮，再退出就好了，不过为了支持原作者，建议还是分享一下吧😁)，具体操作如下图</strong></p><div style="text-align:center">  <img src="/img_1/CA1AA8F8B40A78F3E4CD9932426B3C99.gif" alt="播放界面" ></div><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>不仅如此，这款软件还赋予了你无限的创造力。你可以根据自己的喜好，自定义界面，让每一次打开应用，都成为一场视觉与听觉的双重盛宴。无论是色彩的搭配，还是布局的调整，都能随心所欲，打造出一个完全属于你的音乐空间</strong><br><strong>你也可以设置界面是否为深色模式，以及背景的模糊度和透明度等，具体参照下图，这里就不再演示，可自行探索</strong></p><div style="text-align:center">  <img src="/img_1/7F3CFD25EB3A4E1502F4330A748F859C.jpg" alt="主题切换演示" >  <img src="/img_1/11259F93D8B82874CE5AE29E1C52F5D5.jpg" alt="这是我的主题" style="width:50%;" ></div><p><strong>朋友们，如果你厌倦了复杂的操作，渴望一份简单而纯粹的音乐体验，那么这款软件无疑是你的最佳选择。让我们一起，在这个小小的屏幕上，探索无限的音乐世界，享受那份只属于你的宁静与自由</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg">https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg</a></strong><br><strong>提取码:nt24</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>在我们国内不缺乏一些好用的音乐软甲，但很可惜的是，由于动了别人的蛋糕，难免会遭受排挤，诸如歌词适配，洛雪等老牌软件也未能幸免，想要找到一款好用的软件实属不易，但仍然有许多为爱发电的大佬开发的软件依旧在坚挺，向他们致敬🫡！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><p><strong>在此之前，我们先来聊聊递归的思想</strong><br><strong>递归是计算的基本思想之一，想象一下，你是一个老师，要解释什么是“递归”，你可能会说：“递归就是我给你们举的例子，这个例子就是递归的一个实例。” 这就是递归的本质：用递归自身来解释递归</strong></p><h2 id="递归的工作原理"><a href="#递归的工作原理" class="headerlink" title="递归的工作原理"></a>递归的工作原理</h2><p><strong>递归的工作原理可以想象成俄罗斯套娃，每个娃娃里面都有一个更小的娃娃，直到最小的那个。在编程中，这就像是函数A调用自己A，函数A又调用自己A，如此继续，直到达到最小的娃娃（也就是递归的基本情况），然后开始一层层解开，直到回到最初的那个函数A</strong><br><strong>再换一个例子，想象一下，你正在爬楼梯，每爬一阶，你就离顶层更近一步。递归也是这样，每次函数调用自己时，都会更接近基本情况（base case），也就是递归结束的条件</strong></p><h2 id="递归的两个关键部分"><a href="#递归的两个关键部分" class="headerlink" title="递归的两个关键部分"></a>递归的两个关键部分</h2><p><strong>1.基本情况（Base Case）：这是递归停止的条件，就像最小的俄罗斯套娃，没有更小的娃娃了。或则说，类似于你爬到顶层，就不再爬了在编程中，这通常是最简单的问题，可以直接解决，不需要进一步递归</strong><br><strong>递推关系（Recursive Case）：这是函数如何调用自己的部分，每次调用都应该让问题更接近基本情况</strong></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><h3 id="1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120"><a href="#1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120" class="headerlink" title="1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120"></a>1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120</h3><p>以下是C语言的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为0或1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回n乘以(n-1)的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u 的阶乘是 %llu\n&quot;</span>, num, factorial(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><p><strong>斐波那契数列是这样的数列：0, 1, 1, 2, 3, 5, 8, 13, …，其中每个数是前两个数的和。</strong></p><p>以下是C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 基本情况：如果n为0，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为1，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回前两个斐波那契数的和</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, num, fibonacci(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>递归在编程中是一种强大的编程技术，它通过函数自我调用来解决问题。在使用递归时，确保有明确的基本情况和递推关系，这样可以避免无限递归和栈溢出的问题。希望这些例子能帮助你理解递归的概念和应用</strong></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><strong>通过上面的例子你应该大致理解了递归的思想了，那么接下来我们回到本次要讲的正题————二叉树的遍历。相信学数据结构的同学对它一定不陌生！二叉树的遍历是按照某种规则，依次访问二叉树中的每个节点，每个节点只访问一次。主要有三种遍历方式：先序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）</strong></p><h2 id="先序遍历（Preorder-Traversal）"><a href="#先序遍历（Preorder-Traversal）" class="headerlink" title="先序遍历（Preorder Traversal）"></a>先序遍历（Preorder Traversal）</h2><p><strong>定义：先访问根节点，然后遍历左子树，最后遍历右子树</strong>。<br><strong>递归算法：访问根节点，然后对左子树和右子树递归执行先序遍历。</strong><br><strong>非递归算法：使用栈来模拟递归过程。首先将根节点入栈，然后循环执行以下步骤：弹出栈顶节点，访问它，然后将它的右子节点和左子节点依次入栈（注意顺序，先右后左）</strong></p><p><strong>假设我们有如下的二叉树：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于先序遍历，简单来说就是指按照“根节点 -&gt; 左子树 -&gt; 右子树”的顺序访问二叉树的每个节点,以下是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它打印根节点的值，然后递归地遍历左子树和右子树</strong><br><strong>遍历下来的结果就是：1, 2, 4, 5, 3</strong></p><p><strong>接下来是非递归的遍历算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode* node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.push(node-&gt;right); <span class="comment">// 先右后左，保持顺序</span></span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将根节点压入栈中，然后循环直到栈为空。在每次循环中，它弹出栈顶节点，访问它，然后将右子节点和左子节点依次压入栈中，所以遍历下来的结果就是：非递归遍历结果：1, 2, 4, 5, 3</strong></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>定义：先遍历左子树，然后访问根节点，最后遍历右子树</strong><br><strong>递归算法：对左子树递归执行中序遍历，访问根节点，然后对右子树递归执行中序遍历</strong><br><strong>非递归算法：使用栈来模拟递归过程。从根节点开始，将节点依次入栈直到到达最左节点，然后访问它并转向右子节点，重复此过程</strong></p><p><strong>还是上述的二叉树为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对与中序遍历便是指按照“左子树 -&gt; 根节点 -&gt; 右子树”的顺序访问二叉树的每个节点，以下是递归算法得的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    inOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树，打印根节点的值，然后递归地遍历右子树,所以遍历的结果便是：4, 2, 5, 1, 3</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它弹出栈顶节点，访问它，并转向其右子节点,所以遍历出来的结果便是：4, 2, 5, 1, 3</strong></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>定义：先遍历左子树，然后遍历右子树，最后访问根节点</strong><br><strong>递归算法：对左子树和右子树递归执行后序遍历，然后访问根节点</strong><br><strong>非递归算法：使用两个栈来模拟递归过程。第一个栈用于遍历，第二个栈用于反转遍历顺序。将根节点入第一个栈，然后循环执行以下步骤：从第一个栈中弹出节点并将其入第二个栈，然后将其子节点依次入第一个栈（注意顺序，先右后左）。当第一个栈为空时，从第二个栈中弹出节点并访问它们</strong></p><p><strong>二叉树例子同上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历便是指按照“左子树 -&gt; 右子树 -&gt; 根节点”的顺序访问二叉树的每个节点，接下来是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    postOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树和右子树，然后打印根节点的值，所以遍历出来的结果是：4, 5, 2, 6, 7, 3, 1</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right == <span class="literal">NULL</span> || current-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            prev = current;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它检查栈顶节点的右子节点是否为空或者是否已经访问过。如果是，它弹出栈顶节点，访问它，并更新prev节点。否则，它转向栈顶节点的右子节点,所以运行出来的结果便是：4, 5, 2, 6, 7, 3, 1</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>递归方法：直观，易于实现，但可能遇到栈溢出的问题</strong><br><strong>非递归方法：使用栈或队列来模拟递归过程，可以避免栈溢出的问题，但实现相对复杂</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，学习编程可能会在一开始感到有些挑战，但请记住，每个编程高手都是从基础开始，一步一个脚印走过来的。递归是编程中一个非常强大的工具，一旦你掌握了它，很多复杂的问题都会变得简单起来。记住，每个人的学习速度都是不同的，不要和别人比较，而是和昨天的自己比较。只要你们保持耐心和热情，不断练习，很快就能掌握递归的。加油，你们可以做到的！😉</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF算法与KMP算法</title>
      <link href="/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊数据结构中两种在字符串中寻找子串的方法：暴力匹配（BF算法）和KMP算法。<strong>这两种方法都像是在玩一个“找茬”游戏</strong>，目的是在一个大字符串（我们称之为主串）中找到一个小字符串（我们称之为模式串）出现的位置。</p><p>我们先举一个例子：<br><strong>假设主串为 “ababcabcacbab”，模式串为 “abcac”</strong></p><h2 id="暴力匹配（BF算法）"><a href="#暴力匹配（BF算法）" class="headerlink" title="暴力匹配（BF算法）"></a>暴力匹配（BF算法）</h2><p><strong>BF算法，也称为暴力匹配算法，是一种简单的字符串匹配方法。它的基本思想是从主串的每一个字符开始，逐个与模式串的字符进行比较，直到找到匹配的字符或比较完整个模式串。如果模式串中有某个字符不匹配，BF算法会回溯到主串的下一个字符重新开始匹配。想象一下，你手上有一张小图片（模式串），你想在一个巨大的画布（主串）上找到这张图片。使用暴力匹配的方法，你会从画布的最左边开始，试着把小图片的每个角对准画布上的每个点，看看是否能完全匹配。如果不匹配，你就向右移动一点，再试一次。这个过程会一直重复，直到你找到匹配的地方，或者把整个画布都试一遍。</strong></p><p><strong>原理</strong><br><strong>1.从主串的第一个字符开始，与模式串的第一个字符进行比较。</strong><br><strong>2.如果相等，则继续比较主串和模式串的下一个字符。</strong><br><strong>3.如果不相等，则主串指针回溯到上次匹配的首位的下一位，模式串指针回到开头，重新开始匹配。</strong><br><strong>4.重复上述过程，直到找到匹配的子串或主串遍历完毕。</strong></p><p>以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; S[i + j] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = BF(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h2><p><strong>KMP算法是一种改进的字符串匹配算法。它通过预处理模式串，构建部分匹配表（next数组），在匹配过程中利用已经匹配的信息，避免重复比较，从而提高匹配效率。KMP算法更聪明一些。它在开始全面搜索之前，会先研究一下小图片（模式串），找出一些特征，这样在大画布（主串）上搜索时，就能跳过一些明显不需要检查的地方。这就像是你记住了小图片的一些特征，然后在大画布上快速地找到可能匹配的地方。</strong></p><p><strong>KMP算法的核心是预处理模式串，创建一个“部分匹配表”，这个表告诉我们，当某个位置不匹配时，我们应该跳到模式串的哪个位置继续比较.</strong></p><p><strong>原理</strong><br><strong>1.预处理模式串，构建next数组。next数组记录了模式串中每个位置的最长相等前后缀的长度。</strong><br><strong>2.在匹配过程中，当遇到不匹配时，利用next数组跳过已经匹配的部分，避免回溯。</strong></p><p>还是刚才的例子，以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    computeNext(T, next);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = KMP(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p><strong>BF算法：简单易懂，但效率较低，时间复杂度为 O(n⋅m)</strong><br><strong>KMP算法：通过预处理模式串，利用next数组避免重复比较，提高匹配效率，时间复杂度为O(n+m)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
