<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ 数据结构</title>
      <link href="/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容是<code>C++ 基础教程</code>的最后一部分，对于这一节的内容，看不懂也没关系，等大家学习数据结构以后再来看就能够懂了。说说之后的安排吧，这一节内容结束以后，我将会分享更加深入的知识，也就是<code>C++ 面向对象</code>的相关内容，对于<code>C++ 基础教程</code>这一部分的内容如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C++ 数据结构"></a>C++ 数据结构</h1><p>在 C++ 中，数据结构是用来组织和管理数据的重要工具。C++ 提供了从简单到复杂的多种数据结构，既包括基础的数组、结构体，也包括强大的 STL（Standard Template Library）容器，如 <code>vector</code>、<code>map</code> 等。这些数据结构各有优缺点，适合不同的场景。以下是对这些数据结构的详细介绍。</p><hr><h2 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a><strong>1. 数组（Array）</strong></h2><h3 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a><strong>什么是数组？</strong></h3><p>数组是一组存储相同类型数据的连续内存块，可以通过索引访问元素。数组的大小在声明时固定，不能动态改变。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>连续存储</strong>：所有元素在内存中是连续分布的。</li><li><strong>固定大小</strong>：声明时确定大小，运行时无法更改。</li><li><strong>快速访问</strong>：通过索引直接访问元素，时间复杂度为 O(1)。</li><li><strong>适用场景</strong>：适合存储已知大小的同类型数据集合。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 定义一个整型数组</span></span><br><span class="line">cout &lt;&lt; arr[<span class="number">0</span>]; <span class="comment">// 输出第一个元素 1</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10</span>;    <span class="comment">// 修改第三个元素为 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>访问速度快（随机访问 O(1)）。  </li><li>内存紧凑。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法动态调整大小。  </li><li>插入和删除效率低（需要移动元素）。</li></ul></li></ul><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数值统计（如存储分数列表）。</li><li>固定大小的矩阵或表格。</li></ul><hr><h2 id="2-结构体（Struct）"><a href="#2-结构体（Struct）" class="headerlink" title="2. 结构体（Struct）"></a><strong>2. 结构体（Struct）</strong></h2><h3 id="什么是结构体？"><a href="#什么是结构体？" class="headerlink" title="什么是结构体？"></a><strong>什么是结构体？</strong></h3><p>结构体是一种自定义数据类型，可以将不同类型的数据组合在一起。它可以看作是“迷你数据库”，用来描述某些实体或对象。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>可以组合多种数据类型。</li><li>成员变量可以是基本类型或复杂类型。</li><li>提供基本的封装，但功能有限。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">cout &lt;&lt; p.name &lt;&lt; endl; <span class="comment">// 输出 &quot;Alice&quot;</span></span><br><span class="line">p.age = <span class="number">30</span>; <span class="comment">// 修改年龄</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>逻辑清晰，适合组织复杂数据。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不支持继承和多态，功能比类弱。</li></ul></li></ul><h3 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>用于表示实体对象，如学生、员工等。</li></ul><hr><h2 id="3-类（Class）"><a href="#3-类（Class）" class="headerlink" title="3. 类（Class）"></a><strong>3. 类（Class）</strong></h2><h3 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a><strong>什么是类？</strong></h3><p>类是面向对象编程的核心，可以定义数据（成员变量）和行为（成员函数）。与结构体类似，但功能更强大，支持继承、多态、封装等特性。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>成员变量默认是私有的（<code>private</code>）。</li><li>支持方法、构造函数、析构函数等。</li><li>支持继承和多态。</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">printInfo</span>(); <span class="comment">// 输出: Name: Bob, Age: 30</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>功能强大，适合大型项目。</li></ul></li><li><strong>缺点</strong>：  <ul><li>开发复杂度较高。</li></ul></li></ul><h3 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>面向对象设计中，如实现用户类、产品类等。</li></ul><hr><h2 id="4-链表（Linked-List）"><a href="#4-链表（Linked-List）" class="headerlink" title="4. 链表（Linked List）"></a><strong>4. 链表（Linked List）</strong></h2><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a><strong>什么是链表？</strong></h3><p>链表是一种动态数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：可以在运行时动态调整大小。</li><li><strong>高效插入&#x2F;删除</strong>：在链表头部或尾部操作的时间复杂度为 O(1)。</li><li><strong>线性查找</strong>：访问某个元素需要从头开始查找，时间复杂度为 O(n)。</li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;            <span class="comment">// 链表头指针</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// 新节点</span></span><br><span class="line">head = newNode;                  <span class="comment">// 将新节点插入链表</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态大小，插入&#x2F;删除效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>查找效率低，随机访问效率远不如数组。</li></ul></li></ul><h3 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数据流处理。</li><li>实现队列、栈等动态数据结构。</li></ul><hr><h2 id="5-栈（Stack）"><a href="#5-栈（Stack）" class="headerlink" title="5. 栈（Stack）"></a><strong>5. 栈（Stack）</strong></h2><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a><strong>什么是栈？</strong></h3><p>栈是一种后进先出（LIFO）的数据结构，像“弹簧盒”，只能从顶部插入和删除。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>只能操作栈顶元素。</li><li>插入和删除的时间复杂度为 O(1)。</li></ul><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);       <span class="comment">// 压栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">s.<span class="built_in">pop</span>();         <span class="comment">// 弹栈</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>操作简单，效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不能随机访问。</li></ul></li></ul><h3 id="典型应用-4"><a href="#典型应用-4" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>递归调用栈。</li><li>表达式求值。</li></ul><hr><h2 id="6-队列（Queue）"><a href="#6-队列（Queue）" class="headerlink" title="6. 队列（Queue）"></a><strong>6. 队列（Queue）</strong></h2><h3 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a><strong>什么是队列？</strong></h3><p>队列是一种先进先出（FIFO）的数据结构，像排队的队伍。</p><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>从队尾插入元素，从队头删除元素。</li><li>时间复杂度为 O(1)。</li></ul><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);        <span class="comment">// 入队</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>(); <span class="comment">// 输出 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();          <span class="comment">// 出队</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>按顺序处理数据，适合任务调度等场景。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法随机访问。</li></ul></li></ul><h3 id="典型应用-5"><a href="#典型应用-5" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>任务调度。</li><li>广度优先搜索（BFS）。</li></ul><hr><h2 id="7-动态数组（Vector）"><a href="#7-动态数组（Vector）" class="headerlink" title="7. 动态数组（Vector）"></a><strong>7. 动态数组（Vector）</strong></h2><h3 id="什么是动态数组？"><a href="#什么是动态数组？" class="headerlink" title="什么是动态数组？"></a><strong>什么是动态数组？</strong></h3><p><code>vector</code> 是 C++ 标准库提供的动态数组实现，可以根据需要自动扩展大小。</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：内存不足时会自动扩容。</li><li><strong>随机访问</strong>：支持通过索引访问元素，时间复杂度为 O(1)。</li></ul><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; v[<span class="number">0</span>]; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态调整大小，使用方便。</li></ul></li><li><strong>缺点</strong>：  <ul><li>插入&#x2F;删除中间元素效率较低。</li></ul></li></ul><h3 id="典型应用-6"><a href="#典型应用-6" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>动态增长的数据集合。</li></ul><hr><h2 id="8-哈希表（Hash-Table）"><a href="#8-哈希表（Hash-Table）" class="headerlink" title="8. 哈希表（Hash Table）"></a><strong>8. 哈希表（Hash Table）</strong></h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a><strong>什么是哈希表？</strong></h3><p>哈希表是一种通过键值对存储数据的结构，使用哈希函数快速定位元素。</p><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>快速操作</strong>：查找、插入和删除的时间复杂度为 O(1)。</li><li><strong>无序存储</strong>：元素存储顺序不固定。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">hashTable[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; hashTable[<span class="string">&quot;apple&quot;</span>]; <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>高效查找和操作。</li></ul></li><li><strong>缺点</strong>：  <ul><li>可能发生哈希冲突。</li></ul></li></ul><h3 id="典型应用-7"><a href="#典型应用-7" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>实现键值对存储，如字典。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>数据结构</th><th>特点</th><th>典型场景</th></tr></thead><tbody><tr><td>数组（Array）</td><td>连续存储，固定大小，快速随机访问</td><td>固定大小的数据集合</td></tr><tr><td>结构体（Struct）</td><td>组合不同类型的数据</td><td>实体对象描述</td></tr><tr><td>类（Class）</td><td>支持面向对象编程，封装数据与行为</td><td>复杂对象建模</td></tr><tr><td>链表（Linked List）</td><td>动态大小，高效插入&#x2F;删除，但查找效率低</td><td>数据流，动态数据集合</td></tr><tr><td>栈（Stack）</td><td>后进先出，操作简单</td><td>表达式求值，递归处理</td></tr><tr><td>队列（Queue）</td><td>先进先出，适合按顺序处理数据</td><td>任务调度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ vector容器</title>
      <link href="/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-vector容器"><a href="#C-vector容器" class="headerlink" title="C++ vector容器"></a>C++ vector容器</h1><p>在 C++ 中，<code>vector</code> 是一种非常强大的数据结构，它和数组类似，但功能更灵活。<strong>它是一个可以动态调整大小的数组</strong>，不需要你手动管理内存，是 C++ 标准模板库（STL）的一部分。</p><p>如果你需要一个可以自动扩展的数组来存储数据，<code>vector</code> 是你的首选。</p><hr><h2 id="为什么用-vector-而不是数组？"><a href="#为什么用-vector-而不是数组？" class="headerlink" title="为什么用 vector 而不是数组？"></a><strong>为什么用 <code>vector</code> 而不是数组？</strong></h2><p>数组虽然可以存储元素，但有几个缺点：</p><ol><li><strong>固定大小</strong>：数组在创建时必须指定大小，无法动态扩展或缩小。</li><li><strong>手动管理内存</strong>：如果需要动态数组，你必须手动分配和释放内存，容易出错。</li><li><strong>功能有限</strong>：数组没有直接提供添加、删除、查找等功能。</li></ol><p>而 <code>vector</code> 可以解决这些问题：</p><ul><li><strong>动态大小</strong>：<code>vector</code> 可以根据需要自动增长或缩小。</li><li><strong>连续存储</strong>：<code>vector</code> 的元素存储在连续的内存中，因此访问速度快。</li><li><strong>灵活接口</strong>：提供了丰富的操作方法，如添加、删除、清空等。</li></ul><hr><h2 id="如何使用-vector？"><a href="#如何使用-vector？" class="headerlink" title="如何使用 vector？"></a><strong>如何使用 <code>vector</code>？</strong></h2><h3 id="1-引入头文件"><a href="#1-引入头文件" class="headerlink" title="1. 引入头文件"></a>1. <strong>引入头文件</strong></h3><p>要使用 <code>vector</code>，必须包含 <code>&lt;vector&gt;</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="2-创建-vector"><a href="#2-创建-vector" class="headerlink" title="2. 创建 vector"></a>2. <strong>创建 <code>vector</code></strong></h3><p>创建 <code>vector</code> 和声明普通变量一样简单。</p><h4 id="示例：创建一个存储整数的-vector"><a href="#示例：创建一个存储整数的-vector" class="headerlink" title="示例：创建一个存储整数的 vector"></a>示例：创建一个存储整数的 <code>vector</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector; <span class="comment">// 创建一个空的整数向量</span></span><br></pre></td></tr></table></figure><h4 id="示例：创建时指定大小"><a href="#示例：创建时指定大小" class="headerlink" title="示例：创建时指定大小"></a>示例：创建时指定大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，初始值为默认值（0）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，每个元素初始值为10</span></span><br></pre></td></tr></table></figure><h4 id="示例：使用列表初始化"><a href="#示例：使用列表初始化" class="headerlink" title="示例：使用列表初始化"></a>示例：使用列表初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 创建一个包含元素1, 2, 3, 4, 5的向量</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-向-vector-添加元素"><a href="#3-向-vector-添加元素" class="headerlink" title="3. 向 vector 添加元素"></a>3. <strong>向 <code>vector</code> 添加元素</strong></h3><p>使用 <code>push_back</code> 方法，可以在 <code>vector</code> 的末尾添加元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">push_back</span>(<span class="number">7</span>); <span class="comment">// 向向量末尾添加元素7</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-访问-vector-中的元素"><a href="#4-访问-vector-中的元素" class="headerlink" title="4. 访问 vector 中的元素"></a>4. <strong>访问 <code>vector</code> 中的元素</strong></h3><p>你可以通过两种方式访问元素：</p><ul><li>**下标操作符 <code>[]</code>**：直接通过下标访问元素（从 0 开始计数）。</li><li><strong><code>at()</code> 方法</strong>：更安全的访问方法，会检查下标是否合法。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = myVector[<span class="number">0</span>];      <span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="type">int</span> y = myVector.<span class="built_in">at</span>(<span class="number">1</span>);   <span class="comment">// 获取第二个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-获取-vector-的大小"><a href="#5-获取-vector-的大小" class="headerlink" title="5. 获取 vector 的大小"></a>5. <strong>获取 <code>vector</code> 的大小</strong></h3><p>使用 <code>size()</code> 方法可以得到 <code>vector</code> 中的元素数量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = myVector.<span class="built_in">size</span>(); <span class="comment">// 获取向量大小</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-遍历-vector"><a href="#6-遍历-vector" class="headerlink" title="6. 遍历 vector"></a>6. <strong>遍历 <code>vector</code></strong></h3><p>你可以用多种方式遍历 <code>vector</code>：</p><h4 id="方法-1：普通-for-循环"><a href="#方法-1：普通-for-循环" class="headerlink" title="方法 1：普通 for 循环"></a>方法 1：普通 for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-2：迭代器"><a href="#方法-2：迭代器" class="headerlink" title="方法 2：迭代器"></a>方法 2：迭代器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-3：范围循环（推荐）"><a href="#方法-3：范围循环（推荐）" class="headerlink" title="方法 3：范围循环（推荐）"></a>方法 3：范围循环（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">    std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-删除元素"><a href="#7-删除元素" class="headerlink" title="7. 删除元素"></a>7. <strong>删除元素</strong></h3><p>使用 <code>erase()</code> 方法可以删除某个位置的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">// 删除第三个元素（下标为2）</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-清空-vector"><a href="#8-清空-vector" class="headerlink" title="8. 清空 vector"></a>8. <strong>清空 <code>vector</code></strong></h3><p>使用 <code>clear()</code> 方法可以清空 <code>vector</code> 中的所有元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">clear</span>(); <span class="comment">// 清空向量</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a><strong>完整实例</strong></h2><p>以下代码展示了如何创建一个 <code>vector</code>，添加、访问、删除、清空元素，并输出其内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到向量中</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问第一个和第二个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; myVector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; myVector.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取向量大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第三个元素</span></span><br><span class="line">    myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的向量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector after erasing: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空向量</span></span><br><span class="line">    myVector.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector after clearing: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Elements in the vector: 3 7 11 5</span><br><span class="line">First element: 3</span><br><span class="line">Second element: 7</span><br><span class="line">Size of the vector: 4</span><br><span class="line">Elements in the vector after erasing: 3 7 5</span><br><span class="line">Size of the vector after clearing: 0</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong><code>vector</code> 是一个动态数组</strong>，可以根据需要自动扩展或缩小。</li><li>使用方便：<ul><li>添加元素：<code>push_back()</code></li><li>删除元素：<code>erase()</code></li><li>访问元素：<code>[]</code> 或 <code>at()</code></li><li>遍历：普通循环、迭代器、范围循环。</li></ul></li><li><strong>适用场景</strong>：<ul><li>需要动态调整大小的数组。</li><li>需要频繁在末尾添加或移除元素。</li><li>需要高效的随机访问操作。</li></ul></li></ol><p><code>vector</code> 是 C++ 开发中最常用的容器之一，简单易用且功能强大，几乎可以胜任所有需要动态数组的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 结构体(struct)</title>
      <link href="/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/"/>
      <url>/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-结构体-struct"><a href="#C-结构体-struct" class="headerlink" title="C++ 结构体(struct)"></a>C++ 结构体(struct)</h1><p>在C++中，<strong>结构体（<code>struct</code>）</strong> 是一种非常有用的数据类型，它可以把多种类型的数据组合在一起，形成一个整体。简单来说，<strong>结构体就是一个容器，可以存放不同类型的变量，这些变量称为结构体的“成员”</strong>。</p><hr><h2 id="为什么需要结构体？"><a href="#为什么需要结构体？" class="headerlink" title="为什么需要结构体？"></a><strong>为什么需要结构体？</strong></h2><p>假设我们要管理一本书的信息，比如：</p><ul><li><strong>标题（Title）</strong>：比如《C++ 教程》</li><li><strong>作者（Author）</strong>：比如“张三”</li><li><strong>类别（Subject）</strong>：比如“编程”</li><li><strong>编号（Book ID）</strong>：比如“12345”</li></ul><p>这些属性的数据类型是不同的：</p><ul><li>标题和作者是<strong>字符串</strong>，</li><li>编号是<strong>整数</strong>。</li></ul><p>如果用普通的变量来存储这些信息，代码会变得杂乱无章：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string title1 = <span class="string">&quot;C++ 教程&quot;</span>;</span><br><span class="line">string author1 = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">string subject1 = <span class="string">&quot;编程&quot;</span>;</span><br><span class="line"><span class="type">int</span> bookID1 = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure><p>每增加一本书，就需要定义四个变量，管理起来非常麻烦。<br><strong>结构体</strong>解决了这个问题：它允许我们把这些相关的数据组合起来，作为一个整体来管理。</p><hr><h2 id="如何定义结构体？"><a href="#如何定义结构体？" class="headerlink" title="如何定义结构体？"></a><strong>如何定义结构体？</strong></h2><p>用 <code>struct</code> 关键字来定义结构体，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StructName</span> &#123;</span><br><span class="line">    DataType MemberName1; <span class="comment">// 第一个成员</span></span><br><span class="line">    DataType MemberName2; <span class="comment">// 第二个成员</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，定义一个用于表示“书籍”的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Book</code></strong> 是结构体类型的名字。</li><li>结构体里包含的成员有：<code>title</code>、<code>author</code>、<code>subject</code> 和 <code>book_id</code>。</li></ul><hr><h2 id="如何使用结构体？"><a href="#如何使用结构体？" class="headerlink" title="如何使用结构体？"></a><strong>如何使用结构体？</strong></h2><p>定义了结构体后，可以用它来创建“结构体变量”，表示具体的对象（如一本书）：</p><h3 id="1-创建结构体变量"><a href="#1-创建结构体变量" class="headerlink" title="1. 创建结构体变量"></a><strong>1. 创建结构体变量</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book book1, book2;</span><br></pre></td></tr></table></figure><p>上面创建了两个结构体变量 <code>book1</code> 和 <code>book2</code>，分别表示两本书。</p><h3 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2. 访问结构体成员"></a><strong>2. 访问结构体成员</strong></h3><p>结构体的成员可以通过 <strong><code>.</code> 运算符</strong> 来访问或赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book<span class="number">1.</span>book_id = <span class="number">12345</span>;               <span class="comment">// 设置编号</span></span><br><span class="line"><span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);     <span class="comment">// 设置标题</span></span><br><span class="line">cout &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;         <span class="comment">// 输出标题</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整示例：存储并输出两本书的信息"><a href="#完整示例：存储并输出两本书的信息" class="headerlink" title="完整示例：存储并输出两本书的信息"></a><strong>完整示例：存储并输出两本书的信息</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串处理函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个书的结构体变量</span></span><br><span class="line">    Book book1, book2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第一本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第二本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>author, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>subject, <span class="string">&quot;前端开发&quot;</span>);</span><br><span class="line">    book<span class="number">2.</span>book_id = <span class="number">12346</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第一本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书标题: &quot;</span> &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书作者: &quot;</span> &lt;&lt; book<span class="number">1.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书类别: &quot;</span> &lt;&lt; book<span class="number">1.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书编号: &quot;</span> &lt;&lt; book<span class="number">1.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第二本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书标题: &quot;</span> &lt;&lt; book<span class="number">2.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书作者: &quot;</span> &lt;&lt; book<span class="number">2.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书类别: &quot;</span> &lt;&lt; book<span class="number">2.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书编号: &quot;</span> &lt;&lt; book<span class="number">2.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一本书标题: C++ 教程</span><br><span class="line">第一本书作者: 张三</span><br><span class="line">第一本书类别: 编程</span><br><span class="line">第一本书编号: 12345</span><br><span class="line">第二本书标题: CSS 教程</span><br><span class="line">第二本书作者: 李四</span><br><span class="line">第二本书类别: 前端开发</span><br><span class="line">第二本书编号: 12346</span><br></pre></td></tr></table></figure><hr><h2 id="结构体的高级用法"><a href="#结构体的高级用法" class="headerlink" title="结构体的高级用法"></a><strong>结构体的高级用法</strong></h2><h3 id="1-结构体作为函数参数"><a href="#1-结构体作为函数参数" class="headerlink" title="1. 结构体作为函数参数"></a><strong>1. 结构体作为函数参数</strong></h3><p>可以把结构体传递给函数，用来操作结构体成员数据。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，打印书的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题: &quot;</span> &lt;&lt; book.title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作者: &quot;</span> &lt;&lt; book.author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类别: &quot;</span> &lt;&lt; book.subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; book.book_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book1;</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printBook</span>(book1); <span class="comment">// 调用函数打印书的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-指针操作结构体"><a href="#2-指针操作结构体" class="headerlink" title="2. 指针操作结构体"></a><strong>2. 指针操作结构体</strong></h3><p>用指针操作结构体变量，可以通过 <code>-&gt;</code> 运算符访问成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Book book1;</span><br><span class="line">Book* bookPtr = &amp;book1; <span class="comment">// 定义一个指向 book1 的指针</span></span><br><span class="line"></span><br><span class="line">bookPtr-&gt;book_id = <span class="number">12345</span>; <span class="comment">// 通过指针设置编号</span></span><br><span class="line">cout &lt;&lt; bookPtr-&gt;book_id; <span class="comment">// 通过指针获取编号</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-结构体中添加构造函数"><a href="#3-结构体中添加构造函数" class="headerlink" title="3. 结构体中添加构造函数"></a><strong>3. 结构体中添加构造函数</strong></h3><p>像类一样，结构体也可以有构造函数，用来初始化数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    string subject;</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Book</span>(string t, string a, string s, <span class="type">int</span> id)</span><br><span class="line">        : <span class="built_in">title</span>(t), <span class="built_in">author</span>(a), <span class="built_in">subject</span>(s), <span class="built_in">book_id</span>(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="function">Book <span class="title">book1</span><span class="params">(<span class="string">&quot;C++ 教程&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;编程&quot;</span>, <span class="number">12345</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a><strong>结构体和类的区别</strong></h2><ul><li><p><strong>默认访问权限不同</strong>：</p><ul><li><code>struct</code> 的成员默认是 <strong>public</strong>。</li><li><code>class</code> 的成员默认是 <strong>private</strong>。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>结构体</strong>：用于简单数据的封装，比如存储图书信息、学生信息等。</li><li><strong>类</strong>：用于更复杂的场景，比如需要继承、封装和多态的情况下。</li></ul></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ol><li><strong>结构体</strong> 是一种用户自定义的数据类型，用来把不同类型的数据组合成一个整体。</li><li>结构体可以用来管理复杂的数据，比如图书馆的书籍、学生的成绩等。</li><li>可以通过 <strong><code>.</code> 运算符</strong> 访问成员，也可以通过 <strong><code>-&gt;</code> 运算符</strong> 用指针访问。</li><li>结构体支持函数传参、构造函数、指针操作等高级用法。</li><li>和类类似，但结构体更轻量，适合简单的数据封装任务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本的输入输出</title>
      <link href="/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a>C++ 基本的输入输出</h1><p><strong>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</strong><br><strong>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</strong></p><p><strong>在C++中，有一些专门用来处理输入输出的头文件，它们让我们能够与用户交互，或处理文件。以下是最常用的输入输出头文件以及它们的用途：</strong></p><hr><h2 id="头文件及作用"><a href="#头文件及作用" class="headerlink" title="头文件及作用"></a>头文件及作用</h2><ol><li><p><strong><code>&lt;iostream&gt;</code></strong><br>提供 <strong>标准输入输出功能</strong>，例如用 <code>cin</code> 从键盘输入数据，<code>cout</code> 在屏幕输出数据。</p></li><li><p><strong><code>&lt;iomanip&gt;</code></strong><br>提供 <strong>格式化输出功能</strong>，比如设置小数点精度、对齐输出等操作，常用函数有 <code>setw</code> 和 <code>setprecision</code>。</p></li><li><p><strong><code>&lt;fstream&gt;</code></strong><br>提供 <strong>文件读写功能</strong>，用于从文件中读取数据或向文件写入数据。</p></li></ol><hr><h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a><strong>标准输出流（<code>cout</code>）</strong></h2><ul><li><p><strong><code>cout</code></strong> 用来在屏幕输出内容，通常和 <code>&lt;&lt;</code>（流插入运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出内容是：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出内容是：Hello C++</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&lt;&lt;</code> 操作符会根据变量类型自动选择适合的输出格式。</li><li><code>endl</code> 用于换行，相当于 <code>\n</code>，并且刷新输出缓冲区。</li></ul></li></ul><hr><h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a><strong>标准输入流（<code>cin</code>）</strong></h2><ul><li><p><strong><code>cin</code></strong> 用来从键盘输入数据，通常和 <code>&gt;&gt;</code>（流提取运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入您的名称： &quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;您的名称是：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行过程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入您的名称： cplusplus</span><br><span class="line">您的名称是： cplusplus</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&gt;&gt;</code> 会根据变量的类型读取输入数据。</li><li>如果需要输入多个数据，可以像这样使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a><strong>标准错误流（<code>cerr</code>）</strong></h2><ul><li><strong><code>cerr</code></strong> 用来输出错误消息，特点是 <strong>不经过缓冲，直接输出</strong>，适合需要立即显示的错误信息。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;错误信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a><strong>标准日志流（<code>clog</code>）</strong></h2><ul><li><strong><code>clog</code></strong> 用来输出日志信息，和 <code>cerr</code> 不同的是，<strong>它是缓冲的</strong>，日志信息会先存入缓冲区，等缓冲区满了或刷新时才会输出。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    clog &lt;&lt; <span class="string">&quot;日志信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><strong><code>cout</code></strong>: 用于正常输出，比如结果或普通信息。</li><li><strong><code>cin</code></strong>: 用于从键盘输入数据。</li><li><strong><code>cerr</code></strong>: 用于立即输出错误信息，适合显示错误日志。</li><li><strong><code>clog</code></strong>: 用于输出普通日志信息，会经过缓冲区，适合较少实时性的消息。</li></ol><p>尽管在小程序中 <code>cout</code>、<code>cerr</code> 和 <code>clog</code> 的区别不明显，但在复杂系统中，合理区分这些流有助于调试和维护代码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 日期＆时间</title>
      <link href="/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/"/>
      <url>/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-日期＆时间"><a href="#C-日期＆时间" class="headerlink" title="C++ 日期＆时间"></a>C++ 日期＆时间</h1><p>在C++编程中，我们可以通过标准库来操作日期和时间，但它没有专门的“日期类型”。取而代之的是通过结构和函数来处理。这些功能是从C语言继承而来的，需要使用 <code>&lt;ctime&gt;</code> 头文件。</p><p>C++ 提供了几种与时间相关的类型和结构：</p><ul><li><strong><code>time_t</code></strong>: 用于存储系统时间，表示从1970年1月1日开始的秒数。</li><li><strong><code>tm</code></strong>: 是一个结构体，用来表示更详细的日期和时间信息，比如年、月、日、时、分、秒等。</li></ul><h2 id="tm结构体长什么样？"><a href="#tm结构体长什么样？" class="headerlink" title="tm结构体长什么样？"></a><code>tm</code>结构体长什么样？</h2><p><code>tm</code> 是一个保存日期和时间信息的结构，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围 0-11（0表示1月）</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 从 1900 年起的年数（比如2024年对应值为124）</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围 0-6（0表示星期日）</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 是否是夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见日期和时间的操作函数"><a href="#常见日期和时间的操作函数" class="headerlink" title="常见日期和时间的操作函数"></a>常见日期和时间的操作函数</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>time()</code></td><td>获取当前时间（从1970年到现在的秒数）</td></tr><tr><td><code>localtime()</code></td><td>将时间转换为本地时间，并返回 <code>tm</code> 结构</td></tr><tr><td><code>gmtime()</code></td><td>将时间转换为 UTC 时间（格林威治时间），返回 <code>tm</code> 结构</td></tr><tr><td><code>ctime()</code></td><td>将时间转换为可读的字符串，比如 <code>Mon Jan 1 12:34:56 2024</code></td></tr><tr><td><code>asctime()</code></td><td>将 <code>tm</code> 结构转换为字符串形式</td></tr><tr><td><code>difftime()</code></td><td>计算两个时间点的秒差</td></tr><tr><td><code>strftime()</code></td><td>自定义格式化输出时间</td></tr></tbody></table><hr><h2 id="实例1：获取当前日期和时间"><a href="#实例1：获取当前日期和时间" class="headerlink" title="实例1：获取当前日期和时间"></a>实例1：获取当前日期和时间</h2><p>以下代码演示如何获取并打印系统的当前时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="type">char</span>* dt = <span class="built_in">ctime</span>(&amp;now); <span class="comment">// 转换为字符串形式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tm *gmtm = <span class="built_in">gmtime</span>(&amp;now); <span class="comment">// 转换为 UTC 时间</span></span><br><span class="line">    dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地日期和时间：Sat Nov 16 15:35:21 2024</span><br><span class="line">UTC 日期和时间：Sat Nov 16 07:35:21 2024</span><br></pre></td></tr></table></figure><hr><h2 id="实例2：格式化日期和时间"><a href="#实例2：格式化日期和时间" class="headerlink" title="实例2：格式化日期和时间"></a>实例2：格式化日期和时间</h2><p>使用 <code>tm</code> 结构可以详细访问时间信息，比如年、月、日等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    tm *ltm = <span class="built_in">localtime</span>(&amp;now); <span class="comment">// 转换为本地时间结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间的各个组成部分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1970到现在经过的秒数：&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年: &quot;</span> &lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;月: &quot;</span> &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;日: &quot;</span> &lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;时间: &quot;</span> &lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1970到现在经过的秒数：1737093321</span><br><span class="line">当前时间：</span><br><span class="line">年: 2024</span><br><span class="line">月: 11</span><br><span class="line">日: 16</span><br><span class="line">时间: 15:35:21</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li><strong><code>time_t</code></strong> 是一个简单的整数类型，用来表示时间戳。</li><li><strong><code>tm</code></strong> 是一个更复杂的结构，用来处理年月日等详细信息。</li><li>我们可以通过函数（如 <code>localtime</code> 或 <code>gmtime</code>）来获取和转换时间，然后打印出想要的格式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/2024/11/16/C-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/11/16/C-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="什么是引用？"><a href="#什么是引用？" class="headerlink" title="什么是引用？"></a>什么是引用？</h2><p>在 C++ 中，<strong>引用</strong> 就是变量的另一个名字（别名）。<br>可以把它理解成一个“昵称”：通过这个昵称，和直接用变量名字效果是一样的，操作的都是同一个数据。<br>一旦给变量起了这个“昵称”，就不能再改了，引用会一直绑定在这个变量上。</p><hr><h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><p>虽然引用和指针都能用来间接访问变量的内容，但它们有以下重要区别：</p><ol><li><p><strong>引用必须合法</strong>：  </p><ul><li>引用在创建时，必须绑定到一个有效的变量。  </li><li>指针可以为空（指向 <code>NULL</code>），或者在以后指向其他变量。</li></ul></li><li><p><strong>绑定不可更改</strong>：  </p><ul><li>引用一旦和某个变量绑定，就不能改为绑定其他变量。  </li><li>指针可以随时指向其他变量。</li></ul></li><li><p><strong>必须初始化</strong>：  </p><ul><li>引用在创建时，必须立刻绑定到某个变量。  </li><li>指针可以在创建时不赋值，稍后再初始化。</li></ul></li></ol><hr><h2 id="如何创建引用？"><a href="#如何创建引用？" class="headerlink" title="如何创建引用？"></a>如何创建引用？</h2><p>想象变量是贴在内存位置上的标签，引用就是这个标签的第二个名字。<br>用法很简单，直接用符号 <code>&amp;</code> 创建一个引用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">17</span>;  <span class="comment">// 定义一个变量 i</span></span><br><span class="line"><span class="type">int</span>&amp; r = i;  <span class="comment">// 给 i 起了一个别名 r</span></span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>r</code> 是变量 <code>i</code> 的引用。</li><li>无论是用 <code>i</code> 还是用 <code>r</code>，操作的都是同一个数据。</li></ul><hr><h2 id="一个完整例子"><a href="#一个完整例子" class="headerlink" title="一个完整例子"></a>一个完整例子</h2><p>来看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明简单变量</span></span><br><span class="line">    <span class="type">int</span> i;        <span class="comment">// 一个整型变量</span></span><br><span class="line">    <span class="type">double</span> d;     <span class="comment">// 一个 double 型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明引用变量</span></span><br><span class="line">    <span class="type">int</span>&amp; r = i;   <span class="comment">// r 是 i 的引用</span></span><br><span class="line">    <span class="type">double</span>&amp; s = d; <span class="comment">// s 是 d 的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 i 和 d 赋值</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    d = <span class="number">11.7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过变量名和引用名访问值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i: &quot;</span> &lt;&lt; i &lt;&lt; endl;         <span class="comment">// 直接用 i</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i reference: &quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="comment">// 用引用 r</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d: &quot;</span> &lt;&lt; d &lt;&lt; endl;         <span class="comment">// 直接用 d</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d reference: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// 用引用 s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 5</span><br><span class="line">Value of i reference: 5</span><br><span class="line">Value of d: 11.7</span><br><span class="line">Value of d reference: 11.7</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p><strong><code>int&amp; r = i;</code></strong>  </p><ul><li>这里 <code>r</code> 是变量 <code>i</code> 的别名。之后，无论是通过 <code>r</code> 还是通过 <code>i</code> 修改值，结果都是一样的，因为它们指向同一块内存。</li></ul></li><li><p><strong><code>double&amp; s = d;</code></strong>  </p><ul><li>这里 <code>s</code> 是变量 <code>d</code> 的别名，类似上面。</li></ul></li></ul><p><strong>总结</strong>：引用就是变量的另一个名字，引用名和变量名操作的是同一个值。</p><hr><h2 id="引用的两个重要用法"><a href="#引用的两个重要用法" class="headerlink" title="引用的两个重要用法"></a>引用的两个重要用法</h2><ol><li><p><strong>引用作为函数参数</strong>  </p><ul><li>在函数参数中使用引用，可以让函数直接操作传入的变量，而不是创建一个副本。  </li><li>这种方法既高效，又可以避免不必要的数据拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);  <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 输出 a: 10, b: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>swap</code> 函数的参数是引用，因此可以直接修改 <code>a</code> 和 <code>b</code> 的值，而不需要返回值。</li></ul></li><li><p><strong>引用作为函数返回值</strong>  </p><ul><li>可以从函数中返回一个引用，这样可以直接操作返回的值，而不需要拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];  <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">getReference</span>(numbers, <span class="number">1</span>) = <span class="number">50</span>;  <span class="comment">// 修改数组的第二个元素</span></span><br><span class="line">    cout &lt;&lt; numbers[<span class="number">1</span>] &lt;&lt; endl;     <span class="comment">// 输出 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>getReference</code> 返回的是数组元素的引用，因此可以直接修改数组内容，而不需要拷贝数据。</li></ul></li></ol><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><p><strong>什么是引用？</strong><br>引用是变量的另一个名字（昵称），操作引用就等于操作变量本身。</p></li><li><p><strong>引用有什么用？</strong>  </p><ul><li>减少不必要的数据拷贝，提高效率。</li><li>让代码更简洁，比如用在函数参数或返回值中。</li></ul></li><li><p><strong>引用和指针的区别？</strong>  </p><ul><li>引用更安全，因为它不能是空引用，且绑定后不能改变。</li><li>指针更灵活，因为它可以为空，也可以随时指向其他变量。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针</title>
      <link href="/2024/11/16/C-%E6%8C%87%E9%92%88/"/>
      <url>/2024/11/16/C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容我们将正式进入指针的学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><p>C++ 中的 <strong>指针</strong> 就像一个“地址簿”，它记录了存储某个值的“房子”（内存位置）的地址。学习指针是 C++ 编程的重要部分，因为它不仅可以让你写出更高效的代码，还能完成像 <strong>动态内存分配</strong> 这样的高级操作，这些是没有指针无法实现的。</p><h3 id="什么是地址？"><a href="#什么是地址？" class="headerlink" title="什么是地址？"></a>什么是地址？</h3><p>每个变量（比如 <code>int</code>、<code>char</code> 等）在计算机的内存中都占据一个“房子”（内存位置）。这个房子有自己的“地址”，就像你家的门牌号一样，唯一且能指引我们找到这个变量存储在哪里。</p><p>在 C++ 中，可以使用符号 <code>&amp;</code>（取地址符）来获取变量的地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1;         <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">char</span> var2[<span class="number">10</span>];    <span class="comment">// 定义一个字符数组</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出的地址是什么？"><a href="#输出的地址是什么？" class="headerlink" title="输出的地址是什么？"></a>输出的地址是什么？</h3><p>当这段代码运行时，会输出类似下面的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 变量的地址： 0xbfebd5c0</span><br><span class="line">var2 变量的地址： 0xbfebd5b6</span><br></pre></td></tr></table></figure><p>这些看起来像一串奇怪的数字（比如 <code>0xbfebd5c0</code>），其实是计算机给变量分配的“内存地址”。通过这些地址，程序可以快速找到变量的位置，访问或者操作它的值。</p><h3 id="更通俗的比喻"><a href="#更通俗的比喻" class="headerlink" title="更通俗的比喻"></a>更通俗的比喻</h3><p>假设你的内存是一个巨大的公寓楼，每个房间都有一个房号（内存地址）：</p><ul><li><code>var1</code> 是住在某个房间的小明，他的房间号是 <code>0xbfebd5c0</code>。</li><li><code>var2</code> 是住在另一个房间的小红，她的房间号是 <code>0xbfebd5b6</code>。</li></ul><p>如果你想找小明或小红，只需要知道他们的房间号（地址），然后直接去找就可以了。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>变量</strong> 是房间里的住户。</li><li><strong>内存地址</strong> 是房间号。</li><li>用 <code>&amp;</code> 可以查到变量住在哪个房间（内存地址）。</li></ul><p>指针就是“记住房间号”的一种方式，后面你会学习如何用指针操作变量的值，让编程更加灵活和高效！</p><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针是一个变量，存放着另一个变量的“地址”（类似于一个门牌号）。通过这个门牌号，我们可以找到并操作那个变量。<br>想象一下，一个指针就像地图上的标记，指向某个具体位置（变量所在的内存地址）。</p><hr><h3 id="如何声明一个指针？"><a href="#如何声明一个指针？" class="headerlink" title="如何声明一个指针？"></a>如何声明一个指针？</h3><p>在 C++ 中，声明指针的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><strong><code>type</code></strong> 是指针指向的变量类型，比如 <code>int</code>、<code>float</code> 等。</li><li><strong><code>*</code></strong> 告诉编译器这个变量是一个指针，而不是普通变量。</li><li><strong><code>var-name</code></strong> 是指针变量的名称。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">// 一个整型指针</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">// 一个 double 型指针</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">// 一个浮点型指针</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">// 一个字符型指针</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>*</code> 在这里的作用是“定义指针”，而不是数学中的乘号。</p><hr><h3 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h3><p>指针的主要操作可以分为以下几步：</p><ol><li><strong>定义指针变量</strong>：告诉编译器，你要存储某个变量的地址。</li><li><strong>存储地址到指针变量</strong>：通过取地址符 <code>&amp;</code>，获取变量的内存地址，并存储到指针中。</li><li><strong>访问地址对应的值</strong>：通过解引用符 <code>*</code>，获取指针指向的变量的值。</li></ol><hr><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们通过一个简单的程序来说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">20</span>;    <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">int</span> *ip;         <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"></span><br><span class="line">    ip = &amp;var;       <span class="comment">// 将 var 的地址赋值给指针 ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出存储在指针 ip 中的地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span> &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of var variable: 20</span><br><span class="line">Address stored in ip variable: 0xbfc601ac</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure><hr><h3 id="程序的核心解释"><a href="#程序的核心解释" class="headerlink" title="程序的核心解释"></a>程序的核心解释</h3><ol><li><p><strong><code>int var = 20;</code></strong><br>定义一个整数变量，值为 20。</p></li><li><p><strong><code>int *ip;</code></strong><br>定义了一个指针变量 <code>ip</code>，它可以存储一个整数变量的地址。</p></li><li><p><strong><code>ip = &amp;var;</code></strong><br>使用取地址符 <code>&amp;</code>，获取变量 <code>var</code> 的地址，并存储到指针 <code>ip</code> 中。<br>此时，<code>ip</code> 的值就是 <code>var</code> 在内存中的地址。</p></li><li><p><strong>输出指针指向的值</strong><br>使用解引用符 <code>*ip</code>，可以通过指针访问变量 <code>var</code> 的值。<br>也就是说，<code>*ip</code> 等价于 <code>var</code>。</p></li></ol><hr><h3 id="指针的本质"><a href="#指针的本质" class="headerlink" title="指针的本质"></a>指针的本质</h3><p>无论指针指向的是整数、浮点数还是字符，<strong>指针的实际值都是内存地址</strong>（一个十六进制数）。<br>指针的类型（比如 <code>int*</code> 或 <code>char*</code>）是为了告诉编译器，指针指向的变量是什么类型，从而正确操作。</p><hr><h3 id="C-中的一些指针概念"><a href="#C-中的一些指针概念" class="headerlink" title="C++ 中的一些指针概念"></a>C++ 中的一些指针概念</h3><table><thead><tr><th><strong>概念</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>空指针</strong></td><td>指向“空地址”的指针（<code>NULL</code>）。如果指针未初始化，最好设为 NULL，避免意外使用。</td></tr><tr><td><strong>指针运算</strong></td><td>可以对指针做加减法（比如指向下一个元素）。</td></tr><tr><td><strong>指针与数组</strong></td><td>数组的名称本质上是一个指向数组第一个元素的指针。</td></tr><tr><td><strong>指针数组</strong></td><td>数组可以存储多个指针，称为“指针数组”。</td></tr><tr><td><strong>指向指针的指针</strong></td><td>一个指针可以指向另一个指针，称为“二级指针”或“指向指针的指针”。</td></tr><tr><td><strong>传递指针给函数</strong></td><td>通过指针传参，可以直接操作原始数据，而不是拷贝数据。</td></tr><tr><td><strong>从函数返回指针</strong></td><td>函数可以返回一个指针，指向局部变量、静态变量或动态分配的内存。</td></tr></tbody></table><hr><h3 id="通俗总结"><a href="#通俗总结" class="headerlink" title="通俗总结"></a>通俗总结</h3><ol><li><p><strong>指针是什么？</strong><br>它是“一个变量的地址”。</p></li><li><p><strong>指针能干什么？</strong>  </p><ul><li>指向一个变量，间接操作它的值。</li><li>动态管理内存（比如数组的大小可以运行时确定）。</li></ul></li><li><p><strong>如何理解指针？</strong>  </p><ul><li>想象成地图上的标记：指针记录了某个地点（变量）的地址。通过标记，我们可以访问这个地点的内容。</li></ul></li><li><p><strong>为什么要用指针？</strong><br>指针让代码更高效，可以节省内存，快速定位变量，实现复杂的数据结构（如链表、树等）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串</title>
      <link href="/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><p><strong>C 风格字符串</strong><br><strong>C++ 引入的 string 类类型</strong></p><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="**C风格字符串"></a>**C风格字符串</h2><p>在 C 和 C++ 中，字符串实际上是用来存放文字或字符的一种特殊的 <strong>字符数组</strong>，并在最后加上一个 **特殊符号 <code>\0</code>**（表示字符串结束）。我们称这种字符串为 <strong>C 风格字符串</strong>。</p><hr><h3 id="字符串的本质：字符数组"><a href="#字符串的本质：字符数组" class="headerlink" title="字符串的本质：字符数组"></a><strong>字符串的本质：字符数组</strong></h3><ul><li>就像一个储物柜，里面每个格子存放一个字符。</li><li>字符串的末尾会有一个 **隐藏的结束符 <code>\0</code>**，告诉程序「字符串到这里就结束了」。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>site</code> 是一个字符数组，包含：</p><ul><li><strong>6 个字符</strong>：<code>R</code>、<code>U</code>、<code>N</code>、<code>O</code>、<code>O</code>、<code>B</code></li><li><strong>1 个结束符</strong>：<code>&#39;\0&#39;</code></li></ul><p>储存结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位置：  [0]  [1]  [2]  [3]  [4]  [5]  [6]</span><br><span class="line">字符：  &#x27;R&#x27;  &#x27;U&#x27;  &#x27;N&#x27;  &#x27;O&#x27;  &#x27;O&#x27;  &#x27;B&#x27;  &#x27;\0&#x27;</span><br></pre></td></tr></table></figure><p>因为有 <code>\0</code>，字符串的大小比字符数多 1。</p><hr><h3 id="字符串的简化写法"><a href="#字符串的简化写法" class="headerlink" title="字符串的简化写法"></a><strong>字符串的简化写法</strong></h3><p>你可以用更简单的方式直接初始化字符串，程序会自动在末尾加上 <code>\0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>等同于</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>所以 <code>site</code> 中存储的内容依然是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;RUNOOB\0&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串的打印"><a href="#字符串的打印" class="headerlink" title="字符串的打印"></a><strong>字符串的打印</strong></h3><p>在 C++ 中，<code>cout</code> 遇到字符串时，会从第一个字符开始输出，一直到碰到 <code>\0</code> 结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;网站名: &quot;</span> &lt;&lt; site &lt;&lt; endl; <span class="comment">// 输出 &quot;RUNOOB&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网站名: RUNOOB</span><br></pre></td></tr></table></figure><hr><h3 id="常用的字符串操作函数"><a href="#常用的字符串操作函数" class="headerlink" title="常用的字符串操作函数"></a><strong>常用的字符串操作函数</strong></h3><p>C++ 提供了一些常用的函数来操作 C 风格字符串，这些函数都在 <code>&lt;cstring&gt;</code> 头文件中。</p><h3 id="1-strcpy：字符串复制"><a href="#1-strcpy：字符串复制" class="headerlink" title="1. strcpy：字符串复制"></a><strong>1. <code>strcpy</code>：字符串复制</strong></h3><p>把一个字符串复制到另一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(str2, str1); <span class="comment">// 把 str1 的内容复制到 str2</span></span><br><span class="line">cout &lt;&lt; str2;       <span class="comment">// 输出：runoob</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-strcat：字符串拼接"><a href="#2-strcat：字符串拼接" class="headerlink" title="2. strcat：字符串拼接"></a><strong>2. <code>strcat</code>：字符串拼接</strong></h3><p>把一个字符串追加到另一个字符串的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2); <span class="comment">// 拼接：str1 = &quot;runoobgoogle&quot;</span></span><br><span class="line">cout &lt;&lt; str1;       <span class="comment">// 输出：runoobgoogle</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-strlen：字符串长度"><a href="#3-strlen：字符串长度" class="headerlink" title="3. strlen：字符串长度"></a><strong>3. <code>strlen</code>：字符串长度</strong></h3><p>计算字符串的长度（不包括 <code>\0</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 长度是 6</span></span><br><span class="line">cout &lt;&lt; len;           <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-strcmp：字符串比较"><a href="#4-strcmp：字符串比较" class="headerlink" title="4. strcmp：字符串比较"></a><strong>4. <code>strcmp</code>：字符串比较</strong></h3><p>比较两个字符串的大小：</p><ul><li>如果相等，返回 <code>0</code></li><li>如果第一个字符串比第二个小，返回负值</li><li>如果第一个字符串比第二个大，返回正值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2); <span class="comment">// 返回正值，因为 &quot;runoob&quot; &gt; &quot;google&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-strchr：查找字符"><a href="#5-strchr：查找字符" class="headerlink" title="5. strchr：查找字符"></a><strong>5. <code>strchr</code>：查找字符</strong></h3><p>在字符串中查找某个字符的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strchr</span>(str, <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 找到 &#x27;n&#x27;，返回其地址</span></span><br><span class="line">cout &lt;&lt; *pos;                <span class="comment">// 输出：n</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-strstr：查找子字符串"><a href="#6-strstr：查找子字符串" class="headerlink" title="6. strstr：查找子字符串"></a><strong>6. <code>strstr</code>：查找子字符串</strong></h3><p>在字符串中查找某个子字符串的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoobgoogle&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strstr</span>(str1, str2); <span class="comment">// 找到 &quot;google&quot;，返回其地址</span></span><br><span class="line">cout &lt;&lt; pos;                    <span class="comment">// 输出：google</span></span><br></pre></td></tr></table></figure><hr><h3 id="完整示例：操作-C-风格字符串"><a href="#完整示例：操作-C-风格字符串" class="headerlink" title="完整示例：操作 C 风格字符串"></a><strong>完整示例：操作 C 风格字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串操作函数头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制 str1 到 str3</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;复制后 str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接 str2 到 str1</span></span><br><span class="line">    <span class="built_in">strcat</span>(str1, str2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后 str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算 str1 的长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 长度: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制后 str3: runoob</span><br><span class="line">拼接后 str1: runoobgoogle</span><br><span class="line">str1 长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="C-的-string-类（现代方式）"><a href="#C-的-string-类（现代方式）" class="headerlink" title="C++ 的 string 类（现代方式）"></a><strong>C++ 的 <code>string</code> 类（现代方式）</strong></h2><p>C++ 提供了 <code>string</code> 类，操作字符串更简单，推荐使用：</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制字符串</span></span><br><span class="line">    string str3 = str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接字符串</span></span><br><span class="line">    str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取长度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;长度: &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str3: runoob</span><br><span class="line">拼接后: runoobgoogle</span><br><span class="line">长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ul><li><strong>C 风格字符串</strong>：用字符数组实现，需注意 <code>\0</code> 结束符。</li><li><strong>字符串操作函数</strong>：如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 提供基本功能。</li><li><strong>C++ <code>string</code> 类</strong>：更现代化，更灵活，推荐在 C++ 中使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数组</title>
      <link href="/2024/11/16/C-%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h1><p>C++ 中的数组可以看作是一个「容器」，专门用来存储一组相同类型的数据，就像一个排成一列的储物柜。每个储物柜都有一个编号（索引），你可以通过这个编号来取出或者放入对应位置的数据。</p><h3 id="用通俗的例子来理解："><a href="#用通俗的例子来理解：" class="headerlink" title="用通俗的例子来理解："></a>用通俗的例子来理解：</h3><p>假设你有 100 本书，不想给每本书都取个名字（比如 book1、book2、book3… book100），这会非常麻烦。这时，你可以用一个「书架」（数组），把这些书按照顺序摆放在书架上，然后给每本书一个位置编号，比如：</p><ul><li>第一本书在位置 <code>0</code>，第二本书在位置 <code>1</code>，以此类推。</li></ul><p>在 C++ 里，你可以通过「书架名字 + 编号」直接访问书的位置，比如：</p><ul><li><code>books[0]</code> 就是第 1 本书。</li><li><code>books[99]</code> 就是第 100 本书。</li></ul><h3 id="数组的本质："><a href="#数组的本质：" class="headerlink" title="数组的本质："></a>数组的本质：</h3><ol><li><strong>连续的存储空间</strong>：就像这些书在书架上是紧挨着摆放的，每个位置依次存储数据。</li><li><strong>索引从 0 开始</strong>：C++ 习惯用 <code>0</code> 表示第一个位置。</li><li><strong>方便操作</strong>：你只需要知道位置编号，就能快速找到书（数据）。</li></ol><h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><p>数组是把一堆同类数据放到一个「共享的容器」里，用编号（索引）来区分每个数据，既节省了管理多个变量的麻烦，也让操作更高效。</p><h2 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1. 声明数组"></a><strong>1. 声明数组</strong></h2><p>数组是用来存储一组数据的，就像一本多格笔记本，每个格子都可以用来记数据。要告诉电脑这个数组需要存储什么类型的数据（比如数字或文字）以及需要多少格（大小）。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><strong><code>double</code></strong> 表示每个格子存放小数。</li><li><strong><code>balance</code></strong> 是这个数组的名字。</li><li><strong><code>[10]</code></strong> 表示有 10 个格子。</li></ul><p><strong>想象一下：</strong><br>你有一个存放 10 个数字的储物柜，每个柜子大小都一样，按顺序编号：<code>0</code> 到 <code>9</code>。</p><hr><h2 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2. 初始化数组"></a><strong>2. 初始化数组</strong></h2><p><strong>方式 1：逐个存放</strong><br>就像你一格一格手动往柜子里放东西：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">0</span>] = <span class="number">1000.0</span>;</span><br><span class="line">balance[<span class="number">1</span>] = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// 依次放入其他值...</span></span><br></pre></td></tr></table></figure><p><strong>方式 2：一次性存放</strong><br>如果你已经知道每格要存什么，可以一次性写完：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这就像直接打包好了 5 件东西，放进 5 个柜子。</p><p><strong>省略大小：</strong><br>如果你不想提前指定柜子数量，C++ 会根据数据的个数自动分配大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-访问数组中的数据"><a href="#3-访问数组中的数据" class="headerlink" title="3. 访问数组中的数据"></a><strong>3. 访问数组中的数据</strong></h2><p>你可以通过柜子的编号（索引）取出或修改里面的东西，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;  <span class="comment">// 改变第 5 个柜子的值为 50.0</span></span><br><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>]; <span class="comment">// 获取第 10 个柜子的值</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>柜子编号从 <strong>0</strong> 开始。</li><li>如果数组大小是 <code>10</code>，最后一个柜子的编号是 <code>9</code>。</li></ul><hr><h2 id="4-使用数组举例"><a href="#4-使用数组举例" class="headerlink" title="4. 使用数组举例"></a><strong>4. 使用数组举例</strong></h2><p>以下程序会创建一个数组 <code>n</code>，存储从 <code>100</code> 开始的 10 个数字，并输出它们的值：</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">// 创建一个大小为 10 的整数数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给数组的每个柜子存值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">// 每个柜子的值 = 编号 + 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组中的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Element\tValue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; n[j] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element    Value</span><br><span class="line">0          100</span><br><span class="line">1          101</span><br><span class="line">2          102</span><br><span class="line">3          103</span><br><span class="line">4          104</span><br><span class="line">5          105</span><br><span class="line">6          106</span><br><span class="line">7          107</span><br><span class="line">8          108</span><br><span class="line">9          109</span><br></pre></td></tr></table></figure><hr><h2 id="5-更高级的数组概念"><a href="#5-更高级的数组概念" class="headerlink" title="5. 更高级的数组概念"></a><strong>5. 更高级的数组概念</strong></h2><table><thead><tr><th><strong>概念</strong></th><th><strong>通俗解释</strong></th></tr></thead><tbody><tr><td><strong>多维数组</strong></td><td>就像一个表格或一个盒子，可以存储二维或多维的数据。比如二维数组就像一个 Excel 表格，有行和列。</td></tr><tr><td><strong>指向数组的指针</strong></td><td>数组的名字本身就是一个指向第一个格子的「地址」。这就像你有一个地图，可以用地图快速找到第一个储物柜。</td></tr><tr><td><strong>传递数组给函数</strong></td><td>你可以把整个数组传递给函数，就像把储物柜的地图交给别人，让他们根据地图找到所有东西。</td></tr><tr><td><strong>从函数返回数组</strong></td><td>函数也可以返回一个数组，就像别人帮你装满东西后，把一个新的储物柜还给你。</td></tr></tbody></table><hr><h2 id="小总结：-1"><a href="#小总结：-1" class="headerlink" title="小总结："></a>小总结：</h2><ol><li><strong>声明</strong>：定义一个装东西的储物柜（数组），指定它能装什么类型、装多少。</li><li><strong>初始化</strong>：往柜子里放东西，可以逐个放，也可以一次性全放。</li><li><strong>访问</strong>：通过编号（索引）取柜子里的东西或改它的值。</li><li><strong>进阶用法</strong>：数组还可以做更多复杂的操作，比如作为表格、多维容器、或通过函数共享数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数字</title>
      <link href="/2024/11/16/C++%E6%95%B0%E5%AD%97/"/>
      <url>/2024/11/16/C++%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数字"><a href="#C-数字" class="headerlink" title="C++数字"></a>C++数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 <a href="https://blog.tomatou.xyz/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">C++ 数据类型</a>一节中讨论过。</p><h2 id="1-定义数字"><a href="#1-定义数字" class="headerlink" title="1. 定义数字"></a><strong>1. 定义数字</strong></h2><p>在 C++ 中，我们可以定义多种类型的数字，具体的数字类型取决于数值的大小和精度。下面是常用的数字类型：</p><ul><li>**<code>short</code>**：用于存储较小的整数（通常为 2 字节）。</li><li>**<code>int</code>**：用于存储整数（通常为 4 字节）。</li><li>**<code>long</code>**：用于存储较大的整数（通常为 4 或 8 字节，取决于平台）。</li><li>**<code>float</code>**：用于存储单精度浮点数，通常用于存储小数（4 字节）。</li><li>**<code>double</code>**：用于存储双精度浮点数，通常用于存储精度较高的小数（8 字节）。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种类型的数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;     <span class="comment">// 小整数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1000</span>;     <span class="comment">// 整数</span></span><br><span class="line">    <span class="type">long</span> l = <span class="number">1000000</span>; <span class="comment">// 大整数</span></span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>; <span class="comment">// 单精度小数</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">30949.374</span>; <span class="comment">// 双精度小数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数字值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short  s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int    i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long   l: &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float  f: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double d: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short  s: 10</span><br><span class="line">int    i: 1000</span><br><span class="line">long   l: 1000000</span><br><span class="line">float  f: 230.47</span><br><span class="line">double d: 30949.4</span><br></pre></td></tr></table></figure><h2 id="2-数学运算"><a href="#2-数学运算" class="headerlink" title="2. 数学运算"></a><strong>2. 数学运算</strong></h2><p>C++ 提供了很多内置的数学函数，可以帮助我们做各种数学计算。要使用这些函数，我们需要引入 <code>&lt;cmath&gt;</code> 头文件。</p><p>以下是一些常见的数学函数：</p><ul><li>**<code>cos(double)</code>**：计算角度的余弦值。</li><li>**<code>sin(double)</code>**：计算角度的正弦值。</li><li>**<code>tan(double)</code>**：计算角度的正切值。</li><li>**<code>log(double)</code>**：计算参数的自然对数。</li><li>**<code>pow(double, double)</code>**：计算第一个数的第二个数次方（幂运算）。</li><li>**<code>sqrt(double)</code>**：计算平方根。</li><li>**<code>abs(int)</code>**：计算整数的绝对值。</li><li>**<code>fabs(double)</code>**：计算浮点数的绝对值。</li><li>**<code>floor(double)</code>**：向下取整，返回小于或等于给定数字的最大整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  <span class="comment">// 引入数学库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1000</span>;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数学函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sin(d): &quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;        <span class="comment">// 计算正弦</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;abs(i): &quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;        <span class="comment">// 计算绝对值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;floor(d): &quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;    <span class="comment">// 向下取整</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sqrt(f): &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;      <span class="comment">// 计算平方根</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pow(d, 2): &quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 计算平方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sin(d): -0.634939</span><br><span class="line">abs(i): 1000</span><br><span class="line">floor(d): 200</span><br><span class="line">sqrt(f): 15.1812</span><br><span class="line">pow(d, 2): 40149.7</span><br></pre></td></tr></table></figure><h2 id="3-随机数生成"><a href="#3-随机数生成" class="headerlink" title="3. 随机数生成"></a><strong>3. 随机数生成</strong></h2><p>在一些应用场景中，我们需要生成随机数。C++ 提供了 <code>rand()</code> 函数来生成伪随机数，但需要注意的是，<code>rand()</code> 每次程序运行时生成的随机数是固定的，类似于一个固定的序列。为了让每次生成的随机数不同，我们可以使用 <code>srand()</code> 函数设置随机数种子。</p><p>通常，<code>srand()</code> 的参数是当前的系统时间，这样每次运行程序时，生成的随机数都不相同。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">// 引入时间库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 引入随机数库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子为当前时间</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并输出 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        j = <span class="built_in">rand</span>();  <span class="comment">// 获取一个随机数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">随机数： 1748144778</span><br><span class="line">随机数： 630873888</span><br><span class="line">随机数： 2134540646</span><br><span class="line">随机数： 219404170</span><br><span class="line">随机数： 902129458</span><br><span class="line">随机数： 920445370</span><br><span class="line">随机数： 1319072661</span><br><span class="line">随机数： 257938873</span><br><span class="line">随机数： 1256201101</span><br><span class="line">随机数： 580322989</span><br></pre></td></tr></table></figure><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>C++ 中可以定义不同类型的数字（如整数、浮点数等）来存储不同类型的数值。</li><li>通过引入 <code>&lt;cmath&gt;</code> 库，我们可以使用 C++ 提供的丰富数学函数来进行各种数学运算。</li><li>通过 <code>rand()</code> 和 <code>srand()</code> 函数，我们可以生成随机数并控制随机数序列的不同。</li></ul><p>这些基础知识是进行 C++ 编程的关键，掌握这些概念能帮助我们更好地处理数字数据、进行数学运算以及实现随机化功能。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数</title>
      <link href="/2024/11/16/C-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/11/16/C-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将正式进入函数的相关学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p><strong>在C++中，函数就像是一个小助手，它负责完成一个特定的任务。你可以把一段代码想象成是一个小助手，当你需要它的时候，就可以召唤它来帮你做事，而不需要每次都从头开始写这段代码。</strong></p><p><strong>每个C++程序至少会有一个主函数，也就是<code>main()</code>函数，它是程序的起点。但是，你还可以定义更多的函数来帮助你完成不同的任务。</strong></p><p><strong>函数声明就像是给小助手起个名字，告诉计算机它叫什么，能帮你做什么，以及你需要给它什么信息（参数）。函数定义则是真正告诉计算机这个小助手具体应该怎么做。</strong></p><p><strong>C++标准库就像是一个有很多小助手的团队，它们已经准备好了，你可以直接召唤它们来帮你做事，比如<code>strcat()</code>可以把两个字符串连在一起，<code>memcpy()</code>可以帮你复制一段内存。</strong></p><p><strong>函数还有其他的名字，比如方法、子例程或者程序，它们都是做同样的事情：帮你完成任务。</strong></p><p><strong>总结一下，函数就是一段可以重复使用的代码，它负责完成一个特定的任务。你可以通过声明和定义来创建自己的函数，也可以使用C++标准库中已经定义好的函数。这样可以让你的程序更加整洁和高效。</strong></p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><strong>函数的定义</strong></h2><p>一个函数的基本结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组成部分：</strong></p><ul><li><strong>返回类型（Return Type）：</strong> 指定函数完成任务后返回的数据类型。如果函数不返回任何值，使用 <code>void</code>。</li><li><strong>函数名（Function Name）：</strong> 函数的标识符，用于调用函数。</li><li><strong>参数列表（Parameter List）：</strong> 函数接受的输入，类似占位符。在调用函数时，实际参数的值会传递给这些参数。参数可以有多个，也可以没有。</li><li><strong>函数体（Function Body）：</strong> 包含实现函数功能的代码块。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个数中较大的一个</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><strong>函数声明</strong></h2><p>函数声明告诉编译器函数的名称和如何调用它，实际的函数体可以在别处定义。</p><p><strong>格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure><p>参数名在函数声明中是可选的，只要指定类型即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><strong>调用函数</strong></h2><p>当我们需要使用函数时，通过函数名和参数来调用它。</p><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取较大的值</span></span><br><span class="line">    ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最大值是：&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是：200</span><br></pre></td></tr></table></figure><hr><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h2><p>函数可以通过参数接受输入，有三种传递参数的方式：</p><ol><li><strong>值传递（Pass by Value）：</strong> 将实际参数的值复制一份传递给函数。函数内对参数的修改不会影响实际参数。</li><li><strong>指针传递（Pass by Pointer）：</strong> 将实际参数的地址传递给函数。函数可以通过指针修改实际参数的值。</li><li><strong>引用传递（Pass by Reference）：</strong> 传递参数的引用，函数内对参数的修改会直接影响实际参数。</li></ol><p><strong>注意：</strong> 默认情况下，C++ 使用值传递。</p><hr><h2 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a><strong>参数的默认值</strong></h2><p>函数参数可以有默认值，如果在调用函数时未提供该参数的值，将使用默认值。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个参数</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个参数，b 使用默认值</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总和是：300</span><br><span class="line">总和是：120</span><br></pre></td></tr></table></figure><hr><h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a><strong>Lambda 函数与表达式</strong></h2><p>C++11 引入了匿名函数，称为 Lambda 函数或 Lambda 表达式。它们使您可以在代码中定义简短的内联函数。</p><p><strong>基本形式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[capture]（捕获列表）：</strong> 指定哪些外部变量可以在 Lambda 中使用。</li><li><strong>(参数列表)：</strong> Lambda 接受的参数。</li><li><strong>返回类型（可选）：</strong> 如果编译器无法推断返回类型，可以显式指定。</li><li><strong>函数体：</strong> Lambda 执行的代码。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的比较函数</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br></pre></td></tr></table></figure><p><strong>无参数的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不接受参数的 Lambda</span></span><br><span class="line"><span class="keyword">auto</span> increment = [] &#123; ++global_x; &#125;;</span><br></pre></td></tr></table></figure><p><strong>指定返回类型的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定返回类型</span></span><br><span class="line"><span class="keyword">auto</span> sum = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    <span class="keyword">return</span> z + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="捕获列表（Capture-List）"><a href="#捕获列表（Capture-List）" class="headerlink" title="捕获列表（Capture List）"></a><strong>捕获列表（Capture List）</strong></h2><p>Lambda 可以捕获其所在作用域的变量，有多种方式：</p><ul><li><strong>[]：</strong> 不捕获任何变量。尝试使用外部变量会导致错误。</li><li><strong>[x, &amp;y]：</strong> 捕获 <code>x</code> 的值，捕获 <code>y</code> 的引用。</li><li><strong>[&amp;]：</strong> 引用捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&#x3D;]：</strong> 值捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&amp;, x]：</strong> 引用捕获除 <code>x</code> 之外的所有变量，<code>x</code> 值捕获。</li><li><strong>[&#x3D;, &amp;z]：</strong> 值捕获除 <code>z</code> 之外的所有变量，<code>z</code> 引用捕获。</li></ul><p><strong>注意使用 <code>this</code> 指针：</strong></p><ul><li><p>对于 <code>[=]</code> 或 <code>[&amp;]</code>，<code>this</code> 指针会被自动捕获，可直接使用成员变量和函数。</p></li><li><p>对于 <code>[]</code>，如果需要使用 <code>this</code>，必须显式捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++判断</title>
      <link href="/2024/11/16/C-%E5%88%A4%E6%96%AD/"/>
      <url>/2024/11/16/C-%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习判断的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明不白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C++判断"></a>C++判断</h1><p>在编程中，判断结构就像是做选择题。程序员需要设定一些问题（条件），然后告诉计算机：</p><ol><li>如果问题的答案是肯定的（条件为真），那么计算机应该做什么（执行哪些语句）。</li><li>如果问题的答案是否定的（条件为假），那么计算机可以做什么（执行哪些语句，这部分是可选的）。</li></ol><p>简单来说，判断结构就是让计算机根据条件来决定下一步做什么的一种方法。这就像是我们日常生活中做决定的过程：如果天气好，我们就去公园；如果天气不好，我们就待在家里。在编程中，我们用代码来实现这样的逻辑。</p><p><strong>在 C++ 编程语言中，判断语句就是用来根据条件来决定代码如何执行的一种方式。以下是几种判断语句，用简单的方式解释它们的功能：</strong></p><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. <strong>if 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时，执行一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就会显示“a 比 b 大”。如果条件不成立，就什么也不做。</em></li></ul><hr><h2 id="2-if…else-语句"><a href="#2-if…else-语句" class="headerlink" title="2. if…else 语句"></a>2. <strong>if…else 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时执行一段代码，否则执行另一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 不比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就输出第一句话；否则，输出第二句话。</em></li></ul><hr><h2 id="3-嵌套-if-语句"><a href="#3-嵌套-if-语句" class="headerlink" title="3. 嵌套 if 语句"></a>3. <strong>嵌套 if 语句</strong></h2><ul><li><strong>功能：</strong> 如果需要多个条件，可以把一个 <code>if</code> 放到另一个 <code>if</code> 里面。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 最大&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，同时 <code>b</code> 比 <code>c</code> 大，就输出“a 最大”。</em></li></ul><hr><h2 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4. switch 语句"></a>4. <strong>switch 语句</strong></h2><ul><li><strong>功能：</strong> 检查一个变量的值，并根据值执行不同的代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>grade</code> 是 <code>&#39;A&#39;</code>，就显示“优秀”；如果是 <code>&#39;B&#39;</code>，就显示“良好”；其他情况显示“其他”。</em></li></ul><hr><h2 id="5-嵌套-switch-语句"><a href="#5-嵌套-switch-语句" class="headerlink" title="5. 嵌套 switch 语句"></a>5. <strong>嵌套 switch 语句</strong></h2><ul><li><strong>功能：</strong> 可以在一个 <code>switch</code> 语句里嵌套另一个 <code>switch</code>，用于复杂的判断。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">        <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;大狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他动物&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>animal</code> 是 <code>&#39;dog&#39;</code> 并且 <code>size</code> 是 <code>&#39;big&#39;</code>，就输出“大狗”。</em></li></ul><hr><h2 id="6-条件运算符"><a href="#6-条件运算符" class="headerlink" title="6. 条件运算符 (? :)"></a>6. <strong>条件运算符 (<code>? :</code>)</strong></h2><ul><li><strong>功能：</strong> 用于替代简单的 <code>if...else</code>，结构更紧凑。</li><li><strong>格式：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 真值 : 假值;</span><br></pre></td></tr></table></figure></li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 大于 <code>b</code>，就把 <code>a</code> 的值赋给 <code>max</code>；否则，把 <code>b</code> 的值赋给 <code>max</code>。</em></li></ul><hr><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><ul><li><code>if</code> 和 <code>if...else</code>：判断一件事情是否成立。</li><li>嵌套 <code>if</code> 和 <code>switch</code>：用于处理多个条件。</li><li><code>switch</code>：更适合检查一个变量的多种可能值。</li><li>条件运算符：用最短的方式写简单的判断，通常用在赋值或输出语句里。</li></ul><p><strong>这样解释是不是更清晰？ 😊</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环</title>
      <link href="/2024/11/16/C-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2024/11/16/C-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习循环的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p><strong>在编程中，我们经常会遇到需要重复做同一件事情的情况。通常，代码是按照顺序一行一行执行的：先执行第一行，然后是第二行，以此类推。但是，有时候我们想让某段代码重复执行多次，而不是只执行一次。这时候，就需要用到编程语言提供的控制结构，它们可以让代码的执行路径变得更加灵活和复杂。</strong><br><strong>简单来说，控制结构就像是代码的“交通规则”，它们告诉我们代码应该如何“行驶”。在C++中，有几种常用的控制结构可以帮助我们实现代码的重复执行，比如循环。循环就像是设置了“循环播放”模式，让某段代码可以按照我们指定的次数或者条件，一遍又一遍地执行。</strong><br><strong>通过使用循环，我们可以更高效地处理重复的任务，而不需要手动复制粘贴大量的代码。这样不仅可以节省时间，还可以减少错误，让代码更加简洁和易于维护。</strong></p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><hr><h3 id="循环类型-1"><a href="#循环类型-1" class="headerlink" title="循环类型"></a><strong>循环类型</strong></h3><p>在编程中，<strong>循环</strong>用于重复执行一段代码，直到满足某个条件为止。C++ 提供了几种常用的循环结构，让我们来一一了解它们。</p><h4 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a><strong>1. <code>while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>while</code> 循环会在<strong>每次执行循环体之前</strong>，先检查一个条件。如果条件为真（<code>true</code>），就执行循环体的代码；如果条件为假（<code>false</code>），就结束循环。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体（要重复执行的代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环会从 <code>i = 0</code> 开始，每次输出 <code>i</code> 的值，然后将 <code>i</code> 加 1，直到 <code>i</code> 不小于 5。</p></li></ul><h4 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a><strong>2. <code>for</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>for</code> 循环适合在你<strong>知道要循环多少次</strong>的情况下使用。它把循环变量的初始化、条件判断和更新都放在一行，便于管理。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环与上面的 <code>while</code> 循环功能相同，但写法更紧凑。</p></li></ul><h4 id="3-do-while-循环"><a href="#3-do-while-循环" class="headerlink" title="3. do...while 循环"></a><strong>3. <code>do...while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>do...while</code> 循环会<strong>先执行一次</strong>循环体，然后再检查条件是否满足。这意味着即使条件一开始为假，循环体也会执行一次。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：即使 <code>i</code> 一开始就不小于 5，循环体也会执行一次。</p></li></ul><h4 id="4-嵌套循环"><a href="#4-嵌套循环" class="headerlink" title="4. 嵌套循环"></a><strong>4. 嵌套循环</strong></h4><ul><li><p><strong>基本概念</strong>：你可以在一个循环内部再放入一个循环，称为<strong>嵌套循环</strong>。这在需要遍历多维数据时非常有用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：外层循环控制 <code>i</code>，内层循环控制 <code>j</code>，总共会输出 6 组组合。</p></li></ul><hr><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a><strong>循环控制语句</strong></h3><p>有时候，我们需要在循环过程中改变正常的执行流程，比如提前结束循环或跳过某次循环。C++ 提供了以下控制语句。</p><h4 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1. break 语句"></a><strong>1. <code>break</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>break</code> 用于<strong>立即退出</strong>所在的循环或 <code>switch</code> 语句，程序会继续执行循环或 <code>switch</code> 后面的代码。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环在 <code>i</code> 等于 5 时，会提前结束，不再继续循环。</p></li></ul><h4 id="2-continue-语句"><a href="#2-continue-语句" class="headerlink" title="2. continue 语句"></a><strong>2. <code>continue</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>continue</code> 用于<strong>跳过当前循环的剩余代码</strong>，立即开始下一次循环的判断。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过当前循环，i == 2 时不执行下面的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：当 <code>i</code> 等于 2 时，<code>continue</code> 会跳过 <code>cout</code>，因此不会输出 <code>i = 2</code>。</p></li></ul><h4 id="3-goto-语句"><a href="#3-goto-语句" class="headerlink" title="3. goto 语句"></a><strong>3. <code>goto</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>goto</code> 可以无条件地<strong>跳转</strong>到程序中标记的位置。但由于它可能导致代码难以阅读和维护，一般<strong>不推荐使用</strong>。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">start:</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">goto</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这段代码使用 <code>goto</code> 模拟了一个循环。</p></li></ul><hr><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a><strong>无限循环</strong></h3><ul><li><p><strong>基本概念</strong>：如果循环的条件永远为真，那么循环将永远执行下去，这就是<strong>无限循环</strong>。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This loop will run forever.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>for</code> 循环的三个部分（初始化、条件、更新）都可以省略，如果条件部分被省略，默认视为真，所以循环会无限执行。</p></li><li><p><strong>注意</strong>：在实际编程中，需要确保有机制能跳出无限循环，比如在循环体内使用 <code>break</code>，或者在某种条件下退出。否则，程序可能会卡住。</p></li><li><p><strong>终止无限循环的方法</strong>：在命令行环境下，可以按 <code>Ctrl + C</code> 终止程序的执行。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符</title>
      <link href="/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习运算符的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++运算符"></a>C++运算符</h1><p>在C++编程中，运算符就像是数学中的加减乘除符号，它们告诉计算机执行特定的操作。C++提供了很多这样的符号，我们可以将它们分为几大类：</p><ol><li><p><strong>算术运算符</strong>：就像我们在数学课上学的那样，用来做加法（+）、减法（-）、乘法（*）、除法（&#x2F;）等计算的符号。</p></li><li><p><strong>关系运算符</strong>：这些符号用来比较两个值，比如看一个值是否大于（&gt;）、小于（&lt;）、等于（&#x3D;&#x3D;）另一个值。</p></li><li><p><strong>逻辑运算符</strong>：这些符号用来处理真（true）或假（false）的情况，比如“并且”（&amp;&amp;）表示两个条件都必须为真，结果才为真；“或者”（||）表示只要有一个条件为真，结果就为真。</p></li><li><p><strong>位运算符</strong>：这些符号在二进制层面上操作数据，比如将两个数的二进制表示进行“与”（&amp;）、“或”（|）操作。</p></li><li><p><strong>赋值运算符</strong>：这个符号（&#x3D;）用来给变量赋值，比如将一个值赋给一个变量。</p></li><li><p><strong>杂项运算符</strong>：还有一些其他的符号，比如访问对象成员的点（.）运算符，或者取地址的与（&amp;）运算符。</p></li></ol><p>接下来的内容会详细解释这些运算符是如何工作的，帮助你更好地理解如何在C++中使用它们。简而言之，运算符就是编程语言中的“动词”，它们告诉计算机要执行什么样的操作。</p><p><strong>在学习 C++ 编程时，我们经常需要使用各种运算符来进行计算和逻辑判断。下面，我们来解释一下这些常见的运算符。</strong></p><hr><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h2><p>这些运算符用于基本的数学计算，就像我们日常生活中的加减乘除。</p><ul><li><p><strong><code>+</code> 加号</strong>：把两个数相加。</p><p>例子：<code>A + B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，那么结果是 <strong>30</strong>。</p></li><li><p><strong><code>-</code> 减号</strong>：从第一个数中减去第二个数。</p><p>例子：<code>A - B</code>，结果是 <strong>-10</strong>。</p></li><li><p><strong><code>*</code> 乘号</strong>：把两个数相乘。</p><p>例子：<code>A * B</code>，结果是 <strong>200</strong>。</p></li><li><p><strong><code>/</code> 除号</strong>：用第一个数除以第二个数。</p><p>例子：<code>B / A</code>，结果是 <strong>2</strong>。</p></li><li><p><strong><code>%</code> 取模</strong>：求两个整数相除的余数。</p><p>例子：<code>B % A</code>，结果是 <strong>0</strong>。</p></li><li><p><strong><code>++</code> 自增</strong>：把变量的值增加 1。</p><p>例子：<code>A++</code>，如果 <code>A</code> 原本是 10，执行后变为 <strong>11</strong>。</p></li><li><p><strong><code>--</code> 自减</strong>：把变量的值减少 1。</p><p>例子：<code>A--</code>，执行后 <code>A</code> 变为 <strong>9</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl; <span class="comment">// 输出 31</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a - b = &quot;</span> &lt;&lt; a - b &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; a * b &lt;&lt; endl; <span class="comment">// 输出 210</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a / b = &quot;</span> &lt;&lt; a / b &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a % b = &quot;</span> &lt;&lt; a % b &lt;&lt; endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++ = &quot;</span> &lt;&lt; c++ &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 11</span></span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c-- = &quot;</span> &lt;&lt; c-- &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><p>这些运算符用于比较两个值之间的大小关系，结果是 <strong>真（true）</strong> 或 <strong>假（false）</strong>。</p><ul><li><p><strong><code>==</code> 等于</strong>：判断两个值是否相等。</p><p>例子：<code>A == B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，结果为 <strong>false</strong>。</p></li><li><p><strong><code>!=</code> 不等于</strong>：判断两个值是否不相等。</p><p>例子：<code>A != B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;</code> 大于</strong>：判断左边的值是否大于右边的值。</p><p>例子：<code>A &gt; B</code>，结果为 <strong>false</strong>。</p></li><li><p><strong><code>&lt;</code> 小于</strong>：判断左边的值是否小于右边的值。</p><p>例子：<code>A &lt; B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;=</code> 大于等于</strong>：判断左边的值是否大于或等于右边的值。</p></li><li><p><strong><code>&lt;=</code> 小于等于</strong>：判断左边的值是否小于或等于右边的值。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt;= b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于或等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b &gt;= a)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b 大于或等于 a&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h2><p>这些运算符用于连接多个条件，形成更复杂的逻辑判断。</p><ul><li><p><strong><code>&amp;&amp;</code> 逻辑与</strong>：当 <strong>两个条件都为真</strong>，结果才为真。</p><p>例子：<code>(A &amp;&amp; B)</code>，只有当 <code>A</code> 和 <code>B</code> 都为真，结果才为 <strong>true</strong>。</p></li><li><p><strong><code>||</code> 逻辑或</strong>：当 <strong>至少一个条件为真</strong>，结果为真。</p><p>例子：<code>(A || B)</code>，只要 <code>A</code> 或 <code>B</code> 其中一个为真，结果就是 <strong>true</strong>。</p></li><li><p><strong><code>!</code> 逻辑非</strong>：对条件取反，<strong>真变假，假变真</strong>。</p><p>例子：<code>!(A &amp;&amp; B)</code>，如果 <code>(A &amp;&amp; B)</code> 为真，取反后结果为 <strong>false</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a || b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 或 b 至少一个为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(a &amp;&amp; b))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真（取反后为真）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h2><p>位运算符用于直接操作二进制位，常用于底层编程或性能优化。</p><ul><li><p><strong><code>&amp;</code> 按位与</strong>：对应位都为 1，结果才为 1。</p></li><li><p><strong><code>|</code> 按位或</strong>：对应位只要有一个为 1，结果就是 1。</p></li><li><p><strong><code>^</code> 按位异或</strong>：对应位不同，结果为 1，相同为 0。</p></li><li><p><strong><code>~</code> 按位取反</strong>：把每一位都取反，0 变 1，1 变 0。</p></li><li><p><strong><code>&lt;&lt;</code> 左移</strong>：把二进制位向左移动，右边补 0。</p></li><li><p><strong><code>&gt;&gt;</code> 右移</strong>：把二进制位向右移动，左边根据符号位补 0 或 1。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>; <span class="comment">// 二进制：0011 1100</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>; <span class="comment">// 二进制：0000 1101</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = a &amp; b; <span class="comment">// 12，二进制：0000 1100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &amp; b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a | b; <span class="comment">// 61，二进制：0011 1101</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a | b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a ^ b; <span class="comment">// 49，二进制：0011 0001</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a ^ b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = ~a; <span class="comment">// 对 a 取反</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~a = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 左移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &lt;&lt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &gt;&gt; <span class="number">2</span>; <span class="comment">// 右移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &gt;&gt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h2><p>这些运算符用于给变量赋值，并可以结合其他操作。</p><ul><li><p><strong><code>=</code> 赋值</strong>：把右边的值赋给左边的变量。</p><p>例子：<code>c = a + b</code>。</p></li><li><p><strong><code>+=</code> 加且赋值</strong>：<code>c += a</code> 等同于 <code>c = c + a</code>。</p></li><li><p><strong><code>-=</code> 减且赋值</strong>：<code>c -= a</code> 等同于 <code>c = c - a</code>。</p></li><li><p><strong><code>*=</code> 乘且赋值</strong>：<code>c *= a</code> 等同于 <code>c = c * a</code>。</p></li><li><p><strong><code>/=</code> 除且赋值</strong>：<code>c /= a</code> 等同于 <code>c = c / a</code>。</p></li><li><p><strong><code>%=</code> 取模且赋值</strong>：<code>c %= a</code> 等同于 <code>c = c % a</code>。</p></li><li><p><strong><code>&lt;&lt;=</code> 左移且赋值</strong>：<code>c &lt;&lt;= 2</code> 等同于 <code>c = c &lt;&lt; 2</code>。</p></li><li><p><strong><code>&gt;&gt;=</code> 右移且赋值</strong>：<code>c &gt;&gt;= 2</code> 等同于 <code>c = c &gt;&gt; 2</code>。</p></li><li><p><strong><code>&amp;=</code> 按位与且赋值</strong>：<code>c &amp;= 2</code> 等同于 <code>c = c &amp; 2</code>。</p></li><li><p><strong><code>^=</code> 按位异或且赋值</strong>：<code>c ^= 2</code> 等同于 <code>c = c ^ 2</code>。</p></li><li><p><strong><code>|=</code> 按位或且赋值</strong>：<code>c |= 2</code> 等同于 <code>c = c | 2</code>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c += a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c += a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    c -= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c -= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c *= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c *= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 441</span></span><br><span class="line"></span><br><span class="line">    c /= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c /= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c = <span class="number">200</span>;</span><br><span class="line">    c %= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c %= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &lt;&lt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 44</span></span><br><span class="line"></span><br><span class="line">    c &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &gt;&gt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &amp;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &amp;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    c ^= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c ^= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    c |= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c |= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a><strong>其他运算符</strong></h2><ul><li><p><strong><code>sizeof</code> 求大小</strong>：返回数据类型或变量所占的字节数。</p><p>例子：<code>sizeof(int)</code> 返回 <strong>4</strong>。</p></li><li><p><strong><code>?:</code> 条件运算符（三目运算符）</strong>：根据条件返回不同的值。</p><p>例子：<code>int max = (a &gt; b) ? a : b;</code>，如果 <code>a &gt; b</code> 为真，<code>max</code> 等于 <code>a</code>，否则等于 <code>b</code>。</p></li><li><p><strong><code>,</code> 逗号运算符</strong>：可以在一行中执行多个表达式，返回最后一个表达式的值。</p></li><li><p><strong><code>.</code> 和 <code>-&gt;</code> 成员访问运算符</strong>：用于访问对象或指针的成员。</p><p>例子：<code>object.member</code>，<code>pointer-&gt;member</code>。</p></li><li><p><strong><code>(type)</code> 类型转换</strong>：将一个值转换为指定的类型。</p><p>例子：<code>int x = (int)3.14;</code>，<code>x</code> 的值为 <strong>3</strong>。</p></li><li><p><strong><code>&amp;</code> 取地址运算符</strong>：获取变量的内存地址。</p><p>例子：<code>int *p = &amp;a;</code>，<code>p</code> 指向 <code>a</code> 的地址。</p></li><li><p><strong><code>*</code> 指针解引用运算符</strong>：访问指针所指向的变量的值。</p><p>例子：<code>int value = *p;</code>，<code>value</code> 等于 <code>p</code> 所指向的变量的值。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++存储类</title>
      <link href="/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
      <url>/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-存储类型"><a href="#C-存储类型" class="headerlink" title="C++存储类型"></a>C++存储类型</h1><hr><h2 id="什么是存储类？"><a href="#什么是存储类？" class="headerlink" title="什么是存储类？"></a>什么是存储类？</h2><p>存储类决定了变量或函数的<strong>作用范围</strong>（在哪里可以访问）和<strong>生命周期</strong>（何时创建、何时销毁）。在C++中，存储类的关键字会放在变量或函数类型的前面，用来改变它们的默认行为。</p><hr><h3 id="C-中常见的存储类说明符"><a href="#C-中常见的存储类说明符" class="headerlink" title="C++中常见的存储类说明符"></a>C++中常见的存储类说明符</h3><p>以下是C++存储类关键字的通俗解释：</p><h4 id="1-auto（自动存储期，默认行为）"><a href="#1-auto（自动存储期，默认行为）" class="headerlink" title="1. auto（自动存储期，默认行为）"></a>1. <strong>auto</strong>（自动存储期，默认行为）</h4><ul><li><strong>定义</strong>：这是C++的默认存储类说明符，通常可以省略不写。它表示变量的生命周期仅限于它所在的块（如函数内部）。</li><li><strong>特点</strong>：<ul><li>变量会在块结束时自动销毁。</li><li>在C++11后，<code>auto</code>更多用于自动推导变量类型，而不是存储类。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量，块结束后自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-register（寄存器变量）"><a href="#2-register（寄存器变量）" class="headerlink" title="2. register（寄存器变量）"></a>2. <strong>register</strong>（寄存器变量）</h4><ul><li><strong>定义</strong>：建议编译器将变量存储在CPU寄存器中以提高访问速度。</li><li><strong>特点</strong>：<ul><li>在现代C++中（C++11及以后），<code>register</code>已经被废弃，编译器会自动优化变量的存储。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是建议存储在寄存器中的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="3-static（静态存储期）"><a href="#3-static（静态存储期）" class="headerlink" title="3. static（静态存储期）"></a>3. <strong>static</strong>（静态存储期）</h4><ul><li><strong>定义</strong>：表示变量的生命周期贯穿整个程序的运行期。</li><li><strong>特点</strong>：<ul><li><strong>函数内部的static变量</strong>：只初始化一次，函数多次调用时会保留上次的值。</li><li><strong>全局变量或函数的static</strong>：限制变量或函数只能在当前文件中使用。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count;  <span class="comment">// 多次调用会保留上次的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-extern（外部链接）"><a href="#4-extern（外部链接）" class="headerlink" title="4. extern（外部链接）"></a>4. <strong>extern</strong>（外部链接）</h4><ul><li><strong>定义</strong>：声明全局变量或函数，可以跨多个文件使用。</li><li><strong>特点</strong>：<ul><li><code>extern</code>告诉编译器变量或函数是在别的文件中定义的。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar; <span class="comment">// 引用 file1.cpp 中的变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="5-mutable（可变成员变量）"><a href="#5-mutable（可变成员变量）" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong>mutable</strong>（可变成员变量）</h4><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，也允许修改这个变量。</li><li><strong>特点</strong>：<ul><li>通常用于需要在<code>const</code>成员函数中更新的变量，比如缓存或计数器。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// counter 可以在 const 函数中修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="6-thread-local（线程局部存储期，C-11-引入）"><a href="#6-thread-local（线程局部存储期，C-11-引入）" class="headerlink" title="6. thread_local（线程局部存储期，C++11 引入）"></a>6. <strong>thread_local</strong>（线程局部存储期，C++11 引入）</h4><ul><li><strong>定义</strong>：表示每个线程都有变量的独立副本，变量的生命周期与线程一致。</li><li><strong>特点</strong>：<ul><li>适合多线程编程中需要每个线程独立数据的场景。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>; <span class="comment">// 每个线程都有自己的 threadVar</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h3><p>以下代码展示了不同存储类的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar; <span class="comment">// 全局变量，默认是 extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> localVar = <span class="number">10</span>;  <span class="comment">// 局部变量，块结束后销毁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">20</span>; <span class="comment">// 静态变量，函数多次调用保留值</span></span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">30</span>; <span class="comment">// 每个线程有独立的变量副本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">mutable</span> <span class="type">int</span> mutableVar; <span class="comment">// 可变变量，即使对象是 const 也可以修改</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            mutableVar = <span class="number">50</span>; <span class="comment">// 合法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><table><thead><tr><th><strong>关键字</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>默认存储类，生命周期随块结束，现代C++更多用于类型推导。</td></tr><tr><td><code>register</code></td><td>提示编译器优化变量存储（C++11后废弃）。</td></tr><tr><td><code>static</code></td><td>生命周期贯穿整个程序，但作用范围受限。</td></tr><tr><td><code>extern</code></td><td>允许跨文件共享全局变量或函数。</td></tr><tr><td><code>mutable</code></td><td>允许修改<code>const</code>对象的成员变量。</td></tr><tr><td><code>thread_local</code></td><td>每个线程有独立变量副本，生命周期与线程一致（C++11后引入）。</td></tr></tbody></table><hr><h2 id="常见存储类及其用途"><a href="#常见存储类及其用途" class="headerlink" title="常见存储类及其用途"></a>常见存储类及其用途</h2><h3 id="1-auto（自动推导类型）"><a href="#1-auto（自动推导类型）" class="headerlink" title="1. auto（自动推导类型）"></a>1. <strong><code>auto</code>（自动推导类型）</strong></h3><ul><li><strong>定义</strong>：自动根据初始化的值推断变量的类型。</li><li><strong>特点</strong>：<ul><li>省去了手动写类型的麻烦。</li><li>适合用在复杂类型的变量上，比如迭代器。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;     <span class="comment">// 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">3.14</span>;   <span class="comment">// 推断为 double</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 推断为 const char*</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-register（寄存器变量，C-11后已废弃）"><a href="#2-register（寄存器变量，C-11后已废弃）" class="headerlink" title="2. register（寄存器变量，C++11后已废弃）"></a>2. <strong><code>register</code>（寄存器变量，C++11后已废弃）</strong></h3><ul><li><strong>定义</strong>：建议将变量存储在CPU寄存器中，以便快速访问。</li><li><strong>特点</strong>：<ul><li>提高访问速度，适合频繁使用的变量。</li><li>在现代编译器中，<code>register</code>的效果已被优化算法替代。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提示编译器将 i 存储在寄存器中</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-static（静态变量）"><a href="#3-static（静态变量）" class="headerlink" title="3. static（静态变量）"></a>3. <strong><code>static</code>（静态变量）</strong></h3><ul><li><strong>定义</strong>：变量的生命周期贯穿程序始终，无论它在局部还是全局作用域。</li><li><strong>特点</strong>：<ul><li><strong>局部静态变量</strong>：函数内部的<code>static</code>变量只初始化一次，值会在函数调用之间保留。</li><li><strong>全局静态变量</strong>：只能在当前文件中使用，其他文件无法访问。</li><li><strong>类静态变量</strong>：类中所有对象共享一个静态变量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="4-extern（外部变量）"><a href="#4-extern（外部变量）" class="headerlink" title="4. extern（外部变量）"></a>4. <strong><code>extern</code>（外部变量）</strong></h3><ul><li><strong>定义</strong>：声明一个全局变量或函数，使其在多个文件之间共享。</li><li><strong>特点</strong>：<ul><li>通常用于跨文件访问变量或函数。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sharedVar = <span class="number">42</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sharedVar; <span class="comment">// 引用 file1 中的变量</span></span><br><span class="line">std::cout &lt;&lt; sharedVar;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="5-mutable（可变成员变量）-1"><a href="#5-mutable（可变成员变量）-1" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong><code>mutable</code>（可变成员变量）</strong></h3><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>特点</strong>：<ul><li>通常用于缓存、计数器等需要在<code>const</code>上下文中改变状态的场景。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-thread-local（线程本地存储，C-11引入）"><a href="#6-thread-local（线程本地存储，C-11引入）" class="headerlink" title="6. thread_local（线程本地存储，C++11引入）"></a>6. <strong><code>thread_local</code>（线程本地存储，C++11引入）</strong></h3><ul><li><strong>定义</strong>：每个线程都有一个独立的变量副本，线程之间互不干扰。</li><li><strong>特点</strong>：<ul><li>适用于多线程编程。</li><li>每个线程的<code>thread_local</code>变量在线程结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    threadVar = id; <span class="comment">// 每个线程有独立的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h3><table><thead><tr><th><strong>存储类</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>自动推断变量类型，简化复杂类型的声明。</td></tr><tr><td><code>register</code></td><td>提示频繁使用的变量（现代C++中已废弃）。</td></tr><tr><td><code>static</code></td><td>保留局部变量值、限制全局变量访问范围、类成员共享变量。</td></tr><tr><td><code>extern</code></td><td>跨文件共享全局变量和函数。</td></tr><tr><td><code>mutable</code></td><td>在<code>const</code>对象中允许修改成员变量（如缓存或计数器）。</td></tr><tr><td><code>thread_local</code></td><td>线程安全，每个线程都有独立的变量副本。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++修饰符类型</title>
      <link href="/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-修饰符类型"><a href="#C-修饰符类型" class="headerlink" title="C++修饰符类型"></a>C++修饰符类型</h1><hr><h2 id="什么是修饰符类型？"><a href="#什么是修饰符类型？" class="headerlink" title="什么是修饰符类型？"></a>什么是修饰符类型？</h2><p>修饰符是用来调整变量的存储范围和行为的关键字。例如：</p><ul><li>变量是否能存储负数？</li><li>变量的存储范围是更大还是更小？</li></ul><p>C++ 提供了多个修饰符来满足不同的需求</p><hr><h3 id="常见修饰符"><a href="#常见修饰符" class="headerlink" title="常见修饰符"></a>常见修饰符</h3><ol><li><p><strong>signed（有符号）</strong></p><ul><li>变量可以存储正数和负数。</li><li><strong>默认情况下</strong>，整型变量（<code>int</code>）都是有符号的，所以<code>int</code>和<code>signed int</code>是一样的。</li></ul></li><li><p><strong>unsigned（无符号）</strong></p><ul><li>变量只能存储正数。</li><li>因为没有负数，存储范围扩大了一倍（范围从0开始）。</li></ul></li><li><p><strong>short（短整型）</strong></p><ul><li>比<code>int</code>的存储范围更小，通常用来节省存储空间。</li></ul></li><li><p><strong>long（长整型）</strong></p><ul><li>比<code>int</code>的存储范围更大，适合表示更大的数字。</li><li><strong>C++11</strong> 增加了<code>long long</code>，存储范围比<code>long</code>还要大。</li></ul></li><li><p><strong>float（单精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度较低。</li></ul></li><li><p><strong>double（双精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度比<code>float</code>更高。</li></ul></li><li><p><strong>bool（布尔类型）</strong></p><ul><li>只有两个值：<code>true</code>和<code>false</code>，常用于条件判断。</li></ul></li><li><p><strong>char（字符类型）</strong></p><ul><li>用来存储单个字符，比如<code>&#39;a&#39;</code>。</li></ul></li><li><p><strong>wchar_t（宽字符类型）</strong></p><ul><li>用来存储Unicode字符，可以表示多国语言的字符。</li></ul></li></ol><hr><h3 id="修饰符的组合"><a href="#修饰符的组合" class="headerlink" title="修饰符的组合"></a>修饰符的组合</h3><ul><li><p>修饰符可以组合使用，例如：</p><ul><li><code>unsigned long int</code>：无符号长整型。</li><li><code>short unsigned int</code>：无符号短整型。</li></ul></li><li><p><strong>简写方式</strong>：</p><ul><li>省略<code>int</code>是允许的，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> num1 = <span class="number">10</span>; <span class="comment">// 无符号整型变量</span></span><br><span class="line"><span class="type">short</span> num2 = <span class="number">5</span>;     <span class="comment">// 短整型变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="示例-1：普通变量的定义"><a href="#示例-1：普通变量的定义" class="headerlink" title="示例 1：普通变量的定义"></a>示例 1：普通变量的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>;    <span class="comment">// 有符号整型，值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>;   <span class="comment">// 无符号整型，值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> num3 = <span class="number">10</span>;          <span class="comment">// 短整型，值为 10</span></span><br><span class="line"><span class="type">long</span> num4 = <span class="number">100000</span>;       <span class="comment">// 长整型，值为 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num5 = <span class="number">10000000000</span>; <span class="comment">// 长长整型，值为 10000000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.14f</span>;         <span class="comment">// 单精度浮点数，值为 3.14</span></span><br><span class="line"><span class="type">double</span> e = <span class="number">2.71828</span>;       <span class="comment">// 双精度浮点数，值为 2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;         <span class="comment">// 布尔值，表示真</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;            <span class="comment">// 字符，值为 &#x27;A&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> wideChar = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 宽字符，值为 &#x27;你&#x27;</span></span><br></pre></td></tr></table></figure><hr><h4 id="示例-2：有符号和无符号的区别"><a href="#示例-2：有符号和无符号的区别" class="headerlink" title="示例 2：有符号和无符号的区别"></a>示例 2：有符号和无符号的区别</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> i;          <span class="comment">// 有符号短整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// 无符号短整型</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">50000</span>; <span class="comment">// 无符号变量 j 存储 50000</span></span><br><span class="line">    i = j;     <span class="comment">// i 将 j 的位模式解释为有符号数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j; <span class="comment">// 输出 -15536 和 50000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>j</code>存储的值是<code>50000</code>，它的二进制表示不会改变。</li><li>当将<code>j</code>的值赋给<code>i</code>时，二进制位模式被解释为有符号数，因此显示为<code>-15536</code>。</li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>有符号（signed）</strong>：可以存储正数和负数。</li><li><strong>无符号（unsigned）</strong>：只能存储正数，存储范围更大。</li><li><strong>short 和 long</strong>：分别表示更小或更大的整型范围。</li><li><strong>float 和 double</strong>：用于存储小数，<code>double</code>的精度更高。</li><li><strong>bool 和 char</strong>：布尔值表示真&#x2F;假，字符表示单个字符。</li><li><strong>wchar_t</strong>：表示Unicode字符。<br>通过修饰符，C++ 能够更灵活地定义变量类型，适应不同的存储需求。</li></ul><h2 id="C-中的类型限定符"><a href="#C-中的类型限定符" class="headerlink" title="C++中的类型限定符"></a>C++中的类型限定符</h2><hr><h3 id="什么是类型限定符？"><a href="#什么是类型限定符？" class="headerlink" title="什么是类型限定符？"></a>什么是类型限定符？</h3><p>类型限定符是C++中的关键字，用来给变量或函数添加额外的“行为限制”或“说明”。它们可以改变变量的默认行为，使其更适应特定需求。</p><hr><h3 id="常见的类型限定符"><a href="#常见的类型限定符" class="headerlink" title="常见的类型限定符"></a>常见的类型限定符</h3><table><thead><tr><th><strong>限定符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><code>const</code></td><td>表示变量是<strong>常量</strong>，定义后它的值不能被修改。</td></tr><tr><td><code>volatile</code></td><td>告诉编译器，这个变量的值可能会被外部（如硬件或其他线程）改变，因此不能对它的访问进行优化。</td></tr><tr><td><code>restrict</code></td><td><strong>仅在C99标准中</strong>：表示一个指针是访问它所指向对象的唯一方式，用于优化指针操作。</td></tr><tr><td><code>mutable</code></td><td>用于修饰类的成员变量，即使类对象是<code>const</code>的，也允许修改这个变量。</td></tr><tr><td><code>static</code></td><td>表示变量是静态的，它的生命周期贯穿整个程序，并且作用范围有限。</td></tr><tr><td><code>register</code></td><td>提示编译器将变量存储在CPU寄存器中，以提高访问速度（实际效果由编译器决定）。</td></tr></tbody></table><hr><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><h4 id="1-const（常量）"><a href="#1-const（常量）" class="headerlink" title="1. const（常量）"></a>1. <strong><code>const</code>（常量）</strong></h4><ul><li>定义后变量的值不能被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// NUM 是一个常量，不能被改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;NUM; <span class="comment">// ptr 是指向常量的指针，指针所指向的值不能修改</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li><code>NUM</code>是一个固定的值，就像刻在石头上的数字，无法更改。</li><li><code>ptr</code>是指向这块石头的指针，你可以看它，但不能刻字。</li></ul></li></ul><hr><h4 id="2-volatile（易变变量）"><a href="#2-volatile（易变变量）" class="headerlink" title="2. volatile（易变变量）"></a>2. <strong><code>volatile</code>（易变变量）</strong></h4><ul><li>告诉编译器，这个变量的值可能会在程序以外被修改（如硬件或多线程）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// num 的值可能会被硬件改变</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>这个变量是一个随时可能“被动”变化的数字，比如硬件设备传回来的数据。</li></ul></li></ul><hr><h4 id="3-mutable（可变成员变量）"><a href="#3-mutable（可变成员变量）" class="headerlink" title="3. mutable（可变成员变量）"></a>3. <strong><code>mutable</code>（可变成员变量）</strong></h4><ul><li>修饰类成员变量时，即使对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// 允许修改 value_，即使这个函数是 const 的</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_; <span class="comment">// value_ 是可变的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>一个“特别许可”的变量，即使在“禁止修改”的情况下，也可以被改变。</li></ul></li></ul><hr><h4 id="4-static（静态变量）"><a href="#4-static（静态变量）" class="headerlink" title="4. static（静态变量）"></a>4. <strong><code>static</code>（静态变量）</strong></h4><ul><li>静态变量的生命周期贯穿整个程序，作用范围却受限。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 的值在整个程序中保留</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>静态变量就像一个“长期储存”的数据，即使函数结束，它的值也会保留。</li></ul></li></ul><hr><h4 id="5-register（寄存器变量）"><a href="#5-register（寄存器变量）" class="headerlink" title="5. register（寄存器变量）"></a>5. <strong><code>register</code>（寄存器变量）</strong></h4><ul><li>建议编译器将变量存储在CPU的寄存器中，以提高访问速度（是否采纳由编译器决定）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提示编译器将 num 存储在寄存器中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>把一个变量放在“最快的储物柜”里，方便程序快速访问。</li></ul></li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li>**<code>const</code>**：值不能改动，就像固定的规则。</li><li>**<code>volatile</code>**：值可能会被外部修改，比如实时更新的数据。</li><li>**<code>mutable</code>**：给特别变量的“修改许可”。</li><li>**<code>static</code>**：数据长期有效，即使函数多次调用也保留值。</li><li>**<code>register</code>**：请求把变量放到“快速通道”，提高访问速度。<br>可以看出，这些限定符让C++中的变量更灵活、更高效地适应不同的需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常量</title>
      <link href="/2024/11/16/C-%E5%B8%B8%E9%87%8F/"/>
      <url>/2024/11/16/C-%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C++常量"></a>C++常量</h1><p>在C++编程语言中，常量指的是那些一旦被设定就不能再改变的值，它们就像是被冻结的数据，始终保持不变。这些值就像是直接写在代码里的字面量，比如数字、字母或者特定的文本。</p><p>常量可以是各种基本数据类型，包括：</p><ol><li><strong>整型数字</strong>：比如整数123。</li><li><strong>浮点数字</strong>：比如带有小数点的数字3.14。</li><li><strong>字符</strong>：单个字母或符号，比如’A’或’#’。</li><li><strong>字符串</strong>：一系列字符组成的文本，比如”Hello, World!”。</li><li><strong>布尔值</strong>：只有两个可能的值，true（真）或false（假）。</li></ol><p><strong>注意：常量和变量类似，但关键的区别在于常量一旦被赋予一个值，这个值就不能被改变。这意味着，如果你在程序中声明了一个常量，你就必须在声明时给它一个值，并且在程序的其余部分，这个值是不可更改的。这样的设计可以帮助避免在程序运行过程中意外改变重要的数据，确保程序的稳定性和可靠性。</strong></p><hr><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><ul><li><p><strong>定义</strong>：整数常量是没有小数部分的数字，可以是十进制、八进制或十六进制。</p></li><li><p><strong>进制表示</strong>：</p><ul><li><strong>十进制</strong>：直接写数字，比如 <code>85</code>。</li><li><strong>八进制</strong>：以 <code>0</code> 开头，比如 <code>0213</code>。</li><li><strong>十六进制</strong>：以 <code>0x</code> 或 <code>0X</code> 开头，比如 <code>0x4B</code>。</li></ul></li><li><p><strong>后缀</strong>：整数常量可以带后缀，表示类型：</p><ul><li><code>U</code>：无符号整数（Unsigned）。</li><li><code>L</code>：长整数（Long）。</li><li>顺序不重要，比如 <code>30U</code> 和 <code>30u</code> 都可以。</li></ul></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的十进制整数</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">// 合法的无符号整数</span></span><br><span class="line"><span class="number">0xFeeL</span>      <span class="comment">// 合法的十六进制长整数</span></span><br><span class="line"><span class="number">07</span>8         <span class="comment">// 非法：8 不是八进制数字</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">// 非法：不能重复后缀</span></span><br></pre></td></tr></table></figure><hr><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><ul><li><strong>定义</strong>：浮点常量是带小数点的数，或者用科学计数法表示的数。</li><li><strong>表示方式</strong>：<ul><li><strong>小数形式</strong>：同时包含整数部分和小数部分，比如 <code>3.14</code>。</li><li><strong>指数形式</strong>：用 <code>e</code> 或 <code>E</code> 表示，比如 <code>314E-2</code>（等于 3.14）。</li></ul></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>小数形式必须包含整数或小数部分，比如 <code>3.</code> 或 <code>.141</code>。</li><li>指数形式必须包含 <code>e</code> 或 <code>E</code>，后面跟一个指数值。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的小数形式</span></span><br><span class="line"><span class="number">314159E-5L</span>    <span class="comment">// 合法的指数形式</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法：缺少指数</span></span><br><span class="line">.e55          <span class="comment">// 非法：缺少整数部分</span></span><br></pre></td></tr></table></figure><hr><h2 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h2><ul><li><strong>定义</strong>：布尔常量只有两个值，用于表示“真”和“假”：<ul><li><code>true</code>：表示“真”。</li><li><code>false</code>：表示“假”。</li></ul></li><li><strong>注意</strong>：虽然 <code>true</code> 和 <code>false</code> 在底层分别表示 <code>1</code> 和 <code>0</code>，但我们不应该直接把它们当成数字使用。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> isComplete = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><ul><li><strong>定义</strong>：字符常量是用单引号包裹的单个字符，比如 <code>&#39;a&#39;</code>。</li><li><strong>宽字符</strong>：<ul><li>如果以 <code>L</code> 开头（如 <code>L&#39;x&#39;</code>），则表示宽字符，存储在 <code>wchar_t</code> 类型变量中。</li></ul></li><li><strong>窄字符</strong>：<ul><li>普通字符（如 <code>&#39;x&#39;</code>）存储在 <code>char</code> 类型变量中。</li></ul></li></ul><h4 id="特殊字符（转义序列）："><a href="#特殊字符（转义序列）：" class="headerlink" title="特殊字符（转义序列）："></a>特殊字符（转义序列）：</h4><ul><li><strong>转义字符</strong>：用反斜杠 <code>\</code> 开头，表示特殊含义的字符。</li><li><strong>常见转义字符</strong>：<table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td><code>\\</code></td><td>反斜杠 <code>\</code></td></tr><tr><td><code>\&#39;</code></td><td>单引号 <code>&#39;</code></td></tr><tr><td><code>\&quot;</code></td><td>双引号 <code>&quot;</code></td></tr><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\r</code></td><td>回车符</td></tr></tbody></table></li></ul><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello\tWorld\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><ul><li><strong>定义</strong>：字符串常量是用双引号<code>&quot;&quot;</code>包裹的一段文本内容。</li><li><strong>组成</strong>：它可以包含普通字符、特殊字符（通过转义序列如<code>\n</code>表示换行）以及通用字符（如Unicode字符）。</li></ul><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>如何表示字符串</strong>：  </p><ul><li>只需要用双引号包裹内容，例如：<code>&quot;Hello, World!&quot;</code>。</li><li>字符串中可以包含字母、数字、符号，以及通过转义序列表示的特殊字符。</li></ul></li><li><p><strong>分行显示字符串</strong>：  </p><ul><li>如果字符串太长，可以使用反斜杠<code>\</code>将其分成多行书写，但显示时仍会显示为一行。</li></ul></li></ol><hr><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码展示了如何使用字符串常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个普通的字符串常量</span></span><br><span class="line">    string greeting = <span class="string">&quot;hello, runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting &lt;&lt; endl;  <span class="comment">// 输出字符串并换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个分行的字符串常量</span></span><br><span class="line">    string greeting2 = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">                       runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting2 &lt;&lt; endl;  <span class="comment">// 显示为一行输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob</span><br><span class="line">hello, runoob</span><br></pre></td></tr></table></figure><hr><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><code>greeting</code>是一个普通的字符串，直接赋值并输出。</li><li><code>greeting2</code>使用了反斜杠<code>\</code>来分行写字符串，但显示时仍为一行，因为<code>\</code>只是告诉编译器“这是一行字符串，书写上分为了多行”。</li></ol><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>整数常量</strong>：表示整数，可以加后缀指定类型，支持十进制、八进制和十六进制。</li><li><strong>浮点常量</strong>：表示带小数的数，支持小数形式和指数形式。</li><li><strong>布尔常量</strong>：表示逻辑上的真或假，分别为 <code>true</code> 和 <code>false</code>。</li><li><strong>字符常量</strong>：用单引号表示单个字符，支持转义字符表示特殊符号。</li><li><strong>字符串常量</strong>是用双引号括起来的文本。</li><li>如果字符串太长，可以用反斜杠<code>\</code>进行分行，输出时仍显示为一行。</li><li>字符串可以包含特殊字符，比如<code>\n</code>表示换行符，<code>\t</code>表示制表符。</li></ul><p>以下是对“定义常量”更通俗易懂的解释：</p><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li>如前面所说，<strong>常量</strong>是值在程序运行过程中<strong>不会改变</strong>的变量。</li><li>在C++中，我们可以通过两种简单的方法定义常量：<ol><li>使用<code>#define</code>预处理器。</li><li>使用<code>const</code>关键字。</li></ol></li></ul><hr><h3 id="方法一：使用-define预处理器"><a href="#方法一：使用-define预处理器" class="headerlink" title="方法一：使用#define预处理器"></a>方法一：使用<code>#define</code>预处理器</h3><ul><li><code>#define</code> 是一种直接替换文本的工具，在编译前会将程序中所有出现的标识符替换为指定的值。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10  <span class="comment">// 定义常量 LENGTH 为 10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  5   <span class="comment">// 定义常量 WIDTH 为 5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// 定义换行符常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li>程序运行前，所有的<code>LENGTH</code>都会被替换为<code>10</code>，<code>WIDTH</code>会被替换为<code>5</code>，<code>NEWLINE</code>会被替换为换行符。</li><li><code>#define</code>没有类型约束，是一种简单直接的方法。</li></ul><hr><h3 id="方法二：使用const关键字"><a href="#方法二：使用const关键字" class="headerlink" title="方法二：使用const关键字"></a>方法二：使用<code>const</code>关键字</h3><ul><li><code>const</code> 是一种更严格的方式，用于定义带类型的常量。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">10</span>;  <span class="comment">// 定义一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">5</span>;    <span class="comment">// 定义另一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 定义换行符常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><ul><li>使用<code>const</code>定义的常量有类型约束，更加安全。</li><li><code>const</code>可以直接参与类型检查，这对大型程序更有帮助。</li></ul><hr><h3 id="哪种方式更好？"><a href="#哪种方式更好？" class="headerlink" title="哪种方式更好？"></a>哪种方式更好？</h3><ul><li><p>**<code>#define</code>**：</p><ul><li>优点：简单直接，没有类型约束。</li><li>缺点：在大型项目中，缺乏类型检查，可能会引发难以追踪的错误。</li></ul></li><li><p>**<code>const</code>**：</p><ul><li>优点：具有类型约束，更加安全；现代C++中更推荐使用。</li><li>缺点：相较于<code>#define</code>，书写稍显繁琐。</li></ul></li></ul><hr><h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><ul><li>通常，我们会将常量的名字用<strong>大写字母</strong>表示，这样可以让代码更容易阅读和维护。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SPEED = <span class="number">120</span>;  <span class="comment">// 推荐的命名方式</span></span><br></pre></td></tr></table></figure>通过以上两种方式，你可以选择适合自己需求的方式来定义常量。对于现代C++程序，推荐优先使用<code>const</code>关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量作用域</title>
      <link href="/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量作用域的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>这里温故一下</strong></p><h1 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++变量作用域"></a>C++变量作用域</h1><h3 id="1-变量的定义位置"><a href="#1-变量的定义位置" class="headerlink" title="1. 变量的定义位置"></a>1. 变量的定义位置</h3><p>在C++中，根据变量定义的位置，变量可以分为以下几类：</p><ul><li><strong>局部变量</strong>：在函数或代码块中声明的变量，只能在该函数或块中使用。</li><li><strong>形式参数</strong>：函数的参数，它是函数调用时用来接收外部传入数据的变量。</li><li><strong>全局变量</strong>：在所有函数之外声明的变量，可以在整个程序中使用。</li></ul><hr><h3 id="2-什么是作用域？"><a href="#2-什么是作用域？" class="headerlink" title="2. 什么是作用域？"></a>2. 什么是作用域？</h3><p>作用域是一个变量可以被访问的“范围”或“区域”。根据变量的定义位置，它的作用域可以分为以下几种：</p><h4 id="（1）局部作用域"><a href="#（1）局部作用域" class="headerlink" title="（1）局部作用域"></a>（1）局部作用域</h4><ul><li><strong>定义位置</strong>：在函数内部声明。</li><li><strong>特点</strong>：<ul><li>只能在函数内部访问，函数外部无法使用。</li><li>每次调用函数时，局部变量都会被创建；函数结束后，局部变量会被销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）全局作用域"><a href="#（2）全局作用域" class="headerlink" title="（2）全局作用域"></a>（2）全局作用域</h4><ul><li><strong>定义位置</strong>：在所有函数之外。</li><li><strong>特点</strong>：<ul><li>全局变量可以被程序中的任何函数访问。</li><li>全局变量在程序启动时创建，程序结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// x 是全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 可以访问全局变量 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）块作用域"><a href="#（3）块作用域" class="headerlink" title="（3）块作用域"></a>（3）块作用域</h4><ul><li><strong>定义位置</strong>：在代码块 <code>&#123;&#125;</code> 内部。</li><li><strong>特点</strong>：<ul><li>只能在块内部访问，块外部无法使用。</li><li>每次执行代码块时，块作用域的变量都会被创建，执行完后销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>; <span class="comment">// x 是块作用域变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）类作用域"><a href="#（4）类作用域" class="headerlink" title="（4）类作用域"></a>（4）类作用域</h4><ul><li><strong>定义位置</strong>：在类的内部。</li><li><strong>特点</strong>：<ul><li>类作用域的变量可以被类的所有成员函数访问。</li><li>它的生命周期与类的对象相同。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// x 是类作用域的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        x = value; <span class="comment">// 可以访问类的变量 x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-特殊情况：变量重名"><a href="#3-特殊情况：变量重名" class="headerlink" title="3. 特殊情况：变量重名"></a>3. 特殊情况：变量重名</h3><p>如果在内部作用域中声明的变量与外部作用域中的变量同名，内部作用域的变量会覆盖外部作用域的变量。</p><ul><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">50</span>; <span class="comment">// 全局变量 x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 局部变量 x，覆盖了全局变量 x</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>局部变量</strong>：在函数或代码块中声明，只能在内部使用。</li><li><strong>全局变量</strong>：在所有函数之外声明，可以在程序的任何地方使用。</li><li><strong>块作用域变量</strong>：在 <code>&#123;&#125;</code> 中声明，只能在块内部使用。</li><li><strong>类作用域变量</strong>：在类内部声明，可以被类的所有成员函数使用。</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><hr><h3 id="什么是局部变量？"><a href="#什么是局部变量？" class="headerlink" title="什么是局部变量？"></a>什么是局部变量？</h3><ul><li>局部变量是<strong>在函数或代码块内部声明的变量</strong>，它们的作用范围仅限于声明它们的那个函数或代码块。</li><li>当函数执行结束时，局部变量就会被销毁。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a, b, c; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>a</code>, <code>b</code>, <code>c</code> 是局部变量，它们只能在<code>main()</code>函数中使用。</li><li>当程序运行到<code>return 0;</code>时，<code>a</code>, <code>b</code>, <code>c</code>会被销毁，无法在<code>main()</code>之外访问。</li></ul><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="什么是全局变量？"><a href="#什么是全局变量？" class="headerlink" title="什么是全局变量？"></a>什么是全局变量？</h3><ul><li>全局变量是在<strong>所有函数之外</strong>定义的变量。</li><li>它们的作用范围是整个程序，可以在任何函数中使用。</li><li>全局变量在程序开始时创建，在程序结束时销毁。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    g = a + b;  <span class="comment">// 赋值给全局变量 g</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>g</code>是全局变量，<code>a</code>和<code>b</code>是局部变量。</li><li><code>g</code>可以被程序中的任何函数访问，比如<code>main()</code>。</li></ul><hr><h3 id="局部变量和全局变量同名时的情况"><a href="#局部变量和全局变量同名时的情况" class="headerlink" title="## 局部变量和全局变量同名时的情况"></a>## 局部变量和全局变量同名时的情况</h3><ul><li>如果局部变量和全局变量同名，在函数内部使用的是局部变量，<strong>局部变量会覆盖全局变量的值</strong>。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>全局变量<code>g</code>的值是<code>20</code>，但在<code>main()</code>函数中，局部变量<code>g</code>的值是<code>10</code>。</li><li>当程序运行到<code>cout &lt;&lt; g;</code>时，优先使用局部变量<code>g</code>，所以输出是<code>10</code>。</li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li><p><strong>局部变量</strong>：</p><ul><li>定义在函数或代码块内部。</li><li>只能在声明它的地方使用，离开作用域就无法访问。</li><li>在函数结束时销毁。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li>定义在所有函数外部。</li><li>作用范围是整个程序，任何函数都可以访问。</li><li>在程序运行期间一直存在。</li></ul></li></ul><h2 id="局部变量和全局变量的初始化"><a href="#局部变量和全局变量的初始化" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h2><hr><h3 id="局部变量和全局变量的初始化-1"><a href="#局部变量和全局变量的初始化-1" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h3><h4 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h4><ul><li>局部变量是定义在函数或代码块内部的变量。</li><li><strong>特点</strong>：<ul><li>局部变量<strong>不会自动初始化</strong>，如果没有赋值，变量的值是随机的，可能会导致意外的结果。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 局部变量未初始化</span></span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li>全局变量是定义在所有函数之外的变量。</li><li><strong>特点</strong>：<ul><li>全局变量<strong>会自动初始化</strong>，默认值取决于数据类型：<table><thead><tr><th><strong>数据类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td><code>int</code></td><td>0</td></tr><tr><td><code>char</code></td><td><code>&#39;\0&#39;</code></td></tr><tr><td><code>float</code></td><td>0.0</td></tr><tr><td><code>double</code></td><td>0.0</td></tr><tr><td>指针</td><td><code>NULL</code></td></tr></tbody></table></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;  <span class="comment">// 全局变量自动初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>块作用域指的是在代码块 <code>&#123;&#125;</code> 内部定义的变量，这些变量只在该块内有效。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 外部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 块作用域变量，覆盖外部变量 a</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;块变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">块变量: 20</span><br><span class="line">外部变量: 10</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>在块 <code>&#123;&#125;</code> 内部声明的变量 <code>a</code> 是一个新的变量，覆盖了外部变量 <code>a</code>。</li><li>块执行完后，内部变量 <code>a</code> 被销毁，外部变量 <code>a</code> 重新生效。</li></ul><hr><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>类作用域指的是在类中声明的变量，这些变量属于类，可以被类的所有成员函数访问。</p><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> class_var;  <span class="comment">// 类作用域变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类变量并初始化</span></span><br><span class="line"><span class="type">int</span> MyClass::class_var = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类变量: &quot;</span> &lt;&lt; MyClass::class_var &lt;&lt; std::endl;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类变量: 30</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>class_var</code> 是类的一个静态变量，属于整个类，而不是某个对象。</li><li>使用类名和作用域解析符号 <code>::</code> 可以直接访问它，无需创建类的实例。</li></ul><hr><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><ol><li><strong>局部变量</strong>：需要手动初始化；仅在函数或代码块内有效。</li><li><strong>全局变量</strong>：自动初始化；在整个程序中都可访问。</li><li><strong>块作用域</strong>：块内的变量会覆盖外部变量，块结束后自动销毁。</li><li><strong>类作用域</strong>：类中的变量可以通过类名访问，生命周期与类相关。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人新作</title>
      <link href="/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/"/>
      <url>/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>看到这个标题想必大家也知晓今天的内容是什么了😏，没错，今天我带来的是我的新作，一首纯音乐，歌名叫做《Sunrise》。由于github不支持超过100MB的文件，所以我上传的视频只是部分内容，如果有想要看完整内容的小伙伴，可以通过文章底部的链接下载哦~</strong><br><strong>废话不多说，开始吧！</strong><br><strong>自制歌曲：Sunrise</strong><br><strong>音频制作与处理：码头</strong><br><strong>后期：码头</strong><br><strong>工具：</strong><br><strong>音频制作：Fruity Loops Studio</strong><br><strong>音频处理：Adobe Audition</strong><br><strong>图片：Photoshop</strong><br><strong>动画特效：Adobe After Effects</strong><br><strong>剪辑：Adobe Premiere Pro</strong></p><h1 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h1><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p><strong>以下是音频文件。温馨提示：戴上耳机效果更佳哦！😋</strong><br><audio controls><br>    <source src="/music/Sunrise.wav" type="audio/wav"><br>    您的浏览器不支持 audio 元素。<br></audio></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><strong>以下是视频文件，与上面一样，戴上耳机效果更佳！</strong><br><video controls><br>  <source src="/video/20241115182839517.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA">https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA</a></strong><br><strong>提取码:yb77</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量类型</title>
      <link href="/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++变量类型"></a>C++变量类型</h1><p>在程序中，<strong>变量</strong>就是存储数据的容器。它们是程序可以操作的存储位置，每个变量都有一个名字和特定的数据类型。</p><hr><h3 id="变量类型的作用"><a href="#变量类型的作用" class="headerlink" title="变量类型的作用"></a>变量类型的作用</h3><ul><li><strong>变量类型</strong>定义了：<ol><li><strong>占用的内存大小和布局</strong>：不同类型的数据需要不同大小的内存空间。</li><li><strong>可以存储的值范围</strong>：例如，整数型不能存储小数，布尔型只能存储 <code>true</code> 或 <code>false</code>。</li><li><strong>适用的运算</strong>：变量类型决定了哪些运算符可以对它们进行操作。</li></ol></li></ul><hr><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ol><li><strong>可以使用的字符</strong>：变量名可以由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线（_）</strong>组成。</li><li><strong>开头限制</strong>：变量名必须以<strong>字母</strong>或<strong>下划线</strong>开头，不能以数字开头。</li><li><strong>区分大小写</strong>：C++ 是<strong>区分大小写</strong>的语言，所以 <code>Var</code> 和 <code>var</code> 是两个不同的变量名。</li><li><strong>建议使用有意义的名称</strong>：例如，用 <code>age</code> 表示年龄，比用 <code>a</code> 更直观。</li></ol><hr><h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>C++ 中有多种变量类型，每种类型适用于不同种类的数据，例如：</p><ul><li><strong>整数型</strong>存储整数。</li><li><strong>浮点型</strong>存储小数。</li><li><strong>字符型</strong>存储单个字符。</li><li><strong>布尔型</strong>存储逻辑值（<code>true</code> 或 <code>false</code>）。</li></ul><p>在后续章节中，我们将具体介绍这些变量类型的使用和特点！</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Data Types Description</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>Data Types Description</h2><table>    <tr>        <th>类型</th>        <th>描述</th>    </tr>    <tr>        <td>bool</td>        <td>布尔类型，存储值 true 或 false，占用 1 个字节。</td>    </tr>    <tr>        <td>char</td>        <td>字符类型，用于存储 ASCII 字符，通常占用 1 个字节。</td>    </tr>    <tr>        <td>int</td>        <td>整数类型，通常用于存储普通整数，通常占用 4 个字节。</td>    </tr>    <tr>        <td>float</td>        <td>单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。</td>    </tr>    <tr>        <td>double</td>        <td>双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。</td>    </tr>    <tr>        <td>void</td>        <td>表示类型的缺失。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。</td>    </tr></table></body></html><h2 id="C-中的变量类型"><a href="#C-中的变量类型" class="headerlink" title="C++中的变量类型"></a>C++中的变量类型</h2><p>在 C++ 中，你可以定义各种类型的变量来存储不同种类的数据，以下是常见的几种类型：</p><h3 id="整数类型-Integer-Types"><a href="#整数类型-Integer-Types" class="headerlink" title="整数类型 (Integer Types)"></a>整数类型 (Integer Types)</h3><ul><li><strong>int</strong>：存储整数，通常占用 4 个字节。</li><li><strong>short</strong>：存储较小的整数，通常占用 2 个字节。</li><li><strong>long</strong>：存储较大的整数，通常占用 4 个字节。</li><li><strong>long long</strong>：存储更大的整数，通常占用 8 个字节。</li></ul><h3 id="浮点类型-Floating-Point-Types"><a href="#浮点类型-Floating-Point-Types" class="headerlink" title="浮点类型 (Floating-Point Types)"></a>浮点类型 (Floating-Point Types)</h3><ul><li><strong>float</strong>：存储单精度浮点数（带小数的数），通常占用 4 个字节。</li><li><strong>double</strong>：存储双精度浮点数，精度比 <code>float</code> 高，通常占用 8 个字节。</li><li><strong>long double</strong>：存储更高精度的浮点数，字节数依编译器和系统而不同。</li></ul><h3 id="字符类型-Character-Types"><a href="#字符类型-Character-Types" class="headerlink" title="字符类型 (Character Types)"></a>字符类型 (Character Types)</h3><ul><li><strong>char</strong>：存储一个字符，通常占用 1 个字节。</li><li><strong>wchar_t</strong>：存储宽字符（用于表示更复杂的字符），占用 2 或 4 个字节。</li><li><strong>char16_t</strong>：存储 16 位 Unicode 字符，占用 2 个字节。</li><li><strong>char32_t</strong>：存储 32 位 Unicode 字符，占用 4 个字节。</li></ul><h3 id="布尔类型-Boolean-Type"><a href="#布尔类型-Boolean-Type" class="headerlink" title="布尔类型 (Boolean Type)"></a>布尔类型 (Boolean Type)</h3><ul><li><strong>bool</strong>：存储布尔值，只能是 <code>true</code> 或 <code>false</code>。</li></ul><h3 id="枚举类型-Enumeration-Types"><a href="#枚举类型-Enumeration-Types" class="headerlink" title="枚举类型 (Enumeration Types)"></a>枚举类型 (Enumeration Types)</h3><ul><li><strong>enum</strong>：定义一组命名的整数常量，通常用来表示具有多个固定值的变量。</li></ul><h3 id="指针类型-Pointer-Types"><a href="#指针类型-Pointer-Types" class="headerlink" title="指针类型 (Pointer Types)"></a>指针类型 (Pointer Types)</h3><ul><li><strong>type</strong>*：存储指向某个类型变量的地址。</li></ul><h3 id="数组类型-Array-Types"><a href="#数组类型-Array-Types" class="headerlink" title="数组类型 (Array Types)"></a>数组类型 (Array Types)</h3><ul><li><strong>type[] 或 type[size]：</strong>存储多个相同类型的元素。</li></ul><h3 id="结构体类型-Structure-Types"><a href="#结构体类型-Structure-Types" class="headerlink" title="结构体类型 (Structure Types)"></a>结构体类型 (Structure Types)</h3><ul><li><strong>struct</strong>：存储多个不同类型的数据（可以是整数、字符等的组合）。</li></ul><h3 id="类类型-Class-Types"><a href="#类类型-Class-Types" class="headerlink" title="类类型 (Class Types)"></a>类类型 (Class Types)</h3><ul><li><strong>class</strong>：存储具有属性和方法的自定义数据类型。</li></ul><h3 id="共用体类型-Union-Types"><a href="#共用体类型-Union-Types" class="headerlink" title="共用体类型 (Union Types)"></a>共用体类型 (Union Types)</h3><ul><li><strong>union</strong>：存储多种类型的数据，但它们共享同一块内存空间，这意味着同一时刻只能存储其中一种类型。</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>C++ 标准规定了这些类型的最小大小，但实际占用的字节数可能会因为编译器或计算机架构的不同而有所差异。例如，<code>int</code> 在许多现代计算机上占用 4 字节，<code>long</code> 有时占用 8 字节。</li><li>了解这些变量类型及其占用内存的特点有助于更好地管理程序中的数据和内存。</li></ul><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++中的变量定义"></a>C++中的变量定义</h2><p>在 C++ 中，<strong>变量定义</strong>是指告诉编译器在内存中为变量分配空间，并指定变量的数据类型。</p><h3 id="变量定义的基本形式："><a href="#变量定义的基本形式：" class="headerlink" title="变量定义的基本形式："></a>变量定义的基本形式：</h3><p>定义一个变量时，需要指定它的数据类型和变量的名称，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><p>这里，<code>type</code> 是你要定义的变量的数据类型，例如 <code>int</code>（整数）、<code>char</code>（字符）等，<code>variable_list</code> 是你要定义的变量名，多个变量名用逗号分隔。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;   <span class="comment">// 定义了三个整数变量 i, j, k</span></span><br><span class="line"><span class="type">char</span> c, ch;     <span class="comment">// 定义了两个字符变量 c 和 ch</span></span><br><span class="line"><span class="type">float</span> f, salary; <span class="comment">// 定义了两个浮点数变量 f 和 salary</span></span><br><span class="line"><span class="type">double</span> d;       <span class="comment">// 定义了一个双精度浮点数变量 d</span></span><br></pre></td></tr></table></figure><p>这行代码表示在内存中为 <code>i</code>、<code>j</code>、<code>k</code>、<code>c</code>、<code>ch</code>、<code>f</code>、<code>salary</code> 和 <code>d</code> 这些变量分配空间，并且每个变量的类型已经被明确指定。</p><h3 id="变量初始化："><a href="#变量初始化：" class="headerlink" title="变量初始化："></a>变量初始化：</h3><p>你可以在定义变量时，给它们一个初始值，这叫做<strong>初始化</strong>。格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;    <span class="comment">// 定义并初始化了两个整数变量 d 和 f</span></span><br><span class="line">byte z = <span class="number">22</span>;         <span class="comment">// 定义并初始化了一个名为 z 的变量</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>;        <span class="comment">// 定义了一个字符变量 x，其值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>这里，<code>d</code> 被初始化为 3，<code>f</code> 被初始化为 5，<code>z</code> 被初始化为 22，而 <code>x</code> 被初始化为字符 <code>&#39;x&#39;</code>。</p><h3 id="未初始化的变量："><a href="#未初始化的变量：" class="headerlink" title="未初始化的变量："></a>未初始化的变量：</h3><p>如果你定义变量时没有给它们初始值，那么对于<strong>静态存储持续时间的变量</strong>，它们会被自动初始化为 0（空值）；而对于<strong>局部变量</strong>，它们没有初始值，可能包含不确定的值，这样的变量会被称为“未定义值”。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>变量定义时，你要指定数据类型和变量名。</li><li>可以在定义时给变量初始化一个值。</li><li>如果没有初始化，静态变量会被自动初始化为 0，而其他变量没有初始值。</li></ul><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++中的变量声明"></a>C++中的变量声明</h2><p>在 C++ 中，<strong>变量声明</strong>告诉编译器你将在某个地方使用某个变量，但不需要在此时提供变量的具体内容。简单来说，声明只是告诉编译器“这个变量存在”。而<strong>变量定义</strong>则是真正分配内存空间并给变量赋值的过程。</p><h3 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h3><p>声明一个变量时，使用<code>extern</code>关键字告诉编译器该变量在其他地方定义，不需要在当前代码中重复定义。声明的目的是为了让编译器知道该变量的类型和名称，以便在编译时不会出错。</p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> type variable_name;</span><br></pre></td></tr></table></figure><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;   <span class="comment">// 声明了 a 和 b，表示它们将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c;      <span class="comment">// 声明了 c，表示它将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> f;    <span class="comment">// 声明了 f，表示它将在其他地方定义</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 变量定义和初始化</span></span><br><span class="line">  <span class="type">int</span> a, b;         <span class="comment">// 定义变量 a 和 b</span></span><br><span class="line">  <span class="type">int</span> c;            <span class="comment">// 定义变量 c</span></span><br><span class="line">  <span class="type">float</span> f;          <span class="comment">// 定义变量 f</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;   <span class="comment">// 输出 c 的值</span></span><br><span class="line"></span><br><span class="line">  f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl;   <span class="comment">// 输出 f 的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>我们在代码的开头声明了<code>a</code>、<code>b</code>、<code>c</code>和<code>f</code>这几个变量，告诉编译器它们将在其他地方定义。</li><li>然后，在<code>main</code>函数中，我们实际上定义了这些变量并初始化了它们。</li></ul><h3 id="重要注意点："><a href="#重要注意点：" class="headerlink" title="重要注意点："></a>重要注意点：</h3><ol><li><strong>声明</strong>：只是告诉编译器变量存在，不会分配内存。例如，<code>extern int a;</code> 声明了变量<code>a</code>，但它没有给<code>a</code>分配内存。</li><li><strong>定义</strong>：才会为变量分配内存，并且可以给它一个初始值。例如，<code>int a = 10;</code> 会定义变量<code>a</code>，并给它分配内存和初始值。</li><li><strong>多个声明，单次定义</strong>：你可以在多个地方声明同一个变量，但只应该在一个地方定义它。定义时会分配内存并赋值。</li></ol><h3 id="类似函数声明："><a href="#类似函数声明：" class="headerlink" title="类似函数声明："></a>类似函数声明：</h3><p>就像变量声明一样，函数也可以先声明再定义。你可以在程序的其他地方声明一个函数，而函数的定义可以放在程序的任何位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">func</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数<code>func</code>先声明，在<code>main</code>函数中调用它，实际的定义可以放在程序的任何地方。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>变量声明</strong>只是告诉编译器变量存在，并不分配内存。</li><li><strong>变量定义</strong>才会分配内存，并可以赋初值。</li><li><strong>函数声明</strong>告诉编译器函数存在，函数的实际实现可以在其他地方。</li></ul><h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues）"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>在 C++ 中，<strong>左值</strong>（Lvalue）和 <strong>右值</strong>（Rvalue）是两种不同类型的表达式，它们的区别在于是否可以被赋值，以及它们代表的内存位置。</p><h3 id="左值（Lvalue）："><a href="#左值（Lvalue）：" class="headerlink" title="左值（Lvalue）："></a>左值（Lvalue）：</h3><ul><li><strong>定义</strong>：左值表示一个可以出现在赋值符号（&#x3D;）左边的表达式，通常是一个可以定位到内存地址的对象。</li><li><strong>特点</strong>：左值表示一个存储位置，可以对其进行赋值，因为它表示内存中的一个具体位置。</li><li><strong>例子</strong>：变量、数组元素、解引用的指针等都是左值。例如，<code>g = 20;</code> 中的 <code>g</code> 是左值，因为它可以接受赋值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;  <span class="comment">// g 是左值</span></span><br><span class="line">g = <span class="number">30</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="右值（Rvalue）："><a href="#右值（Rvalue）：" class="headerlink" title="右值（Rvalue）："></a>右值（Rvalue）：</h3><ul><li><strong>定义</strong>：右值通常是一个没有明确内存地址的表达式。它表示一个临时的值或常量，通常只出现在赋值符号的右边。</li><li><strong>特点</strong>：右值不能出现在赋值符号的左边，因为它没有可以存储的内存位置，不能被赋值。</li><li><strong>例子</strong>：常量、字面值、表达式的计算结果（如 <code>10 + 5</code>）等都是右值。例如，<code>10 = 20;</code> 是非法的，因为 <code>10</code> 是右值，不能作为赋值的左边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能出现在赋值符号的左边</span></span><br></pre></td></tr></table></figure><h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul><li><strong>左值</strong>：可以出现在赋值符号的左边，表示一个可以被修改的内存位置（如变量）。</li><li><strong>右值</strong>：只能出现在赋值符号的右边，表示一个临时的、无法修改的值（如常量或表达式的结果）。</li></ul><p><strong>正确的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// a 是左值，10 是右值</span></span><br><span class="line">a = <span class="number">20</span>;       <span class="comment">// 可以对 a（左值）赋值</span></span><br></pre></td></tr></table></figure><p><strong>错误的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能作为赋值的左边</span></span><br></pre></td></tr></table></figure><p>通过这种方式，你可以理解左值是可以被赋值和修改的存储位置，而右值则是一次性的值，不能直接进行赋值。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的关键字（保留字）完整介绍</title>
      <link href="/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        body {            text-align: left; /* 使整个页面内容居中 */        }        table {            margin: 0 auto; /* 使表格在页面中居中 */            border-collapse: collapse;            font-weight: bold; /* 字体加粗 */        }        th, td {            border: 1px solid #ddd;            padding: 8px;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>保留字(关键字)</h2><p>C++系统中预定义的、在语言或编译系统的实现中具有特殊含义的单词:</p><table>    <tr>        <td>if</td>        <td>else</td>        <td>while</td>        <td>signed</td>        <td>throw</td>        <td>union</td>        <td>this</td>    </tr>    <tr>        <td>int</td>        <td>char</td>        <td>double</td>        <td>unsigned</td>        <td>const</td>        <td>goto</td>        <td>virtual</td>    </tr>    <tr>        <td>for</td>        <td>float</td>        <td>break</td>        <td>auto</td>        <td>class</td>        <td>operator</td>        <td>case</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>typedef</td>        <td>static</td>        <td>friend</td>        <td>template</td>        <td>default</td>    </tr>    <tr>        <td>new</td>        <td>void</td>        <td>register</td>        <td>extern</td>        <td>return</td>        <td>enum</td>        <td>inline</td>    </tr>    <tr>        <td>try</td>        <td>short</td>        <td>continue</td>        <td>sizeof</td>        <td>switch</td>        <td>private</td>        <td>protected</td>    </tr>    <tr>        <td>asm</td>        <td>while</td>        <td>catch</td>        <td>delete</td>        <td>public</td>        <td>volatile</td>        <td>struct</td>    </tr></table></body></html><p><strong>以下是对上述C++关键字的解释：</strong></p><hr><h3 id="1-asm（汇编指令）"><a href="#1-asm（汇编指令）" class="headerlink" title="1. asm（汇编指令）"></a>1. <strong>asm（汇编指令）</strong></h3><ul><li><code>asm</code>允许在C++程序中直接嵌入汇编代码。  </li><li>用法场景：需要执行底层硬件相关的指令时，可以使用它。</li></ul><hr><h3 id="2-auto（自动存储类型）"><a href="#2-auto（自动存储类型）" class="headerlink" title="2. auto（自动存储类型）"></a>2. <strong>auto（自动存储类型）</strong></h3><ul><li><code>auto</code>用来声明变量的存储类型是“自动的”，这意味着变量的生命周期受限于它所在的代码块（比如函数、循环等）。  </li><li>通常可以省略，因为这是默认行为。</li></ul><hr><h3 id="3-bool（布尔类型）"><a href="#3-bool（布尔类型）" class="headerlink" title="3. bool（布尔类型）"></a>3. <strong>bool（布尔类型）</strong></h3><ul><li><code>bool</code>表示“真或假”的值。  </li><li>有两个有效值：<code>true</code>（真）和<code>false</code>（假）。  </li><li>示例：<code>bool isActive = true;</code>  </li><li>在条件判断中很常用，比如<code>if</code>语句。</li></ul><hr><h3 id="4-break（跳出语句）"><a href="#4-break（跳出语句）" class="headerlink" title="4. break（跳出语句）"></a>4. <strong>break（跳出语句）</strong></h3><ul><li><code>break</code>用于终止循环或退出<code>switch</code>语句。  </li><li>当程序遇到<code>break</code>时，会直接跳到代码块的外面继续执行。  </li><li>示例：在<code>for</code>循环中提前停止迭代。</li></ul><hr><h3 id="5-case（条件分支）"><a href="#5-case（条件分支）" class="headerlink" title="5. case（条件分支）"></a>5. <strong>case（条件分支）</strong></h3><ul><li><code>case</code>用在<code>switch</code>语句中，表示不同的条件。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-catch（异常捕获）"><a href="#6-catch（异常捕获）" class="headerlink" title="6. catch（异常捕获）"></a>6. <strong>catch（异常捕获）</strong></h3><ul><li><code>catch</code>和<code>try</code>配合使用，用于处理程序运行时的异常。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-char（字符类型）"><a href="#7-char（字符类型）" class="headerlink" title="7. char（字符类型）"></a>7. <strong>char（字符类型）</strong></h3><ul><li><code>char</code>表示一个字符，比如字母或符号。  </li><li>数据范围是0到255，对应ASCII码表的值。  </li><li>示例：<code>char letter = &#39;A&#39;;</code></li></ul><hr><h3 id="8-class（类）"><a href="#8-class（类）" class="headerlink" title="8. class（类）"></a>8. <strong>class（类）</strong></h3><ul><li><code>class</code>是C++面向对象编程的核心，用来定义对象的模板或蓝图。  </li><li>类中可以包含属性和方法，用于模拟现实世界中的事物。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string brand;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 驾驶行为</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-const（常量）"><a href="#9-const（常量）" class="headerlink" title="9. const（常量）"></a>9. <strong><code>const</code>（常量）</strong></h3><ul><li><p><code>const</code>表示“不可更改”。  </p></li><li><p>用<code>const</code>修饰的变量或对象，其值在程序运行中不能被改变。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// pi 是一个常量，不能修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数</strong>：<br>如果<code>const</code>修饰一个函数，则该函数不能修改外部变量，也不能调用非<code>const</code>函数。<br>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// getValue不能修改任何变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：<br>相较于<code>#define</code>，<code>const</code>不仅可以定义常量，还具有类型检查功能，使用更安全。</p></li></ul><hr><h3 id="10-const-cast（类型转换运算符）"><a href="#10-const-cast（类型转换运算符）" class="headerlink" title="10. const_cast（类型转换运算符）"></a>10. <strong><code>const_cast</code>（类型转换运算符）</strong></h3><ul><li><p><code>const_cast</code>用来去除<code>const</code>属性，允许对原本不可修改的对象进行更改。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* px = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x); <span class="comment">// 去掉 x 的 const 性质</span></span><br><span class="line">*px = <span class="number">100</span>;                     <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：使用<code>const_cast</code>需要小心，错误的使用可能导致程序未定义行为。</p></li></ul><hr><h3 id="11-continue（跳过当前循环）"><a href="#11-continue（跳过当前循环）" class="headerlink" title="11. continue（跳过当前循环）"></a>11. <strong><code>continue</code>（跳过当前循环）</strong></h3><ul><li><p><code>continue</code>用在循环中，跳过本次循环剩下的代码，直接开始下一次循环。  </p></li><li><p><strong>与<code>break</code>的区别</strong>：  </p><ul><li><code>break</code>会结束整个循环。</li><li><code>continue</code>只跳过当前循环的后续部分，继续执行下一次循环。</li></ul></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过 i == 2 的情况</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 3 4</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="12-default（默认分支）"><a href="#12-default（默认分支）" class="headerlink" title="12. default（默认分支）"></a>12. <strong><code>default</code>（默认分支）</strong></h3><ul><li><p><code>default</code>是<code>switch</code>语句中的默认分支。  </p></li><li><p>当所有的<code>case</code>条件都不满足时，执行<code>default</code>部分的代码。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 5&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 8&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：x is something else</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>default</code>是可选的，可以没有。</p></li></ul><hr><h3 id="13-delete（释放内存）"><a href="#13-delete（释放内存）" class="headerlink" title="13. delete（释放内存）"></a>13. <strong><code>delete</code>（释放内存）</strong></h3><ul><li><code>delete</code>用于释放通过<code>new</code>关键字动态分配的内存空间。</li><li>释放的对象可以是单个变量或数组，但必须与分配时的形式匹配。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 动态分配一个整数</span></span><br><span class="line"><span class="keyword">delete</span> ptr;             <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 动态分配一个数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：释放内存后不能再次使用，否则会导致“悬空指针”。</li></ul><hr><h3 id="14-do（循环结构）"><a href="#14-do（循环结构）" class="headerlink" title="14. do（循环结构）"></a>14. <strong><code>do</code>（循环结构）</strong></h3><ul><li><code>do</code>是<code>do-while</code>循环的一部分，与<code>while</code>循环类似，但它<strong>至少执行一次循环体</strong>，因为条件是在循环体执行之后才检查的。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i is 0</span><br><span class="line">i is 1</span><br><span class="line">i is 2</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="15-double（双精度浮点数）"><a href="#15-double（双精度浮点数）" class="headerlink" title="15. double（双精度浮点数）"></a>15. <strong><code>double</code>（双精度浮点数）</strong></h3><ul><li><code>double</code>是C++中表示浮点数的一种数据类型，用于存储带小数点的数值，精度比<code>float</code>更高。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi is &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li>通常用于需要更高精度的数学计算。</li></ul><hr><h3 id="16-dynamic-cast（动态类型转换）"><a href="#16-dynamic-cast（动态类型转换）" class="headerlink" title="16. dynamic_cast（动态类型转换）"></a>16. <strong><code>dynamic_cast</code>（动态类型转换）</strong></h3><ul><li><code>dynamic_cast</code>用于在运行时将基类指针或引用转换为派生类指针或引用，确保类型安全。</li><li>适用于有<strong>继承关系</strong>的类之间的转换。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 必须有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion successful!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：<ul><li>如果转换失败，返回<code>nullptr</code>（对于指针）或抛出异常（对于引用）。</li></ul></li></ul><hr><h3 id="17-else（条件分支）"><a href="#17-else（条件分支）" class="headerlink" title="17. else（条件分支）"></a>17. <strong><code>else</code>（条件分支）</strong></h3><ul><li><code>else</code>和<code>if</code>配合使用，用于处理<code>if</code>条件为<code>false</code>时的操作。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is non-positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is positive</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="18"><li><strong>enum（枚举）</strong><br><code>enum</code>（枚举）类型用于定义一组固定的值，值的选择只能在这些预定义的选项中进行。例如，你可以使用枚举类型来表示一周的七天，每天对应一个固定的值：<code>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</code>。每个枚举值都代表一个常量，确保只能选择这些特定的值。</li></ol><hr><ol start="19"><li><strong>explicit（显式的）</strong><br><code>explicit</code>关键字的作用是“禁止单参数构造函数”在自动类型转换中被使用。简单来说，它防止编译器在进行类型转换时，自动将一个类型转换成这个构造函数的类型。例如，某些容器类型的构造函数可能接收一个数字作为初始大小，如果没有<code>explicit</code>，那么编译器可能会错误地将一个整数自动转换成容器类型。通过显式标记构造函数，可以避免这种自动转换。</li></ol><hr><ol start="20"><li><strong>export（导出）</strong><br>当你想访问其他代码文件中的变量或对象时，如果是普通类型（如基本数据类型、结构体或类），可以使用<code>extern</code>来引用。但是对于模板类型（如模板类或模板函数），你需要使用<code>export</code>来声明它们。在这种情况下，<code>export</code>告诉编译器这些模板是为了在其他文件中使用而被定义的。</li></ol><hr><ol start="21"><li><strong>extern（外部的）</strong><br><code>extern</code>关键字用于声明一个变量或函数是“外部链接”的，意思是它在其他文件中可以被访问和使用。这意味着这个变量或函数并没有在当前文件中定义，而是在程序的其他部分定义的。使用<code>extern</code>声明的变量或函数会在程序开始时分配空间，结束时释放。它们的定义应该出现在其他文件或同一文件的其他地方。如果要使用其他语言编写的代码，可以用<code>extern &quot;C&quot;</code>来声明，指明用C语言的方式进行链接。</li></ol><hr><ol start="22"><li><strong>false（假的）</strong><br><code>false</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“假”。它等价于整数类型中的0。在C++中，<code>bool</code>类型的变量可以是<code>true</code>（真）或<code>false</code>（假）。</li></ol><hr><ol start="23"><li><strong>float（浮点数）</strong><br><code>float</code>是C++中的一种数据类型，用于表示小数（浮点数）。它的精度比<code>double</code>低，适用于对精度要求不高的情况。比如，如果你只需要表示一位小数，使用<code>float</code>可以节省内存。</li></ol><hr><ol start="24"><li><strong>for（循环）</strong><br><code>for</code>是C++中的一种循环结构，用来反复执行一段代码，直到满足特定的条件为止。通常用于已知需要循环多少次的场景。例如，遍历数组或从1加到10。</li></ol><hr><ol start="25"><li><strong>friend（友元）</strong><br><code>friend</code>关键字用来声明友元关系，它允许其他函数或类访问当前类的私有（<code>private</code>）和保护（<code>protected</code>）成员。通过友元，某些函数或类可以直接操作本应隐藏的成员，从而提高效率或简化代码。友元可以是函数、类或特定的成员函数。</li></ol><hr><ol start="26"><li><strong>goto（转到）</strong><br><code>goto</code>是C++中的一种语句，用于跳转到程序中的另一个位置。虽然它可以改变程序的执行流，但通常不推荐使用，因为它会让程序的逻辑变得混乱。现代编程中，常用其他控制流结构（如<code>for</code>、<code>while</code>、<code>if</code>等）来替代<code>goto</code>。</li></ol><hr><ol start="27"><li><strong>if（如果）</strong><br><code>if</code>是C++中的条件语句，用于判断某个条件是否为真。如果条件为真，程序就会执行相应的代码块；如果为假，则跳过这个代码块。它是实现程序决策和分支逻辑的基础。</li></ol><hr><ol start="28"><li><strong>inline（内联函数）</strong><br><code>inline</code>用于定义内联函数，即编译器在调用该函数时，将函数的代码直接插入调用处，而不是进行常规的函数调用。内联函数通常很小，且频繁调用，使用<code>inline</code>可以提高程序执行效率，减少函数调用的开销。</li></ol><hr><ol start="29"><li><strong>int（整型）</strong><br><code>int</code>是C++中的基本数据类型，用来表示整数（没有小数的数）。它的范围通常较小，比<code>long</code>类型的整数范围要窄一些。</li></ol><hr><ol start="30"><li><strong>long（长整型）</strong><br><code>long</code>是C++中的另一种整型数据类型，用来表示比<code>int</code>类型范围更大的整数。它可以存储更大的数值。</li></ol><hr><ol start="31"><li><strong>mutable（易变的）</strong><br><code>mutable</code>是C++中的一个特殊关键字，通常用于类中的成员变量。它允许即使在<code>const</code>函数中，也可以修改被声明为<code>mutable</code>的成员变量。换句话说，它让类的常量成员函数能够修改某些成员变量，这通常用于需要记录某些信息但又不能改变对象状态的情况。</li></ol><hr><ol start="32"><li><strong>namespace（命名空间）</strong><br><code>namespace</code>用于组织和区分类。它是一种比类更大的组织结构，允许你将不同的类、函数等进行分组，避免命名冲突。你可以把它看作一个容器，帮助管理代码。</li></ol><hr><ol start="33"><li><strong>new（新建）</strong><br><code>new</code>是C++中的一个运算符，用于动态创建对象。它会在内存中为对象分配空间，并返回指向该对象的指针。也就是说，<code>new</code>会返回一个指向新创建对象的指针。</li></ol><hr><ol start="34"><li><strong>operator（操作符）</strong><br><code>operator</code>用于操作符重载，它让你可以为C++中的操作符（比如加号、减号等）定义自定义的行为。通过操作符重载，你可以让这些操作符在你的类对象上起作用。</li></ol><hr><ol start="35"><li><strong>private（私有的）</strong><br><code>private</code>是C++中的访问控制符之一，表示一个类的成员（如变量和函数）只能在该类的内部或者其友元类中访问。外部代码不能直接访问这些私有成员。</li></ol><hr><ol start="36"><li><strong>protected（受保护的）</strong><br><code>protected</code>也是C++中的访问控制符之一。被<code>protected</code>标记的成员只能在当前类、派生类（继承的类）以及友元类中访问。外部代码无法直接访问这些受保护的成员。</li></ol><hr><ol start="37"><li><strong>public（公有的）</strong><br><code>public</code>是C++中的访问控制符之一，表示一个类的成员可以被任何代码访问。它没有访问限制，可以在类的外部直接访问这些公有成员。</li></ol><hr><ol start="38"><li><strong>register（寄存器）</strong><br><code>register</code>是C++中的一个关键字，表示请求编译器将某个变量存放在CPU的寄存器中（而不是内存中），以提高访问速度。这个优化仅适用于局部变量，但在现代编译器中，它通常会根据实际情况自动优化，因此在32位编译器中作用较小。</li></ol><hr><ol start="39"><li><strong>reinterpret_cast（重新解释转换）</strong><br><code>reinterpret_cast</code>是C++中的一种类型转换，它可以把一个类型转换成完全不同的另一个类型。例如，它可以把指针转换成整数，或者把整数转换成指针。它的作用是直接重解释数据的二进制表示，而不考虑数据的实际类型，因此需要谨慎使用。</li></ol><hr><ol start="40"><li><strong>return（返回）</strong><br><code>return</code>关键字用于从函数中返回一个值，并结束函数的执行。一旦程序执行到<code>return</code>语句，函数会立即返回结果，之后的代码不会再执行。</li></ol><hr><ol start="41"><li><strong>short（短整型）</strong><br><code>short</code>是C++中的一种整型数据类型，用于表示比<code>int</code>类型范围小的整数。它占用的内存空间比<code>int</code>小，适用于存储较小范围的整数。</li></ol><hr><ol start="42"><li><strong>signed（有符号）</strong><br><code>signed</code>表示数字类型（如整型）是有符号的，也就是说它可以表示正数和负数。与之相对的是<code>unsigned</code>，即无符号类型，表示只有正数和零。大多数数值类型默认就是<code>signed</code>，所以通常不需要显式声明。</li></ol><hr><ol start="43"><li><strong>sizeof（大小）</strong><br><code>sizeof</code>是一个运算符，用来获取数据类型占用的内存大小（以字节为单位）。由于不同系统和编译器可能会有不同的内存分配，使用<code>sizeof</code>可以确保程序的可移植性。</li></ol><hr><ol start="44"><li><strong>static（静态的）</strong><br><code>static</code>关键字用于声明静态变量或静态函数。静态变量在程序开始时分配内存，并且在程序结束时释放。它的作用范围限于定义它的文件或类，在其他文件中不可访问。对于类的静态成员，它是由类的所有实例共享的，所有对象共享同一个静态变量。静态成员变量必须在类外部进行初始化。</li></ol><p>好的，下面是这些概念的更简洁易懂的解释：</p><hr><ol start="45"><li><strong>static_cast（静态转换）</strong><br><code>static_cast</code>是C++中的一种类型转换方式，它把表达式转换为指定的类型。它没有运行时的类型检查，所以开发者需要确保转换是安全的。常见的用法包括：</li></ol><ul><li><strong>类层次转换</strong>：在继承关系中，可以将子类指针&#x2F;引用转换为基类类型（安全），也可以把基类转换为子类（不安全，因为没有检查）。</li><li><strong>基本类型转换</strong>：在不同基本类型之间转换，比如<code>int</code>转换为<code>char</code>或枚举类型。  </li><li><strong>空指针转换</strong>：可以将空指针转换为其他类型的空指针。</li><li><strong>转换为<code>void</code>类型</strong>：可以将任何类型转换为<code>void</code>，用于不返回任何内容。</li></ul><p>需要注意的是，<code>static_cast</code>无法移除<code>const</code>、<code>volatile</code>或<code>__unaligned</code>属性。</p><hr><ol start="46"><li><strong>struct（结构体）</strong><br><code>struct</code>是C++中用于定义结构体的一种数据类型，与<code>class</code>类似，但与C语言兼容。它可以用来定义面向对象的程序，且所有成员默认是公有的（<code>public</code>），在实现上类似于<code>class</code>。</li></ol><hr><ol start="47"><li><strong>switch（选择）</strong><br><code>switch</code>是C++中的一种条件语句，用于在多个可能的分支中选择执行一条。它的用法类似于<code>if-else</code>链，但更简洁。<code>switch</code>的条件表达式必须是整型（如<code>int</code>或<code>char</code>）。<code>switch</code>语句通常包括一个可选的<code>default</code>分支，以处理没有匹配的情况。</li></ol><hr><ol start="48"><li><strong>template（模板）</strong><br><code>template</code>是C++中实现泛型编程的关键字。通过模板，可以定义适用于多种数据类型的通用函数或类，使代码更灵活、可重用。</li></ol><hr><ol start="49"><li><strong>this</strong><br><code>this</code>是C++中的一个指针，用于指向当前对象，也就是正在调用该成员函数的对象本身。通过<code>this</code>，对象可以访问它自己的数据成员和其他成员函数。</li></ol><hr><ol start="50"><li><strong>throw（抛出）</strong><br><code>throw</code>关键字用于C++中的异常处理。当程序遇到错误情况时，可以使用<code>throw</code>来抛出一个异常，通知调用者出错。<code>throw</code>的值可以是任意类型的异常对象。</li></ol><hr><ol start="51"><li><strong>true（真的）</strong><br><code>true</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“真”，等价于整数的非零值。布尔类型<code>bool</code>的值可以是<code>true</code>或<code>false</code>。</li></ol><hr><ol start="52"><li><strong>try（尝试）</strong><br><code>try</code>是C++异常处理机制的一部分。它用于包围可能会抛出异常的代码块，并与<code>catch</code>语句搭配使用，以捕获并处理异常。</li></ol><hr><ol start="53"><li><strong>typedef（类型定义）</strong><br><code>typedef</code>用于为已有数据类型创建一个新的别名。例如，可以用<code>typedef</code>给<code>int</code>类型取一个新的名字。这样可以使代码更易读，但并不会创建新的数据类型。</li></ol><hr><ol start="54"><li><strong>typeid</strong><br><code>typeid</code>用于在运行时获得某个对象或指针的实际类型（比如某个指针或引用指向的派生类型），常用于了解继承关系中的具体类型信息。</li></ol><hr><ol start="55"><li><strong>typename（类型名）</strong><br><code>typename</code>关键字告诉编译器，某个名称代表的是一种类型。主要用于模板代码中，以便让编译器正确地理解该名称的含义，尤其当该名称嵌套在其他类型中或依赖于模板参数时。</li></ol><hr><ol start="56"><li><strong>union（联合体）</strong><br><code>union</code>是一种数据结构，允许存储不同类型的数据，但同一时刻只存储一种。所有成员共享同一段内存，大小取决于最大的数据成员。这与<code>enum</code>不同，<code>enum</code>只能用于整数类型。</li></ol><hr><ol start="57"><li><strong>unsigned（无符号）</strong><br><code>unsigned</code>表示无符号类型，只能存储非负数。与<code>signed</code>（有符号）相对，<code>unsigned</code>省去了负数部分，使得同样的空间可以存储更大的正数。</li></ol><hr><ol start="58"><li><strong>using</strong><br><code>using</code>用于简化命名空间的引用。通过<code>using</code>声明，可以直接使用某命名空间的内容，而不必每次都写命名空间前缀。</li></ol><hr><ol start="59"><li><strong>virtual（虚函数）</strong><br><code>virtual</code>用于实现多态性，允许在基类中声明虚函数，从而可以在派生类中实现不同的行为。这样，通过基类指针或引用调用函数时，会执行派生类中的实际实现。</li></ol><hr><ol start="60"><li><strong>void（空）</strong><br><code>void</code>是一种特殊类型，表示“没有类型”或“空”。它可以用于：</li></ol><ul><li><strong>函数返回类型</strong>：表示函数不返回值。</li><li><strong>函数参数</strong>：表示没有参数传入。</li><li><strong>指针类型</strong>：<code>void*</code>表示一个通用指针，可以指向任意类型的数据。</li></ul><hr><ol start="61"><li><strong>volatile（易变的）</strong><br><code>volatile</code>用于标记变量的值可能会随时被系统或其他进程修改，防止编译器对它进行优化。常用于异步处理，如中断程序中涉及的变量。</li></ol><hr><ol start="62"><li><strong>wchar_t（宽字符）</strong><br><code>wchar_t</code>是一种数据类型，用于表示宽字符（即多字节字符）。每个<code>wchar_t</code>占用两个字节，适合表示Unicode字符，例如汉字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据类型</title>
      <link href="/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/15/%E5%88%9D%E5%A7%8BC/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h1><p><strong>在编写程序时，我们经常需要用到变量来保存各种信息。变量其实是内存中的一块空间，用来存储特定的数据。创建变量时，计算机会根据变量的类型，分配合适大小的内存，并决定存储的数据格式。</strong></p><p>不同的数据类型可以用来保存不同种类的信息，比如：  </p><ul><li><strong>字符类型</strong>：用来存储单个字符，比如<code>&#39;A&#39;</code>。  </li><li><strong>宽字符类型</strong>：用于存储多字节字符，比如Unicode字符。  </li><li><strong>整数类型</strong>：用来存储整数，比如<code>10</code>或<code>-5</code>。  </li><li><strong>浮点数类型</strong>：用来存储小数，比如<code>3.14</code>。  </li><li><strong>双精度浮点数类型</strong>：精度更高的小数，比如<code>3.1415926</code>。  </li><li><strong>布尔类型</strong>：用来存储<code>true</code>（真）或<code>false</code>（假）。</li></ul><p>操作系统会根据变量的类型，确定分配多少内存以及如何处理存储的数据。这样，可以更高效地利用系统资源并保证数据正确存储。</p><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>数据类型和关键字</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>数据类型和关键字</h2><table>    <tr>        <th>类型</th>        <th>关键字</th>    </tr>    <tr>        <td>布尔型</td>        <td>bool</td>    </tr>    <tr>        <td>字符型</td>        <td>char</td>    </tr>    <tr>        <td>整型</td>        <td>int</td>    </tr>    <tr>        <td>浮点型</td>        <td>float</td>    </tr>    <tr>        <td>双浮点型</td>        <td>double</td>    </tr>    <tr>        <td>无类型</td>        <td>void</td>    </tr>    <tr>        <td>宽字符型</td>        <td>wchar_t</td>    </tr></table></body></html><p><code>wchar_t</code> 其实是通过定义类型别名实现的，具体是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>这意味着，<code>wchar_t</code> 实际上占用的空间和 <code>short int</code> 一样，通常是 2 个字节。</p><p>C++ 中的一些基本数据类型可以通过修饰符来修改它们的属性，包括：</p><ul><li><strong>signed</strong>：表示带符号（可以是正数或负数，默认情况下大多数整数类型是带符号的）。</li><li><strong>unsigned</strong>：表示无符号，只能是正数。</li><li><strong>short</strong>：表示短整型，通常占用比 <code>int</code> 更少的内存（通常是 2 个字节）。</li><li><strong>long</strong>：表示长整型，通常占用比 <code>int</code> 更多的内存（通常是 8 个字节）。</li></ul><p>不同的数据类型在内存中占用的空间（字节数）会有所不同，而且它们能存储的最大值和最小值也会根据系统有所不同。通常情况下，1 字节等于 8 位。</p><h3 id="默认情况下："><a href="#默认情况下：" class="headerlink" title="默认情况下："></a>默认情况下：</h3><ul><li><code>int</code>、<code>short</code>、<code>long</code> 类型都是带符号的（<code>signed</code>），可以表示负数和正数。</li></ul><h3 id="关于-long-int-和-int-的大小："><a href="#关于-long-int-和-int-的大小：" class="headerlink" title="关于 long int 和 int 的大小："></a>关于 <code>long int</code> 和 <code>int</code> 的大小：</h3><ul><li>在一些早期的编译器中，<code>long int</code> 占 4 个字节，<code>int</code> 占 2 个字节。但是现代的 C&#x2F;C++ 标准已经兼容这种设定，通常在较新的系统中，<code>long int</code> 占 8 个字节，<code>int</code> 占 4 个字节。<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Data Types and Ranges</title>  <style>      table {          width: 100%;          border-collapse: collapse;      }      th, td {          border: 1px solid #ddd;          padding: 8px;          text-align: left;      }      th {          background-color: #add8e6; /* 浅蓝色背景 */          color: #000; /* 文本颜色，可以根据需要调整 */      }  </style></head><body></li></ul><h2>Data Types and Ranges</h2><table>    <tr>        <th>类型</th>        <th>位</th>        <th>范围</th>    </tr>    <tr>        <td>char</td>        <td>1个字节</td>        <td>-128到127或者0到255</td>    </tr>    <tr>        <td>unsigned char</td>        <td>1个字节</td>        <td>0到255</td>    </tr>    <tr>        <td>signed char</td>        <td>1个字节</td>        <td>-128到127</td>    </tr>    <tr>        <td>int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>unsigned int</td>        <td>4个字节</td>        <td>0到4294967295</td>    </tr>    <tr>        <td>signed int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>unsigned short int</td>        <td>2个字节</td>        <td>0到65,535</td>    </tr>    <tr>        <td>signed short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>signed long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>unsigned long int</td>        <td>8个字节</td>        <td>0到18,446,744,073,709,551,615</td>    </tr>    <tr>        <td>float</td>        <td>4个字节</td>        <td>精度型占4个字节(32位)内存空间,+/-3.4e+/-38(~7个数字)</td>    </tr>    <tr>        <td>double</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,+/-1.7e+/-308(~15个数字)</td>    </tr>    <tr>        <td>long long</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,表示-9,223,372,036,854,775,807到9,223,372,036,854,775,807的范围</td>    </tr>    <tr>        <td>long double</td>        <td>16个字节</td>        <td>长双精度型16个字节(128位)内存空间,可提供18-19位有效数字。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>2或4个字节</td>        <td>1个宽字符</td>    </tr></table></body></html><h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>在 C++ 中，<code>typedef</code> 关键字可以用来给已有的类型起一个新的名字。这相当于创建一个类型的别名，让代码更清晰或者更方便。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原类型 新名字;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>如果想给 <code>int</code> 类型起一个新名字 <code>feet</code>，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet;</span><br></pre></td></tr></table></figure><p>从现在起，<code>feet</code> 就和 <code>int</code> 完全等价，表示同一种类型。比如下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance; <span class="comment">// 等同于 int distance;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>distance</code> 是一个整型变量，但通过 <code>feet</code> 这个名字，它更直观地表示变量的意义，比如“表示距离”。这让代码更容易阅读和理解。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>枚举类型（<code>enumeration</code>）是 C++ 中一种用户自定义的数据类型，用来定义一组固定的值。它非常适合表示只有有限可能取值的变量。通过枚举，可以为变量列举出所有合法值，变量的取值范围就被限制在这些列举的值中。</strong></p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举用关键字 <code>enum</code> 定义，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; </span><br><span class="line">    标识符<span class="number">1</span>[=整型常数], </span><br><span class="line">    标识符<span class="number">2</span>[=整型常数], </span><br><span class="line">    ...</span><br><span class="line">    标识符n[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>如果没有为标识符赋值（即省略 <code>=整型常数</code>），枚举会默认从 0 开始，后续值依次加 1。</li><li>也可以为部分或全部标识符指定具体的值。未指定的标识符会自动比前一个值大 1。</li></ul><h3 id="示例-1：默认值"><a href="#示例-1：默认值" class="headerlink" title="示例 1：默认值"></a>示例 1：默认值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125;; <span class="comment">// red=0, green=1, blue=2</span></span><br><span class="line">color c;  <span class="comment">// 定义变量 c，类型为 color</span></span><br><span class="line">c = blue; <span class="comment">// c 的值为 blue（等价于 2）</span></span><br></pre></td></tr></table></figure><h3 id="示例-2：自定义值"><a href="#示例-2：自定义值" class="headerlink" title="示例 2：自定义值"></a>示例 2：自定义值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;; <span class="comment">// red=0, green=5, blue=6</span></span><br><span class="line">color c = green;  <span class="comment">// c 的值为 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>red</code> 的值为 0。</li><li><code>green</code> 的值被设置为 5。</li><li><code>blue</code> 自动被赋值为 6，因为它比前一个值大 1。</li></ul><h3 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h3><ol><li><strong>代码更易读</strong>：通过枚举名称表达变量的意义（如 <code>red</code> 和 <code>green</code>）。</li><li><strong>更安全</strong>：变量的取值被限制在定义的枚举值范围内，避免了非法值的出现。</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换是指将一种数据类型的值转换成另一种数据类型的值。在 C++ 中，主要有四种类型转换方式：<strong>静态转换、动态转换、常量转换</strong>和<strong>重新解释转换</strong>。下面我们用更简单的语言解释这些转换方式。</p><hr><h3 id="1-静态转换（Static-Cast）"><a href="#1-静态转换（Static-Cast）" class="headerlink" title="1. 静态转换（Static Cast）"></a>1. <strong>静态转换（Static Cast）</strong></h3><ul><li><strong>作用</strong>：在编译时，将一种类型强制转换成另一种类型。</li><li><strong>特点</strong>：没有运行时检查，所以如果转换不合理，可能会导致程序运行时出错。</li><li><strong>用途</strong>：通常用在类型之间有一定相似性的场景，比如 <code>int</code> 和 <code>float</code> 的转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 把 int 类型的值转换为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-动态转换（Dynamic-Cast）"><a href="#2-动态转换（Dynamic-Cast）" class="headerlink" title="2. 动态转换（Dynamic Cast）"></a>2. <strong>动态转换（Dynamic Cast）</strong></h3><ul><li><strong>作用</strong>：在运行时将基类的指针或引用转换为派生类的指针或引用。</li><li><strong>特点</strong>：会进行运行时类型检查，如果转换不合法，会返回空指针或抛出异常。</li><li><strong>用途</strong>：主要用于带有<strong>继承关系的类</strong>之间的指针或引用转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 转换成派生类指针</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-常量转换（Const-Cast）"><a href="#3-常量转换（Const-Cast）" class="headerlink" title="3. 常量转换（Const Cast）"></a>3. <strong>常量转换（Const Cast）</strong></h3><ul><li><strong>作用</strong>：用于移除变量的 <code>const</code> 属性，允许对其进行修改。</li><li><strong>特点</strong>：只能去掉 <code>const</code>，不会改变数据类型。</li><li><strong>用途</strong>：在特定场景下需要修改 <code>const</code> 修饰的变量时使用。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;  <span class="comment">// 一个常量</span></span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 将 const int 转换为普通 int</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-重新解释转换（Reinterpret-Cast）"><a href="#4-重新解释转换（Reinterpret-Cast）" class="headerlink" title="4. 重新解释转换（Reinterpret Cast）"></a>4. <strong>重新解释转换（Reinterpret Cast）</strong></h3><ul><li><strong>作用</strong>：直接将一种类型的值按二进制格式解释为另一种类型。</li><li><strong>特点</strong>：不做任何检查，可能会导致未定义行为。</li><li><strong>用途</strong>：通常用于需要对内存内容重新解释的场景（如底层编程）。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 强行把 int 的内存解释为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th><strong>转换方式</strong></th><th><strong>特点</strong></th><th><strong>主要用途</strong></th></tr></thead><tbody><tr><td><strong>静态转换</strong></td><td>编译时转换，无运行时检查</td><td>类型相似的普通数据类型转换（如 <code>int</code> 转 <code>float</code>）</td></tr><tr><td><strong>动态转换</strong></td><td>运行时检查，安全但速度稍慢</td><td>基类与派生类之间的指针或引用转换</td></tr><tr><td><strong>常量转换</strong></td><td>去掉 <code>const</code> 属性，只修改可变性</td><td>修改 <code>const</code> 变量的值</td></tr><tr><td><strong>重新解释转换</strong></td><td>直接按内存内容重新解释类型，不安全</td><td>内存地址、类型的低级转换（如底层硬件编程）</td></tr></tbody></table><p>需要注意的是，<strong>尽量避免不必要的类型转换</strong>，特别是动态转换和重新解释转换，因为它们可能引发潜在的问题或性能损耗。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.tomatou.xyz/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">面向对象与面向过程</a>，本节我将正式开始讲解关于C++的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>C++ 程序可以看作是由一组对象组成的，每个对象都有自己的特性和行为。这些对象通过互相调用方法来交流。现在让我们用简单的方式理解一下<strong>类</strong>、<strong>对象</strong>、<strong>方法</strong>和<strong>实例变量</strong>。</p><ol><li><p><strong>对象</strong>  </p><ul><li>对象就像是生活中的实物，它既有特性，也有行为。  <ul><li>比如：一只狗。  <ul><li><strong>特性</strong>：颜色（白色）、名字（小白）、品种（牧羊犬）。  </li><li><strong>行为</strong>：摇尾巴、叫、吃东西。</li></ul></li><li><strong>在程序中，对象是根据类创建出来的“实例”。</strong></li></ul></li></ul></li><li><p><strong>类</strong>  </p><ul><li>类可以看作是创建对象的“设计图”或者“模板”。  <ul><li>比如，“狗”这个类就描述了所有狗的共性（颜色、名字、品种）和它们可以做的事（摇尾巴、叫、吃东西）。  </li><li><strong>具体的狗（如小白、小黑）就是从这个类生成的对象。</strong></li></ul></li></ul></li><li><p><strong>方法</strong>  </p><ul><li>方法就是对象可以执行的“动作”或者“功能”。  <ul><li>对狗来说，方法可以是“叫”（bark()）、“吃”（eat()）。  </li><li><strong>方法中包含程序逻辑，定义了对象可以做的事情。</strong></li></ul></li></ul></li><li><p><strong>实例变量</strong>  </p><ul><li>实例变量是对象的“特性值”，每个对象都有自己的值。  <ul><li>比如，狗类中可能有变量“颜色”、“名字”。小白的颜色是白色，名字是“小白”；而小黑的颜色是黑色，名字是“小黑”。这些特性值存储在实例变量中，决定了对象的状态。</li></ul></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把类比作“模板”，对象是根据模板创建的“具体实例”，方法定义了对象的“行为”，而实例变量存储了对象的“特性值”。通过这种方式，我们可以用编程模拟真实世界中的事物和它们之间的交互。</p><h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h1><p>让我们看一段简单的代码，可以输出单词 Hello World</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来我们讲解一下这个程序:</strong></p><ol><li><p><strong>头文件 <code>&lt;iostream&gt;</code></strong>  </p><ul><li><code>&lt;iostream&gt;</code> 是一个标准库，提供输入输出功能。  </li><li>在这个程序中，它允许我们使用 <code>cout</code> 输出信息到屏幕上。</li></ul></li><li><p><strong><code>using namespace std;</code></strong>  </p><ul><li>告诉编译器我们要使用标准命名空间 <code>std</code>。  </li><li>这样，我们可以直接写 <code>cout</code> 而不用每次都写成 <code>std::cout</code>。</li></ul></li><li><p><strong>单行注释 <code>//</code></strong>  </p><ul><li>以 <code>//</code> 开头的部分是注释，它的作用是让程序员记录说明，编译器会忽略这些内容。  </li><li>比如 <code>// main() 是程序的开始</code>，是为了帮助人类理解程序的结构。</li></ul></li><li><p><strong>主函数 <code>int main()</code></strong>  </p><ul><li><code>main()</code> 是程序的入口点，每个 C++ 程序都需要这个函数。  </li><li>程序从这里开始运行。</li></ul></li><li><p><strong>输出语句 <code>cout &lt;&lt; &quot;Hello World&quot;;</code></strong>  </p><ul><li><code>cout</code> 是 C++ 用来输出信息到屏幕的工具。  </li><li>这句代码会在屏幕上打印 <code>Hello World</code>。</li></ul></li><li><p><strong><code>return 0;</code></strong>  </p><ul><li>这句话的意思是：程序运行结束，并返回一个值 <code>0</code> 给系统。  </li><li>在 C++ 中，返回 <code>0</code> 通常表示程序正常结束。</li></ul></li></ol><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤:</p><ol><li><p><strong>编写代码</strong>  </p><ul><li>打开一个文本编辑器，比如记事本或代码编辑器（如 VS Code、Sublime Text）。  </li><li>将前面写好的代码粘贴进去。</li></ul></li><li><p><strong>保存文件</strong>  </p><ul><li>将文件保存为 <code>hello.cpp</code>（扩展名必须是 <code>.cpp</code>，表示这是一个 C++ 程序）。</li></ul></li><li><p><strong>打开命令提示符</strong>  </p><ul><li>在 Windows 系统中，可以通过按下 <code>Win + R</code>，输入 <code>cmd</code> 打开命令提示符。  </li><li>使用 <code>cd</code> 命令进入保存 <code>hello.cpp</code> 文件的文件夹。<br>例如，如果文件在桌面上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编译代码</strong>  </p><ul><li>输入以下命令，按下回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure></li><li>如果代码没有错误，编译器会生成一个可执行文件，默认命名为 <code>a.exe</code>（在 Windows 中）或 <code>a.out</code>（在 Linux&#x2F;macOS 中）。</li></ul></li><li><p><strong>运行程序</strong>  </p><ul><li>在命令提示符中输入以下命令，运行生成的可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.exe    <span class="comment"># Windows 系统</span></span><br><span class="line">./a.out  <span class="comment"># Linux/macOS 系统</span></span><br></pre></td></tr></table></figure></li><li>你将看到屏幕上显示 <code>Hello World</code>。</li></ul></li></ol><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li><strong>什么是编译？</strong><br>编译是将我们写的 C++ 代码转换成机器能理解的二进制文件（可执行文件）的过程。  </li><li><strong>为什么需要编译？</strong><br>计算机只能理解二进制代码，因此必须先将源代码“翻译”成计算机语言，才能运行。<br>通过以上步骤，你的第一个 C++ 程序就成功运行了！</li></ul><h2 id="C-中的分号-语句块"><a href="#C-中的分号-语句块" class="headerlink" title="C++ 中的分号 &amp; 语句块"></a>C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束</p><h3 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h3><ol><li><p><strong>分号是语句结束的标志</strong>：  </p><ul><li>每条C++语句都需要以分号结尾，用来告诉编译器“这句话结束了”。</li><li>你可以把分号看成是句号，表示一个完整的逻辑结束。</li></ul></li><li><p><strong>示例</strong>：<br>下面是三条独立的语句，每条语句都以分号结束：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;         <span class="comment">// 把 y 的值赋给 x</span></span><br><span class="line">y = y + <span class="number">1</span>;     <span class="comment">// y 加 1 后赋值给 y</span></span><br><span class="line"><span class="built_in">add</span>(x, y);     <span class="comment">// 调用函数 add，把 x 和 y 作为参数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="语句块的作用"><a href="#语句块的作用" class="headerlink" title="语句块的作用"></a>语句块的作用</h3><ol><li><p><strong>语句块是逻辑上的一组代码</strong>：  </p><ul><li>使用大括号 <code>&#123;&#125;</code> 将多条语句包裹在一起，这些语句作为一个整体，通常用于函数、条件语句、循环等结构中。</li></ul></li><li><p><strong>示例</strong>：<br>下面是一个语句块，它包含两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 返回值 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同一行的多个语句"><a href="#同一行的多个语句" class="headerlink" title="同一行的多个语句"></a>同一行的多个语句</h3><ol><li><p><strong>C++ 不限制每行只能写一条语句</strong>：  </p><ul><li>你可以在同一行放置多条语句，只要每条语句以分号结束即可。</li></ul></li><li><p><strong>示例</strong>：<br>以下两种写法是等价的：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y; y = y + <span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>分号</strong>：是C++的语句结束符，必须添加。</li><li><strong>语句块</strong>：是一组用大括号 <code>&#123;&#125;</code> 包裹的语句，用于逻辑上的分组。</li><li><strong>多语句</strong>：C++允许多条语句写在一行，只需确保用分号分隔即可。<br>通过这些规则，你可以更灵活地组织代码。</li></ul><h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用于命名变量、函数、类等的符号，用来帮助程序员在代码中识别不同的内容。下面是一些详细解释：</p><ol><li><p><strong>命名规则</strong>：</p><ul><li>标识符必须以字母（A-Z或a-z）或下划线（_）开头。</li><li>后面可以跟字母、数字（0-9）或下划线的组合。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能包含特殊字符，如 <code>@</code>、<code>&amp;</code>、<code>%</code> 等。</li><li>C++ 区分大小写，也就是说 <code>apple</code> 和 <code>Apple</code> 是两个不同的标识符。</li></ul></li><li><p><strong>有效的标识符示例</strong>：</p><ul><li><code>mohd</code>, <code>zara</code>, <code>move_name</code>, <code>a_123</code>, <code>_temp</code> 等，符合规则。<br>通过这些规则，C++ 程序员可以创建各种命名来组织代码，使代码更有条理。</li></ul></li></ol><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h2><p>下面出了一些在 C++ 中的保留字，这些保留字不能作为常量名、变量名或其他标识符名称。<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>C++ Keywords</h2><table>    <tr>        <td>asm</td>        <td>else</td>        <td>new</td>        <td>this</td>    </tr>    <tr>        <td>auto</td>        <td>enum</td>        <td>operator</td>        <td>throw</td>    </tr>    <tr>        <td>bool</td>        <td>explicit</td>        <td>private</td>        <td>true</td>    </tr>    <tr>        <td>break</td>        <td>export</td>        <td>protected</td>        <td>try</td>    </tr>    <tr>        <td>case</td>        <td>extern</td>        <td>public</td>        <td>typedef</td>    </tr>    <tr>        <td>catch</td>        <td>false</td>        <td>register</td>        <td>typeid</td>    </tr>    <tr>        <td>char</td>        <td>float</td>        <td>reinterpret_cast</td>        <td>typename</td>    </tr>    <tr>        <td>class</td>        <td>for</td>        <td>return</td>        <td>union</td>    </tr>    <tr>        <td>const</td>        <td>friend</td>        <td>short</td>        <td>unsigned</td>    </tr>    <tr>        <td>const_cast</td>        <td>goto</td>        <td>signed</td>        <td>using</td>    </tr>    <tr>        <td>continue</td>        <td>if</td>        <td>sizeof</td>        <td>virtual</td>    </tr>    <tr>        <td>default</td>        <td>inline</td>        <td>static</td>        <td>void</td>    </tr>    <tr>        <td>delete</td>        <td>int</td>        <td>static_cast</td>        <td>volatile</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>struct</td>        <td>wchar_t</td>    </tr>    <tr>        <td>double</td>        <td>mutable</td>        <td>switch</td>        <td>while</td>    </tr>    <tr>        <td>dynamic_cast</td>        <td>namespace</td>        <td>template</td>        <td></td>    </tr></table></body></html><p>若要查看完整关键字介绍可查阅：<a href="https://blog.tomatou.xyz/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">C++ 的关键字（保留字）完整介绍</a></p><h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><h3 id="什么是三字符组？"><a href="#什么是三字符组？" class="headerlink" title="什么是三字符组？"></a>什么是三字符组？</h3><p>三字符组是用三个特定字符组合来表示其他字符的一种方法，通常以??开头。这是早期为了解决一些键盘上缺少特定字符的问题而设计的。虽然现代编译器和键盘已经不需要这个功能，但它仍然是C++标准的一部分。</p><h3 id="三字符组的常用替换规则"><a href="#三字符组的常用替换规则" class="headerlink" title="三字符组的常用替换规则"></a>三字符组的常用替换规则</h3><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>字符替换表</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>字符替换表</h2><table>    <tr>        <th>三字符组</th>        <th>替换</th>    </tr>    <tr>        <td>??=</td>        <td>#</td>    </tr>    <tr>        <td>??/</td>        <td>\</td>    </tr>    <tr>        <td>??'</td>        <td>^</td>    </tr>    <tr>        <td>??(</td>        <td>[</td>    </tr>    <tr>        <td>??)</td>        <td>]</td>    </tr>    <tr>        <td>??!</td>        <td>|</td>    </tr>    <tr>        <td>??&lt;</td>        <td>{</td>    </tr>    <tr>        <td>??&gt;</td>        <td>}</td>    </tr>    <tr>        <td>??-</td>        <td>~</td>    </tr></table></body></html><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用三字符组代替常规符号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> ??! std::endl;  <span class="comment">// ??! 替换成 |</span></span><br><span class="line">    <span class="type">int</span> arr??(<span class="number">3</span>??) = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">// ??( 和 ??) 替换成 [ 和 ]</span></span><br><span class="line">    std::cout &lt;&lt; arr??(<span class="number">0</span>??) &lt;&lt; std::endl;       <span class="comment">// 输出数组第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="三字符组的注意事项"><a href="#三字符组的注意事项" class="headerlink" title="三字符组的注意事项"></a>三字符组的注意事项</h3><p><strong>特殊情况避免替换</strong>：</p><p>如果你需要在字符串、字符常量或者注释中保留两个连续的问号，而不被自动替换，可以用以下方式：<br>转义序列：”???“。<br>字符串拼接：”??””?”。</p><p><strong>现代编译器支持：</strong></p><p>Microsoft Visual C++：从2010版开始，默认不再支持三字符组。如果需要启用，可以使用命令行选项&#x2F;Zc:trigraphs。<br>GCC编译器：仍支持三字符组，但会提示编译警告，表明这种用法已经过时。</p><h3 id="为什么了解三字符组？"><a href="#为什么了解三字符组？" class="headerlink" title="为什么了解三字符组？"></a>为什么了解三字符组？</h3><p>虽然三字符组在现代开发中极少使用，但在维护一些古老的代码时可能会遇到。这是一个有趣的历史遗留特性，了解它有助于更全面地理解C++语言的设计。</p><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><p>以下是对“C++ 中的空格”更通俗易懂的解释：</p><h3 id="空白行和空格"><a href="#空白行和空格" class="headerlink" title="空白行和空格"></a>空白行和空格</h3><ol><li><p><strong>空白行</strong>：只有空格或注释的行称为“空白行”。C++ 编译器会自动忽略这些行，它们不会影响代码运行。</p></li><li><p><strong>空格的作用</strong>：</p><ul><li>空格不仅指空白符，还包括制表符（Tab）、换行符和注释，它们都属于“空白符号”。</li><li>空格帮助编译器区分不同部分，比如在<code>int age;</code>这行代码中，<code>int</code>和<code>age</code>之间需要空格，这样编译器才能知道<code>int</code>是数据类型，<code>age</code>是变量名。</li></ul></li><li><p><strong>代码的可读性</strong>：</p><ul><li>在一些地方，空格不是必需的，比如在 <code>fruit = apples + oranges;</code> 中，<code>fruit</code> 和 <code>=</code> 之间不强制要求空格，但适当添加空格可以让代码更清晰，便于阅读。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>空格让代码更易读，帮助编译器识别代码中的不同部分。虽然有些地方空格不是必须的，但为了让代码更美观，推荐合理使用空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与面向过程</title>
      <link href="/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从现在开始我将正式开始分享一些C++程序的讲解，相信大家对于C语言并不陌生，我们接下来需要去学习的C++这个编程语言也跟C语言有关系，但是它与C语言有很大的区别，本节内容不会有代码的讲解，作为一个引文的作用，目的在于让大家认识到C++与C语言的区别，或者说面向对象程序设计语言与面向过程程序设计语言的区别，以便于之后更好的去理解代码、语法等等</strong></p><h1 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h1><h2 id="一-面向过程-OOP"><a href="#一-面向过程-OOP" class="headerlink" title="一.面向过程(OOP)"></a>一.面向过程(OOP)</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p><strong>面向过程是一种以步骤为核心的编程方式，逻辑比较线性。可以理解为<u>以完成任务为目标</u>，通过一系列有序的指令来操作数据，逐步完成任务。我们来具体谈谈：</strong></p><h4 id="游戏中的面向过程"><a href="#游戏中的面向过程" class="headerlink" title="游戏中的面向过程"></a>游戏中的面向过程</h4><p><strong>设想我们要设计一个战斗游戏，有以下角色和功能：</strong></p><p><strong>角色：玩家、怪物</strong><br><strong>功能：攻击、逃跑、升级</strong></p><p><strong>在面向过程的思维中，我们可以按照以下步骤实现：</strong></p><p><strong>1.定义玩家的属性：生命值、攻击力、防御力</strong><br><strong>2.定义怪物的属性：生命值、攻击力、防御力</strong><br><strong>3.编写函数：</strong><br><strong>玩家攻击函数——playerAttackMonster()：玩家攻击怪物，怪物的生命值减少</strong><br><strong>怪物攻击函数——monsterAttackPlayer()：怪物攻击玩家，玩家的生命值减少</strong><br><strong>升级函数——upgradePlayer()：玩家升级时提升攻击力和防御力</strong><br><strong>4.游戏逻辑：通过调用这些函数来实现游戏流程，如玩家攻击、怪物攻击、玩家升级等</strong>。<br><strong>我们可以看到，<u>游戏的主要逻辑由一系列的函数组成，这些函数一个接一个地执行</u></strong></p><p><strong>所以可以得到面向过程的特点：</strong><br><strong>1.步骤清晰：逐步执行代码，如先定义角色，再实现攻击功能</strong><br><strong>2.数据分散：每个角色的数据和行为都是分开的，玩家和怪物的属性、函数不相关</strong><br><strong>3.适合小型项目：如果游戏简单，面向过程的逻辑非常直观</strong></p><p><strong>但这也带来了面向过程的劣势：</strong><br><strong>1.代码重复：不同的角色可能要定义相似的属性（如生命值、攻击力等）</strong><br><strong>2.维护困难：如果要新增一个角色，如“弓箭手”，需要增加很多函数和属性，工作量增加</strong></p><h2 id="二-面向对象-POP"><a href="#二-面向对象-POP" class="headerlink" title="二.面向对象(POP)"></a>二.面向对象(POP)</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向对象是一种以数据和行为组合为核心的编程方式，结构较为模块化。它强调将数据和操作结合在一起，通过“类”和“对象”将复杂的任务组织为独立的模块，还是以游戏为例：</strong></p><h4 id="游戏中的面向对象"><a href="#游戏中的面向对象" class="headerlink" title="游戏中的面向对象"></a>游戏中的面向对象</h4><p><strong>在面向对象的思维中，我们可以通过创建类来封装角色和行为：</strong></p><p><strong>1.定义一个“玩家”类（Player）：</strong><br><strong>属性：生命值、攻击力、防御力等</strong><br><strong>方法：攻击怪物（attack()）、升级（levelUp()）</strong></p><p><strong>2.继承和扩展：</strong><br><strong>如果有不同类型的玩家角色，比如战士（Warrior）、法师（Mage），我们可以让Warrior和Mage继承Player类，这样它们就自动拥有了生命值、攻击力等属性和攻击、升级等方法</strong><br><strong>我们可以为Warrior增加“近战攻击”方法（meleeAttack()），为Mage增加“施法”方法（castSpell()），这样每种角色都有独特的行为，而不需要重复编写基础属性</strong></p><p><strong>3.怪物类（Monster）：</strong><br><strong>我们也可以定义一个Monster类，包含怪物的生命值和攻击力</strong><br><strong>通过定义方法如attackPlayer()，实现怪物对玩家的攻击</strong></p><p><strong>4.道具类（Item）：</strong><br><strong>还可以定义道具类，包含道具名称、效果等属性</strong><br><strong>比如药水类可以恢复玩家的生命值，而武器类可以提升玩家的攻击力</strong></p><p><strong>从上面的例子我们不难看出面向过程的特点：</strong><br><strong>1.模块化：每个类都包含属性和行为，Player类中的方法直接操作Player的数据，怪物则自成一体</strong><br><strong>2.继承性：Warrior、Mage继承自Player，只需扩展各自的特性，而无需重复代码</strong><br><strong>3.封装性：属性和行为封装在类内，外部代码无需关心具体实现，只需调用方法</strong><br><strong>4.扩展性：可以轻松添加新角色或功能，如增加“弓箭手”类，继承Player类，扩展新技能，不影响已有代码</strong></p><h2 id="三-面向对象-vs-面向过程：对比分析"><a href="#三-面向对象-vs-面向过程：对比分析" class="headerlink" title="三.面向对象 vs. 面向过程：对比分析"></a>三.面向对象 vs. 面向过程：对比分析</h2><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><strong>1.面向对象是对面向过程的进一步抽象，结构上更清晰，适合管理复杂系统</strong><br><strong>2.二者的基本逻辑相同，但面向对象在逻辑结构和扩展性上更优</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>1.核心思维：面向过程以步骤和流程为主，逐步实现目标。面向对象通过类和对象组织代码，模块化更高</strong><br><strong>2.代码结构：面向过程的代码较分散，面向对象将数据和操作结合，封装在类中，结构更紧密</strong><br><strong>3.适用场景：面向过程适合简单、线性逻辑；面向对象适合复杂系统，方便维护和扩展</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>通过面向对象编程，我们可以更轻松地在游戏中管理不同角色、怪物、道具的行为和状态。这种模块化的设计方式不仅让代码更易读，还使得后续扩展和维护更加简单。在C++中，面向对象为我们提供了丰富的表达能力，从而使游戏设计更具灵活性和扩展性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站 www.______.com😏</title>
      <link href="/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>先问大家一个问题：大家的浏览器收藏夹里面有多少好东西呢？😋</strong></p><p><strong>我收藏夹里藏着不少“古董级”的宝贝网站，就像那些被遗忘在阁楼角落里的旧玩具，虽然不常拿出来玩，但偶尔翻出来，总能发现一些意想不到的乐趣。这些网站可能平时默默无闻，但说不定在某个无聊的下午，它们就能给你带来惊喜，让你的浏览器收藏夹不再是“尘封的记忆”，而是“宝藏的宝库”。那么，这次我为大家带来了哪些新奇有趣的网站呢？让我们一起来看看，说不定能发现一些被我们忽略的“隐藏版”乐趣哦！</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p><strong>使用设备：电脑</strong><br><strong>获取方式：文章底部(每一个推荐网站的底部)</strong></p><h3 id="1-懒盘搜索——聚合搜索神器"><a href="#1-懒盘搜索——聚合搜索神器" class="headerlink" title="1. 懒盘搜索——聚合搜索神器"></a>1. 懒盘搜索——聚合搜索神器</h3><p><strong>这是一个非常好用的网盘搜索工具，包括音乐、电影、动漫、小说等等内容都能搜索到</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120117.png" alt="主页面" >  <img src="/img_2/QQ截图20241111120126.png" alt="聚合搜索界面" ></div><p><strong>电影搜索</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120237.png" alt="电影搜素" ></div><p><strong>学习资源</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120246.png" alt="学习资源" >  <img src="/img_2/QQ截图20241111121051.png" alt="学习资源" ></div><h4 id="懒盘搜索官网链接：https-www-lzpan-com"><a href="#懒盘搜索官网链接：https-www-lzpan-com" class="headerlink" title="懒盘搜索官网链接：https://www.lzpan.com/"></a>懒盘搜索官网链接：<a href="https://www.lzpan.com/">https://www.lzpan.com/</a></h4><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p><strong>虫部落是一个集结了海量资源的搜索平台。在这里，你能找到的资源大多是通过网盘链接分享的。只要你拥有相应的网盘账户，轻轻一点，就能迅速将资源保存到你的网盘中，然后直接下载，方便快捷</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111121454.png" alt="主页面" >  <img src="/img_2/QQ截图20241111121853.png" alt="部分内容" >  <img src="/img_2/QQ截图20241111121916.png" alt="部分内容" ></div><p><strong>这个平台就像是一个资源宝库，让寻找各类资料变得轻而易举。它极大地简化了我的日常搜索任务，让我能够快速获取所需资源，真是一个值得向大家推荐的实用工具</strong></p><h4 id="虫部落官网链接：http-www-chongbuluo-com"><a href="#虫部落官网链接：http-www-chongbuluo-com" class="headerlink" title="虫部落官网链接：http://www.chongbuluo.com/"></a>虫部落官网链接：<a href="http://www.chongbuluo.com/">http://www.chongbuluo.com/</a></h4><h3 id="3-考研百科网"><a href="#3-考研百科网" class="headerlink" title="3.考研百科网"></a>3.考研百科网</h3><p><strong>这个平台致力于为准备考研的学生提供全方位的支持，让他们能够提前掌握所需的学习资源和准备工作。该平台划分为四个核心板块，分别是考研入门知识、考研流程指导、考研目标规划和备考技巧建议</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111122642.png" alt="主页面" >  <img src="/img_2/QQ截图20241111122656.png" alt="部分内容" ></div><p><strong>这个网站提供了非常全面的资源，我就不在这里一一列举了。正在准备考研或者有意向考研的朋友们，可以查看下面的图表，或者直接访问这个网站来获取更多信息</strong></p><h4 id="考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk"><a href="#考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk" class="headerlink" title="考研百科官网链接：https://yz.chsi.com.cn/yzzt/kybk"></a>考研百科官网链接：<a href="https://yz.chsi.com.cn/yzzt/kybk">https://yz.chsi.com.cn/yzzt/kybk</a></h4><h3 id="一键抠图——在线图片处理神器"><a href="#一键抠图——在线图片处理神器" class="headerlink" title="一键抠图——在线图片处理神器"></a>一键抠图——在线图片处理神器</h3><p><strong>一键抠图是一个卓越的网络图像编辑工具，它提供了众多的图片处理功能，包括但不限于图像抠图、证件照制作、照片修复、文件格式转换、全面编辑以及图片裁剪等，这些功能全面覆盖了日常工作中可能遇到的图像编辑需求</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111123156.png" alt="主页面" ></div><p><strong>抠图功能使用起来非常简单便捷，即使是初学者也能快速掌握。用户只需选择相应的功能，上传图片，系统便会自动进行识别并提取图片中的核心元素，整个过程轻松无压力</strong><br><video controls><br>  <source src="/img_2/bandicam 2024-11-11 12-34-06-243.mp4" type="video/mp4"><br></video></p><h4 id="一键抠图官网链接：https-www-yijiankoutu-com"><a href="#一键抠图官网链接：https-www-yijiankoutu-com" class="headerlink" title="一键抠图官网链接：https://www.yijiankoutu.com/"></a>一键抠图官网链接：<a href="https://www.yijiankoutu.com/">https://www.yijiankoutu.com/</a></h4><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，我们每个人的周围其实都有着不少宝贵的资源，无论是知识、技能、人脉还是物质条件。这些资源就像是我们生活中的宝藏，等待着我们去发掘和利用。不要害怕去探索和尝试，因为每一次的尝试都可能开启新的可能性。让我们勇敢地迈出步伐，用开放的心态去学习，用智慧的眼光去发现，用创新的思维去整合。记住，善于利用身边的资源，不仅能帮助我们解决问题，还能让我们在成长的道路上走得更远。所以，请用好每一份资源，让它们成为我们成功的助力！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
            <tag> 宝藏网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对不住了，Steam！Steam 游戏发烧友必备😏</title>
      <link href="/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/"/>
      <url>/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>说到 Steam，那可是游戏爱好者心中的圣地，就像图书馆之于书虫，糖果店之于小朋友，那是一个应有尽有，让人眼花缭乱的地方。你想要最新的 3A 大作？没问题！在线游戏？小菜一碟！但问题是，这些游戏可不是免费派发的糖果，你得先掏腰包才能把它们领回家</strong><br><strong>如果你偶尔心血来潮，买一两个游戏，那钱包还能勉强保持微笑。但如果你是个游戏收藏家，那可就得小心了，你的钱包可能会因为过度兴奋而 “心脏病发作”</strong><br><strong>当然，如果游戏能让你爱不释手，那花点钱也值了。但最怕的就是，你花了钱，结果发现这游戏跟你八字不合，那可真是让人哭笑不得</strong><br><strong>所以，今天给大家介绍一个神奇的游戏下载盒子，它能让你在 Steam 的海洋里畅游，而不用掏空你的口袋。这可不是普通的盒子，它能让你免费享受那些让人垂涎三尺的游戏大餐。这就好比你走进了一家自助餐厅，却发现老板说：“今天免费，随便吃！” 这等好事，你怎能错过呢？</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：游戏盒子 (game box)</strong><br><strong>使用设备：电脑</strong><br><strong>软件大小：130.04MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p><strong>软件已经出了新版本，但是大家不需要进行更新，我觉得这个版本也是没啥问题，并且也是可以正常使用的，大家想更新的也可以选择更新试试看！然后大家也是能看到内置了超多的游戏资源～</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-41-37-709.mp4" type="video/mp4"><br></video></p><h3 id="游戏搜索"><a href="#游戏搜索" class="headerlink" title="游戏搜索"></a>游戏搜索</h3><p><strong>软件支持直接搜索，你可以通过搜索游戏并下载，下方也是有内置各种分类可供选择，可以在不同类别里发掘自己喜欢的游戏</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-43-08-343.mp4" type="video/mp4"><br></video></p><h3 id="安装路径与下载"><a href="#安装路径与下载" class="headerlink" title="安装路径与下载"></a>安装路径与下载</h3><p><strong>软件提供了一系列精彩的游戏资源，包括许多高品质的 3A 级作品。在开始下载之前，需要先登录天翼云网盘 (免费注册的)，再通过设置选项来指定下载和安装的位置，这样可以确保一切顺利进行。只需点击界面右上角的 “设置” 图标，就可以轻松地自定义您的下载和安装路径了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-04-45-737.mp4" type="video/mp4"><br></video></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p><strong>安装的方式也简单，找到自己喜欢的游戏后，点击安装按钮，然后选择游戏的版本号即可一键下载安装该游戏了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-12-23-001.mp4" type="video/mp4"><br></video></p><h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><strong>测试了一下游戏的下载速度，非常不错，开发大佬优化了下载速度，可以让大家快速的下载完成</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-15-17-955.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>通过网盘分享的文件：gamebox.exe</strong><br><strong>链接: <a href="https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg">https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg</a></strong><br><strong>提取码: e5sa</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>对于这些无私地提供免费软件的开发者们，我们应当怀有敬意和感激之情，向他们致敬🫡</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的歌曲</title>
      <link href="/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是我最近这段时间做的曲子，偏励志的歌曲，希望大家能够喜欢</strong></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="以下是歌词"><a href="#以下是歌词" class="headerlink" title="以下是歌词"></a>以下是歌词</h3><p><strong>歌名：Step By step</strong></p><p><strong>In the race of life, we take our place,</strong><br><strong>With hopes aflame, in this timeless chase.</strong><br><strong>Through storms we walk, lessons deep and wise,</strong><br><strong>With each dawn’s light, a new dream arises.</strong></p><p><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we claim the prize,</strong><br><strong>Eyes set forward, on dreams that rise.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step</strong><br><strong>Step by step</strong><br><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we’ll mark our way.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step, beyond the fear,</strong><br><strong>Through shadows cast, our way is clear.is clear</strong><br><strong>Step by step, we’re redefined,</strong><br><strong>Into a strength of heart and mind.</strong></p><p><strong>Lift your gaze, the world awaits,</strong><br><strong>The dawn of dreams, through future gates.</strong><br><strong>Step by step, we’ll mark our way,</strong><br><strong>Leaving echoes in history’s sway.</strong></p><h3 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h3><video controls>  <source src="/img_1/bandicam 2024-11-09 21-43-51-757.mp4" type="video/mp4"></video><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>进化是万物的自然法则 ，不问因由、不辨方向，只因适应便是生存的唯一。【成长】却是内心深处的觉醒，为更坚定的信念，心向未来，带着无悔的初心启程。 在探索中我们成长，不再因未知而迷茫，在风雨中我们成长，所有的挑战都将迎刃而解，跌倒的站起 ，彷徨的找到归途，仰望那片无际的星空，成长的力量化为无形的支柱，筑起我们心中坚不可摧的信念，成为那份无论何时都不曾动摇的守望！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以使用到下架的音乐软件</title>
      <link href="/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在这个快节奏的世界里，音乐无疑是我们心灵的慰藉，它如同一股清泉，滋润着我们的灵魂。今天想与大家分享的，不仅仅是一款音乐软件，而是一段音乐旅程的开始。这是一款简约而不简单的音乐应用。🙂</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：酷狗概念版</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：124.33MB</strong><br><strong>获取方式：文章底部</strong></p><div style="text-align:center">  <img src="/img_1/55CF549DC97727664019811146FF1E35.jpg" alt="主页面" ></div><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p><strong>想象一下，当你在繁忙的日常中寻找一丝宁静，这款软件就像是一位老朋友，静静地等待你的召唤。它的界面相对于其它几个平台的软件较为简洁，操作直观，只需轻轻一点，就能带你进入音乐的海洋。</strong></p><div style="text-align:center">  <img src="/img_1/5D3400BE1891D4531BD075F73B1F69E2.jpg" alt="播放界面" style="width:50%;">  <img src="/img_1/8BC982518DF64AE8D876DA37D4E8F6D1.jpg" alt="播放界面" style="width:50%;"></div><p><strong>与其他音乐平台相比，这款软件的独特之处在于它的“音乐故事”功能。在这里，每一首歌曲都不仅仅是旋律的堆砌，它们背后的故事，如同珍珠般串联起来，让你在聆听的同时，也能感受到音乐的深度与温度。</strong></p><p><strong>官方还更新了开屏画面，各位可以按照下面的方式去根据自己喜欢的风格壁纸设置</strong></p><div style="text-align:center">  <img src="/img_1/83885ACB3D60D33140B471BD706C4A9A.jpg" alt="" >  <img src="/img_1/1100F28525ACE1DC8B3B740DFFEF4C3A.jpg" alt="效果展示" style="width:50%;"></div><p><strong>值得一提的是这个软件的好处在于，每日都可以领取一日的VIP，只需要看五秒的广告，理论上可以一直不收费的听下去，这绝对是白嫖党的福利😀!</strong></p><div style="text-align:center">  <img src="/img_1/0C8331419A6D582631E22F5406EA3CF6.jpg" alt="" style="width:50%;">  <img src="/img_1/C92DEA934D74627728C5CF99FFA655FC.jpg" alt="" style="width:50%;"></div><p><strong>各位音乐爱好者们，如果你渴望在音乐的世界里寻找一份纯粹，那么这款软件定会是你的不二之选。让我们一起，随着音符跳跃，随着旋律起舞，不要错过这场音乐的盛宴。😆</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA">https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA</a></strong> <br><strong>提取码:iay2</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星际之舞：宇宙的诗篇</title>
      <link href="/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/img_1/9E0BE8E969CAC462282B28BDB3DF1AFE.jpg" alt="马头星云"></p><h3 id="星河璀璨"><a href="#星河璀璨" class="headerlink" title="星河璀璨"></a>星河璀璨</h3><p>  <strong>在浩瀚无垠的宇宙中，每一个星系都是一个独特的存在，它们以自己的方式讲述着宇宙的故事。 这张图片捕捉到了一个遥远星系的壮丽景象，它的中心散发出耀眼的光芒，仿佛是宇宙的灯塔，指引着迷失在星际间的旅者</strong></p><div style="text-align:center">  <img src="/img_1/7318400BB81BE3610CB7C214222D802A.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="旋舞银河"><a href="#旋舞银河" class="headerlink" title="旋舞银河"></a>旋舞银河</h3><p><strong>星系的旋臂如同宇宙的舞者，优雅地旋转着，上面点缀着无数的恒星，每一颗都在以自己的生命节奏闪烁。这些恒星的诞生、演化和死亡，构成了宇宙生命的交响曲。而那些暗淡的尘埃和气体，则是新恒星的摇篮，孕育着未来的光明</strong></p><div style="text-align:center">  <img src="/img_1/F872DED84FC80417240DFAA73466AD77.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/C880F01E01FF0D0849D9AFBB44BA7CA6.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="微光感悟"><a href="#微光感悟" class="headerlink" title="微光感悟"></a>微光感悟</h3><p> <strong>在这片星海中，我们不仅看到了宇宙的壮丽，也感受到了自己的渺小。然而，正是这种渺小，让我们对宇宙的探索充满了无限的好奇和渴望。每一次对星空的凝视，都是对未知的一次致敬，也是对人类探索精神的一次肯定。</strong></p><div style="text-align:center">  <img src="/img_1/34E6F253E9EB266011351DBB9C2F2082.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/39DC3EE370E1BC8F31E5739ED3707C34.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="远征"><a href="#远征" class="headerlink" title="远征"></a>远征</h3><p> <strong>每一颗星星都可能是一个新世界的开始。在这个无尽的宇宙之旅中，我们都是勇敢的探险者，追寻着知识的光，照亮前行的路。</strong></p><div style="text-align:center">  <img src="/img_1/CAA771D7E2B3AE60CE7475CD17304335.jpg" alt="拍摄＆后期 By 码头"></div><p><strong>自己拍摄的图，分享给大家，希望每个人都可以在自己的追寻的道路上走的足够远，成为有所建树的人😃</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款好用的音乐软件</title>
      <link href="/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在数字时代的浪潮中，音乐软件如同璀璨的星辰，点缀着我们的生活。今天我要向大家介绍的，是一款与众不同的音乐应用，它以其独特的魅力，悄然走进了我们的世界</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：速悦音乐</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：31.01MB</strong><br><strong>获取方式：文章底部</strong></p><p><strong>这款音乐软件如同一股清新的风，吹散了繁琐的注册登录流程(你可以不需要注册或登录就可以直接使用)，让你无需任何门槛，甚至可以下载音乐，即可直接沉浸在音乐的海洋中。它的首界面，简洁至极，如同一张白纸，等待着你用指尖的魔法，绘制出属于自己的音乐天地</strong></p><div style="text-align:center">  <img src="/img_1/488C7C60ED9CA57D5F062D06E558EBC5.jpg" alt="主页面" >  <img src="/img_1/42F2AA03FF2EF5FB741F2B8A6BADF78D.jpg" alt="播放界面" style="width:50%;" ></div><p><strong>顺带一提，下载音乐只需要分享就可以下载了(你可以不直接分享，点击分享按钮，再退出就好了，不过为了支持原作者，建议还是分享一下吧😁)，具体操作如下图</strong></p><div style="text-align:center">  <img src="/img_1/CA1AA8F8B40A78F3E4CD9932426B3C99.gif" alt="播放界面" ></div><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>不仅如此，这款软件还赋予了你无限的创造力。你可以根据自己的喜好，自定义界面，让每一次打开应用，都成为一场视觉与听觉的双重盛宴。无论是色彩的搭配，还是布局的调整，都能随心所欲，打造出一个完全属于你的音乐空间</strong><br><strong>你也可以设置界面是否为深色模式，以及背景的模糊度和透明度等，具体参照下图，这里就不再演示，可自行探索</strong></p><div style="text-align:center">  <img src="/img_1/7F3CFD25EB3A4E1502F4330A748F859C.jpg" alt="主题切换演示" >  <img src="/img_1/11259F93D8B82874CE5AE29E1C52F5D5.jpg" alt="这是我的主题" style="width:50%;" ></div><p><strong>朋友们，如果你厌倦了复杂的操作，渴望一份简单而纯粹的音乐体验，那么这款软件无疑是你的最佳选择。让我们一起，在这个小小的屏幕上，探索无限的音乐世界，享受那份只属于你的宁静与自由</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg">https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg</a></strong><br><strong>提取码:nt24</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>在我们国内不缺乏一些好用的音乐软甲，但很可惜的是，由于动了别人的蛋糕，难免会遭受排挤，诸如歌词适配，洛雪等老牌软件也未能幸免，想要找到一款好用的软件实属不易，但仍然有许多为爱发电的大佬开发的软件依旧在坚挺，向他们致敬🫡！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><p><strong>在此之前，我们先来聊聊递归的思想</strong><br><strong>递归是计算的基本思想之一，想象一下，你是一个老师，要解释什么是“递归”，你可能会说：“递归就是我给你们举的例子，这个例子就是递归的一个实例。” 这就是递归的本质：用递归自身来解释递归</strong></p><h2 id="递归的工作原理"><a href="#递归的工作原理" class="headerlink" title="递归的工作原理"></a>递归的工作原理</h2><p><strong>递归的工作原理可以想象成俄罗斯套娃，每个娃娃里面都有一个更小的娃娃，直到最小的那个。在编程中，这就像是函数A调用自己A，函数A又调用自己A，如此继续，直到达到最小的娃娃（也就是递归的基本情况），然后开始一层层解开，直到回到最初的那个函数A</strong><br><strong>再换一个例子，想象一下，你正在爬楼梯，每爬一阶，你就离顶层更近一步。递归也是这样，每次函数调用自己时，都会更接近基本情况（base case），也就是递归结束的条件</strong></p><h2 id="递归的两个关键部分"><a href="#递归的两个关键部分" class="headerlink" title="递归的两个关键部分"></a>递归的两个关键部分</h2><p><strong>1.基本情况（Base Case）：这是递归停止的条件，就像最小的俄罗斯套娃，没有更小的娃娃了。或则说，类似于你爬到顶层，就不再爬了在编程中，这通常是最简单的问题，可以直接解决，不需要进一步递归</strong><br><strong>递推关系（Recursive Case）：这是函数如何调用自己的部分，每次调用都应该让问题更接近基本情况</strong></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><h3 id="1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120"><a href="#1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120" class="headerlink" title="1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120"></a>1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120</h3><p>以下是C语言的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为0或1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回n乘以(n-1)的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u 的阶乘是 %llu\n&quot;</span>, num, factorial(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><p><strong>斐波那契数列是这样的数列：0, 1, 1, 2, 3, 5, 8, 13, …，其中每个数是前两个数的和。</strong></p><p>以下是C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 基本情况：如果n为0，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为1，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回前两个斐波那契数的和</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, num, fibonacci(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>递归在编程中是一种强大的编程技术，它通过函数自我调用来解决问题。在使用递归时，确保有明确的基本情况和递推关系，这样可以避免无限递归和栈溢出的问题。希望这些例子能帮助你理解递归的概念和应用</strong></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><strong>通过上面的例子你应该大致理解了递归的思想了，那么接下来我们回到本次要讲的正题————二叉树的遍历。相信学数据结构的同学对它一定不陌生！二叉树的遍历是按照某种规则，依次访问二叉树中的每个节点，每个节点只访问一次。主要有三种遍历方式：先序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）</strong></p><h2 id="先序遍历（Preorder-Traversal）"><a href="#先序遍历（Preorder-Traversal）" class="headerlink" title="先序遍历（Preorder Traversal）"></a>先序遍历（Preorder Traversal）</h2><p><strong>定义：先访问根节点，然后遍历左子树，最后遍历右子树</strong>。<br><strong>递归算法：访问根节点，然后对左子树和右子树递归执行先序遍历。</strong><br><strong>非递归算法：使用栈来模拟递归过程。首先将根节点入栈，然后循环执行以下步骤：弹出栈顶节点，访问它，然后将它的右子节点和左子节点依次入栈（注意顺序，先右后左）</strong></p><p><strong>假设我们有如下的二叉树：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于先序遍历，简单来说就是指按照“根节点 -&gt; 左子树 -&gt; 右子树”的顺序访问二叉树的每个节点,以下是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它打印根节点的值，然后递归地遍历左子树和右子树</strong><br><strong>遍历下来的结果就是：1, 2, 4, 5, 3</strong></p><p><strong>接下来是非递归的遍历算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode* node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.push(node-&gt;right); <span class="comment">// 先右后左，保持顺序</span></span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将根节点压入栈中，然后循环直到栈为空。在每次循环中，它弹出栈顶节点，访问它，然后将右子节点和左子节点依次压入栈中，所以遍历下来的结果就是：非递归遍历结果：1, 2, 4, 5, 3</strong></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>定义：先遍历左子树，然后访问根节点，最后遍历右子树</strong><br><strong>递归算法：对左子树递归执行中序遍历，访问根节点，然后对右子树递归执行中序遍历</strong><br><strong>非递归算法：使用栈来模拟递归过程。从根节点开始，将节点依次入栈直到到达最左节点，然后访问它并转向右子节点，重复此过程</strong></p><p><strong>还是上述的二叉树为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对与中序遍历便是指按照“左子树 -&gt; 根节点 -&gt; 右子树”的顺序访问二叉树的每个节点，以下是递归算法得的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    inOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树，打印根节点的值，然后递归地遍历右子树,所以遍历的结果便是：4, 2, 5, 1, 3</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它弹出栈顶节点，访问它，并转向其右子节点,所以遍历出来的结果便是：4, 2, 5, 1, 3</strong></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>定义：先遍历左子树，然后遍历右子树，最后访问根节点</strong><br><strong>递归算法：对左子树和右子树递归执行后序遍历，然后访问根节点</strong><br><strong>非递归算法：使用两个栈来模拟递归过程。第一个栈用于遍历，第二个栈用于反转遍历顺序。将根节点入第一个栈，然后循环执行以下步骤：从第一个栈中弹出节点并将其入第二个栈，然后将其子节点依次入第一个栈（注意顺序，先右后左）。当第一个栈为空时，从第二个栈中弹出节点并访问它们</strong></p><p><strong>二叉树例子同上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历便是指按照“左子树 -&gt; 右子树 -&gt; 根节点”的顺序访问二叉树的每个节点，接下来是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    postOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树和右子树，然后打印根节点的值，所以遍历出来的结果是：4, 5, 2, 6, 7, 3, 1</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right == <span class="literal">NULL</span> || current-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            prev = current;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它检查栈顶节点的右子节点是否为空或者是否已经访问过。如果是，它弹出栈顶节点，访问它，并更新prev节点。否则，它转向栈顶节点的右子节点,所以运行出来的结果便是：4, 5, 2, 6, 7, 3, 1</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>递归方法：直观，易于实现，但可能遇到栈溢出的问题</strong><br><strong>非递归方法：使用栈或队列来模拟递归过程，可以避免栈溢出的问题，但实现相对复杂</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，学习编程可能会在一开始感到有些挑战，但请记住，每个编程高手都是从基础开始，一步一个脚印走过来的。递归是编程中一个非常强大的工具，一旦你掌握了它，很多复杂的问题都会变得简单起来。记住，每个人的学习速度都是不同的，不要和别人比较，而是和昨天的自己比较。只要你们保持耐心和热情，不断练习，很快就能掌握递归的。加油，你们可以做到的！😉</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF算法与KMP算法</title>
      <link href="/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊数据结构中两种在字符串中寻找子串的方法：暴力匹配（BF算法）和KMP算法。<strong>这两种方法都像是在玩一个“找茬”游戏</strong>，目的是在一个大字符串（我们称之为主串）中找到一个小字符串（我们称之为模式串）出现的位置。</p><p>我们先举一个例子：<br><strong>假设主串为 “ababcabcacbab”，模式串为 “abcac”</strong></p><h2 id="暴力匹配（BF算法）"><a href="#暴力匹配（BF算法）" class="headerlink" title="暴力匹配（BF算法）"></a>暴力匹配（BF算法）</h2><p><strong>BF算法，也称为暴力匹配算法，是一种简单的字符串匹配方法。它的基本思想是从主串的每一个字符开始，逐个与模式串的字符进行比较，直到找到匹配的字符或比较完整个模式串。如果模式串中有某个字符不匹配，BF算法会回溯到主串的下一个字符重新开始匹配。想象一下，你手上有一张小图片（模式串），你想在一个巨大的画布（主串）上找到这张图片。使用暴力匹配的方法，你会从画布的最左边开始，试着把小图片的每个角对准画布上的每个点，看看是否能完全匹配。如果不匹配，你就向右移动一点，再试一次。这个过程会一直重复，直到你找到匹配的地方，或者把整个画布都试一遍。</strong></p><p><strong>原理</strong><br><strong>1.从主串的第一个字符开始，与模式串的第一个字符进行比较。</strong><br><strong>2.如果相等，则继续比较主串和模式串的下一个字符。</strong><br><strong>3.如果不相等，则主串指针回溯到上次匹配的首位的下一位，模式串指针回到开头，重新开始匹配。</strong><br><strong>4.重复上述过程，直到找到匹配的子串或主串遍历完毕。</strong></p><p>以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; S[i + j] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = BF(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h2><p><strong>KMP算法是一种改进的字符串匹配算法。它通过预处理模式串，构建部分匹配表（next数组），在匹配过程中利用已经匹配的信息，避免重复比较，从而提高匹配效率。KMP算法更聪明一些。它在开始全面搜索之前，会先研究一下小图片（模式串），找出一些特征，这样在大画布（主串）上搜索时，就能跳过一些明显不需要检查的地方。这就像是你记住了小图片的一些特征，然后在大画布上快速地找到可能匹配的地方。</strong></p><p><strong>KMP算法的核心是预处理模式串，创建一个“部分匹配表”，这个表告诉我们，当某个位置不匹配时，我们应该跳到模式串的哪个位置继续比较.</strong></p><p><strong>原理</strong><br><strong>1.预处理模式串，构建next数组。next数组记录了模式串中每个位置的最长相等前后缀的长度。</strong><br><strong>2.在匹配过程中，当遇到不匹配时，利用next数组跳过已经匹配的部分，避免回溯。</strong></p><p>还是刚才的例子，以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    computeNext(T, next);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = KMP(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p><strong>BF算法：简单易懂，但效率较低，时间复杂度为 O(n⋅m)</strong><br><strong>KMP算法：通过预处理模式串，利用next数组避免重复比较，提高匹配效率，时间复杂度为O(n+m)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
