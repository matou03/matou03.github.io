<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C语言指针</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容十分的重要，所以需要非常认真的对待，我也会可能的用最容易理解的方式进行讲解！！！</strong></p><h1 id="🧭-C语言指针——内存导航"><a href="#🧭-C语言指针——内存导航" class="headerlink" title="🧭 C语言指针——内存导航"></a>🧭 <strong>C语言指针——内存导航</strong></h1><p>指针是C语言的灵魂，也是初学者最易困惑的部分。本文将以最详细、最通俗的方式，手把手带你彻底征服指针！  </p><hr><h2 id="一、指针基础：内存世界的「快递单号系统」"><a href="#一、指针基础：内存世界的「快递单号系统」" class="headerlink" title="一、指针基础：内存世界的「快递单号系统」"></a><strong>一、指针基础：内存世界的「快递单号系统」</strong></h2><p><strong>1. 内存地址：每个变量的「仓库编号」</strong>  </p><ul><li><strong>内存比喻</strong>：想象内存是一个超大仓库，每个变量是仓库中的货物，地址就是货物的具体位置编号（如A区-1排-3号）。  </li><li><strong>查看地址</strong>：使用<code>&amp;</code>运算符获取变量地址：  <pre><code class="c">int num = 10;  printf(&quot;变量地址：%p\n&quot;, &amp;num); // 输出类似0x7ffd42a3a4dc  </code></pre><strong>注意</strong>：每次运行程序，变量地址可能不同（操作系统动态分配）。</li></ul><p><strong>2. 指针变量：存储地址的「快递单号」</strong>  </p><ul><li><strong>定义指针</strong>：指针变量专门存储其他变量的地址，类型必须匹配：</li></ul><pre><code class="c">int *p;      // 声明一个整型指针  p = &amp;num;    // p存储num的地址  </code></pre><p><strong>3. 解引用：通过「单号」找到货物</strong>  </p><ul><li>使用<code>*</code>访问指针指向的值：  <pre><code class="c">printf(&quot;num的值：%d\n&quot;, *p); // 输出10  *p = 20;                    // 通过指针修改num的值  printf(&quot;num的新值：%d\n&quot;, num); // 输出20  </code></pre><strong>关键点</strong>：  <ul><li><code>p</code>存储的是地址（如0x7ffd42a3a4dc）  </li><li><code>*p</code>表示访问该地址存储的值</li></ul></li></ul><hr><h2 id="二、NULL指针：避免「快递单号」丢失的安全锁"><a href="#二、NULL指针：避免「快递单号」丢失的安全锁" class="headerlink" title="二、NULL指针：避免「快递单号」丢失的安全锁"></a><strong>二、NULL指针：避免「快递单号」丢失的安全锁</strong></h2><p><strong>1. 空指针的作用</strong>：  </p><ul><li>防止指针未初始化时指向随机内存（野指针），导致程序崩溃。  </li><li>用于表示指针不指向任何有效数据。</li></ul><p><strong>2. 使用NULL初始化指针</strong>：  </p><pre><code class="c">int *p = NULL; // 初始化为空指针  if (p != NULL) &#123;      printf(&quot;%d&quot;, *p); // 不会执行  &#125;  </code></pre><p><strong>3. 空指针的危险操作</strong>：  </p><pre><code class="c">*p = 10; // ❌ 运行时错误！访问空指针地址  </code></pre><hr><h2 id="三、指针算术：在内存仓库中「精准跳跃」"><a href="#三、指针算术：在内存仓库中「精准跳跃」" class="headerlink" title="三、指针算术：在内存仓库中「精准跳跃」"></a><strong>三、指针算术：在内存仓库中「精准跳跃」</strong></h2><p>指针加减法不是普通数值运算，而是按<strong>类型大小</strong>移动地址！  </p><p><strong>1. 基础规则</strong>：  </p><table><thead><tr><th>操作</th><th>实际地址变化</th></tr></thead><tbody><tr><td><code>p + n</code></td><td>地址增加 <code>n * sizeof(类型)</code></td></tr><tr><td><code>p - n</code></td><td>地址减少 <code>n * sizeof(类型)</code></td></tr><tr><td><code>p++</code></td><td>地址增加 <code>sizeof(类型)</code></td></tr><tr><td><code>p--</code></td><td>地址减少 <code>sizeof(类型)</code></td></tr></tbody></table><p><strong>2. 实例演示</strong>：  </p><pre><code class="c">int arr[3] = &#123;10, 20, 30&#125;;  int *p = arr; // p指向arr[0]（地址A）  printf(&quot;arr[0]: %d\n&quot;, *p);   // 10  p++;                          // 地址A + 4字节（int占4字节）  printf(&quot;arr[1]: %d\n&quot;, *p);   // 20  p += 2;                       // 地址A + 12字节 → 指向arr[3]（越界！）  printf(&quot;越界值: %d\n&quot;, *p);   // 随机值  </code></pre><p><strong>3. 指针比较</strong>：判断指针位置关系  </p><pre><code class="c">int *p1 = &amp;arr[0];  int *p2 = &amp;arr[2];  if (p1 &lt; p2) &#123;      printf(&quot;p1在前，p2在后\n&quot;);  &#125;  </code></pre><hr><h2 id="四、指针与数组：仓库中的「连续货架」"><a href="#四、指针与数组：仓库中的「连续货架」" class="headerlink" title="四、指针与数组：仓库中的「连续货架」"></a><strong>四、指针与数组：仓库中的「连续货架」</strong></h2><p><strong>1. 数组名是首元素地址</strong>：  </p><pre><code class="c">int arr[5] = &#123;1,2,3,4,5&#125;;  int *p = arr; // 等价于 p = &amp;arr[0]  </code></pre><p><strong>2. 遍历数组的两种方式</strong>：  </p><ul><li><strong>下标法</strong>：  <pre><code class="c">for (int i=0; i&lt;5; i++) &#123;      printf(&quot;%d &quot;, arr[i]);  &#125;  </code></pre></li><li><strong>指针法</strong>：  <pre><code class="c">for (int *ptr=arr; ptr &lt; arr+5; ptr++) &#123;      printf(&quot;%d &quot;, *ptr);  &#125;  </code></pre></li></ul><p><strong>3. 数组指针 vs 指针数组</strong>：  </p><ul><li><strong>数组指针</strong>：指向数组的指针  <pre><code class="c">int (*pArr)[5] = &amp;arr; // pArr指向整个数组  printf(&quot;第一个元素：%d\n&quot;, (*pArr)[0]); // 1  </code></pre></li><li><strong>指针数组</strong>：存储指针的数组  <pre><code class="c">int *ptrArr[3];  int a=1, b=2, c=3;  ptrArr[0] = &amp;a;  ptrArr[1] = &amp;b;  ptrArr[2] = &amp;c;  </code></pre></li></ul><hr><h2 id="五、多级指针：快递单号的「多层包裹」"><a href="#五、多级指针：快递单号的「多层包裹」" class="headerlink" title="五、多级指针：快递单号的「多层包裹」"></a><strong>五、多级指针：快递单号的「多层包裹」</strong></h2><p><strong>1. 指向指针的指针</strong>：  </p><pre><code class="c">int num = 100;  int *p = &amp;num;  int **pp = &amp;p;    // pp存储p的地址  printf(&quot;num的值：%d\n&quot;, **pp); // 100  </code></pre><p><strong>2. 应用场景</strong>：动态二维数组  </p><pre><code class="c">int rows=3, cols=4;  int **matrix = (int**)malloc(rows * sizeof(int*));  for (int i=0; i&lt;rows; i++) &#123;      matrix[i] = (int*)malloc(cols * sizeof(int));  &#125;  </code></pre><hr><h2 id="六、指针与函数：远程操控仓库的「机械臂」"><a href="#六、指针与函数：远程操控仓库的「机械臂」" class="headerlink" title="六、指针与函数：远程操控仓库的「机械臂」"></a><strong>六、指针与函数：远程操控仓库的「机械臂」</strong></h2><p><strong>1. 指针作为函数参数</strong>：实现函数内外数据交互  </p><pre><code class="c">void addTen(int *num) &#123;      *num += 10;  &#125;  int main() &#123;      int x = 5;      addTen(&amp;x);      printf(&quot;x = %d\n&quot;, x); // 15  &#125;  </code></pre><p><strong>2. 返回指针的函数</strong>：  </p><pre><code class="c">int* createArray(int size) &#123;      int *arr = (int*)malloc(size * sizeof(int));      return arr; // 返回动态数组指针  &#125;  int main() &#123;      int *myArr = createArray(5);      myArr[0] = 10;      free(myArr); // 必须手动释放内存！  &#125;  </code></pre><p><strong>3. 函数指针：指向函数的「说明书」</strong>  </p><pre><code class="c">int add(int a, int b) &#123; return a + b; &#125;  int sub(int a, int b) &#123; return a - b; &#125;  int main() &#123;      int (*funcPtr)(int, int); // 声明函数指针      funcPtr = add;      printf(&quot;3+5=%d\n&quot;, funcPtr(3,5)); // 8      funcPtr = sub;      printf(&quot;5-3=%d\n&quot;, funcPtr(5,3)); // 2  &#125;  </code></pre><hr><h2 id="七、动态内存管理：自主管理「仓库扩建」"><a href="#七、动态内存管理：自主管理「仓库扩建」" class="headerlink" title="七、动态内存管理：自主管理「仓库扩建」"></a><strong>七、动态内存管理：自主管理「仓库扩建」</strong></h2><p><strong>1. malloc：申请新货架</strong>  </p><pre><code class="c">int *p = (int*)malloc(5 * sizeof(int)); // 申请5个int空间  if (p == NULL) &#123;      printf(&quot;内存不足！\n&quot;);      exit(1);  &#125;  p[0] = 10;  free(p); // 必须释放！  </code></pre><p><strong>2. calloc：申请并初始化</strong>  </p><pre><code class="c">int *p = (int*)calloc(5, sizeof(int)); // 全部初始化为0  </code></pre><p><strong>3. realloc：调整货架大小</strong>  </p><pre><code class="c">p = realloc(p, 10 * sizeof(int)); // 扩容到10个int  </code></pre><hr><h2 id="八、常见错误案例集：指针「翻车现场」实录"><a href="#八、常见错误案例集：指针「翻车现场」实录" class="headerlink" title="八、常见错误案例集：指针「翻车现场」实录"></a><strong>八、常见错误案例集：指针「翻车现场」实录</strong></h2><p><strong>1. 野指针：未初始化的指针</strong>  </p><pre><code class="c">int *p;          // 未初始化！  *p = 10;         // ❌ 随机写入内存，导致崩溃或数据损坏  </code></pre><p><strong>2. 内存泄漏：忘记释放</strong>  </p><pre><code class="c">void func() &#123;      int *p = malloc(100);      // 忘记free(p)  &#125; // 函数结束后，p指向的内存永远无法回收  </code></pre><p><strong>3. 越界访问</strong>  </p><pre><code class="c">int arr[3] = &#123;1,2,3&#125;;  int *p = &amp;arr[3]; // ❌ 访问arr[3]（有效下标是0-2）  printf(&quot;%d&quot;, *p); // 随机值或崩溃  </code></pre><p><strong>4. 返回局部变量指针</strong>  </p><pre><code class="c">int* badFunc() &#123;      int num = 10;      return &amp;num; // ❌ num在函数结束后被销毁  &#125;  int *p = badFunc();  printf(&quot;%d&quot;, *p); // 结果不可预测！  </code></pre><hr><h2 id="九、综合实战：指针应用全演练"><a href="#九、综合实战：指针应用全演练" class="headerlink" title="九、综合实战：指针应用全演练"></a><strong>九、综合实战：指针应用全演练</strong></h2><p><strong>1. 字符串反转（指针版）</strong>  </p><pre><code class="c">void reverseString(char *str) &#123;      char *start = str;      char *end = str + strlen(str) - 1;      while (start &lt; end) &#123;          char temp = *start;          *start = *end;          *end = temp;          start++;          end--;      &#125;  &#125;  int main() &#123;      char s[] = &quot;hello&quot;;      reverseString(s);      printf(&quot;%s&quot;, s); // 输出&quot;olleh&quot;  &#125;  </code></pre><p><strong>2. 动态二维数组</strong>  </p><pre><code class="c">int rows=3, cols=4;  int **matrix = (int**)malloc(rows * sizeof(int*));  for (int i=0; i&lt;rows; i++) &#123;      matrix[i] = (int*)malloc(cols * sizeof(int));      for (int j=0; j&lt;cols; j++) &#123;          matrix[i][j] = i * cols + j;      &#125;  &#125;  // 使用后释放  for (int i=0; i&lt;rows; i++) &#123;      free(matrix[i]);  &#125;  free(matrix);  </code></pre><hr><h2 id="💡-终极总结：指针核心口诀"><a href="#💡-终极总结：指针核心口诀" class="headerlink" title="💡 终极总结：指针核心口诀"></a>💡 <strong>终极总结：指针核心口诀</strong></h2><blockquote><p>指针即地址，变量门牌号。<br>声明类型要匹配，解引用用星号找。<br>算术运算按类型跳，数组遍历效率高。<br>函数参数传地址，动态内存自己搞。<br>多级指针套娃妙，函数指针灵活调。<br>空指针初始化保平安，内存泄漏错误要记牢！  </p></blockquote><p><strong>练习建议</strong>：  </p><ol><li>手写代码实现各种指针操作  </li><li>用指针重写所有数组操作练习  </li><li>调试观察指针地址变化</li></ol><p>掌握指针，你就掌握了C语言的精髓！ 🚀 遇到问题多画内存图，理解会更深刻哦~</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cenum(枚举)</title>
      <link href="/2025/02/03/Cenum-%E6%9E%9A%E4%B8%BE/"/>
      <url>/2025/02/03/Cenum-%E6%9E%9A%E4%B8%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="📚-C语言枚举（enum）——给数字赋予意义的名字"><a href="#📚-C语言枚举（enum）——给数字赋予意义的名字" class="headerlink" title="📚 C语言枚举（enum）——给数字赋予意义的名字"></a>📚 <strong>C语言枚举（enum）——给数字赋予意义的名字</strong></h1><hr><h2 id="一、什么是枚举？——数字的「身份证」"><a href="#一、什么是枚举？——数字的「身份证」" class="headerlink" title="一、什么是枚举？——数字的「身份证」"></a><strong>一、什么是枚举？——数字的「身份证」</strong></h2><p><strong>概念</strong>：枚举（Enumeration）是一种用户自定义的数据类型，用于为一组整数常量赋予有意义的名字。<br><strong>思想</strong>：用易于理解的单词代替数字，让代码更清晰、更易维护。<br><strong>作用</strong>：  </p><ul><li>提高代码可读性（看到名字就知道含义）  </li><li>限制变量的取值范围（只能选枚举中的值）  </li><li>替代散乱的<code>#define</code>宏定义</li></ul><p><strong>类比理解</strong>：  </p><ul><li>假设你管理一个图书馆📚，书籍分类用数字表示：  <ul><li><strong>不用枚举</strong>：看到<code>1</code>，需要查文档才知道是“科幻类”  </li><li><strong>使用枚举</strong>：直接写<code>SciFi</code>，一看就懂！</li></ul></li></ul><hr><h2 id="二、为什么需要枚举？——告别「神秘数字」"><a href="#二、为什么需要枚举？——告别「神秘数字」" class="headerlink" title="二、为什么需要枚举？——告别「神秘数字」"></a><strong>二、为什么需要枚举？——告别「神秘数字」</strong></h2><p><strong>痛点</strong>：  </p><pre><code class="c">// 用数字表示状态，难以记忆！if (status == 1) &#123; /* 处理成功 */ &#125;  else if (status == 2) &#123; /* 处理失败 */ &#125;</code></pre><p><strong>枚举解决方案</strong>：  </p><pre><code class="c">enum Status &#123;Success=1, Failure=2&#125;;if (status == Success) &#123; ... &#125; // 一目了然✨</code></pre><p><strong>优点</strong>：  </p><ol><li><strong>代码自解释</strong>：名字比数字更易懂  </li><li><strong>类型安全</strong>：编译器检查枚举变量赋值  </li><li><strong>易维护</strong>：修改枚举值只需改一处</li></ol><p><strong>缺点</strong>：  </p><ol><li><strong>本质是整数</strong>：无法直接打印名字（需手动转换）  </li><li><strong>不连续枚举难遍历</strong>：无法自动获取所有值</li></ol><hr><h2 id="三、枚举的定义与使用——三步创建「命名册」"><a href="#三、枚举的定义与使用——三步创建「命名册」" class="headerlink" title="三、枚举的定义与使用——三步创建「命名册」"></a><strong>三、枚举的定义与使用——三步创建「命名册」</strong></h2><h3 id="1-定义枚举类型"><a href="#1-定义枚举类型" class="headerlink" title="1. 定义枚举类型"></a><strong>1. 定义枚举类型</strong></h3><p><strong>语法</strong>：  </p><pre><code class="c">enum 枚举类型名 &#123;      名字1,      名字2,      // ...  &#125;;  </code></pre><p><strong>示例</strong>：  </p><pre><code class="c">// 定义星期枚举  enum Week &#123;      Monday,    // 默认值0      Tuesday,   // 自动+1 → 1      Wednesday, // 2      // ...  &#125;;  </code></pre><h3 id="2-创建枚举变量"><a href="#2-创建枚举变量" class="headerlink" title="2. 创建枚举变量"></a><strong>2. 创建枚举变量</strong></h3><p><strong>三种方式</strong>：  </p><ul><li><p><strong>先声明类型，后定义变量</strong>：  </p><pre><code class="c">enum Week &#123;Mon, Tue, Wed&#125;;  enum Week today;  // 定义变量  today = Mon;      // 赋值  </code></pre></li><li><p><strong>声明同时定义变量</strong>：  </p><pre><code class="c">enum Week &#123;Mon, Tue, Wed&#125; today;  today = Tue;  </code></pre></li><li><p><strong>匿名枚举（不推荐）</strong>：  </p><pre><code class="c">enum &#123;Mon=1, Tue, Wed&#125; today; // 无类型名，无法复用  </code></pre></li></ul><h3 id="3-赋值规则"><a href="#3-赋值规则" class="headerlink" title="3. 赋值规则"></a><strong>3. 赋值规则</strong></h3><ul><li><p><strong>默认从0开始</strong>：  </p><pre><code class="c">enum Color &#123;Red, Green, Blue&#125;; // Red=0, Green=1, Blue=2  </code></pre></li><li><p><strong>手动指定起始值</strong>：  </p><pre><code class="c">enum Week &#123;Mon=1, Tue, Wed&#125;; // Mon=1, Tue=2, Wed=3  </code></pre></li><li><p><strong>跳跃赋值</strong>：  </p><pre><code class="c">enum HttpStatus &#123;OK=200, NotFound=404, Error=500&#125;;  </code></pre></li></ul><hr><h2 id="四、枚举的实战应用——让代码「会说话」"><a href="#四、枚举的实战应用——让代码「会说话」" class="headerlink" title="四、枚举的实战应用——让代码「会说话」"></a><strong>四、枚举的实战应用——让代码「会说话」</strong></h2><h3 id="1-替代魔数（Magic-Number）"><a href="#1-替代魔数（Magic-Number）" class="headerlink" title="1. 替代魔数（Magic Number）"></a><strong>1. 替代魔数（Magic Number）</strong></h3><p><strong>坏代码</strong>：  </p><pre><code class="c">if (status == 404) &#123; ... &#125; // 404是什么？需要查文档！  </code></pre><p><strong>好代码</strong>：  </p><pre><code class="c">enum HttpStatus &#123;OK=200, NotFound=404&#125;;  if (status == NotFound) &#123; ... &#125; // 清晰！  </code></pre><h3 id="2-在switch-case中使用"><a href="#2-在switch-case中使用" class="headerlink" title="2. 在switch-case中使用"></a><strong>2. 在switch-case中使用</strong></h3><pre><code class="c">enum Color &#123;Red=1, Green, Blue&#125;;  enum Color favorite = Green;  switch (favorite) &#123;      case Red:   printf(&quot;❤️&quot;); break;      case Green: printf(&quot;💚&quot;); break;      case Blue:  printf(&quot;💙&quot;); break;      default:    printf(&quot;未知颜色&quot;);  &#125;  </code></pre><h3 id="3-限制变量取值范围"><a href="#3-限制变量取值范围" class="headerlink" title="3. 限制变量取值范围"></a><strong>3. 限制变量取值范围</strong></h3><pre><code class="c">enum Week day = 99; // ❌ 编译器警告！99不在枚举范围内  </code></pre><hr><h2 id="五、常见错误——小白的「避坑指南」"><a href="#五、常见错误——小白的「避坑指南」" class="headerlink" title="五、常见错误——小白的「避坑指南」"></a><strong>五、常见错误——小白的「避坑指南」</strong></h2><ol><li><p><strong>误以为枚举是字符串</strong>  </p><pre><code class="c">printf(&quot;%s&quot;, Tue); // ❌ 错误！Tue是整数，不是字符串  // 正确：需手动映射  char* weekNames[] = &#123;&quot;Mon&quot;, &quot;Tue&quot;, &quot;Wed&quot;&#125;;  printf(&quot;%s&quot;, weekNames[today]);  </code></pre></li><li><p><strong>遍历不连续枚举</strong>  </p><pre><code class="c">enum Gaps &#123;A=1, B=3, C&#125;; // C=4  for (int i=A; i&lt;=C; i++) &#123;      // i=1,2,3,4 → 但B=3和C=4有效，i=2无效！  &#125;  </code></pre></li><li><p><strong>忘记枚举的整型本质</strong>  </p><pre><code class="c">enum Week day = Wed;  int num = day; // ✅ 合法！枚举值可赋值给整型  day = 5;       // ❌ 如果枚举最大值是3，会越界！  </code></pre></li></ol><hr><h2 id="六、枚举的「伪遍历」技巧"><a href="#六、枚举的「伪遍历」技巧" class="headerlink" title="六、枚举的「伪遍历」技巧"></a><strong>六、枚举的「伪遍历」技巧</strong></h2><p><strong>前提</strong>：枚举值必须连续！  </p><pre><code class="c">enum Week &#123;Mon=1, Tue, Wed, Thu, Fri&#125;;  // 遍历所有枚举值  for (enum Week day = Mon; day &lt;= Fri; day++) &#123;      printf(&quot;Day %d\n&quot;, day);  &#125;  </code></pre><p><strong>输出</strong>：  </p><pre><code>Day 1  Day 2  Day 3  Day 4  Day 5  </code></pre><hr><h2 id="七、综合练习——巩固知识"><a href="#七、综合练习——巩固知识" class="headerlink" title="七、综合练习——巩固知识"></a><strong>七、综合练习——巩固知识</strong></h2><ol><li><p><strong>创建菜单系统</strong>  </p><ul><li>定义枚举：<code>Menu &#123;Start=1, Load, Save, Exit&#125;</code>  </li><li>用户输入数字选择菜单项  </li><li>用switch处理选项</li></ul></li><li><p><strong>处理错误码</strong>  </p><ul><li>定义枚举：<code>enum ErrorCode &#123;Success=0, FileNotFound=-1, Timeout=100&#125;</code>  </li><li>根据函数返回的错误码打印提示信息</li></ul></li></ol><hr><h2 id="💡-总结"><a href="#💡-总结" class="headerlink" title="💡 总结"></a>💡 <strong>总结</strong></h2><p>枚举是让代码「自解释」的利器，通过为数字赋予有意义的名字，让程序更易读、更健壮。记住：  </p><ul><li><strong>优点</strong>：代码清晰、类型安全、易维护  </li><li><strong>缺点</strong>：本质是整数、遍历受限  </li><li><strong>核心规则</strong>：默认从0开始，可手动赋值，避免不连续遍历</li></ul><p>现在，尝试用枚举替换代码中的魔数，让你的程序像故事书一样易懂吧！📖✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言二维数组</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言二维数组深度解析！-😊👇"><a href="#👇😊-C语言二维数组深度解析！-😊👇" class="headerlink" title="👇😊 C语言二维数组深度解析！ 😊👇"></a>👇😊 <strong>C语言二维数组深度解析！</strong> 😊👇</h1><hr><h2 id="🌈-1-二维数组是什么？"><a href="#🌈-1-二维数组是什么？" class="headerlink" title="🌈 1. 二维数组是什么？"></a><strong>🌈 1. 二维数组是什么？</strong></h2><p>现在你的手里一个<strong>数学表格</strong>📊，或者一个<strong>棋盘</strong>♟️，每个格子可以存放一个数据。  </p><ul><li><strong>行（Row）</strong> → 横向排列（比如Excel中的行号）  </li><li><strong>列（Column）</strong> → 纵向排列（比如Excel中的列标）  </li><li><strong>元素</strong> → 每个格子里的数据</li></ul><p><strong>例如</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">学生成绩表（3个学生，2门课）</span><br><span class="line">行 → 学生 | 列 → 科目</span><br><span class="line">+----+----+</span><br><span class="line">| 80 | 90 | → 学生1的成绩</span><br><span class="line">+----+----+</span><br><span class="line">| 70 | 85 | → 学生2的成绩</span><br><span class="line">+----+----+</span><br><span class="line">| 95 | 88 | → 学生3的成绩</span><br><span class="line">+----+----+</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-2-二维数组的声明与初始化"><a href="#🌈-2-二维数组的声明与初始化" class="headerlink" title="🌈 2. 二维数组的声明与初始化"></a><strong>🌈 2. 二维数组的声明与初始化</strong></h2><h3 id="2-1-声明二维数组"><a href="#2-1-声明二维数组" class="headerlink" title="2.1 声明二维数组"></a><strong>2.1 声明二维数组</strong></h3><p>📝 <strong>语法</strong>：<code>数据类型 数组名[行数][列数];</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>];  <span class="comment">// 3行2列的整型数组（3学生×2科目）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化二维数组"><a href="#2-2-初始化二维数组" class="headerlink" title="2.2 初始化二维数组"></a><strong>2.2 初始化二维数组</strong></h3><ul><li><p><strong>逐行初始化</strong>：用大括号分组  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">80</span>, <span class="number">90</span>&#125;, <span class="comment">// 第0行：学生1的语文和数学成绩</span></span><br><span class="line">    &#123;<span class="number">70</span>, <span class="number">85</span>&#125;, <span class="comment">// 第1行：学生2的成绩</span></span><br><span class="line">    &#123;<span class="number">95</span>, <span class="number">88</span>&#125;  <span class="comment">// 第2行：学生3的成绩</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>省略行数</strong>（编译器自动计算行数）：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[][<span class="number">2</span>] = &#123; </span><br><span class="line">    &#123;<span class="number">80</span>, <span class="number">90</span>&#125;,</span><br><span class="line">    &#123;<span class="number">70</span>, <span class="number">85</span>&#125;,</span><br><span class="line">    &#123;<span class="number">95</span>, <span class="number">88</span>&#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>不完整初始化</strong>：剩余元素补0  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>&#125;,       <span class="comment">// 第0行 → [1,0,0]</span></span><br><span class="line">    &#123;<span class="number">2</span>,<span class="number">3</span>&#125;      <span class="comment">// 第1行 → [2,3,0]</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="🌈-3-访问二维数组元素"><a href="#🌈-3-访问二维数组元素" class="headerlink" title="🌈 3. 访问二维数组元素"></a><strong>🌈 3. 访问二维数组元素</strong></h2><ul><li><strong>索引规则</strong>：<code>数组名[行号][列号]</code>  </li><li><strong>索引从0开始</strong>！最大行号 &#x3D; 行数-1，最大列号 &#x3D; 列数-1</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">80</span>,<span class="number">90</span>&#125;, &#123;<span class="number">70</span>,<span class="number">85</span>&#125;, &#123;<span class="number">95</span>,<span class="number">88</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, scores[<span class="number">0</span>][<span class="number">1</span>]); <span class="comment">// 输出第0行第1列 → 90</span></span><br><span class="line">scores[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">100</span>;         <span class="comment">// 修改第2行第0列 → 变成100</span></span><br></pre></td></tr></table></figure><p>💥 <strong>致命错误</strong>：越界访问！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scores[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">60</span>; <span class="comment">// ❌ 行号最大是2（共3行）</span></span><br><span class="line">scores[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">75</span>; <span class="comment">// ❌ 列号最大是1（共2列）</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-内存中的二维数组"><a href="#🌈-4-内存中的二维数组" class="headerlink" title="🌈 4. 内存中的二维数组"></a><strong>🌈 4. 内存中的二维数组</strong></h2><p>二维数组在内存中是<strong>按行连续存储</strong>的！<br>例如 <code>int arr[2][3] = &#123;&#123;1,2,3&#125;, &#123;4,5,6&#125;&#125;</code> 的内存布局：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址低 → 高</span><br><span class="line">1 2 3 4 5 6</span><br></pre></td></tr></table></figure><ul><li>访问 <code>arr[1][1]</code> → 实际是第 <code>1*3 +1 =4</code> 个元素（值5）</li></ul><h3 id="用一维视角理解二维数组"><a href="#用一维视角理解二维数组" class="headerlink" title="用一维视角理解二维数组"></a><strong>用一维视角理解二维数组</strong></h3><p>可以把二维数组看作一个“被折叠”的一维数组：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="type">int</span> arr_flat[<span class="number">6</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-遍历二维数组"><a href="#🌈-5-遍历二维数组" class="headerlink" title="🌈 5. 遍历二维数组"></a><strong>🌈 5. 遍历二维数组</strong></h2><p>用<strong>嵌套循环</strong>：外层循环行，内层循环列  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">3</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">80</span>,<span class="number">90</span>&#125;, &#123;<span class="number">70</span>,<span class="number">85</span>&#125;, &#123;<span class="number">95</span>,<span class="number">88</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;       <span class="comment">// 遍历行</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">2</span>; j++) &#123;   <span class="comment">// 遍历列</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, scores[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>); <span class="comment">// 换行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80 90 </span><br><span class="line">70 85 </span><br><span class="line">95 88 </span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-二维数组与指针"><a href="#🌈-6-二维数组与指针" class="headerlink" title="🌈 6. 二维数组与指针"></a><strong>🌈 6. 二维数组与指针</strong></h2><p>二维数组名是<strong>指向第一个元素（即第0行）的指针</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;, &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;&#125;;</span><br><span class="line"><span class="type">int</span> (*p)[<span class="number">3</span>] = arr; <span class="comment">// p指向第0行（整个一维数组）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问第1行第2列 → 6</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, p[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 等价于 arr[1][2]</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-动态二维数组（进阶）"><a href="#🌈-7-动态二维数组（进阶）" class="headerlink" title="🌈 7. 动态二维数组（进阶）"></a><strong>🌈 7. 动态二维数组（进阶）</strong></h2><p>使用<strong>指针数组</strong> + <strong>malloc</strong> 动态创建二维数组：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">3</span>, cols = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *)); <span class="comment">// 申请行指针</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));   <span class="comment">// 每行申请列空间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 赋值</span></span><br><span class="line">matrix[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存（先释放列，再释放行）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    <span class="built_in">free</span>(matrix[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">free</span>(matrix);</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-8-常见错误"><a href="#🌈-8-常见错误" class="headerlink" title="🌈 8. 常见错误"></a><strong>🌈 8. 常见错误</strong></h2><ol><li><p><strong>行列顺序颠倒</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">5</span>; <span class="comment">// ❌ 行号最大1，列号最大2</span></span><br></pre></td></tr></table></figure></li><li><p><strong>错误初始化</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;; <span class="comment">// ✅ 但可读性差</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;  <span class="comment">// ✅ 补0 → [1,2,0], [3,0,0]</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">2</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;   <span class="comment">// ❌ 第0行元素过多</span></span><br></pre></td></tr></table></figure></li><li><p><strong>动态数组未释放内存</strong> → 内存泄漏！</p></li></ol><hr><h2 id="🌈-9-练习时间！"><a href="#🌈-9-练习时间！" class="headerlink" title="🌈 9. 练习时间！"></a><strong>🌈 9. 练习时间！</strong></h2><h3 id="练习1：求二维数组的总和"><a href="#练习1：求二维数组的总和" class="headerlink" title="练习1：求二维数组的总和"></a><strong>练习1：求二维数组的总和</strong></h3><p>写一个函数 <code>int sumMatrix(int matrix[][3], int rows)</code>，计算3列二维数组所有元素的和。  </p><h3 id="练习2：矩阵转置"><a href="#练习2：矩阵转置" class="headerlink" title="练习2：矩阵转置"></a><strong>练习2：矩阵转置</strong></h3><p>写一个函数 <code>void transpose(int src[][3], int dest[][2], int rows)</code>，将2行3列的矩阵转置为3行2列的矩阵（行列互换）。  </p><h3 id="练习3：动态创建二维数组"><a href="#练习3：动态创建二维数组" class="headerlink" title="练习3：动态创建二维数组"></a><strong>练习3：动态创建二维数组</strong></h3><p>动态创建一个4行5列的整型二维数组，并初始化所有元素为0。  </p><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sumMatrix</span><span class="params">(<span class="type">int</span> matrix[][<span class="number">3</span>], <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            sum += matrix[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">transpose</span><span class="params">(<span class="type">int</span> src[][<span class="number">3</span>], <span class="type">int</span> dest[][<span class="number">2</span>], <span class="type">int</span> rows)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">3</span>; j++) &#123;</span><br><span class="line">            dest[j][i] = src[i][j]; <span class="comment">// 行列互换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rows = <span class="number">4</span>, cols = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> **matrix = (<span class="type">int</span> **)<span class="built_in">malloc</span>(rows * <span class="keyword">sizeof</span>(<span class="type">int</span> *));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;rows; i++) &#123;</span><br><span class="line">    matrix[i] = (<span class="type">int</span> *)<span class="built_in">malloc</span>(cols * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;cols; j++) &#123;</span><br><span class="line">        matrix[i][j] = <span class="number">0</span>; <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>🚀 <strong>总结</strong>：二维数组就是“数组的数组”，想象成表格或棋盘更容易理解！掌握行优先存储、嵌套循环遍历和动态内存管理，其实二维数组也不难！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言数组-😊👇"><a href="#👇😊-C语言数组-😊👇" class="headerlink" title="👇😊 C语言数组 😊👇"></a>👇😊 <strong>C语言数组</strong> 😊👇</h1><hr><h2 id="🌈-1-数组是什么？"><a href="#🌈-1-数组是什么？" class="headerlink" title="🌈 1. 数组是什么？"></a><strong>🌈 1. 数组是什么？</strong></h2><p>想象你有一排<strong>储物柜</strong>🔒，每个柜子编号从0开始，存放同类型物品（比如全是书包）。这就是数组！  </p><ul><li><strong>作用</strong>：一次性管理多个同类数据，避免定义一堆变量！  </li><li><strong>特点</strong>：<strong>连续内存</strong>存储，快速访问任意元素！</li></ul><hr><h2 id="🌈-2-数组的声明与初始化"><a href="#🌈-2-数组的声明与初始化" class="headerlink" title="🌈 2. 数组的声明与初始化"></a><strong>🌈 2. 数组的声明与初始化</strong></h2><h3 id="2-1-声明数组"><a href="#2-1-声明数组" class="headerlink" title="2.1 声明数组"></a><strong>2.1 声明数组</strong></h3><p>📝 <strong>语法</strong>：<code>数据类型 数组名[元素个数];</code>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> scores[<span class="number">5</span>];      <span class="comment">// 声明能存5个整数的数组</span></span><br><span class="line"><span class="type">double</span> prices[<span class="number">10</span>];  <span class="comment">// 声明能存10个双精度数的数组</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> arr[size]; <span class="comment">// ❌ 错误！数组大小必须是常量（C99前）</span></span><br></pre></td></tr></table></figure><h3 id="2-2-初始化数组"><a href="#2-2-初始化数组" class="headerlink" title="2.2 初始化数组"></a><strong>2.2 初始化数组</strong></h3><ul><li><strong>完全初始化</strong>：指定所有元素  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;; <span class="comment">// nums[0]=10, nums[1]=20, nums[2]=30</span></span><br></pre></td></tr></table></figure></li><li><strong>部分初始化</strong>：剩余元素自动补0  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>&#125;; <span class="comment">// arr = [1,2,0,0,0]</span></span><br></pre></td></tr></table></figure></li><li><strong>自动计算大小</strong>：省略元素个数  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> letters[] = &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>&#125;; <span class="comment">// 自动识别长度为3</span></span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>错误示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// ❌ 初始值太多！</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-访问数组元素"><a href="#🌈-3-访问数组元素" class="headerlink" title="🌈 3. 访问数组元素"></a><strong>🌈 3. 访问数组元素</strong></h2><ul><li><strong>索引从0开始</strong>！最后一个元素索引是<code>长度-1</code>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> nums[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, nums[<span class="number">0</span>]); <span class="comment">// 输出10</span></span><br><span class="line">nums[<span class="number">2</span>] = <span class="number">40</span>;          <span class="comment">// 修改第三个元素为40</span></span><br></pre></td></tr></table></figure></li></ul><p>💥 <strong>致命错误</strong>：数组越界！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">arr[<span class="number">5</span>] = <span class="number">10</span>; <span class="comment">// ❌ 有效索引是0-4，越界可能导致程序崩溃！</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-获取数组长度"><a href="#🌈-4-获取数组长度" class="headerlink" title="🌈 4. 获取数组长度"></a><strong>🌈 4. 获取数组长度</strong></h2><p>使用 <code>sizeof</code> 计算总大小除以单个元素大小：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">int</span> length = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><p>🔧 <strong>进阶技巧</strong>：用宏定义简化  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LEN(arr) (sizeof(arr)/sizeof(arr[0]))</span></span><br><span class="line"><span class="type">int</span> len = LEN(arr); <span class="comment">// 直接调用</span></span><br></pre></td></tr></table></figure><p>⚠️ <strong>注意</strong>：<strong>在函数中传递数组时，无法用此法获取长度</strong>（数组退化为指针）！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">printArray</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">    <span class="comment">// sizeof(arr) 这里得到的是指针大小，不是数组大小！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-5-数组名与指针的关系"><a href="#🌈-5-数组名与指针的关系" class="headerlink" title="🌈 5. 数组名与指针的关系"></a><strong>🌈 5. 数组名与指针的关系</strong></h2><ul><li><p><strong>数组名</strong>是首元素地址的<strong>常量指针</strong>（不能修改指向）  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line"><span class="type">int</span> *ptr = arr; <span class="comment">// 等价于 ptr = &amp;arr[0]</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, *ptr); <span class="comment">// 输出10</span></span><br></pre></td></tr></table></figure></li><li><p><strong>用指针遍历数组</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, *(ptr + i)); <span class="comment">// 访问arr[i]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>⚠️ <strong>易混淆点</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span> *p = arr;</span><br><span class="line"><span class="comment">// arr++;  // ❌ 数组名是常量，不能修改！</span></span><br><span class="line">p++;      <span class="comment">// ✅ 指针可以移动</span></span><br></pre></td></tr></table></figure><hr><h2 id="🌈-6-数组作为函数参数"><a href="#🌈-6-数组作为函数参数" class="headerlink" title="🌈 6. 数组作为函数参数"></a><strong>🌈 6. 数组作为函数参数</strong></h2><p>传递数组给函数时，实际传递的是<strong>指针</strong>（首地址），函数内可修改原数组！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">doubleValues</span><span class="params">(<span class="type">int</span> *arr, <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">        arr[i] *= <span class="number">2</span>; <span class="comment">// 修改原数组元素</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> nums[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    doubleValues(nums, <span class="number">3</span>); <span class="comment">// 传递数组名和长度</span></span><br><span class="line">    <span class="comment">// nums变成[2,4,6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-7-多维数组（以二维为例）"><a href="#🌈-7-多维数组（以二维为例）" class="headerlink" title="🌈 7. 多维数组（以二维为例）"></a><strong>🌈 7. 多维数组（以二维为例）</strong></h2><h3 id="7-1-声明与初始化"><a href="#7-1-声明与初始化" class="headerlink" title="7.1 声明与初始化"></a><strong>7.1 声明与初始化</strong></h3><p>二维数组类似表格📊，有行和列：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> matrix[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,  <span class="comment">// 第0行</span></span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;   <span class="comment">// 第1行</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="7-2-访问元素"><a href="#7-2-访问元素" class="headerlink" title="7.2 访问元素"></a><strong>7.2 访问元素</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, matrix[<span class="number">1</span>][<span class="number">2</span>]); <span class="comment">// 输出6（第1行第2列）</span></span><br></pre></td></tr></table></figure><h2 id="后续的话会单独用一篇文章来讲解二维数组！！！😏"><a href="#后续的话会单独用一篇文章来讲解二维数组！！！😏" class="headerlink" title="后续的话会单独用一篇文章来讲解二维数组！！！😏"></a><strong>后续的话会单独用一篇文章来讲解二维数组！！！😏</strong></h2><h2 id="🌈-8-静态数组-vs-动态数组"><a href="#🌈-8-静态数组-vs-动态数组" class="headerlink" title="🌈 8. 静态数组 vs 动态数组"></a><strong>🌈 8. 静态数组 vs 动态数组</strong></h2><table><thead><tr><th>类型</th><th>特点</th><th>示例</th></tr></thead><tbody><tr><td><strong>静态数组</strong></td><td>编译时确定大小，内存自动分配&#x2F;释放</td><td><code>int arr[10];</code></td></tr><tr><td><strong>动态数组</strong></td><td>运行时手动分配（<code>malloc</code>），需手动释放</td><td><code>int *arr = malloc(n * sizeof(int));</code></td></tr></tbody></table><p>🌰 <strong>动态数组示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *arr = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * <span class="keyword">sizeof</span>(<span class="type">int</span>)); <span class="comment">// 申请内存</span></span><br><span class="line"><span class="keyword">if</span>(arr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">        arr[i] = i+<span class="number">1</span>; <span class="comment">// 初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(arr); <span class="comment">// 释放内存！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="❌-9-常见错误集锦"><a href="#❌-9-常见错误集锦" class="headerlink" title="❌ 9. 常见错误集锦"></a><strong>❌ 9. 常见错误集锦</strong></h2><ol><li><strong>越界访问</strong>：索引超出范围 → 程序崩溃  </li><li><strong>未初始化就使用</strong>：局部数组元素是随机值  </li><li><strong>在函数中用sizeof求长度</strong>：得到指针大小而非数组长度  </li><li><strong>修改数组名</strong>：数组名是常量指针，不能<code>arr++</code></li></ol><hr><h2 id="🌈-10-综合练习"><a href="#🌈-10-综合练习" class="headerlink" title="🌈 10. 综合练习"></a><strong>🌈 10. 综合练习</strong></h2><h3 id="练习1：求数组最大值"><a href="#练习1：求数组最大值" class="headerlink" title="练习1：求数组最大值"></a><strong>练习1：求数组最大值</strong></h3><p>写一个函数 <code>int findMax(int arr[], int len)</code>，返回数组中的最大值。  </p><h3 id="练习2：反转数组"><a href="#练习2：反转数组" class="headerlink" title="练习2：反转数组"></a><strong>练习2：反转数组</strong></h3><p>写一个函数 <code>void reverse(int arr[], int len)</code>，将数组元素原地反转。  </p><h3 id="练习3：错误修复"><a href="#练习3：错误修复" class="headerlink" title="练习3：错误修复"></a><strong>练习3：错误修复</strong></h3><p>以下代码有什么问题？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[<span class="number">3</span>]); <span class="comment">// 输出第4个元素？</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h2><h3 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="type">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[i] &gt; max) max = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> len)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len/<span class="number">2</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> temp = arr[i];</span><br><span class="line">        arr[i] = arr[len<span class="number">-1</span>-i];</span><br><span class="line">        arr[len<span class="number">-1</span>-i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h3><p><strong>错误</strong>：<code>arr[3]</code> 越界访问（有效索引为0-2）<br><strong>修正</strong>：<code>printf(&quot;%d&quot;, arr[2]);</code>  </p><hr><p>🚀 <strong>总结</strong>：数组是C语言的“数据集装箱”，掌握索引、内存布局和指针操作是关键！多练习，多调试，轻松玩转数组！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言作用域规则</title>
      <link href="/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/"/>
      <url>/2025/02/03/C%E8%AF%AD%E8%A8%80%E4%BD%9C%E7%94%A8%E5%9F%9F%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h1 id="👇😊-C语言作用域规则-😊👇"><a href="#👇😊-C语言作用域规则-😊👇" class="headerlink" title="👇😊 C语言作用域规则 😊👇"></a>👇😊 <strong>C语言作用域规则</strong> 😊👇</h1><hr><h2 id="🌈-1-作用域是什么？"><a href="#🌈-1-作用域是什么？" class="headerlink" title="🌈 1. 作用域是什么？"></a><strong>🌈 1. 作用域是什么？</strong></h2><p>想象你家的房间🏠：  </p><ul><li><strong>客厅的零食</strong>🍿 → 全家人都能拿（<strong>全局变量</strong>）  </li><li><strong>你抽屉里的日记</strong>📔 → 只有你能看到（<strong>局部变量</strong>）<br><strong>作用域</strong>就是变量的“可见范围”——出了这个区域，变量就“隐身”了！👻</li></ul><hr><h2 id="🌈-2-变量的三种身份"><a href="#🌈-2-变量的三种身份" class="headerlink" title="🌈 2. 变量的三种身份"></a><strong>🌈 2. 变量的三种身份</strong></h2><h3 id="2-1-局部变量（Local-Variables）"><a href="#2-1-局部变量（Local-Variables）" class="headerlink" title="2.1 局部变量（Local Variables）"></a><strong>2.1 局部变量（Local Variables）</strong></h3><ul><li><strong>位置</strong>：在<strong>函数或代码块内部</strong>定义  </li><li><strong>寿命</strong>：函数被调用时“出生”，函数结束“死亡”💀  </li><li><strong>特点</strong>：只能在所属函数&#x2F;代码块内使用</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">myFunction</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> localVar = <span class="number">5</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inside function: %d\n&quot;</span>, localVar); <span class="comment">// 正常输出5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    myFunction();</span><br><span class="line">    <span class="comment">// printf(&quot;%d&quot;, localVar); ❌ 错误！localVar在这里不可见</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❌ <strong>常见错误</strong>：在代码块外使用局部变量  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x的作用域只在if块内</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); ❌ 错误！x已经“死了”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-2-全局变量（Global-Variables）"><a href="#2-2-全局变量（Global-Variables）" class="headerlink" title="2.2 全局变量（Global Variables）"></a><strong>2.2 全局变量（Global Variables）</strong></h3><ul><li><strong>位置</strong>：在<strong>所有函数外部</strong>定义  </li><li><strong>寿命</strong>：程序启动时“出生”，程序结束时“死亡”⚰️  </li><li><strong>特点</strong>：所有函数都能访问和修改它！</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    globalVar += <span class="number">10</span>; <span class="comment">// 修改全局变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;GlobalVar: %d\n&quot;</span>, globalVar); <span class="comment">// 输出110（如果func1被调用过）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    func1();</span><br><span class="line">    func2(); <span class="comment">// 输出110</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>⚠️ <strong>危险操作</strong>：局部变量同名覆盖全局变量  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">50</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num); <span class="comment">// 输出20，全局变量被“屏蔽”！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-3-形式参数（Formal-Parameters）"><a href="#2-3-形式参数（Formal-Parameters）" class="headerlink" title="2.3 形式参数（Formal Parameters）"></a><strong>2.3 形式参数（Formal Parameters）</strong></h3><ul><li><strong>位置</strong>：函数定义的参数列表  </li><li><strong>寿命</strong>：函数被调用时“出生”，函数结束“死亡”💀  </li><li><strong>特点</strong>：本质是函数的<strong>局部变量</strong>，优先于全局变量</li></ul><p>🌰 <strong>例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">99</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span> a)</span> &#123; <span class="comment">// 形式参数a是局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;参数a: %d\n&quot;</span>, a); <span class="comment">// 输出5，优先使用局部变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    check(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-3-变量初始化陷阱"><a href="#🌈-3-变量初始化陷阱" class="headerlink" title="🌈 3. 变量初始化陷阱"></a><strong>🌈 3. 变量初始化陷阱</strong></h2><table><thead><tr><th>变量类型</th><th>默认初始值</th><th>必须手动初始化？</th></tr></thead><tbody><tr><td><strong>全局变量</strong></td><td>0（int）、0.0（float）等</td><td>否 ✅</td></tr><tr><td><strong>局部变量</strong></td><td>随机值（垃圾值）🗑️</td><td>是 ❗</td></tr></tbody></table><p>🌰 <strong>例子</strong>：未初始化的局部变量导致问题  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 未初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// 输出随机值，可能是-32421、0等！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>❌ <strong>危险代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">// sum未初始化，结果不可预测！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, sum); <span class="comment">// 可能是奇怪的数值！</span></span><br></pre></td></tr></table></figure><p>✅ <strong>正确做法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>; <span class="comment">// 初始化！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    sum += i; <span class="comment">// 正确累加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🌈-4-内存中的变量存储"><a href="#🌈-4-内存中的变量存储" class="headerlink" title="🌈 4. 内存中的变量存储"></a><strong>🌈 4. 内存中的变量存储</strong></h2><table><thead><tr><th>变量类型</th><th>存储位置</th><th>特点</th></tr></thead><tbody><tr><td><strong>全局变量</strong></td><td>全局&#x2F;静态存储区</td><td>程序整个生命周期存在</td></tr><tr><td><strong>局部变量</strong></td><td>栈区（Stack）</td><td>函数结束时自动释放</td></tr></tbody></table><p>🌰 <strong>比喻</strong>：  </p><ul><li><strong>全局变量</strong> → 公共储物柜🗄️，随时存取  </li><li><strong>局部变量</strong> → 临时寄存柜📦，用后清空</li></ul><hr><h2 id="🌈-5-综合练习：测测你掌握了吗？"><a href="#🌈-5-综合练习：测测你掌握了吗？" class="headerlink" title="🌈 5. 综合练习：测测你掌握了吗？"></a><strong>🌈 5. 综合练习：测测你掌握了吗？</strong></h2><h3 id="练习1：猜输出"><a href="#练习1：猜输出" class="headerlink" title="练习1：猜输出"></a><strong>练习1：猜输出</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：20 10  </p><hr><h3 id="练习2：找错误"><a href="#练习2：找错误" class="headerlink" title="练习2：找错误"></a><strong>练习2：找错误</strong></h3><p>以下代码有什么问题？如何修正？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">printSum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    printSum();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 这里有问题！</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误原因</strong>：<code>a</code>是<code>printSum</code>的局部变量，不能在<code>main</code>中使用<br><strong>修正</strong>：删除<code>printf(&quot;%d&quot;, a);</code>  </p><hr><h3 id="练习3：写代码"><a href="#练习3：写代码" class="headerlink" title="练习3：写代码"></a><strong>练习3：写代码</strong></h3><p>写一个函数<code>void updateGlobal()</code>，将全局变量<code>count</code>（初始为0）每次调用加1，并在<code>main</code>中调用3次后输出结果。  </p><p><strong>参考答案</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">updateGlobal</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    updateGlobal();</span><br><span class="line">    updateGlobal();</span><br><span class="line">    updateGlobal();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count: %d&quot;</span>, count); <span class="comment">// 输出3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h2><ul><li><strong>局部变量</strong>：函数内部的小秘密，用完即焚 🔥  </li><li><strong>全局变量</strong>：全程序的公共财产，谨慎使用 ⚠️  </li><li><strong>形式参数</strong>：函数的“临时工”，优先级最高 🥇  </li><li><strong>初始化</strong>：局部变量必须手动初始化，否则后果自负！</li></ul><p><strong>记住</strong>：作用域是变量的“活动范围”，超出范围就会“消失”！多写代码多调试，变量作用域不再迷路！ 🧭💻</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言函数</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>👇😊 <strong>C语言函数超超详细讲解！新手保姆级教程！</strong> 😊👇</p><hr><h3 id="🌈-0-为什么要学函数？"><a href="#🌈-0-为什么要学函数？" class="headerlink" title="🌈 0. 为什么要学函数？"></a><strong>🌈 0. 为什么要学函数？</strong></h3><p>想象你要盖一座房子🏠：</p><ul><li>如果所有砖头、水泥、电线都堆在一起，你会疯掉！</li><li><strong>函数</strong>就像提前做好的“预制件”：窗户、门、楼梯… 随用随拿，<strong>代码复用</strong>！</li></ul><p><strong>举个栗子🌰</strong>：<br>你需要<strong>10次</strong>计算两个数的最大值，如果不用函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第1次计算</span></span><br><span class="line"><span class="keyword">if</span>(a &gt; b) max = a; <span class="keyword">else</span> max = b; </span><br><span class="line"><span class="comment">// 第2次计算</span></span><br><span class="line"><span class="keyword">if</span>(c &gt; d) max = c; <span class="keyword">else</span> max = d; </span><br><span class="line"><span class="comment">// ...重复10次！😫</span></span><br></pre></td></tr></table></figure><p>用函数后：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123; <span class="keyword">return</span> (x &gt; y) ? x : y; &#125; <span class="comment">// 定义一次</span></span><br><span class="line"><span class="comment">// 调用10次！</span></span><br><span class="line">max(a, b); </span><br><span class="line">max(c, d); </span><br><span class="line"><span class="comment">// ...清爽！✨</span></span><br></pre></td></tr></table></figure><hr><h3 id="🌈-1-解剖函数：从“头”到“脚”"><a href="#🌈-1-解剖函数：从“头”到“脚”" class="headerlink" title="🌈 1. 解剖函数：从“头”到“脚”"></a><strong>🌈 1. 解剖函数：从“头”到“脚”</strong></h3><h4 id="1-1-函数头（Function-Header）"><a href="#1-1-函数头（Function-Header）" class="headerlink" title="1.1 函数头（Function Header）"></a><strong>1.1 函数头（Function Header）</strong></h4><p>就像人的“身份证”🆔，告诉编译器：“我是谁，我能做什么”<br>📝 <strong>格式</strong>：<code>返回类型 函数名(参数类型1 参数1, 参数类型2 参数2...)</code><br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回int | 函数名max | 参数int a, int b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span><br></pre></td></tr></table></figure><h4 id="1-2-函数体（Function-Body）"><a href="#1-2-函数体（Function-Body）" class="headerlink" title="1.2 函数体（Function Body）"></a><strong>1.2 函数体（Function Body）</strong></h4><p>大括号 <code>&#123;&#125;</code> 里的代码是函数的“内脏”🧠，负责具体干活！<br><strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="type">int</span> result;</span><br><span class="line">   result = (a &gt; b) ? a : b; <span class="comment">// 三目运算符简化</span></span><br><span class="line">   <span class="keyword">return</span> result; <span class="comment">// 必须返回与声明类型一致的值！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-重要细节："><a href="#1-3-重要细节：" class="headerlink" title="1.3 重要细节："></a><strong>1.3 重要细节</strong>：</h4><ul><li><strong>返回值</strong>：如果函数声明为 <code>void</code>（无返回值），<strong>不能</strong>写 <code>return 值;</code>！</li><li><strong>参数列表</strong>：可以是0个或多个参数，用逗号分隔，每个参数必须指明类型！</li></ul><hr><h3 id="🌈-2-函数声明-vs-函数定义：别搞混！"><a href="#🌈-2-函数声明-vs-函数定义：别搞混！" class="headerlink" title="🌈 2. 函数声明 vs 函数定义：别搞混！"></a><strong>🌈 2. 函数声明 vs 函数定义：别搞混！</strong></h3><table><thead><tr><th></th><th><strong>函数声明</strong></th><th><strong>函数定义</strong></th></tr></thead><tbody><tr><td><strong>作用</strong></td><td>告诉编译器“这个函数存在”👋</td><td>告诉编译器“这个函数具体怎么做”💪</td></tr><tr><td><strong>位置</strong></td><td>通常在头文件<code>.h</code>或代码开头</td><td>在源文件<code>.c</code>中</td></tr><tr><td><strong>格式</strong></td><td><code>int max(int, int);</code> （分号结尾）</td><td><code>int max(int a, int b) &#123; ... &#125;</code></td></tr></tbody></table><h4 id="❌-致命错误示例："><a href="#❌-致命错误示例：" class="headerlink" title="❌ 致命错误示例："></a><strong>❌ 致命错误示例</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误1：声明和定义参数类型不一致！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">float</span> a, <span class="type">float</span> b)</span>; <span class="comment">// 声明</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">max</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; ... &#125; <span class="comment">// 定义 → 编译错误！🚨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误2：忘记声明函数，直接调用！</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = max(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 编译器：max是谁？我不认识！→ 报错！😱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-3-参数传递：值传递-vs-指针传递（超重要！）"><a href="#🌈-3-参数传递：值传递-vs-指针传递（超重要！）" class="headerlink" title="🌈 3. 参数传递：值传递 vs 指针传递（超重要！）"></a><strong>🌈 3. 参数传递：值传递 vs 指针传递（超重要！）</strong></h3><h4 id="3-1-值传递（默认）"><a href="#3-1-值传递（默认）" class="headerlink" title="3.1 值传递（默认）"></a><strong>3.1 值传递（默认）</strong></h4><ul><li><strong>原理</strong>：把变量的值复制一份给函数，<strong>原变量不受影响</strong><br>🌰 <strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    x = <span class="number">100</span>; <span class="comment">// 修改的是副本</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    change(a); <span class="comment">// 把5复制给x</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出5，a没变！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-2-指针传递（引用传递）"><a href="#3-2-指针传递（引用传递）" class="headerlink" title="3.2 指针传递（引用传递）"></a><strong>3.2 指针传递（引用传递）</strong></h4><ul><li><strong>原理</strong>：传递变量的地址，函数内可直接修改原变量<br>🌰 <strong>例子</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> *x)</span> &#123; <span class="comment">// 参数是指针</span></span><br><span class="line">    *x = <span class="number">100</span>; <span class="comment">// 通过地址修改原值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    change(&amp;a); <span class="comment">// 传递a的地址</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a); <span class="comment">// 输出100！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="❌-常见错误："><a href="#❌-常见错误：" class="headerlink" title="❌ 常见错误："></a><strong>❌ 常见错误</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误：试图在值传递中修改原变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = temp; <span class="comment">// 交换的是副本，原变量不变！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x=<span class="number">1</span>, y=<span class="number">2</span>;</span><br><span class="line">    swap(x, y); <span class="comment">// 调用后x还是1，y还是2！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>正确做法</strong>：用指针传递！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> *a, <span class="type">int</span> *b)</span> &#123;</span><br><span class="line">    <span class="type">int</span> temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp; <span class="comment">// 成功交换！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-4-作用域：变量能活多久？"><a href="#🌈-4-作用域：变量能活多久？" class="headerlink" title="🌈 4. 作用域：变量能活多久？"></a><strong>🌈 4. 作用域：变量能活多久？</strong></h3><ul><li><p><strong>局部变量</strong>：函数内部定义的变量，<strong>只能在函数内使用</strong>，函数结束就“死亡”💀<br>🌰 <strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">10</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// 报错！local不存在！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>全局变量</strong>：在函数外定义的变量，<strong>所有函数都可以访问</strong><br>🌰 <strong>例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> global = <span class="number">20</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// 输出20</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    global = <span class="number">30</span>; <span class="comment">// 修改全局变量</span></span><br><span class="line">    func(); <span class="comment">// 输出30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="❌-危险操作：局部变量同名覆盖全局变量！"><a href="#❌-危险操作：局部变量同名覆盖全局变量！" class="headerlink" title="❌ 危险操作：局部变量同名覆盖全局变量！"></a><strong>❌ 危险操作</strong>：局部变量同名覆盖全局变量！</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">100</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">50</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, num); <span class="comment">// 输出50，全局变量被“遮盖”！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🌈-5-综合练习：动手巩固知识！"><a href="#🌈-5-综合练习：动手巩固知识！" class="headerlink" title="🌈 5. 综合练习：动手巩固知识！"></a><strong>🌈 5. 综合练习：动手巩固知识！</strong></h3><h4 id="练习1：温度转换函数"><a href="#练习1：温度转换函数" class="headerlink" title="练习1：温度转换函数"></a><strong>练习1：温度转换函数</strong></h4><p>写一个函数 <code>float celsiusToFahrenheit(float celsius)</code>，将摄氏温度转换为华氏温度（公式：<code>华氏度 = 摄氏度 × 9/5 + 32</code>）</p><h4 id="练习2：数组求和"><a href="#练习2：数组求和" class="headerlink" title="练习2：数组求和"></a><strong>练习2：数组求和</strong></h4><p>写一个函数 <code>int arraySum(int arr[], int size)</code>，计算整型数组的和</p><h4 id="练习3：错误找茬"><a href="#练习3：错误找茬" class="headerlink" title="练习3：错误找茬"></a><strong>练习3：错误找茬</strong></h4><p>找出以下代码中的错误并修正：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> result = add(a, b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %d&quot;</span>, result);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🎯-参考答案"><a href="#🎯-参考答案" class="headerlink" title="🎯 参考答案"></a><strong>🎯 参考答案</strong></h3><h4 id="练习1："><a href="#练习1：" class="headerlink" title="练习1："></a><strong>练习1</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> <span class="title function_">celsiusToFahrenheit</span><span class="params">(<span class="type">float</span> celsius)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> celsius * <span class="number">9.0</span> / <span class="number">5.0</span> + <span class="number">32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习2："><a href="#练习2：" class="headerlink" title="练习2："></a><strong>练习2</strong>：</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">arraySum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> size)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">        sum += arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="练习3："><a href="#练习3：" class="headerlink" title="练习3："></a><strong>练习3</strong>：</h4><p><strong>错误</strong>：在 <code>main</code> 函数中调用了未声明的 <code>add</code> 函数<br><strong>修正</strong>：在 <code>main</code> 前添加函数声明  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>; <span class="comment">// 添加声明</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// ...原代码不变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="🚀-总结"><a href="#🚀-总结" class="headerlink" title="🚀 总结"></a><strong>🚀 总结</strong></h3><ul><li>函数是代码复用的核心，避免重复造轮子！</li><li><strong>声明</strong>是预告片，<strong>定义</strong>是正片，两者参数类型必须一致！</li><li><strong>值传递</strong>复制值，<strong>指针传递</strong>操作原变量！</li><li>变量作用域决定了它的“生命周期”⏳</li></ul><p>遇到问题就多写代码，<strong>调试是学习编程的最佳途径</strong>！💻✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言循环</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="🔄-C语言循环——编程中的「重复劳动小助手」"><a href="#🔄-C语言循环——编程中的「重复劳动小助手」" class="headerlink" title="🔄 C语言循环——编程中的「重复劳动小助手」"></a>🔄 <strong>C语言循环——编程中的「重复劳动小助手」</strong></h1><p>循环就像洗碗机👩🍳，自动重复执行任务直到完成！下面用最有趣的方式拆解循环结构！</p><hr><h2 id="一、循环类型——三种「洗碗模式」"><a href="#一、循环类型——三种「洗碗模式」" class="headerlink" title="一、循环类型——三种「洗碗模式」"></a>一、<strong>循环类型——三种「洗碗模式」</strong></h2><h4 id="1-while循环——先检查再洗碗"><a href="#1-while循环——先检查再洗碗" class="headerlink" title="1. while循环——先检查再洗碗"></a>1. <strong>while循环——先检查再洗碗</strong></h4><p><strong>特点</strong>：先看碗脏不脏，再决定洗不洗<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时重复执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 脏碗数量 = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">while</span>(脏碗数量 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;洗了1个碗🍽️\n&quot;</span>);</span><br><span class="line">    脏碗数量--; <span class="comment">// 别忘更新条件，否则无限循环！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-for循环——精确定时洗碗"><a href="#2-for循环——精确定时洗碗" class="headerlink" title="2. for循环——精确定时洗碗"></a>2. <strong>for循环——精确定时洗碗</strong></h3><p><strong>特点</strong>：明确知道要洗多少次<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次洗碗\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：</span></span><br><span class="line"><span class="comment">第1次洗碗</span></span><br><span class="line"><span class="comment">...</span></span><br><span class="line"><span class="comment">第5次洗碗 */</span></span><br></pre></td></tr></table></figure><p><strong>for循环三要素</strong>：  </p><ul><li><strong>初始化</strong>：设置起点（<code>i=1</code>）  </li><li><strong>条件</strong>：循环继续的条件（<code>i&lt;=5</code>）  </li><li><strong>更新</strong>：每次循环后的操作（<code>i++</code>）</li></ul><hr><h3 id="3-do…while循环——先洗一次再检查"><a href="#3-do…while循环——先洗一次再检查" class="headerlink" title="3. do…while循环——先洗一次再检查"></a>3. <strong>do…while循环——先洗一次再检查</strong></h3><p><strong>特点</strong>：至少执行一次，适合先行动再判断<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 先执行代码</span></span><br><span class="line">&#125; <span class="keyword">while</span>(条件);</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 水杯状态;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;冲洗水杯🚰\n&quot;</span>);</span><br><span class="line">    水杯状态 = 检查是否干净(); </span><br><span class="line">&#125; <span class="keyword">while</span>(水杯状态 == 脏);</span><br></pre></td></tr></table></figure><hr><h2 id="二、循环控制——「紧急按钮」和「跳过键」"><a href="#二、循环控制——「紧急按钮」和「跳过键」" class="headerlink" title="二、循环控制——「紧急按钮」和「跳过键」"></a>二、<strong>循环控制——「紧急按钮」和「跳过键」</strong></h2><table><thead><tr><th>控制语句</th><th>作用</th><th>生活类比</th></tr></thead><tbody><tr><td><code>break</code></td><td>立刻终止整个循环</td><td>洗碗中途停电⚡，直接停止</td></tr><tr><td><code>continue</code></td><td>跳过本次循环，继续下次</td><td>跳过破损的碗，洗下一个</td></tr><tr><td><code>goto</code></td><td>跳转到指定标签（慎用❗）</td><td>突然跑去擦桌子，打乱流程🗑️</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过第3次</span></span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">8</span>) <span class="keyword">break</span>;    <span class="comment">// 到第8次停止</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;第%d次洗碗\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 输出：1 2 4 5 6 7 */</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、无限循环——永不停止的洗碗机"><a href="#三、无限循环——永不停止的洗碗机" class="headerlink" title="三、无限循环——永不停止的洗碗机"></a>三、<strong>无限循环——永不停止的洗碗机</strong></h2><p><strong>应用场景</strong>：服务器监听请求、游戏主循环<br><strong>创建方式</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方式1：for循环留空条件</span></span><br><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;一直洗...🌀\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式2：while(1)</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;根本停不下来！\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>必须包含能退出循环的<code>break</code>条件，否则程序卡死！  </li><li>按<code>Ctrl+C</code>强制终止程序</li></ul><hr><h2 id="四、嵌套循环——洗碗-擦碗组合"><a href="#四、嵌套循环——洗碗-擦碗组合" class="headerlink" title="四、嵌套循环——洗碗+擦碗组合"></a>四、<strong>嵌套循环——洗碗+擦碗组合</strong></h2><p><strong>作用</strong>：循环内包含另一个循环（像俄罗斯套娃）  </p><p><strong>示例</strong>：洗3个碗，每个碗擦2遍  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> 碗=<span class="number">1</span>; 碗&lt;=<span class="number">3</span>; 碗++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开始洗第%d个碗\n&quot;</span>, 碗);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> 擦=<span class="number">1</span>; 擦&lt;=<span class="number">2</span>; 擦++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  第%d次擦拭\n&quot;</span>, 擦);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>忘记更新循环变量</strong> → 无限循环！  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt;= <span class="number">5</span>) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;卡在这里了！&quot;</span>);</span><br><span class="line">    <span class="comment">// 漏写i++ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>误用<code>=</code>代替<code>==</code></strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(x = <span class="number">1</span>) &#123; <span class="comment">// ❌ 总是真！应写x==1</span></span><br><span class="line">    <span class="comment">// 无限执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>do…while忘记分号</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123; ... &#125; <span class="keyword">while</span>(条件) <span class="comment">// ❌ 漏写分号！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><ol><li><strong>打印九九乘法表</strong>（使用嵌套for循环）  </li><li><strong>用户输入验证</strong>：直到输入正确数字才退出循环（do…while）</li></ol><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>循环三兄弟，各有各脾气。<br>while先查再执行，for精确控制行。<br>do…while至少走一次，控制语句要分清。<br>break彻底停，continue跳不停。<br>无限循环谨慎用，嵌套组合更聪明！  </p></blockquote><p>掌握这些循环技巧，让你的代码像智能家电一样高效运转！🤖✨</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言判断</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%88%A4%E6%96%AD/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="🚦-C语言判断结构——程序中的「红绿灯」"><a href="#🚦-C语言判断结构——程序中的「红绿灯」" class="headerlink" title="🚦 C语言判断结构——程序中的「红绿灯」"></a>🚦 <strong>C语言判断结构——程序中的「红绿灯」</strong></h1><p>判断结构让程序像交通信号灯一样，根据不同条件决定执行哪段代码。就像“红灯停🚦，绿灯行🚗”，程序也需要根据条件做出选择！</p><hr><h2 id="一、if-语句——单条件检查"><a href="#一、if-语句——单条件检查" class="headerlink" title="一、if 语句——单条件检查"></a>一、<strong>if 语句——单条件检查</strong></h2><p><strong>作用</strong>：如果条件成立，就执行代码块<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真时执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 下雨 = <span class="number">1</span>; <span class="comment">// 1表示下雨</span></span><br><span class="line"><span class="keyword">if</span>(下雨) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;带伞☔&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="二、if-else-语句——二选一"><a href="#二、if-else-语句——二选一" class="headerlink" title="二、if-else 语句——二选一"></a>二、<strong>if-else 语句——二选一</strong></h2><p><strong>作用</strong>：条件成立执行A，否则执行B<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件) &#123;</span><br><span class="line">    <span class="comment">// 条件为真执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 条件为假执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 温度 = <span class="number">28</span>;</span><br><span class="line"><span class="keyword">if</span>(温度 &gt; <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调❄️&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;吹风扇💨&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、嵌套-if——多层条件筛选"><a href="#三、嵌套-if——多层条件筛选" class="headerlink" title="三、嵌套 if——多层条件筛选"></a>三、<strong>嵌套 if——多层条件筛选</strong></h2><p><strong>作用</strong>：在条件内部再判断（像闯关游戏🎮）<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(条件<span class="number">2</span>) &#123; </span><br><span class="line">        <span class="comment">// 条件1和2都满足</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 年龄 = <span class="number">18</span>;</span><br><span class="line"><span class="type">int</span> 身高 = <span class="number">175</span>;</span><br><span class="line"><span class="keyword">if</span>(年龄 &gt;= <span class="number">18</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(身高 &gt;= <span class="number">170</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;可以玩过山车🎢&quot;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、switch-语句——多选一开关"><a href="#四、switch-语句——多选一开关" class="headerlink" title="四、switch 语句——多选一开关"></a>四、<strong>switch 语句——多选一开关</strong></h2><p><strong>作用</strong>：根据变量值选择不同分支<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(变量) &#123;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>: 代码; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>: 代码; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: 默认代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 菜单选项 = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">switch</span>(菜单选项) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>: <span class="built_in">printf</span>(<span class="string">&quot;汉堡🍔&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>: <span class="built_in">printf</span>(<span class="string">&quot;披萨🍕&quot;</span>); <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="built_in">printf</span>(<span class="string">&quot;暂无选项&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>每个<code>case</code>后要加<code>break</code>，否则会继续执行下一个case（称为“穿透”）  </li><li><code>default</code>是可选的，处理未匹配的情况</li></ul><hr><h2 id="五、三元运算符-——快捷判断"><a href="#五、三元运算符-——快捷判断" class="headerlink" title="五、三元运算符 ? : ——快捷判断"></a>五、<strong>三元运算符 ? : ——快捷判断</strong></h2><p><strong>作用</strong>：简化if-else，适合简单赋值<br><strong>语法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量 = (条件) ? 值<span class="number">1</span> : 值<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p><strong>生活例子</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 分数 = <span class="number">75</span>;</span><br><span class="line"><span class="type">char</span> 结果 = (分数 &gt;= <span class="number">60</span>) ? <span class="string">&#x27;✅&#x27;</span> : <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, 结果); <span class="comment">// 输出✅</span></span><br></pre></td></tr></table></figure><p><strong>等价于</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(分数 &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    结果 = <span class="string">&#x27;✅&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    结果 = <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>忘记大括号</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;B&quot;</span>); <span class="comment">// 无论条件如何，B都会执行！</span></span><br><span class="line"><span class="comment">// 正确写法：加&#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>switch穿透问题</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">    <span class="comment">// 漏写break → 会继续执行case2的代码！</span></span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: ...</span><br></pre></td></tr></table></figure></li><li><p><strong>浮点数判断</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0.3</span>) &#123; ... &#125; <span class="comment">// ❌ 可能不成立！应改为范围判断</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><ol><li><p><strong>成绩等级判断</strong>：<br>输入分数，输出等级（A:90+, B:80-89, C:60-79, D:&lt;60）<br><strong>提示</strong>：使用<code>if-else if</code>或<code>switch</code></p></li><li><p><strong>计算折扣</strong>：<br>根据会员等级（1-3级）计算商品折扣（9折、8折、7折）<br><strong>提示</strong>：使用<code>switch</code></p></li></ol><hr><h3 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h3><blockquote><p>判断结构像路口，条件成立向左走。<br>if单闯else双，嵌套多层像迷宫。<br>switch多选break防穿透，三元运算简写牛。<br>非零为真零为假，逻辑清晰bug少！  </p></blockquote><p>掌握了这些判断结构，你的程序就能像智能导航一样灵活决策啦！🗺️🔀</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言运算符</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="🧮-C运算符大全——编程世界的「数学工具包」"><a href="#🧮-C运算符大全——编程世界的「数学工具包」" class="headerlink" title="🧮 C运算符大全——编程世界的「数学工具包」"></a>🧮 <strong>C运算符大全——编程世界的「数学工具包」</strong></h1><p>运算符就像程序员手中的魔法棒✨，能进行各种计算和判断。下面用最有趣的方式拆解所有运算符！</p><hr><h2 id="一、算术运算符——基础计算器-🧮"><a href="#一、算术运算符——基础计算器-🧮" class="headerlink" title="一、算术运算符——基础计算器 🧮"></a>一、<strong>算术运算符——基础计算器</strong> 🧮</h2><p><strong>作用</strong>：处理数字的加减乘除  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>+</code></td><td>加法</td><td><code>3 + 5 → 8</code></td><td>苹果🍎 + 香蕉🍌 &#x3D; 总水果数</td></tr><tr><td><code>-</code></td><td>减法</td><td><code>10 - 4 → 6</code></td><td>钱包💰减掉支出 &#x3D; 剩余金额</td></tr><tr><td><code>*</code></td><td>乘法</td><td><code>2 * 3 → 6</code></td><td>每人2块🍕，3人共需6块</td></tr><tr><td><code>/</code></td><td>除法</td><td><code>10 / 3 → 3</code></td><td>10块糖分3人，每人3块（整数除）</td></tr><tr><td><code>%</code></td><td>取余</td><td><code>10 % 3 → 1</code></td><td>10块糖分3人，剩下1块🍬</td></tr><tr><td><code>++</code></td><td>自增1</td><td><code>a++</code> vs <code>++a</code></td><td>先吃蛋糕🎂 vs 先加奶油再吃</td></tr><tr><td><code>--</code></td><td>自减1</td><td><code>b--</code> vs <code>--b</code></td><td>先喝奶茶🧋 vs 先减糖再喝</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 苹果 = <span class="number">5</span>;</span><br><span class="line">苹果++; <span class="comment">// 苹果变成6（相当于 苹果 = 苹果 + 1）</span></span><br><span class="line"><span class="type">int</span> 奶茶 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> 余量 = 奶茶--; <span class="comment">// 余量=10，奶茶变成9</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、关系运算符——比大小专家-⚖️"><a href="#二、关系运算符——比大小专家-⚖️" class="headerlink" title="二、关系运算符——比大小专家 ⚖️"></a>二、<strong>关系运算符——比大小专家</strong> ⚖️</h2><p><strong>作用</strong>：比较两个值的关系，返回真(1)或假(0)  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>==</code></td><td>等于</td><td><code>5 == 3 → 0</code></td><td>检查密码是否正确🗝️</td></tr><tr><td><code>!=</code></td><td>不等于</td><td><code>5 != 3 → 1</code></td><td>判断奶茶口味是否不同🧋</td></tr><tr><td><code>&gt;</code></td><td>大于</td><td><code>5 &gt; 3 → 1</code></td><td>比较考试成绩📊</td></tr><tr><td><code>&lt;</code></td><td>小于</td><td><code>5 &lt; 3 → 0</code></td><td>判断年龄是否符合条件👶→👨</td></tr><tr><td><code>&gt;=</code></td><td>大于等于</td><td><code>5 &gt;= 5 → 1</code></td><td>身高是否达标📏</td></tr><tr><td><code>&lt;=</code></td><td>小于等于</td><td><code>5 &lt;= 3 → 0</code></td><td>体重是否超标⚖️</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 温度 = <span class="number">25</span>;</span><br><span class="line"><span class="keyword">if</span> (温度 &gt;= <span class="number">30</span>) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调❄️&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;吹风扇💨&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三、逻辑运算符——真假判官-🕵️♂️"><a href="#三、逻辑运算符——真假判官-🕵️♂️" class="headerlink" title="三、逻辑运算符——真假判官 🕵️♂️"></a>三、<strong>逻辑运算符——真假判官</strong> 🕵️♂️</h2><p><strong>作用</strong>：组合多个条件判断  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>生活类比</th></tr></thead><tbody><tr><td><code>&amp;&amp;</code></td><td>逻辑与</td><td><code>(A &amp;&amp; B)</code></td><td>双人合作任务👫→都同意才执行</td></tr><tr><td>&#96;</td><td></td><td>&#96;</td><td>逻辑或</td></tr><tr><td><code>!</code></td><td>逻辑非</td><td><code>!A</code></td><td>取反操作🔄→真变假，假变真</td></tr></tbody></table><p><strong>短路特性</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (a != <span class="number">0</span> &amp;&amp; <span class="number">10</span>/a &gt; <span class="number">1</span>) &#123; </span><br><span class="line">    <span class="comment">// 不会崩溃！因为a!=0为假，后面不执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="四、位运算符——二进制操控师-🔧"><a href="#四、位运算符——二进制操控师-🔧" class="headerlink" title="四、位运算符——二进制操控师 🔧"></a>四、<strong>位运算符——二进制操控师</strong> 🔧</h2><p><strong>作用</strong>：直接操作二进制位  </p><table><thead><tr><th>运算符</th><th>描述</th><th>例子（A&#x3D;60&#x3D;0011 1100）</th></tr></thead><tbody><tr><td><code>&amp;</code></td><td>按位与</td><td><code>A &amp; 13 → 12 (0000 1100)</code></td></tr><tr><td>&#96;</td><td>&#96;</td><td>按位或</td></tr><tr><td><code>^</code></td><td>按位异或</td><td><code>A ^ 13 → 49 (0011 0001)</code></td></tr><tr><td><code>~</code></td><td>按位取反</td><td><code>~A → -61 (1100 0011)</code></td></tr><tr><td><code>&lt;&lt;</code></td><td>左移</td><td><code>A &lt;&lt; 2 → 240 (1111 0000)</code></td></tr><tr><td><code>&gt;&gt;</code></td><td>右移</td><td><code>A &gt;&gt; 2 → 15 (0000 1111)</code></td></tr></tbody></table><p><strong>生活场景</strong>：  </p><ul><li>权限控制：用位掩码管理用户权限🔐  </li><li>加密算法：异或操作用于简单加密🔒</li></ul><hr><h2 id="五、赋值运算符——快捷存钱罐-🐖"><a href="#五、赋值运算符——快捷存钱罐-🐖" class="headerlink" title="五、赋值运算符——快捷存钱罐 🐖"></a>五、<strong>赋值运算符——快捷存钱罐</strong> 🐖</h2><p><strong>作用</strong>：简化变量赋值操作  </p><table><thead><tr><th>运算符</th><th>例子</th><th>等价写法</th><th>生活类比</th></tr></thead><tbody><tr><td><code>=</code></td><td><code>a = 5</code></td><td><code>a = 5</code></td><td>存钱罐放入5元💰</td></tr><tr><td><code>+=</code></td><td><code>a += 3</code></td><td><code>a = a + 3</code></td><td>往存钱罐加3元</td></tr><tr><td><code>-=</code></td><td><code>a -= 2</code></td><td><code>a = a - 2</code></td><td>取出2元</td></tr><tr><td><code>*=</code></td><td><code>a *= 4</code></td><td><code>a = a * 4</code></td><td>钱翻4倍</td></tr><tr><td><code>/=</code></td><td><code>a /= 2</code></td><td><code>a = a / 2</code></td><td>钱平分两份</td></tr><tr><td><code>%=</code></td><td><code>a %= 3</code></td><td><code>a = a % 3</code></td><td>分钱后剩下的零钱</td></tr></tbody></table><p><strong>示例代码</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 钱包 = <span class="number">100</span>;</span><br><span class="line">钱包 += <span class="number">50</span>;  <span class="comment">// 钱包 = 150</span></span><br><span class="line">钱包 /= <span class="number">2</span>;   <span class="comment">// 钱包 = 75</span></span><br></pre></td></tr></table></figure><hr><h2 id="六、杂项运算符——多功能瑞士军刀-🔪"><a href="#六、杂项运算符——多功能瑞士军刀-🔪" class="headerlink" title="六、杂项运算符——多功能瑞士军刀 🔪"></a>六、<strong>杂项运算符——多功能瑞士军刀</strong> 🔪</h2><table><thead><tr><th>运算符</th><th>描述</th><th>例子</th><th>作用</th></tr></thead><tbody><tr><td><code>sizeof()</code></td><td>获取变量&#x2F;类型大小</td><td><code>sizeof(int) → 4</code></td><td>查看数据占内存多少字节💾</td></tr><tr><td><code>&amp;</code></td><td>获取变量地址</td><td><code>&amp;a → 0x7ffe...</code></td><td>找到变量在内存中的门牌号🏠</td></tr><tr><td><code>*</code></td><td>指针运算符</td><td><code>*ptr → 访问指针指向的值</code></td><td>用地址打开对应的储物柜🗄️</td></tr><tr><td><code>?:</code></td><td>三元条件运算符</td><td><code>a &gt; b ? a : b</code></td><td>快速二选一（像自动售货机🤖）</td></tr></tbody></table><p><strong>三元运算符示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 最大温度 = (今天温度 &gt; 昨天温度) ? 今天 : 昨天;</span><br></pre></td></tr></table></figure><hr><h2 id="七、运算符优先级——计算顺序交通灯-🚥"><a href="#七、运算符优先级——计算顺序交通灯-🚥" class="headerlink" title="七、运算符优先级——计算顺序交通灯 🚥"></a>七、<strong>运算符优先级——计算顺序交通灯</strong> 🚥</h2><p><strong>口诀</strong>：  </p><blockquote><p>括号成员是老大；<br>单目运算排老二；<br>乘除余三加减四；<br>移位五来关系六；<br>等与不等排第七；<br>位与异或位或八九十；<br>逻辑或和与；<br>条件赋值逗号垫底。  </p></blockquote><p><strong>优先级表速记</strong>：  </p><ol><li><code>()</code> → 最优先  </li><li><code>!</code> <code>++</code> <code>--</code> <code>&amp;</code>（单目）  </li><li><code>*</code> <code>/</code> <code>%</code>  </li><li><code>+</code> <code>-</code>  </li><li><code>&lt;&lt;</code> <code>&gt;&gt;</code>  </li><li><code>&gt;</code> <code>&lt;</code> <code>&gt;=</code> <code>&lt;=</code>  </li><li><code>==</code> <code>!=</code>  </li><li><code>&amp;&amp;</code> → 逻辑与  </li><li><code>||</code> → 逻辑或  </li><li><code>=</code> <code>+=</code> 等赋值操作</li></ol><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> result = <span class="number">5</span> + <span class="number">3</span> * <span class="number">2</span>; <span class="comment">// 先乘后加 → 11</span></span><br><span class="line"><span class="type">int</span> result2 = (<span class="number">5</span> + <span class="number">3</span>) * <span class="number">2</span>; <span class="comment">// 先加后乘 → 16</span></span><br></pre></td></tr></table></figure><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>自增&#x2F;自减陷阱</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = a++ + ++a; <span class="comment">// ❌ 结果不确定！避免同一变量多次自增</span></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点比较误差</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="number">0.3</span>) &#123; <span class="comment">/* 可能不成立！应用范围判断 */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>逻辑与&#x2F;或短路</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (ptr != <span class="literal">NULL</span> &amp;&amp; *ptr &gt; <span class="number">0</span>) &#123; <span class="comment">/* 安全访问 */</span> &#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌟-实战练习"><a href="#🌟-实战练习" class="headerlink" title="🌟 实战练习"></a>🌟 <strong>实战练习</strong></h2><p><strong>题目</strong>：用三元运算符判断成绩是否及格  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 分数 = <span class="number">75</span>;</span><br><span class="line"><span class="type">char</span> 结果 = (分数 &gt;= <span class="number">60</span>) ? <span class="string">&#x27;✅&#x27;</span> : <span class="string">&#x27;❌&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, 结果); <span class="comment">// 输出✅</span></span><br></pre></td></tr></table></figure><p><strong>题目</strong>：位运算实现权限控制  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 读权限 0b001</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 写权限 0b010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> 执行权限 0b100</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> 用户权限 = 读权限 | 写权限; <span class="comment">// 0b011</span></span><br><span class="line"><span class="keyword">if</span> (用户权限 &amp; 写权限) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;可编辑📝&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>掌握这些运算符，你就能像操控魔法一样编写程序啦！🎮 遇到问题随时复习这张”运算符地图”🗺️</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言存储类</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="🗂️-C存储类——变量的「职场身份」管理"><a href="#🗂️-C存储类——变量的「职场身份」管理" class="headerlink" title="🗂️ C存储类——变量的「职场身份」管理"></a>🗂️ <strong>C存储类——变量的「职场身份」管理</strong></h1><p>存储类决定变量在哪工作（内存位置）、工作多久（生命周期）、能去哪（作用域）。就像员工分为临时工、常驻员工、跨部门协作者，变量也有不同”职场身份”！🚀</p><hr><h2 id="一、auto存储类——默认的「临时工」"><a href="#一、auto存储类——默认的「临时工」" class="headerlink" title="一、auto存储类——默认的「临时工」"></a>一、<strong>auto存储类——默认的「临时工」</strong></h2><p><strong>特点</strong>：  </p><ul><li>所有局部变量默认是<code>auto</code>（可省略不写）  </li><li><strong>生命周期</strong>：函数开始时出生，函数结束被销毁  </li><li><strong>作用域</strong>：仅限于函数内部</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数() &#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> 临时工 = <span class="number">10</span>; <span class="comment">// 等价于 int 临时工 = 10;</span></span><br><span class="line">    <span class="type">int</span> 另一个临时工 = <span class="number">20</span>; <span class="comment">// auto是默认的，不用写</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像快餐店小时工，随叫随到，下班就离开</li></ul><hr><h2 id="二、register存储类——「VIP快速通道」"><a href="#二、register存储类——「VIP快速通道」" class="headerlink" title="二、register存储类——「VIP快速通道」"></a>二、<strong>register存储类——「VIP快速通道」</strong></h2><p><strong>特点</strong>：  </p><ul><li>请求将变量存储在寄存器（非内存），访问更快  </li><li><strong>不能取地址</strong>（因为不在内存）→ <code>&amp;变量</code> 会报错  </li><li>实际是否存寄存器由编译器决定</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 计算() &#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> 计数器 = <span class="number">0</span>; <span class="comment">// 频繁使用的变量</span></span><br><span class="line">    <span class="keyword">while</span>(计数器 &lt; <span class="number">100</span>) &#123;</span><br><span class="line">        计数器++; <span class="comment">// 快速访问</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>⚠️ 注意</strong>：  </p><ul><li>只用于<strong>频繁访问的小变量</strong>（如循环计数器）  </li><li>寄存器空间有限，申请太多可能无效</li></ul><p><strong>生活类比</strong>：  </p><ul><li>像银行VIP窗口，处理速度快但席位有限</li></ul><hr><h2 id="三、static存储类——「常驻员工」"><a href="#三、static存储类——「常驻员工」" class="headerlink" title="三、static存储类——「常驻员工」"></a>三、<strong>static存储类——「常驻员工」</strong></h2><p><strong>特点</strong>：  </p><ul><li><strong>局部变量</strong>：函数调用间保持值，只初始化一次  </li><li><strong>全局变量</strong>：限制作用域到当前文件</li></ul><h3 id="1-静态局部变量"><a href="#1-静态局部变量" class="headerlink" title="1. 静态局部变量"></a>1. <strong>静态局部变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 计数器函数() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> 计数 = <span class="number">0</span>; <span class="comment">// 只初始化一次！</span></span><br><span class="line">    计数++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;调用次数：%d&quot;</span>, 计数);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    计数器函数(); <span class="comment">// 输出1</span></span><br><span class="line">    计数器函数(); <span class="comment">// 输出2</span></span><br><span class="line">    计数器函数(); <span class="comment">// 输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像办公室里的保险箱，每次使用后内容保留</li></ul><h3 id="2-静态全局变量"><a href="#2-静态全局变量" class="headerlink" title="2. 静态全局变量"></a>2. <strong>静态全局变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件A.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> 秘密数字 = <span class="number">42</span>; <span class="comment">// 只在当前文件有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件B.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 秘密数字; <span class="comment">// ❌ 错误！无法访问其他文件的static全局变量</span></span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像部门机密文件，其他部门无权查看</li></ul><hr><h2 id="四、extern存储类——「跨部门协作者」"><a href="#四、extern存储类——「跨部门协作者」" class="headerlink" title="四、extern存储类——「跨部门协作者」"></a>四、<strong>extern存储类——「跨部门协作者」</strong></h2><p><strong>特点</strong>：  </p><ul><li>声明在其他文件中定义的全局变量  </li><li><strong>不分配内存</strong>，只是引用已有变量</li></ul><p><strong>多文件示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文件1.c */</span></span><br><span class="line"><span class="type">int</span> 全局员工数 = <span class="number">100</span>; <span class="comment">// 定义全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 文件2.c */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 全局员工数; <span class="comment">// 声明：借用其他文件的变量</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 打印员工数() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;总数：%d&quot;</span>, 全局员工数); <span class="comment">// 输出100</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>生活类比</strong>：  </p><ul><li>像分公司共享总部数据，无需重复创建</li></ul><hr><h2 id="🔍-存储类对比表"><a href="#🔍-存储类对比表" class="headerlink" title="🔍 存储类对比表"></a>🔍 <strong>存储类对比表</strong></h2><table><thead><tr><th><strong>存储类</strong></th><th><strong>作用域</strong></th><th><strong>生命周期</strong></th><th><strong>典型用途</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>函数内</td><td>函数执行期间</td><td>局部临时变量</td></tr><tr><td><code>register</code></td><td>函数内</td><td>函数执行期间</td><td>高频访问的小变量</td></tr><tr><td><code>static</code></td><td>文件或函数内</td><td>程序整个运行期</td><td>保持状态的局部变量</td></tr><tr><td><code>extern</code></td><td>跨文件</td><td>程序整个运行期</td><td>共享全局变量</td></tr></tbody></table><hr><h2 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h2><ol><li><p><strong>register变量取地址</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x; <span class="comment">// ❌ 错误！无法取寄存器变量地址</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重复定义extern变量</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件1.c</span></span><br><span class="line"><span class="type">int</span> 全局变量 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件2.c</span></span><br><span class="line"><span class="type">int</span> 全局变量 = <span class="number">20</span>; <span class="comment">// ❌ 重复定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> 全局变量; <span class="comment">// ✅ 正确声明</span></span><br></pre></td></tr></table></figure></li><li><p><strong>误解static局部变量初始化</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> 函数() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> x = <span class="number">1</span>; <span class="comment">// 只执行一次！</span></span><br><span class="line">    x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 第一次调用x=2，第二次x=3...</span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="🌰-实战示例——静态变量累计调用次数"><a href="#🌰-实战示例——静态变量累计调用次数" class="headerlink" title="🌰 实战示例——静态变量累计调用次数"></a>🌰 <strong>实战示例——静态变量累计调用次数</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 记录调用() &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> 次数 = <span class="number">0</span>; <span class="comment">// 静态局部变量</span></span><br><span class="line">    次数++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;函数被调用了%d次\n&quot;</span>, 次数);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    记录调用(); <span class="comment">// 第1次</span></span><br><span class="line">    记录调用(); <span class="comment">// 第2次</span></span><br><span class="line">    记录调用(); <span class="comment">// 第3次</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出</strong>：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">函数被调用了1次  </span><br><span class="line">函数被调用了2次  </span><br><span class="line">函数被调用了3次  </span><br></pre></td></tr></table></figure><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>auto临时局部藏，默认写在函数旁。<br>register求速度，高频小量最适当。<br>static常住不销毁，全局文件内隐藏。<br>extern声明借变量，跨文件协作强。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言常量</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="📌-C语言常量——不可变的固定值"><a href="#📌-C语言常量——不可变的固定值" class="headerlink" title="📌 C语言常量——不可变的固定值"></a>📌 <strong>C语言常量——不可变的固定值</strong></h1><p>常量就像刻在石头上的数字🔢，一旦定义就不能修改。下面用最有趣的方式拆解常量知识！</p><hr><h2 id="一、常量的种类——不同口味的「固定饼干」🍪"><a href="#一、常量的种类——不同口味的「固定饼干」🍪" class="headerlink" title="一、常量的种类——不同口味的「固定饼干」🍪"></a>一、<strong>常量的种类</strong>——不同口味的「固定饼干」🍪</h2><h3 id="1-整数常量-🔢"><a href="#1-整数常量-🔢" class="headerlink" title="1. 整数常量 🔢"></a>1. <strong>整数常量</strong> 🔢</h3><p><strong>写法</strong>：支持十进制、八进制、十六进制<br><strong>生活类比</strong>：  </p><ul><li>十进制：日常计数（<code>100</code>）  </li><li>八进制：前导<code>0</code>（<code>0123</code> → 十进制的83）  </li><li>十六进制：前导<code>0x</code>（<code>0xFF</code> → 十进制的255）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">85</span>;       <span class="comment">// 十进制 → 85  </span></span><br><span class="line"><span class="type">int</span> b = <span class="number">0213</span>;     <span class="comment">// 八进制 → 139  </span></span><br><span class="line"><span class="type">int</span> c = <span class="number">0x4B</span>;     <span class="comment">// 十六进制 → 75  </span></span><br></pre></td></tr></table></figure><p><strong>后缀小贴士</strong>：  </p><ul><li><code>L</code>或<code>l</code> → 长整型（<code>100L</code>）  </li><li><code>U</code>或<code>u</code> → 无符号（<code>30U</code>）</li></ul><hr><h3 id="2-浮点常量-🌊"><a href="#2-浮点常量-🌊" class="headerlink" title="2. 浮点常量 🌊"></a>2. <strong>浮点常量</strong> 🌊</h3><p><strong>写法</strong>：小数或科学计数法<br><strong>生活类比</strong>：  </p><ul><li>普通小数：<code>3.14</code>  </li><li>科学计数法：<code>2.5E3</code>（即2500.0）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> pi = <span class="number">3.14f</span>;    <span class="comment">// 加f表示float  </span></span><br><span class="line"><span class="type">double</span> big = <span class="number">1.23e5</span>; <span class="comment">// 科学计数法 → 123000.0  </span></span><br></pre></td></tr></table></figure><p><strong>常见错误</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> x = <span class="number">3.14</span>;   <span class="comment">// ❌ 默认是double，建议加f  </span></span><br><span class="line"><span class="type">double</span> y = <span class="number">5</span>E;    <span class="comment">// ❌ 指数不完整  </span></span><br></pre></td></tr></table></figure><hr><h3 id="3-字符常量-🔤"><a href="#3-字符常量-🔤" class="headerlink" title="3. 字符常量 🔤"></a>3. <strong>字符常量</strong> 🔤</h3><p><strong>写法</strong>：单引号包裹，支持转义符<br><strong>生活类比</strong>：  </p><ul><li>普通字符：<code>&#39;A&#39;</code>  </li><li>转义字符：<code>&#39;\n&#39;</code>（换行）、<code>&#39;\t&#39;</code>（制表符）</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> newline = <span class="string">&#x27;\n&#x27;</span>;       <span class="comment">// 换行符  </span></span><br><span class="line"><span class="type">char</span> tab = <span class="string">&#x27;\t&#x27;</span>;           <span class="comment">// 制表符  </span></span><br><span class="line"><span class="type">char</span> backslash = <span class="string">&#x27;\\&#x27;</span>;     <span class="comment">// 表示一个反斜杠  </span></span><br></pre></td></tr></table></figure><p><strong>ASCII值转换</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> c = <span class="string">&#x27;a&#x27;</span>;  </span><br><span class="line"><span class="type">int</span> ascii = (<span class="type">int</span>)c;   <span class="comment">// 转为ASCII值97  </span></span><br></pre></td></tr></table></figure><hr><h3 id="4-字符串常量-📜"><a href="#4-字符串常量-📜" class="headerlink" title="4. 字符串常量 📜"></a>4. <strong>字符串常量</strong> 📜</h3><p><strong>写法</strong>：双引号包裹，自动加<code>\0</code>结尾<br><strong>生活类比</strong>：  </p><ul><li>字符串像火车🚂，每个字符是车厢，<code>\0</code>是终点标志</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;Hello&quot;</span>; <span class="comment">// 实际存储：H e l l o \0  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好\t世界\n&quot;</span>); <span class="comment">// 输出带转义符的字符串  </span></span><br></pre></td></tr></table></figure><p><strong>多行写法</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> msg[] = <span class="string">&quot;Hello &quot;</span>  </span><br><span class="line">             <span class="string">&quot;World!&quot;</span>; <span class="comment">// 等同于&quot;Hello World!&quot;  </span></span><br></pre></td></tr></table></figure><hr><h2 id="二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️"><a href="#二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️" class="headerlink" title="二、定义常量的两种方式——「替换贴纸」vs「只读标签」🏷️"></a>二、<strong>定义常量的两种方式</strong>——「替换贴纸」vs「只读标签」🏷️</h2><h3 id="1-define-预处理-✨"><a href="#1-define-预处理-✨" class="headerlink" title="1. #define 预处理 ✨"></a>1. <strong>#define 预处理</strong> ✨</h3><p><strong>特点</strong>：  </p><ul><li>简单文本替换（像代码里的贴纸）  </li><li>无类型检查  </li><li>作用域全局</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREETING <span class="string">&quot;你好！&quot;</span>  </span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">double</span> area = PI * <span class="number">5</span> * <span class="number">5</span>;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, GREETING);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>⚠️ 陷阱</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 100;  <span class="comment">// ❌ 末尾不要加分号！  </span></span></span><br><span class="line"><span class="type">int</span> x = MAX * <span class="number">2</span>;  <span class="comment">// 替换后变成 100; * 2 → 语法错误  </span></span><br></pre></td></tr></table></figure><hr><h3 id="2-const-关键字-🔒"><a href="#2-const-关键字-🔒" class="headerlink" title="2. const 关键字 🔒"></a>2. <strong>const 关键字</strong> 🔒</h3><p><strong>特点</strong>：  </p><ul><li>类型安全（编译器会检查）  </li><li>有作用域限制（像局部标签）  </li><li>实际占用内存</li></ul><p><strong>示例</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX = <span class="number">100</span>;  </span><br><span class="line"><span class="type">const</span> <span class="type">float</span> TAX = <span class="number">0.1f</span>;  </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> &#123;  </span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LOCAL_CONST = <span class="number">50</span>; <span class="comment">// 只在函数内有效  </span></span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p><strong>常见错误</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x;  </span><br><span class="line">x = <span class="number">10</span>; <span class="comment">// ❌ 必须定义时初始化！  </span></span><br></pre></td></tr></table></figure><hr><h2 id="三、define-vs-const-大比拼-🥊"><a href="#三、define-vs-const-大比拼-🥊" class="headerlink" title="三、define vs const 大比拼 🥊"></a>三、<strong>define vs const 大比拼</strong> 🥊</h2><table><thead><tr><th><strong>特性</strong></th><th><strong>#define</strong> ✨</th><th><strong>const</strong> 🔒</th></tr></thead><tbody><tr><td><strong>类型检查</strong></td><td>❌ 无</td><td>✅ 有</td></tr><tr><td><strong>作用域</strong></td><td>全局</td><td>局部&#x2F;全局</td></tr><tr><td><strong>内存占用</strong></td><td>无（文本替换）</td><td>有</td></tr><tr><td><strong>调试</strong></td><td>难（替换后看不到原名）</td><td>易（保留变量名）</td></tr></tbody></table><p><strong>总结</strong>：  </p><ul><li>推荐多用<code>const</code>（更安全、易调试）  </li><li><code>#define</code>适合简单替换或跨文件常量</li></ul><hr><h2 id="四、实战避坑指南-🚧"><a href="#四、实战避坑指南-🚧" class="headerlink" title="四、实战避坑指南 🚧"></a>四、<strong>实战避坑指南</strong> 🚧</h2><h3 id="1-转义字符错误"><a href="#1-转义字符错误" class="headerlink" title="1. 转义字符错误"></a>1. <strong>转义字符错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;路径：C:\new\file.txt&quot;</span>); <span class="comment">// ❌ 输出乱码！  </span></span><br><span class="line"><span class="comment">// 正确写法：  </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;路径：C:\\new\\file.txt&quot;</span>); <span class="comment">// ✅ 双反斜杠  </span></span><br></pre></td></tr></table></figure><h3 id="2-字符串忘记-0"><a href="#2-字符串忘记-0" class="headerlink" title="2. 字符串忘记\0"></a>2. <strong>字符串忘记\0</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> arr[<span class="number">4</span>] = &#123;<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>&#125;; <span class="comment">// ❌ 超出长度，无\0  </span></span><br><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;abcd&quot;</span>;             <span class="comment">// ✅ 自动补\0（长度5）  </span></span><br></pre></td></tr></table></figure><h3 id="3-八进制数字错误"><a href="#3-八进制数字错误" class="headerlink" title="3. 八进制数字错误"></a>3. <strong>八进制数字错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = <span class="number">089</span>; <span class="comment">// ❌ 八进制只能0~7！  </span></span><br></pre></td></tr></table></figure><hr><h2 id="五、常量的应用场景-🎯"><a href="#五、常量的应用场景-🎯" class="headerlink" title="五、常量的应用场景 🎯"></a>五、<strong>常量的应用场景</strong> 🎯</h2><ol><li><p><strong>固定配置</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_USERS 1000  </span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> TIMEOUT = <span class="number">30</span>;  </span><br></pre></td></tr></table></figure></li><li><p><strong>数学常数</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> PI = <span class="number">3.1415926535</span>;  </span><br></pre></td></tr></table></figure></li><li><p><strong>错误码定义</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR_FILE_NOT_FOUND 404  </span></span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="💡-记忆口诀"><a href="#💡-记忆口诀" class="headerlink" title="💡 记忆口诀"></a>💡 <strong>记忆口诀</strong></h2><blockquote><p>常量不变值固定，类型不同用不同。<br>整数浮点字符串，转义字符要记清。<br>预处理或const选，安全类型选后者。<br>八进制前加个0，十六进制0x明。  </p></blockquote><hr><p><strong>考考你</strong> 🤔  </p><ol><li><code>0x1A</code> 的十进制值是多少？ → <strong>26</strong>  </li><li><code>const int x = 5; x = 10;</code> 合法吗？ → <strong>❌ 不合法</strong>  </li><li><code>#define</code>定义的常量能被调试吗？ → <strong>❌ 不能（替换后消失）</strong></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言变量</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容将开始讲解一些关于变量的内容，如果你对之前内容还有不会的，可以回去再复习一下！</strong></p><h1 id="C程序变量"><a href="#C程序变量" class="headerlink" title="C程序变量"></a>C程序变量</h1><hr><h2 id="一、变量是什么？——「数据的快递盒」"><a href="#一、变量是什么？——「数据的快递盒」" class="headerlink" title="一、变量是什么？——「数据的快递盒」"></a>一、变量是什么？——「数据的快递盒」</h2><p>想象你有一个快递盒，这个盒子有 <strong>三个重要信息</strong>：</p><ol><li><strong>盒子名字</strong>（变量名）：比如「年龄盒」、「温度盒」</li><li><strong>盒子类型</strong>（数据类型）：决定能放什么（只能放数字？放小数？放文字？）</li><li><strong>盒子里装的东西</strong>（变量的值）：比如数字25、温度36.5</li></ol><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">25</span>; <span class="comment">// 创建一个叫age的整数盒，放数字25</span></span><br><span class="line"><span class="type">float</span> temperature = <span class="number">36.5f</span>; <span class="comment">// 温度盒，放小数36.5</span></span><br><span class="line"><span class="type">char</span> grade = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// 等级盒，放字母A</span></span><br></pre></td></tr></table></figure><hr><h2 id="二、变量的定义——「买快递盒」"><a href="#二、变量的定义——「买快递盒」" class="headerlink" title="二、变量的定义——「买快递盒」"></a>二、变量的定义——「买快递盒」</h2><p><strong>步骤</strong>：告诉计算机你要什么类型、什么名字的盒子<br><strong>语法</strong>：<code>数据类型 变量名;</code><br><strong>重点</strong>：  </p><ul><li><strong>数据类型</strong>：就像盒子材质，决定能装什么（比如 <code>int</code> 盒子只能装整数）  </li><li><strong>变量名</strong>：盒子的标签，必须遵守起名规则（字母&#x2F;下划线开头，不含空格和特殊符号）</li></ul><p><strong>正确例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> student_age; <span class="comment">// 整数盒，名字是student_age</span></span><br><span class="line"><span class="type">float</span> _price;    <span class="comment">// 小数盒，名字是_price（下划线开头）</span></span><br></pre></td></tr></table></figure><p><strong>错误例子</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">3</span>students; <span class="comment">// ❌ 数字开头</span></span><br><span class="line"><span class="type">float</span> price$;  <span class="comment">// ❌ 包含特殊符号$</span></span><br></pre></td></tr></table></figure><hr><h2 id="三、变量的赋值——「往盒子里放东西」"><a href="#三、变量的赋值——「往盒子里放东西」" class="headerlink" title="三、变量的赋值——「往盒子里放东西」"></a>三、变量的赋值——「往盒子里放东西」</h2><p><strong>两种方式</strong>：</p><ol><li><strong>定义时直接放</strong>（初始化）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age = <span class="number">18</span>; <span class="comment">// 创建age盒，直接放18</span></span><br></pre></td></tr></table></figure></li><li><strong>先买盒子，后放东西</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> age;      <span class="comment">// 先买盒子（此时盒子里可能有垃圾）</span></span><br><span class="line">age = <span class="number">18</span>;     <span class="comment">// 再往盒子里放18</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>⚠️ 警告</strong>：  </p><ul><li><strong>局部变量</strong>（在函数内部定义的盒子）如果没放东西，打开时会看到<strong>随机垃圾值</strong>（可能引发bug！）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// 没初始化</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ 输出的是随机数！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="四、变量的类型——「盒子的种类」"><a href="#四、变量的类型——「盒子的种类」" class="headerlink" title="四、变量的类型——「盒子的种类」"></a>四、变量的类型——「盒子的种类」</h2><p>C语言常用的「盒子类型」：</p><table><thead><tr><th>类型</th><th>能装什么</th><th>例子</th><th>备注</th></tr></thead><tbody><tr><td><code>int</code></td><td>整数</td><td><code>int age = 20;</code></td><td>不带小数</td></tr><tr><td><code>float</code></td><td>小数（精度低）</td><td><code>float pi = 3.14f;</code></td><td>末尾加<code>f</code></td></tr><tr><td><code>double</code></td><td>小数（精度高）</td><td><code>double pi = 3.1415926;</code></td><td>默认小数类型</td></tr><tr><td><code>char</code></td><td>单个字符</td><td><code>char c = &#39;A&#39;;</code></td><td>用单引号包裹</td></tr></tbody></table><p><strong>特殊类型</strong>：</p><ul><li><code>void</code>：空盒子（不能装东西，用于特殊场合如函数返回值）  </li><li>其他复杂类型（数组、指针等）：后面章节解锁</li></ul><hr><h2 id="五、变量的作用域——「盒子在哪里能用？」"><a href="#五、变量的作用域——「盒子在哪里能用？」" class="headerlink" title="五、变量的作用域——「盒子在哪里能用？」"></a>五、变量的作用域——「盒子在哪里能用？」</h2><h3 id="1-全局变量：整个程序都能用的「公共快递柜」"><a href="#1-全局变量：整个程序都能用的「公共快递柜」" class="headerlink" title="1. 全局变量：整个程序都能用的「公共快递柜」"></a>1. <strong>全局变量</strong>：整个程序都能用的「公共快递柜」</h3><ul><li><strong>定义位置</strong>：函数外面  </li><li><strong>特点</strong>：默认初始化为0  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>; <span class="comment">// 全局变量，所有函数都能用</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// ✅ 输出100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    test();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-局部变量：只能在某个函数里用的「私人快递盒」"><a href="#2-局部变量：只能在某个函数里用的「私人快递盒」" class="headerlink" title="2. 局部变量：只能在某个函数里用的「私人快递盒」"></a>2. <strong>局部变量</strong>：只能在某个函数里用的「私人快递盒」</h3><ul><li><strong>定义位置</strong>：函数内部  </li><li><strong>特点</strong>：不初始化会含垃圾值，函数结束后盒子销毁  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local = <span class="number">50</span>; <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// ✅ 输出50</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, local); <span class="comment">// ❌ 错误！main函数不认识local</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="六、变量的声明-vs-定义——「快递单-vs-真实包裹」"><a href="#六、变量的声明-vs-定义——「快递单-vs-真实包裹」" class="headerlink" title="六、变量的声明 vs 定义——「快递单 vs 真实包裹」"></a>六、变量的声明 vs 定义——「快递单 vs 真实包裹」</h2><h3 id="1-声明（Declaration）：告诉别人「这个盒子存在」"><a href="#1-声明（Declaration）：告诉别人「这个盒子存在」" class="headerlink" title="1. 声明（Declaration）：告诉别人「这个盒子存在」"></a>1. <strong>声明</strong>（Declaration）：告诉别人「这个盒子存在」</h3><ul><li><strong>语法</strong>：<code>extern 数据类型 变量名;</code>  </li><li><strong>作用</strong>：跨文件使用其他地方的变量（像借用别人的盒子）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.c</span></span><br><span class="line"><span class="type">int</span> global = <span class="number">100</span>; <span class="comment">// 真实盒子</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// file2.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> global; <span class="comment">// 声明：global盒子在别处</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, global); <span class="comment">// ✅ 输出100</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-定义（Definition）：实际创建盒子"><a href="#2-定义（Definition）：实际创建盒子" class="headerlink" title="2. 定义（Definition）：实际创建盒子"></a>2. <strong>定义</strong>（Definition）：实际创建盒子</h3><ul><li><strong>语法</strong>：<code>数据类型 变量名;</code>  </li><li><strong>特点</strong>：分配内存空间</li></ul><hr><h2 id="七、左值-vs-右值——「盒子本身-vs-盒子里的东西」"><a href="#七、左值-vs-右值——「盒子本身-vs-盒子里的东西」" class="headerlink" title="七、左值 vs 右值——「盒子本身 vs 盒子里的东西」"></a>七、左值 vs 右值——「盒子本身 vs 盒子里的东西」</h2><h3 id="1-左值（Lvalue）：能放在赋值左边的表达式"><a href="#1-左值（Lvalue）：能放在赋值左边的表达式" class="headerlink" title="1. 左值（Lvalue）：能放在赋值左边的表达式"></a>1. <strong>左值（Lvalue）</strong>：能放在赋值左边的表达式</h3><ul><li><strong>特点</strong>：有明确的内存位置（像快递盒本身）  </li><li><strong>例子</strong>：变量、数组元素  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>; <span class="comment">// a是左值</span></span><br><span class="line">a = <span class="number">20</span>;     <span class="comment">// ✅ 正确：修改盒子的内容</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="2-右值（Rvalue）：只能放在赋值右边的表达式"><a href="#2-右值（Rvalue）：只能放在赋值右边的表达式" class="headerlink" title="2. 右值（Rvalue）：只能放在赋值右边的表达式"></a>2. <strong>右值（Rvalue）</strong>：只能放在赋值右边的表达式</h3><ul><li><strong>特点</strong>：临时值（像盒子里的物品）  </li><li><strong>例子</strong>：数字、计算结果  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> b = a + <span class="number">5</span>; <span class="comment">// (a+5)是右值</span></span><br><span class="line"><span class="number">10</span> = a;        <span class="comment">// ❌ 错误！不能给数字10赋值</span></span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="八、常见错误-调试技巧"><a href="#八、常见错误-调试技巧" class="headerlink" title="八、常见错误 &amp; 调试技巧"></a>八、常见错误 &amp; 调试技巧</h2><h3 id="1-变量名拼写错误"><a href="#1-变量名拼写错误" class="headerlink" title="1. 变量名拼写错误"></a>1. <strong>变量名拼写错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> studentAge = <span class="number">20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, studentage); <span class="comment">// ❌ 大小写错误！</span></span><br></pre></td></tr></table></figure><h3 id="2-使用未初始化的局部变量"><a href="#2-使用未初始化的局部变量" class="headerlink" title="2. 使用未初始化的局部变量"></a>2. <strong>使用未初始化的局部变量</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ x是随机值！</span></span><br></pre></td></tr></table></figure><h3 id="3-类型不匹配"><a href="#3-类型不匹配" class="headerlink" title="3. 类型不匹配"></a>3. <strong>类型不匹配</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">3.14</span>; <span class="comment">// ❌ 小数强制转整数（实际存3）</span></span><br><span class="line"><span class="type">float</span> b = <span class="number">10</span>; <span class="comment">// ✅ 整数转小数（自动转成10.0）</span></span><br></pre></td></tr></table></figure><h3 id="4-作用域错误"><a href="#4-作用域错误" class="headerlink" title="4. 作用域错误"></a>4. <strong>作用域错误</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">func2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, x); <span class="comment">// ❌ x只在func1里有效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="九、练习：你来试试！"><a href="#九、练习：你来试试！" class="headerlink" title="九、练习：你来试试！"></a>九、练习：你来试试！</h2><ol><li><p><strong>题目1</strong>：修复以下代码的错误  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">1</span>st_place = <span class="number">100</span>;</span><br><span class="line"><span class="type">float</span> price = <span class="number">3.14</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, Price);</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> first_place = <span class="number">100</span>; <span class="comment">// 变量名不能数字开头</span></span><br><span class="line"><span class="type">float</span> price = <span class="number">3.14f</span>;   <span class="comment">// 缺少分号，float建议加f</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%f&quot;</span>, price);   <span class="comment">// Price大小写不匹配</span></span><br></pre></td></tr></table></figure></li><li><p><strong>题目2</strong>：以下代码输出什么？  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> global;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> local;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;global=%d, local=%d&quot;</span>, global, local);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>答案</strong>：<br><code>global=0</code>（全局变量默认0），<code>local</code>的值不确定（随机垃圾值）</p></li></ol><hr><p>如果还有疑问，可以随时问我哦～ (•̀ω•́)✧</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数据类型</title>
      <link href="/2025/02/02/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2025/02/02/C%E8%AF%AD%E8%A8%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C程序数据类型"><a href="#C程序数据类型" class="headerlink" title="C程序数据类型"></a>C程序数据类型</h1><p>咱们可以把 <strong>C语言的数据类型</strong> 想象成 <strong>不同规格的储物容器</strong>，用来存放各种数据。就像你存水用水杯、存书用书包一样，不同的数据类型对应不同的存储需求和大小</p><hr><h2 id="📦-数据类型——数据的「房子」"><a href="#📦-数据类型——数据的「房子」" class="headerlink" title="📦 数据类型——数据的「房子」"></a>📦 <strong>数据类型——数据的「房子」</strong></h2><p><strong>作用</strong>：决定数据在内存中占多大空间，能表示什么范围的数值。</p><hr><h2 id="🗂️-四大类「房子户型」"><a href="#🗂️-四大类「房子户型」" class="headerlink" title="🗂️ 四大类「房子户型」"></a>🗂️ <strong>四大类「房子户型」</strong></h2><ol><li><p><strong>基本类型（单身公寓）</strong>  </p><ul><li><strong>整型</strong>：存整数 → <code>int</code>（标准间）、<code>short</code>（小单间）、<code>long</code>（大平层）  </li><li><strong>字符型</strong>：存单个字符 → <code>char</code>（迷你仓，其实也是小整数）  </li><li><strong>浮点型</strong>：存小数 → <code>float</code>（普通水杯）、<code>double</code>（大桶水）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 年龄 = <span class="number">25</span>;          <span class="comment">// 整型：存年龄</span></span><br><span class="line"><span class="type">float</span> 体重 = <span class="number">65.5f</span>;     <span class="comment">// 浮点：存体重（带f表示float）</span></span><br><span class="line"><span class="type">char</span> 等级 = <span class="string">&#x27;A&#x27;</span>;        <span class="comment">// 字符：存成绩等级</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>枚举类型（VIP专属房）</strong>  </p><ul><li>只能存放预设的整数值（比如星期几、方向）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> &#123;</span> Mon=<span class="number">1</span>, Tue, Wed &#125;; <span class="comment">// 定义枚举</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Week</span> 今天 =</span> Wed;           <span class="comment">// 今天=3</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>void类型（隐形房）</strong>  </p><ul><li><strong>三副面孔</strong>：  <ul><li>函数不返回值 → <code>void 吃饭() &#123; ... &#125;</code>  </li><li>函数不需要参数 → <code>int 随机数(void) &#123; ... &#125;</code>  </li><li>万能指针（像万能钥匙，但要指定类型后才能用） → <code>void* 神秘地址;</code></li></ul></li></ul></li><li><p><strong>派生类型（组合别墅）</strong>  </p><ul><li>后续章节解锁：数组（一排连号房）、指针（门牌号）、结构体（套房）</li></ul></li></ol><hr><h3 id="🔢-整型「房型对比表」"><a href="#🔢-整型「房型对比表」" class="headerlink" title="🔢 整型「房型对比表」"></a>🔢 <strong>整型「房型对比表」</strong></h3><table><thead><tr><th>类型</th><th>存储空间</th><th>值范围（64位系统）</th><th>生活类比</th></tr></thead><tbody><tr><td><code>char</code></td><td>1字节</td><td>-128<del>127 或 0</del>255</td><td>小抽屉（存年龄）</td></tr><tr><td><code>unsigned int</code></td><td>4字节</td><td>0~4,294,967,295</td><td>超大储物箱</td></tr><tr><td><code>long</code></td><td>8字节</td><td>-9万亿~9万亿</td><td>仓库</td></tr></tbody></table><p><strong>📢 关键技巧</strong>  </p><ul><li>选类型就像选背包：<strong>够用就行</strong>，别浪费空间   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> 学生人数 = <span class="number">300</span>;  <span class="comment">// ✅ 0~65535足够</span></span><br><span class="line"><span class="type">short</span> 温度 = <span class="number">-30</span>;              <span class="comment">// ✅ 有符号存负数</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="🌊-浮点型「精度段位」"><a href="#🌊-浮点型「精度段位」" class="headerlink" title="🌊 浮点型「精度段位」"></a>🌊 <strong>浮点型「精度段位」</strong></h3><table><thead><tr><th>类型</th><th>存储空间</th><th>精度</th><th>适用场景</th></tr></thead><tbody><tr><td><code>float</code></td><td>4字节</td><td>6~7位小数</td><td>日常测量（如体重）</td></tr><tr><td><code>double</code></td><td>8字节</td><td>15~16位小数</td><td>科学计算</td></tr><tr><td><code>long double</code></td><td>16字节</td><td>19位小数</td><td>超高精度需求</td></tr></tbody></table><p><strong>🌰 例子</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 圆周率 = <span class="number">3.141592653589793</span>; <span class="comment">// 高精度</span></span><br><span class="line"><span class="type">float</span> 身高 = <span class="number">1.75f</span>;                <span class="comment">// 普通精度</span></span><br></pre></td></tr></table></figure><hr><h3 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>整数溢出</strong> → 像水杯装满还硬倒：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 小杯子 = <span class="number">128</span>; <span class="comment">// ❌ char范围-128~127，128溢出成-128</span></span><br></pre></td></tr></table></figure></li><li><p><strong>浮点精度陷阱</strong> → 别用<code>==</code>直接比较：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> a = <span class="number">0.1</span> + <span class="number">0.2</span>;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">0.3</span>) &#123; ... &#125; <span class="comment">// ❌ 可能失败！应用范围判断</span></span><br></pre></td></tr></table></figure></li><li><p><strong>忘记加<code>f</code>后缀</strong> → 默认是double：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 价格 = <span class="number">9.99</span>;   <span class="comment">// ❌ 9.99默认是double，转float可能丢失精度</span></span><br><span class="line"><span class="type">float</span> 正确价 = <span class="number">9.99f</span>; <span class="comment">// ✅ 加f明确是float</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="🔍-查看「房子」大小（sizeof神器）"><a href="#🔍-查看「房子」大小（sizeof神器）" class="headerlink" title="🔍 查看「房子」大小（sizeof神器）"></a>🔍 <strong>查看「房子」大小（sizeof神器）</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;int大小: %zu字节\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">int</span>));      <span class="comment">// 输出4（64位系统）</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;double大小: %zu字节\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="type">double</span>)); <span class="comment">// 输出8</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="💡-类型选择口诀"><a href="#💡-类型选择口诀" class="headerlink" title="💡 类型选择口诀"></a>💡 <strong>类型选择口诀</strong></h3><blockquote><p>整型看范围，浮点看精度，<br>日常用int&#x2F;double，省心又省力。<br>超大数字上long，负号别忘记，<br>字符本质是整数，存字母很容易！</p></blockquote><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>char 能存300吗？</code> → ❌ 最大255（unsigned char）  </li><li><code>5.0 默认是什么类型？</code> → ✅ double  </li><li><code>void* 指针能直接存整数吗？</code> → ❌ 需要强制转换类型，如<code>(void*)&amp;num</code></li></ol><p>咱们可以把<strong>类型转换</strong>想象成<strong>不同容器之间的倒水操作</strong>——比如把矿泉水倒进保温杯，或者把大桶水分装到小瓶子里。以下是通俗版解释：</p><hr><h2 id="🔄-类型转换——数据的「变形记」"><a href="#🔄-类型转换——数据的「变形记」" class="headerlink" title="🔄 类型转换——数据的「变形记」"></a>🔄 <strong>类型转换——数据的「变形记」</strong></h2><p><strong>作用</strong>：让不同类型的数据能一起工作，但要注意可能发生的数据丢失（像倒水时洒出来）。</p><hr><h3 id="🕵️♂️-两种转换方式"><a href="#🕵️♂️-两种转换方式" class="headerlink" title="🕵️♂️ 两种转换方式"></a>🕵️♂️ <strong>两种转换方式</strong></h3><ol><li><p><strong>隐式转换（自动倒水）</strong>  </p><ul><li><strong>规则</strong>：从小杯转大杯（系统自动帮你完成）  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 小杯子 = <span class="number">100</span>;        <span class="comment">// 整型（4字节）</span></span><br><span class="line"><span class="type">float</span> 中杯子 = <span class="number">3.14f</span>;    <span class="comment">// 浮点（4字节）</span></span><br><span class="line"><span class="type">double</span> 大桶 = 小杯子 + 中杯子; <span class="comment">// ✅ 自动转成double计算（8字节）</span></span><br></pre></td></tr></table></figure></li><li><strong>风险</strong>：大杯转小杯可能溢出（但系统不会提醒你）  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 瓶子 = <span class="number">3.14</span>; <span class="comment">// ✅ 合法，但会截断成3（像只留整数部分的水量）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>显式转换（手动切割）</strong>  </p><ul><li><strong>规则</strong>：强制转换类型（像用模具切出指定形状）  </li><li><strong>语法</strong>：<code>(目标类型)数据</code>  </li><li><strong>例子</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> 精准身高 = <span class="number">175.8</span>;</span><br><span class="line"><span class="type">int</span> 大致身高 = (<span class="type">int</span>)精准身高; <span class="comment">// ✅ 砍掉小数，变成175</span></span><br></pre></td></tr></table></figure></li><li><strong>风险</strong>：数据可能被截断或失真  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 小瓶 = (<span class="type">char</span>)<span class="number">300</span>; <span class="comment">// ❌ char最大255，300转成44（溢出像水溢出杯子）</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活场景对比"><a href="#🌰-生活场景对比" class="headerlink" title="🌰 生活场景对比"></a>🌰 <strong>生活场景对比</strong></h3><table><thead><tr><th><strong>场景</strong></th><th><strong>隐式转换</strong></th><th><strong>显式转换</strong></th></tr></thead><tbody><tr><td><strong>混合计算</strong></td><td><code>int + float</code> 自动转<code>float</code></td><td>无</td></tr><tr><td><strong>精确控制结果类型</strong></td><td>无</td><td><code>double 价格 = (int)9.99 + 1; // 10</code></td></tr><tr><td><strong>处理函数参数类型</strong></td><td><code>sqrt(25)</code> 自动把int转double</td><td><code>sqrt((double)25)</code></td></tr></tbody></table><hr><h3 id="🚧-避坑指南-1"><a href="#🚧-避坑指南-1" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>浮点转整型丢失精度</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 温度 = <span class="number">36.6f</span>;</span><br><span class="line"><span class="type">int</span> 近似温度 = 温度; <span class="comment">// 隐式转成36（直接砍掉小数，不是四舍五入！）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>大类型转小类型溢出</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> 大数字 = <span class="number">2147483648L</span>; <span class="comment">// 假设long是8字节</span></span><br><span class="line"><span class="type">int</span> 小存储 = (<span class="type">int</span>)大数字;   <span class="comment">// ❌ 溢出成-2147483648（像大桶水灌炸小瓶）</span></span><br></pre></td></tr></table></figure></li><li><p><strong>无符号和有符号混用</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> 库存 = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> 销售量 = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">if</span> (销售量 &gt; 库存) &#123; ... &#125; <span class="comment">// ✅ 隐式转无符号，可能导致逻辑错误！</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="💡-类型转换口诀"><a href="#💡-类型转换口诀" class="headerlink" title="💡 类型转换口诀"></a>💡 <strong>类型转换口诀</strong></h3><blockquote><p>隐式转换系统帮，小杯转大杯无痕。<br>显式转换需手动，砍头去尾要谨慎。<br>浮点转整丢小数，大数化小会失真。<br>混用类型先统一，避免暗坑代码稳。</p></blockquote><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>(int)3.99</code>等于多少？ → <strong>3</strong>（直接砍掉小数）  </li><li><code>char c = 1.5 + 2.7;</code>中c的值？ → <strong>4</strong>（隐式转int&#x3D;4，再转char）  </li><li><code>int a = 5; double b = a/2;</code>b的值？ → <strong>2.0</strong>（先做整数除法5&#x2F;2&#x3D;2，再转double）<br><strong>修正方法</strong>：<code>double b = (double)a/2;</code> → 得到2.5</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础语法</title>
      <link href="/2025/02/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
      <url>/2025/02/01/C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.tomatou.xyz/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/">面向对象与面向过程</a>，本节我将正式开始讲解关于C程序的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C语言基础语法"><a href="#C语言基础语法" class="headerlink" title="C语言基础语法"></a>C语言基础语法</h1><p>C 语言是一种通用的编程语言，广泛应用于系统编程、嵌入式开发和高性能计算等领域。</p><p>C 语言具有高效、灵活、可移植性强等特点，是许多其他编程语言的基础。</p><p>在 C 语言中，令牌（Token）是程序的基本组成单位，编译器通过对源代码进行词法分析，将代码分解成一个个的令牌。</p><p>C 语言的令牌主要包括以下几种类型：</p><p><strong>关键字（Keywords）</strong><br><strong>标识符（Identifiers）</strong><br><strong>常量（Constants）</strong><br><strong>字符串字面量（String Literals）</strong><br><strong>运算符（Operators）</strong><br><strong>分隔符（Separators）</strong></p><h2 id="C程序的基本结构"><a href="#C程序的基本结构" class="headerlink" title="C程序的基本结构"></a>C程序的基本结构</h2><p>让我们用更生活化的比喻和简单语言来解释 C 程序的结构</p><h3 id="C-程序就像盖房子-🏠"><a href="#C-程序就像盖房子-🏠" class="headerlink" title="C 程序就像盖房子 🏠"></a>C 程序就像盖房子 🏠</h3><p>想象你要盖一个房子（写程序），需要按步骤准备材料和组织工人。C 程序的结构可以这样理解：</p><h4 id="1-准备工具包（头文件包含）"><a href="#1-准备工具包（头文件包含）" class="headerlink" title="1. 准备工具包（头文件包含）"></a>1. <strong>准备工具包（头文件包含）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> <span class="comment">// 相当于从仓库借工具</span></span></span><br></pre></td></tr></table></figure><ul><li>就像盖房子需要先借电钻、锤子一样，<code>#include</code> 是告诉电脑：”我要用打印文字（<code>printf</code>）和读取输入（<code>scanf</code>）这些工具”。<code>stdio.h</code> 就是存放这些工具的工具箱。</li></ul><h4 id="2-贴便利贴（宏定义）"><a href="#2-贴便利贴（宏定义）" class="headerlink" title="2. 贴便利贴（宏定义）"></a>2. <strong>贴便利贴（宏定义）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14159 <span class="comment">// 相当于在墙上贴个便利贴</span></span></span><br></pre></td></tr></table></figure><ul><li>你可以在墙上贴一张便利贴写着”PI&#x3D;3.14”，之后每次看到”PI”就直接替换成数字。<code>#define</code> 就是给常用的值起个简单名字，电脑会自动替换。</li></ul><h4 id="3-设计图纸（函数声明）"><a href="#3-设计图纸（函数声明）" class="headerlink" title="3. 设计图纸（函数声明）"></a>3. <strong>设计图纸（函数声明）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>; <span class="comment">// 提前告诉工人：&quot;我要一个加法器&quot;</span></span><br></pre></td></tr></table></figure><ul><li>就像先告诉工人”我要一个能加两个数的机器”，但具体怎么造先不说。函数声明就是提前告诉电脑：”后面会有一个叫<code>add</code>的函数，先记着它的样子”。</li></ul><h4 id="4-大门入口（主函数）"><a href="#4-大门入口（主函数）" class="headerlink" title="4. 大门入口（主函数）"></a>4. <strong>大门入口（主函数）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123; </span><br><span class="line">    <span class="comment">// 这里写程序的主要动作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 最后交钥匙表示完工</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>main()</code> 是程序的”大门”，电脑从这里开始执行。<code>return 0;</code> 相当于最后说一句：”一切正常，结束啦！”</li></ul><h4 id="5-准备材料（变量声明）"><a href="#5-准备材料（变量声明）" class="headerlink" title="5. 准备材料（变量声明）"></a>5. <strong>准备材料（变量声明）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num1, num2, sum; <span class="comment">// 准备三个盒子装数字</span></span><br></pre></td></tr></table></figure><ul><li>就像提前准备几个盒子（变量），贴上标签（变量名）用来存数字。在 C 语言中必须提前声明：”我要用这三个盒子装整数！”</li></ul><h4 id="6-具体操作（语句和函数调用）"><a href="#6-具体操作（语句和函数调用）" class="headerlink" title="6. 具体操作（语句和函数调用）"></a>6. <strong>具体操作（语句和函数调用）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;请输入两个数字：&quot;</span>); <span class="comment">// 在屏幕上打印文字</span></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;num1, &amp;num2); <span class="comment">// 读取用户输入的数字</span></span><br><span class="line">sum = add(num1, num2); <span class="comment">// 调用加法器计算结果</span></span><br></pre></td></tr></table></figure><ul><li>这些就像具体的施工步骤：先贴告示让用户输入（<code>printf</code>），然后接收用户输入的数字存到盒子里（<code>scanf</code>），最后用加法器计算（调用函数<code>add</code>）。</li></ul><h4 id="7-建造机器（函数定义）"><a href="#7-建造机器（函数定义）" class="headerlink" title="7. 建造机器（函数定义）"></a>7. <strong>建造机器（函数定义）</strong></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; </span><br><span class="line">    <span class="keyword">return</span> a + b; <span class="comment">// 机器的内部构造：两数相加</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里是真正建造加法器的地方。当<code>add</code>被调用时，它会把两个数相加，然后”吐”出结果。</li></ul><hr><h3 id="举个完整例子-🌰"><a href="#举个完整例子-🌰" class="headerlink" title="举个完整例子 🌰"></a>举个完整例子 🌰</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      <span class="comment">// 工具包：借来打印和输入工具</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREETING <span class="string">&quot;你好呀！&quot;</span> <span class="comment">// 贴个便利贴：把GREETING替换成&quot;你好呀！&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span>;        <span class="comment">// 提前声明：&quot;我要一个打招呼的机器&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    sayHello();         <span class="comment">// 使用打招呼机器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, GREETING); <span class="comment">// 打印便利贴内容</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;           <span class="comment">// 交钥匙结束</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sayHello</span><span class="params">()</span> &#123;       <span class="comment">// 建造打招呼机器</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello!\n&quot;</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="程序运行效果："><a href="#程序运行效果：" class="headerlink" title="程序运行效果："></a>程序运行效果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello!</span><br><span class="line">你好呀！</span><br></pre></td></tr></table></figure><hr><h3 id="关键点总结-🔑"><a href="#关键点总结-🔑" class="headerlink" title="关键点总结 🔑"></a>关键点总结 🔑</h3><ol><li><strong>工具包在前</strong>：所有<code>#include</code>和<code>#define</code>要写在最前面</li><li><strong>入口不能少</strong>：每个程序必须有<code>main()</code>函数</li><li><strong>先声明后使用</strong>：函数和变量都要先告诉电脑它们的存在</li><li><strong>语句像步骤</strong>：一行行代码就像做菜的步骤，按顺序执行</li><li><strong>函数像机器</strong>：先设计机器图纸（声明），再具体建造（定义）</li></ol><p>就像盖房子需要先备料再施工一样，C 程序的结构就是一步步告诉电脑该做什么。刚开始可能觉得步骤繁琐，但熟悉后会发现这是为了保证程序清晰可靠！</p><h2 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h2><p>咱们可以把编程里的”分隔符”想象成写作文时用的标点符号，它们的作用就是让代码更有条理、更容易读懂。下面用最生活化的方式解释：</p><ol><li><p><strong>逗号（,）——像购物清单的分隔符</strong>  </p><ul><li>比如你写购物清单：”苹果、香蕉、牛奶”，逗号就像中间的顿号，用来分开多个东西。</li><li>编程中用它分隔变量或函数参数：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 身高 = <span class="number">180</span>, 体重 = <span class="number">70</span>; <span class="comment">// 同时声明两个变量</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好&quot;</span>, name);      <span class="comment">// 分隔函数的两个参数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>分号（;）——代码的句号</strong>  </p><ul><li>就像写句子结尾要打句号，写代码每句话结束必须加分号。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;我写完代码啦！&quot;</span>); <span class="comment">// 这句结束了，打上分号</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;                <span class="comment">// 这句也结束了，再打个分号</span></span><br></pre></td></tr></table></figure></li><li>甚至可以直接写个光杆分号，表示”这里啥也不干”：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">; <span class="comment">// 相当于对电脑说：&quot;你先歇会儿，我暂时没指令&quot;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>括号三兄弟</strong>  </p><ul><li><p><strong>圆括号 () —— 像数学公式里的括号</strong><br>计算优先级&#x2F;函数调用时用：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">3</span>+<span class="number">5</span>)*<span class="number">2</span>       <span class="comment">// 先算括号里的3+5</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好&quot;</span>) <span class="comment">// 调用函数时必须带这对括号</span></span><br></pre></td></tr></table></figure></li><li><p><strong>花括号 {} —— 代码的集装箱</strong><br>把多行代码打包成一个整体，比如函数、循环、条件判断：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (下雨了) &#123;</span><br><span class="line">    拿伞();</span><br><span class="line">    关窗();    <span class="comment">// 这两行代码被&#123;&#125;包裹成一组操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>方括号 [] —— 储物柜编号</strong><br>主要用来标记数组的位置：  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 成绩[<span class="number">3</span>] = &#123;<span class="number">90</span>,<span class="number">85</span>,<span class="number">95</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,成绩[<span class="number">1</span>]); <span class="comment">// 取出第2个储物柜（下标从0开始）的值85</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>新手常见误区</strong>  </p><ul><li>漏加分号就像说话不喘气，计算机会懵：”你这句话到底结束没？”  </li><li>括号不匹配就像只说了”大家好（今天天气真好”，计算机等着你补上另一半呢！</li></ul><h2 id="📝-注释——代码的便利贴"><a href="#📝-注释——代码的便利贴" class="headerlink" title="📝 注释——代码的便利贴"></a>📝 <strong>注释——代码的便利贴</strong></h2><p><strong>作用</strong>：用来在代码里写<strong>解释说明</strong>，但不会影响程序运行（就像看书时写在空白处的笔记，电脑会直接忽略它们）。</p><hr><h3 id="✏️-两种注释写法"><a href="#✏️-两种注释写法" class="headerlink" title="✏️ 两种注释写法"></a>✏️ <strong>两种注释写法</strong></h3><ol><li><p><strong>单行注释 <code>//</code> —— 便利贴</strong>  </p><ul><li>适合写简短提醒，贴在<strong>某一行代码旁边</strong>：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计算用户年龄（这个便利贴只占一行）</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">2023</span> - birthYear; </span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>多行注释 <code>/* */</code> —— 笔记本上的补充说明</strong>  </p><ul><li>当你想写<strong>大段解释</strong>，或者<strong>暂时屏蔽多行代码</strong>时用：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> 这个函数用来计算工资：</span></span><br><span class="line"><span class="comment"> 1. 获取基本工资</span></span><br><span class="line"><span class="comment"> 2. 加上奖金</span></span><br><span class="line"><span class="comment"> 3. 扣除税</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> salary = base + bonus - tax;</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🚧-使用禁忌（千万别踩坑！）"><a href="#🚧-使用禁忌（千万别踩坑！）" class="headerlink" title="🚧 使用禁忌（千万别踩坑！）"></a>🚧 <strong>使用禁忌（千万别踩坑！）</strong></h3><ol><li><p><strong>禁止套娃注释</strong> ❌  </p><ul><li>不能在一个注释里<strong>再塞另一个注释</strong>，就像便利贴上不能再贴便利贴（会混乱）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 外层注释 </span></span><br><span class="line"><span class="comment">   // 内层注释（错误！电脑会懵） </span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>别在”对话”中插注释</strong> ❌  </p><ul><li>注释不能写在<strong>字符串（比如printf里的文字）</strong>中，就像聊天时突然说括号话会让人迷惑：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;你好啊 /* 这是注释吗？ */&quot;</span>); <span class="comment">// 电脑会原样输出整句话，包括/*</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活化例子"><a href="#🌰-生活化例子" class="headerlink" title="🌰 生活化例子"></a>🌰 <strong>生活化例子</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释：今天要买什么菜（电脑不会管这句）</span></span><br><span class="line"><span class="type">int</span> 土豆 = <span class="number">3</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  多行注释：</span></span><br><span class="line"><span class="comment">  1. 西红柿炒蛋的步骤：</span></span><br><span class="line"><span class="comment">  2. 先炒鸡蛋</span></span><br><span class="line"><span class="comment">  3. 再加西红柿</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> 西红柿 = <span class="number">2</span>;</span><br></pre></td></tr></table></figure><hr><h3 id="💡-为什么需要注释？"><a href="#💡-为什么需要注释？" class="headerlink" title="💡 为什么需要注释？"></a>💡 <strong>为什么需要注释？</strong></h3><ul><li><strong>给未来的自己</strong>：一个月后回来看代码，可能完全忘记当时为啥这么写</li><li><strong>给队友看</strong>：就像在代码里留”使用说明书”</li><li><strong>临时禁用代码</strong>：调试时让某段代码暂时失效（像用胶带贴住不想用的部分）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// printf(&quot;测试用，先屏蔽掉&quot;); </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;正式功能运行中...&quot;</span>);</span><br></pre></td></tr></table></figure><hr><p><strong>新手常见翻车现场</strong> 🚑  </p><ul><li>忘关多行注释：<code>/* 开头没写 */</code>，结果后面代码全被当成注释！</li><li>在字符串里手滑写<code>//</code>：<code>printf(&quot;网址://xxx.com&quot;);</code>（电脑会正常输出，但你可能以为这是注释）</li></ul><h2 id="🏷️-标识符——代码世界的起名规范"><a href="#🏷️-标识符——代码世界的起名规范" class="headerlink" title="🏷️ 标识符——代码世界的起名规范"></a>🏷️ <strong>标识符——代码世界的起名规范</strong></h2><p><strong>作用</strong>：用来给变量、函数、数组等起名字（比如你养的猫叫<code>喵喵</code>，代码里的数字可以叫<code>年龄</code>）。</p><hr><h3 id="📜-起名三大铁律"><a href="#📜-起名三大铁律" class="headerlink" title="📜 起名三大铁律"></a>📜 <strong>起名三大铁律</strong></h3><ol><li><p><strong>开头必须字母或下划线</strong>  </p><ul><li>❌ 禁止数字打头（像手机号不能当人名）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">123</span>abc;  <span class="comment">// 错误！数字开头</span></span><br><span class="line"><span class="type">float</span> _体重;  <span class="comment">// 正确√ 下划线开头</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>只能用字母、数字、下划线</strong>  </p><ul><li>❌ 禁用特殊符号（@、$、%等）：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 邮箱@qq; <span class="comment">// 错误！带了@</span></span><br><span class="line"><span class="type">double</span> $价格;  <span class="comment">// 错误！C语言不支持$（其他语言可能允许）</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>严格区分大小写</strong>  </p><ul><li>就像<code>iPhone</code>和<code>iphone</code>是两回事：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Age = <span class="number">18</span>;  <span class="comment">// 全大写的Age</span></span><br><span class="line"><span class="type">int</span> age = <span class="number">20</span>;  <span class="comment">// 全小写的age（和上面是两个不同变量）</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><h3 id="🌰-生活化例子对比"><a href="#🌰-生活化例子对比" class="headerlink" title="🌰 生活化例子对比"></a>🌰 <strong>生活化例子对比</strong></h3><table><thead><tr><th>✅ 合法名字</th><th>❌ 非法名字</th><th>错误原因</th></tr></thead><tbody><tr><td><code>userName</code></td><td><code>user-name</code></td><td>中间有减号（只能用下划线<code>_</code>）</td></tr><tr><td><code>_count</code></td><td><code>3D模型</code></td><td>数字开头</td></tr><tr><td><code>price2023</code></td><td><code>价格$</code></td><td>包含$符号</td></tr><tr><td><code>isValid</code>（驼峰命名）</td><td><code>break</code></td><td>用了C语言的关键字（后文解释）</td></tr></tbody></table><hr><h3 id="💡-起名技巧"><a href="#💡-起名技巧" class="headerlink" title="💡 起名技巧"></a>💡 <strong>起名技巧</strong></h3><ol><li><p><strong>见名知意</strong>：  </p><ul><li>烂名字 → <code>int a;</code>（鬼知道a代表啥）  </li><li>好名字 → <code>int 学生年龄;</code>（拼音或英文均可，推荐英文）</li></ul></li><li><p><strong>风格统一</strong>：  </p><ul><li>小写+下划线：<code>student_age</code>  </li><li>驼峰式：<code>studentAge</code></li></ul></li><li><p><strong>避开关键字</strong>：  </p><ul><li>别用C语言预留的单词（比如<code>int</code>, <code>return</code>等），就像不能给孩子起名叫”人类”。</li></ul></li></ol><hr><h3 id="🤯-经典翻车现场"><a href="#🤯-经典翻车现场" class="headerlink" title="🤯 经典翻车现场"></a>🤯 <strong>经典翻车现场</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="number">1</span>号学生 = <span class="number">60</span>;    <span class="comment">// 错误！数字开头</span></span><br><span class="line"><span class="type">float</span> 体重<span class="meta">#kg = 50.5; <span class="comment">// 错误！带#号</span></span></span><br><span class="line"><span class="type">char</span> <span class="class"><span class="keyword">class</span> =</span> <span class="string">&#x27;A&#x27;</span>;    <span class="comment">// 错误！class是关键字</span></span><br></pre></td></tr></table></figure><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li>能起名叫<code>_3D模型</code>吗？ → ✅ 可以（下划线开头+数字）  </li><li><code>UserName</code>和<code>username</code>是同一个变量吗？ → ❌ 不是（大小写敏感）  </li><li><code>支付宝到账$100</code>能当变量名吗？ → ❌ 不行（有$和中文，且C建议用英文）</li></ol><h2 id="📌-常量——像冰箱上的便利贴，贴完不能改"><a href="#📌-常量——像冰箱上的便利贴，贴完不能改" class="headerlink" title="📌 常量——像冰箱上的便利贴，贴完不能改"></a>📌 <strong>常量——像冰箱上的便利贴，贴完不能改</strong></h2><p><strong>作用</strong>：定义固定不变的值（比如圆周率π&#x3D;3.14），程序运行中禁止修改。</p><h3 id="🌰-生活化例子-1"><a href="#🌰-生活化例子-1" class="headerlink" title="🌰 生活化例子"></a>🌰 <strong>生活化例子</strong></h3><table><thead><tr><th>类型</th><th>例子</th><th>类比</th></tr></thead><tbody><tr><td>整型常量</td><td><code>const int 最大人数=100;</code></td><td>教室最多容纳100人</td></tr><tr><td>浮点型常量</td><td><code>const float 税率=0.05;</code></td><td>商品统一加5%税</td></tr><tr><td>字符常量</td><td><code>const char 换行=&#39;\n&#39;;</code></td><td>每次敲回车键的效果</td></tr><tr><td>字符串字面量</td><td><code>char 问候[]=&quot;你好呀&quot;;</code></td><td>自动加隐形句号（\0）</td></tr></tbody></table><p><strong>📢 重点提醒</strong>  </p><ul><li>字符串用<strong>双引号</strong>包裹，且末尾会悄悄加个<code>\0</code>（像快递单号末尾的结束符）  </li><li>修改常量会报错（就像撕掉冰箱贴换数字会被家人骂）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">float</span> PI = <span class="number">3.14</span>;</span><br><span class="line">PI = <span class="number">3.1415</span>; <span class="comment">// ❌ 错误！常量禁止修改</span></span><br></pre></td></tr></table></figure><hr><h2 id="🧰-运算符——代码的多功能瑞士军刀"><a href="#🧰-运算符——代码的多功能瑞士军刀" class="headerlink" title="🧰 运算符——代码的多功能瑞士军刀"></a>🧰 <strong>运算符——代码的多功能瑞士军刀</strong></h2><p><strong>作用</strong>：对数据进行各种操作（计算、比较、判断等）</p><h3 id="🔢-常见运算符分类"><a href="#🔢-常见运算符分类" class="headerlink" title="🔢 常见运算符分类"></a>🔢 <strong>常见运算符分类</strong></h3><table><thead><tr><th>类型</th><th>运算符示例</th><th>生活类比</th></tr></thead><tbody><tr><td><strong>算术</strong></td><td><code>+ - * / %</code></td><td>加减乘除（%是求余数）</td></tr><tr><td><strong>关系</strong></td><td><code>&gt; &lt; == !=</code></td><td>比身高、称体重判断是否达标</td></tr><tr><td><strong>逻辑</strong></td><td><code>&amp;&amp; || !</code></td><td>多重条件（比如”雨天&amp;&amp;带伞”）</td></tr><tr><td><strong>赋值</strong></td><td><code>= += -=</code></td><td>快捷操作（钱包+&#x3D;100 就是加钱）</td></tr><tr><td><strong>位运算</strong></td><td><code>&amp; | ^ ~</code></td><td>二进制开关操作（像电路板）</td></tr></tbody></table><h3 id="🌰-代码场景演示"><a href="#🌰-代码场景演示" class="headerlink" title="🌰 代码场景演示"></a>🌰 <strong>代码场景演示</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 钱包 = <span class="number">50</span>;</span><br><span class="line">钱包 += <span class="number">20</span>; <span class="comment">// ✅ 钱包变成70（等价于 钱包 = 钱包 + 20）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (温度 &gt; <span class="number">35</span> &amp;&amp; 有空调) &#123; </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;开空调！&quot;</span>);</span><br><span class="line">&#125; <span class="comment">// 同时满足高温和有空调才执行</span></span><br></pre></td></tr></table></figure><hr><h3 id="🚧-避坑指南"><a href="#🚧-避坑指南" class="headerlink" title="🚧 避坑指南"></a>🚧 <strong>避坑指南</strong></h3><ol><li><p><strong>字符串忘记\0</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> 错误写法[<span class="number">3</span>] = &#123;<span class="string">&#x27;A&#x27;</span>,<span class="string">&#x27;B&#x27;</span>,<span class="string">&#x27;C&#x27;</span>&#125;; <span class="comment">// ❌ 缺少\0，打印可能乱码</span></span><br><span class="line"><span class="type">char</span> 正确写法[] = <span class="string">&quot;ABC&quot;</span>;          <span class="comment">// ✅ 自动补\0</span></span><br></pre></td></tr></table></figure></li><li><p><strong>混淆&#x3D;和&#x3D;&#x3D;</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (身高 = <span class="number">180</span>) &#123; ... &#125;  <span class="comment">// ❌ 其实是赋值，永远为真</span></span><br><span class="line"><span class="keyword">if</span> (身高 == <span class="number">180</span>) &#123; ... &#125; <span class="comment">// ✅ 比较是否等于180</span></span><br></pre></td></tr></table></figure></li><li><p><strong>整数除法陷阱</strong>  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> 结果 = <span class="number">5</span> / <span class="number">2</span>;    <span class="comment">// ❌ 得到2而不是2.5</span></span><br><span class="line"><span class="type">float</span> 正确 = <span class="number">5.0</span> / <span class="number">2</span>;  <span class="comment">// ✅ 得到2.5</span></span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="🛠️-运算符优先级口诀"><a href="#🛠️-运算符优先级口诀" class="headerlink" title="🛠️ 运算符优先级口诀"></a>🛠️ <strong>运算符优先级口诀</strong></h3><blockquote><p>先算乘除再加减，逻辑比关系优先，括号永远最牛逼！<br>记不住就加<code>()</code>，就像用便签明确优先级。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> 迷惑计算 = <span class="number">3</span> + <span class="number">5</span> * <span class="number">2</span>;   <span class="comment">// 结果是13（先算5*2）</span></span><br><span class="line"><span class="type">int</span> 明确计算 = (<span class="number">3</span> + <span class="number">5</span>) * <span class="number">2</span>; <span class="comment">// 结果是16</span></span><br></pre></td></tr></table></figure><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li><code>&quot;Hello&quot;[5]</code>是什么？ → <code>\0</code>（字符串结尾隐身保镖）  </li><li><code>10 % 3</code>等于多少？ → 1（10除以3余1）  </li><li><code>价格 *= 0.8;</code> 等价于？ → 价格 &#x3D; 价格 * 0.8（打8折）</li></ol><h2 id="🔑-关键字——编程界的「禁用词库」"><a href="#🔑-关键字——编程界的「禁用词库」" class="headerlink" title="🔑 关键字——编程界的「禁用词库」"></a>🔑 <strong>关键字——编程界的「禁用词库」</strong></h2><p><strong>作用</strong>：这些单词是C语言预留的<strong>特殊指令</strong>，就像「红灯」「出口」不能随便当人名用。  </p><h3 id="🗂️-分类记忆法（重点掌握常用部分）"><a href="#🗂️-分类记忆法（重点掌握常用部分）" class="headerlink" title="🗂️ 分类记忆法（重点掌握常用部分）"></a>🗂️ <strong>分类记忆法</strong>（重点掌握常用部分）</h3><table><thead><tr><th><strong>类别</strong></th><th><strong>关键字举例</strong></th><th><strong>生活比喻</strong></th></tr></thead><tbody><tr><td><strong>数据类型</strong></td><td><code>int</code>, <code>char</code>, <code>float</code></td><td>不同容器（水杯、饭盒、油桶）</td></tr><tr><td><strong>流程控制</strong></td><td><code>if</code>, <code>for</code>, <code>switch</code></td><td>交通信号灯（停、转弯、直行）</td></tr><tr><td><strong>函数相关</strong></td><td><code>return</code>, <code>void</code></td><td>快递签收（返回包裹&#x2F;空手而归）</td></tr><tr><td><strong>存储方式</strong></td><td><code>static</code>, <code>extern</code></td><td>物品存放位置（固定柜子&#x2F;借隔壁东西）</td></tr><tr><td><strong>特殊操作</strong></td><td><code>sizeof</code>, <code>typedef</code></td><td>工具尺（测量大小）和贴标签（起别名）</td></tr></tbody></table><h3 id="🚫-绝对禁区示例"><a href="#🚫-绝对禁区示例" class="headerlink" title="🚫 绝对禁区示例"></a>🚫 <strong>绝对禁区示例</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="type">int</span> = <span class="number">5</span>;      <span class="comment">// ❌ 用关键字int当变量名 → 就像给孩子取名&quot;法律&quot;</span></span><br><span class="line"><span class="type">char</span> <span class="keyword">return</span> = <span class="string">&#x27;A&#x27;</span>; <span class="comment">// ❌ return是指令词 → 像用&quot;红灯&quot;当店名</span></span><br></pre></td></tr></table></figure><hr><h2 id="📏-空格规则——代码的呼吸感"><a href="#📏-空格规则——代码的呼吸感" class="headerlink" title="📏 空格规则——代码的呼吸感"></a>📏 <strong>空格规则——代码的呼吸感</strong></h2><p><strong>作用</strong>：让代码像排版优美的文章，既方便阅读，又能让编译器准确识别元素。</p><h3 id="✅-必须加空格的情况"><a href="#✅-必须加空格的情况" class="headerlink" title="✅ 必须加空格的情况"></a>✅ <strong>必须加空格的情况</strong></h3><ul><li><strong>关键字和变量名之间</strong> → 像中英文混写要加空格  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>年龄 = <span class="number">18</span>;   <span class="comment">// ❌ 报错！连体婴写法</span></span><br><span class="line"><span class="type">int</span> 年龄 = <span class="number">18</span>;  <span class="comment">// ✅ 正确间距</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="🌟-推荐加空格提升可读性"><a href="#🌟-推荐加空格提升可读性" class="headerlink" title="🌟 推荐加空格提升可读性"></a>🌟 <strong>推荐加空格提升可读性</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 紧凑写法（合法但费眼）</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 舒适写法（推荐！）</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="🚩-可灵活处理的场景"><a href="#🚩-可灵活处理的场景" class="headerlink" title="🚩 可灵活处理的场景"></a>🚩 <strong>可灵活处理的场景</strong></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">price=<span class="number">100</span>*<span class="number">2</span>;     <span class="comment">// ✅ 合法但拥挤</span></span><br><span class="line">price = <span class="number">100</span> * <span class="number">2</span>; <span class="comment">// ✅ 更易读（像数学公式空格）</span></span><br></pre></td></tr></table></figure><hr><h3 id="💡-记忆技巧"><a href="#💡-记忆技巧" class="headerlink" title="💡 记忆技巧"></a>💡 <strong>记忆技巧</strong></h3><ol><li><p><strong>关键字避雷口诀</strong>：  </p><blockquote><p>“改名叫int？立刻报错！<br>用switch当变量？电脑翻脸！”  </p></blockquote></li><li><p><strong>空格使用三字经</strong>：  </p><blockquote><p>关键字后必空格，运算符旁可加空，<br>长表达式分段空，就像呼吸要畅通。</p></blockquote></li></ol><hr><h3 id="🛠️-代码美容院（对比案例）"><a href="#🛠️-代码美容院（对比案例）" class="headerlink" title="🛠️ 代码美容院（对比案例）"></a>🛠️ <strong>代码美容院</strong>（对比案例）</h3><p><strong>丑代码</strong> → 诊断报告  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;<span class="type">int</span> x=<span class="number">5</span>;<span class="keyword">if</span>(x&gt;<span class="number">3</span>)&#123;<span class="built_in">printf</span>(<span class="string">&quot;大&quot;</span>);&#125;<span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure><p><strong>症状</strong>：无空格导致阅读困难，像一段乱码  </p><p><strong>帅代码</strong> → 优化方案  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>疗效</strong>：层次分明，像排版精致的文档  </p><hr><p><strong>附：测试你理解的灵魂三问</strong> 🧐  </p><ol><li>能写<code>float char = 3.14;</code>吗？ → ❌ <code>char</code>是关键字  </li><li><code>for(int i=0;;)</code>中间可以不加空格吗？ → ✅ 合法但建议加  </li><li><code>printf(&quot;hello&quot;);</code>需要在哪里加空格？ → 函数名和括号之间<strong>不需要</strong>（但参数内部按需加）</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C教程 </category>
          
          <category> C基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>雪中温情</title>
      <link href="/2024/12/07/%E9%9B%AA%E4%B8%AD%E6%B8%A9%E6%83%85/"/>
      <url>/2024/12/07/%E9%9B%AA%E4%B8%AD%E6%B8%A9%E6%83%85/</url>
      
        <content type="html"><![CDATA[<h1 id="今日分享"><a href="#今日分享" class="headerlink" title="今日分享"></a>今日分享</h1><p><strong>​在银装素裹的冬夜，我偶遇了一对母子，他们的身影在雪的映衬下显得格外温馨。母亲，一位勤劳的摊贩，她的摊前摆满了香气四溢的鸡锁骨。她带着她的儿子，一个活泼可爱的小男孩，他的眼睛里闪烁着对这个世界的好奇和对母亲的依恋。</strong></p><div style="text-align:center">  <img src="/img_1/91B55A345284EB58E47DC0743FA6AE1A.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>小男孩在雪地里尽情嬉戏，他的身上沾满了洁白的雪花，如同一个小雪人。母亲在忙碌之余，不忘关心儿子，她轻轻地为他拍去身上的雪，那一刹那，母爱的温暖在寒冷的冬夜里显得尤为珍贵。</strong></p><div style="text-align:center">  <img src="/img_1/A6945B877C3A3DA3CFE3CF7589FCB1DE.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>我有幸捕捉到了这温馨的一幕，小男孩在意识到我在拍照时，天真无邪地对母亲说：“妈妈，有人在拍我们。”他的话语中透露出一丝自豪和喜悦。</strong></p><div style="text-align:center">  <img src="/img_1/7AF6681739E006B43924C5B7B5A8462D.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>这两张照片，虽然拍摄时手指几乎冻僵，但它们记录下了这个冬天最温暖的瞬间。它们不仅仅是照片，更是母爱与童真的见证。</strong></p><div style="text-align:center">  <img src="/img_1/91B55A345284EB58E47DC0743FA6AE1A.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>“在这片洁白的雪地里，母爱如同暖阳，温暖着孩子的心。”愿这个冬天，每个人的心中都能感受到这样的温暖。</strong></p><div style="text-align:center">  <img src="/img_1/9E5D33BEB68998800BDE25186AAF14E5.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" >  <img src="/img_1/6134B2C6371C3279BB5DF95ADEC52336.jpg" alt="拍摄＆后期 By 码头" style="width:75%;" ></div><p><strong>​拍摄：码头</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B站被破解，请低调使用</title>
      <link href="/2024/11/29/B%E7%AB%99%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E8%AF%B7%E4%BD%8E%E8%B0%83%E4%BD%BF%E7%94%A8/"/>
      <url>/2024/11/29/B%E7%AB%99%E8%A2%AB%E7%A0%B4%E8%A7%A3%EF%BC%8C%E8%AF%B7%E4%BD%8E%E8%B0%83%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>大型企业的软件和网站往往配备了引人注目的标准界面设计。尽管如此，总有用户对这些UI不甚满意，他们追求个性化和新奇体验，希望通过改变界面来获得乐趣和新鲜感。</strong><br><strong>因此，一位技术大佬开发了一款针对B站的美化插件，旨在为用户提供一种全新的B站浏览体验。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：B站美化插件</strong><br><strong>适用设备：电脑</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p><strong>本站为大家提供的是压缩包，解压以后点击<code>Setup</code>即可下载</strong></p><div style="text-align:center">  <img src="\img_1\5C68DCBE3C8E99717155353FF085D9B5.jpg" alt="" style="width:70%;"></div><p><strong>另外，这款名为<code>bewbewly</code>的插件目前在Github，Chrome等插件商店平台上发布</strong><br><strong>使用起来非常方便，下载插件包后不需要进行解压操作。以微软的Edge浏览器为例，只需打开浏览器的“设置”菜单，然后选择“管理扩展”，就可以轻松访问插件管理页面了。</strong></p><div style="text-align:center">  <img src="\img_1\D573BFC7B69346307CE481D648219C40.jpg" alt="" style="width:70%;"></div><p><strong>首先点击开发者人员模式(按<code>F12</code>或者鼠标右键再点击<code>检查</code>),然后把提供的压缩包直接拉入，最后查看插件是否启用即可</strong></p><div style="text-align:center">  <img src="\img_1\FE0584FC6F5B7ECB067D461B0CD3D928.jpg" alt="" style="width:70%;"></div><p><strong>安装好插件以后，进入你的B站，会发现一个全新面貌的B站展现在你的眼前😏</strong></p><div style="text-align:center">  <img src="\img_1\6F25C57341F80B645AC0B89538E81814.jpg" alt="" style="width:70%;"></div><p><strong>这里举一个例子，我们可以通过右上角的按钮，可以很容易的实现在卡片视图和列表视图之间进行切换</strong></p><div style="text-align:center">  <img src="\img_1\64F0DF6D1D6D52B2F6B4C6B6A99847BC.gif" alt="" style="width:70%;"></div><p><strong>功能还有很多，这里就不一个一个进行阐述了，各位可以自行探索😉</strong></p><h1 id="获取方式"><a href="#获取方式" class="headerlink" title="获取方式"></a>获取方式</h1><p><strong><a href="https://wwso.lanzoub.com/i2qME2azcqbc">https://wwso.lanzoub.com/i2qME2azcqbc</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网盘限速？不存在的</title>
      <link href="/2024/11/22/%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/"/>
      <url>/2024/11/22/%E7%BD%91%E7%9B%98%E9%99%90%E9%80%9F%EF%BC%9F%E4%B8%8D%E5%AD%98%E5%9C%A8%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>在中国，网盘服务领域呈现出多样化的发展趋势，众多网盘品牌如雨后春笋般涌现，包括历史悠久的百度网盘、115网盘、天翼云盘，以及新兴的阿里云盘、夸克网盘和123网盘等。</strong></p><p><strong>然而，用户在使用这些服务时经常遇到一些不便，比如必须登录账户以及下载速度被严重限制等问题。</strong></p><p><strong>为了解决这些问题，一些技术高手开发了多种网盘下载加速工具，这些工具能够显著提升下载速度，让用户能够更充分地利用自己的网络带宽。今天，我将向大家介绍一款这样的工具，它可以帮助用户突破限制，实现高速下载。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：加速下载</strong><br><strong>适用设备：电脑</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h1 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h1><p><strong>在使用特定的网盘加速工具前，大家需要先暂时禁用电脑上的防火墙和安全软件，因为这些安全程序可能会误判这些工具为潜在威胁。接着，用户应将下载的压缩文件解压到桌面上。在启动这个旧版本的百度网盘客户端之前，务必确保已经关闭了电脑上所有其他版本的百度网盘，以避免它们之间发生冲突</strong></p><div style="text-align:center">  <img src="\img_1\DB13E5E57BD3E894FB8F62FCCAF70F37.jpg" alt="" style="width:60%;"></div><p><strong>在启动程序后，请耐心等待片刻，随后会出现登录窗口。此时，小伙伴们可以按照常规流程进行登录操作</strong></p><div style="text-align:center">  <img src="\img_1\F32A4CEF7C9677AD9C786394D2BAA00C.jpg" alt="" style="width:60%;"></div><p><strong>登录成功后，请返回到你之前解压的文件夹中。在继续操作之前，这里请确保你的计算机上所有的防火墙和杀毒软件都已经关闭，以避免它们干扰接下来的步骤。然后，右键点击加速补丁程序，并选择“以管理员身份运行”来启动它</strong></p><div style="text-align:center">  <img src="\img_1\50F03DA9F9FDD2187E22FAD2C7179116.jpg" alt="" style="width:60%;">  <img src="\img_1\DCA080102C2751A3882DB9D890331734.jpg" alt="" style="width:60%;"></div><p><strong>打开以后首先点击【恢复】</strong></p><div style="text-align:center">  <img src="\img_1\10F2DC664033E5999356934EA28B4A0A.jpg" alt="" style="width:60%;"></div><p><strong>在登录并确认安全软件已关闭后，就可以在百度网盘内选择一个文件进行下载。开始下载时，可能会发现速度较慢，这是正常现象。如果下载速度变得非常慢，你需要再次打开之前提到的加速补丁程序</strong></p><div style="text-align:center">  <img src="\img_1\D410659ACDB909E0E6BA5AC7DB232F49.jpg" alt="" style="width:60%;"></div><p><strong>这个时候大家再回到刚才的加速补丁，然后再点击【加速】按钮即可</strong></p><div style="text-align:center">  <img src="\img_1\3EE00D53D32D72D227CDCACD2C7A69BE.jpg" alt="" style="width:60%;"></div><p>当你回到下载界面时，会注意到进度条迅速增长，这意味着加速补丁正在起作用。请注意，<strong>这个过程中可能不会显示具体的下载速度，因此你需要通过观察进度条的移动来判断下载进度</strong></p><div style="text-align:center">  <img src="\img_1\FEB68AAD9641BB019E44DD3AE792BFEE.gif" alt="" style="width:60%;"></div>如果发现加速补丁没有效果，建议你检查是否所有的防火墙和杀毒软件都已完全关闭，有时候这些安全软件可能会阻止补丁的正常运行。<p>以上就是整个加速补丁的使用介绍。如果你对此感兴趣，可以尝试下载并按照上述步骤操作</p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="http://pan.poge.pro/d/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8C%85.rar">http://pan.poge.pro/d/%E7%94%B5%E8%84%91%E8%BD%AF%E4%BB%B6/%E7%99%BE%E5%BA%A6%E7%BD%91%E7%9B%98%E5%8C%85.rar</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 网盘下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++接口(抽象类)</title>
      <link href="/2024/11/22/C-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
      <url>/2024/11/22/C-%E6%8E%A5%E5%8F%A3-%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是C++面向对象的最后一节内容，本节内容将会用到前面类的相关知识以及<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.tomatou.xyz/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><hr><h1 id="C-接口（抽象类）"><a href="#C-接口（抽象类）" class="headerlink" title="C++ 接口（抽象类）"></a>C++ 接口（抽象类）</h1><p>在 C++ 中，<strong>接口</strong>是一种“<strong>规定一类事物应该具备什么功能</strong>”的方式。可以将接口比作“合同”或“蓝图”，它描述了类的功能和行为，但不关心具体如何实现。</p><p>在 C++ 中，接口通常通过<strong>抽象类（Abstract Class）</strong>来实现。抽象类就像建筑的“蓝图”：它定义了应该做什么，但不告诉你怎么做。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#what-is-an-abstract-class">什么是抽象类？</a></li><li><a href="#why-abstract-classes">为什么需要抽象类？</a></li><li><a href="#rules-for-abstract-classes">抽象类的规则</a></li><li><a href="#use-cases-for-abstract-classes">抽象类的使用场景</a></li><li><a href="#examples-of-abstract-classes">抽象类的实例</a></li><li><a href="#wrong-example">常见错误示例</a></li><li><a href="#comparison-between-abstract-classes-and-interfaces">抽象类与接口的比较</a></li><li><a href="#importance-of-virtual-destructors">虚析构函数的重要性</a></li><li><a href="#summary">总结</a></li></ul><hr><h2 id="what-is-an-abstract-class">什么是抽象类？</h2><p>抽象类是一种<strong>不能直接用来创建对象</strong>的特殊类，主要用来给其他类提供标准或模板。</p><p><strong>关键特性</strong>：</p><ol><li><strong>至少包含一个纯虚函数</strong>：抽象类中至少有一个函数是“纯虚函数”。</li><li><strong>纯虚函数的定义</strong>：纯虚函数是一种特殊的函数，它只有声明，没有实现，写法是<code>= 0</code>。</li></ol><h3 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，定义了一个必须实现的接口</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的类<code>Shape</code>就是一个抽象类，<code>getArea()</code>函数只是告诉其他类“你必须提供计算面积的功能”，但并没有实现具体的计算方法。</p><hr><h2 id="why-abstract-classes">为什么需要抽象类？</h2><p>抽象类的主要目的是<strong>定义接口</strong>，而不是实现细节。它告诉子类“你必须做这些事情，但怎么做由你决定”。这样可以：</p><ol><li><strong>统一标准</strong>：确保不同的子类都有一致的功能。</li><li><strong>代码灵活</strong>：子类可以用自己的方式实现这些功能。</li><li><strong>避免错误</strong>：如果某个子类没有实现必要的功能，编译器会报错。</li></ol><h3 id="类比说明"><a href="#类比说明" class="headerlink" title="类比说明"></a>类比说明</h3><p>想象一下，你是一家汽车制造厂的设计师，制定了一份“汽车设计蓝图”（抽象类），规定了汽车必须有发动机、车轮等基本部件，但具体的发动机类型和车轮设计由不同的制造部门负责。这确保了所有汽车都具备基本功能，但具体实现可以多样化。</p><hr><h2 id="rules-for-abstract-classes">抽象类的规则</h2><ul><li><strong>至少包含一个纯虚函数</strong>：抽象类中的函数<code>= 0</code>，表示这个函数是纯虚函数，必须在子类中实现。</li><li><strong>不能直接创建对象</strong>：无法用抽象类创建实例，如果尝试这么做，编译器会报错。</li><li><strong>必须在子类中实现纯虚函数</strong>：子类如果没有实现纯虚函数，也会被当成抽象类，不能实例化。</li></ul><h3 id="举个例子-1"><a href="#举个例子-1" class="headerlink" title="举个例子"></a>举个例子</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数，子类必须实现</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 实现纯虚函数</span></span><br><span class="line">        <span class="keyword">return</span> width * height;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDimensions</span><span class="params">(<span class="type">int</span> w, <span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        width = w;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Shape shape;  // 错误：不能实例化抽象类</span></span><br><span class="line">    Rectangle rect;</span><br><span class="line">    rect.<span class="built_in">setDimensions</span>(<span class="number">5</span>, <span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;  <span class="comment">// 输出：Area: 35</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ol><li>抽象类<code>Shape</code>定义了接口<code>getArea()</code>，但没有实现。</li><li>子类<code>Rectangle</code>实现了<code>getArea()</code>，所以它可以创建实例并使用。</li><li>尝试实例化<code>Shape</code>会导致编译错误，确保接口不能被滥用。</li></ol><hr><h2 id="use-cases-for-abstract-classes">抽象类的使用场景</h2><p>抽象类通常用来：</p><ol><li><strong>统一子类功能</strong>：确保所有子类都有某些共同的功能。</li><li><strong>提供灵活性</strong>：允许子类根据自己的需求，用不同的方式实现这些功能。</li><li><strong>扩展系统</strong>：以后可以很容易地添加新的子类，而不会影响现有代码。</li></ol><h3 id="实际应用示例"><a href="#实际应用示例" class="headerlink" title="实际应用示例"></a>实际应用示例</h3><p>假设你在开发一个图形编辑软件，需要处理多种形状（如矩形、圆形、三角形等）。你可以创建一个抽象类<code>Shape</code>，定义所有形状必须具备的接口，如<code>getArea()</code>和<code>draw()</code>，然后各个具体形状类继承<code>Shape</code>并实现这些接口。</p><hr><h2 id="examples-of-abstract-classes">抽象类的实例</h2><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>假设我们有一个基类<code>Shape</code>，它代表一个形状，并定义了一个接口<code>getArea()</code>。然后我们用它的两个子类<code>Rectangle</code>（矩形）和<code>Triangle</code>（三角形）分别实现计算面积的功能。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 纯虚函数：定义接口，但不实现</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">        width = w;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123;</span><br><span class="line">        height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 虚析构函数，确保子类对象被正确销毁</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123;&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：矩形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> width * height;  <span class="comment">// 矩形面积公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类：三角形</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (width * height) / <span class="number">2</span>;  <span class="comment">// 三角形面积公式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Rectangle rect;</span><br><span class="line">    Triangle tri;</span><br><span class="line"></span><br><span class="line">    rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">    rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Rectangle Area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tri.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">    tri.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Triangle Area: &quot;</span> &lt;&lt; tri.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试实例化抽象类将导致编译错误</span></span><br><span class="line">    <span class="comment">// Shape shape;  // 错误：无法实例化抽象类</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle Area: 35</span><br><span class="line">Triangle Area: 17</span><br></pre></td></tr></table></figure><h3 id="解释："><a href="#解释：" class="headerlink" title="解释："></a>解释：</h3><ol><li>抽象类<code>Shape</code>定义了计算面积的接口<code>getArea()</code>，并且提供了设置宽度和高度的方法。</li><li>子类<code>Rectangle</code>和<code>Triangle</code>分别实现了<code>getArea()</code>，用自己的公式计算面积。</li><li>主程序中通过接口调用<code>getArea()</code>，而不需要关心子类的具体实现。</li></ol><hr><h2 id="wrong-example">常见错误示例</h2><p>为了更好地理解抽象类的限制，来看几个常见的错误示例。</p><h3 id="1-尝试实例化抽象类"><a href="#1-尝试实例化抽象类" class="headerlink" title="1. 尝试实例化抽象类"></a>1. 尝试实例化抽象类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape shape;  <span class="comment">// 错误：无法实例化抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot declare variable ‘shape’ to be of abstract type ‘Shape’</span><br></pre></td></tr></table></figure><h3 id="2-子类未实现所有纯虚函数"><a href="#2-子类未实现所有纯虚函数" class="headerlink" title="2. 子类未实现所有纯虚函数"></a>2. 子类未实现所有纯虚函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IncompleteShape</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="comment">// 未实现 getArea()</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    IncompleteShape ishape;  <span class="comment">// 错误：IncompleteShape 仍然是抽象类</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误信息</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: cannot declare variable ‘ishape’ to be of abstract type ‘IncompleteShape’</span><br></pre></td></tr></table></figure><hr><h2 id="comparison-between-abstract-classes-and-interfaces">抽象类与接口的比较</h2>虽然 C++ 没有明确的“接口”关键字，但抽象类可以用来实现接口的功能。<ul><li><p><strong>抽象类</strong>：</p><ul><li>可以包含成员变量和已实现的成员函数。</li><li>适用于需要共享代码和数据的场景。</li></ul></li><li><p><strong>接口（通过纯虚类实现）</strong>：</p><ul><li>只包含纯虚函数，不包含成员变量。</li><li>适用于仅需要定义行为规范的场景。</li></ul></li></ul><h3 id="示例：接口类"><a href="#示例：接口类" class="headerlink" title="示例：接口类"></a>示例：接口类</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">IPrintable</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">IPrintable</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> : <span class="keyword">public</span> IPrintable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Printing Document&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="importance-of-virtual-destructors">虚析构函数的重要性</h2><p>在抽象类中定义虚析构函数，确保通过基类指针删除子类对象时，子类的析构函数能够被正确调用，防止资源泄漏。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() &#123; cout &lt;&lt; <span class="string">&quot;Shape Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    ~<span class="built_in">Rectangle</span>() &#123; cout &lt;&lt; <span class="string">&quot;Rectangle Destructor&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> width;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line">    <span class="keyword">delete</span> shape;  </span><br><span class="line">    <span class="comment">// 输出：</span></span><br><span class="line">    <span class="comment">// Rectangle Destructor</span></span><br><span class="line">    <span class="comment">// Shape Destructor</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>Shape</code>的析构函数不是虚函数，删除<code>shape</code>时只会调用<code>Shape</code>的析构函数，导致<code>Rectangle</code>的析构函数未被调用，可能引发资源泄漏。</p><hr><h2 id="summary">总结</h2><p>抽象类在面向对象编程中扮演着重要角色，它提供了一个统一的接口，确保所有子类实现特定的功能。通过使用抽象类，可以：</p><ul><li><strong>强制性</strong>：确保子类实现必要的功能，避免遗漏。</li><li><strong>代码复用</strong>：在抽象类中实现通用功能，子类只需专注于特定部分。</li><li><strong>灵活性和扩展性</strong>：方便添加新功能或子类，而不影响现有代码。</li><li><strong>易于维护</strong>：外界依赖于抽象类提供的接口，内部实现可以灵活变化。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++数据封装</title>
      <link href="/2024/11/22/C-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/"/>
      <url>/2024/11/22/C-%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.tomatou.xyz/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><h1 id="数据封装（Data-Encapsulation）：将数据安全地锁在盒子里"><a href="#数据封装（Data-Encapsulation）：将数据安全地锁在盒子里" class="headerlink" title="数据封装（Data Encapsulation）：将数据安全地锁在盒子里"></a><strong>数据封装（Data Encapsulation）：将数据安全地锁在盒子里</strong></h1><p>数据封装是面向对象编程（OOP）中的一个核心概念，它不仅可以提高代码的安全性和灵活性，还能使程序更易于维护和理解。为了让这个概念更容易理解，我们可以把数据封装比作“<strong>把数据和操作这些数据的方法放在一个盒子里，锁上盖子，只留一个钥匙孔</strong>”。外界只能通过钥匙孔（也就是类提供的公共方法）来操作盒子里的内容。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#cpp-program-structure">C++ 程序的基本构成</a></li><li><a href="#core-concepts-of-encapsulation">数据封装的核心思想</a></li><li><a href="#class-definition-and-access-modifiers">类的定义及访问修饰符</a></li><li><a href="#example">数据封装的具体例子</a></li><li><a href="#difference-between-encapsulation-and-data-hiding">数据封装与数据隐藏的区别</a></li><li><a href="#getter-and-setter">封装与访问器 (Getter) 和修改器 (Setter)</a></li><li><a href="#advantages-of-encapsulation">数据封装的优点</a></li><li><a href="#design-recommendations">设计建议</a></li><li><a href="#real-world-encapsulation-examples">数据封装的现实类比</a></li><li><a href="#summary">总结</a></li></ul><h2 id="cpp-program-structure">C++ 程序的基本构成</h2><p>在深入了解数据封装之前，先回顾一下 C++ 程序的两个基本组成部分：</p><ol><li><strong>程序语句（代码）</strong>：负责执行具体的操作，如计算、输出、存储等。这些操作通常由函数实现。</li><li><strong>程序数据</strong>：程序需要处理的信息，如数字、字符、字符串等。</li></ol><p><strong>数据封装</strong>就是将这两部分<strong>绑定在一起</strong>，将数据和操作数据的代码打包成一个整体。</p><hr><h2 id="core-concepts-of-encapsulation">数据封装的核心思想</h2><h3 id="2-1-绑定数据和方法"><a href="#2-1-绑定数据和方法" class="headerlink" title="2.1 绑定数据和方法"></a><strong>2.1 绑定数据和方法</strong></h3><ul><li><strong>类（Class）</strong>：在 C++ 中，类是实现数据封装的基本单位。它将数据（属性）和操作这些数据的方法（函数）封装在一起。</li><li><strong>成员变量（属性）</strong>：类中的数据部分，用于存储对象的状态。</li><li><strong>成员函数（方法）</strong>：类中的函数部分，用于定义对象的行为。</li></ul><h3 id="2-2-隐藏内部实现"><a href="#2-2-隐藏内部实现" class="headerlink" title="2.2 隐藏内部实现"></a><strong>2.2 隐藏内部实现</strong></h3><ul><li><strong>访问控制符</strong>：通过设置 <code>public</code>、<code>private</code>、<code>protected</code> 等访问控制符，控制外部代码对类成员的访问权限。<ul><li><strong><code>private</code>（私有）</strong>：只能在类的内部访问，外部无法直接访问。</li><li><strong><code>public</code>（公有）</strong>：可以在任何地方访问。</li><li><strong><code>protected</code>（受保护）</strong>：在类内部和派生类中访问，外部无法直接访问。</li></ul></li></ul><h3 id="2-3-通过接口操作数据"><a href="#2-3-通过接口操作数据" class="headerlink" title="2.3 通过接口操作数据"></a><strong>2.3 通过接口操作数据</strong></h3><ul><li><strong>公共接口（钥匙孔）</strong>：类对外提供的 <code>public</code> 方法，外部只能通过这些方法与类交互，无法直接访问内部的 <code>private</code> 数据。</li><li><strong>好处</strong>：<ul><li><strong>安全性</strong>：防止外部代码直接修改内部数据，保护数据完整性。</li><li><strong>灵活性</strong>：可以在方法中添加数据验证、日志记录等功能。</li><li><strong>可维护性</strong>：修改内部实现细节时，不影响外部代码。</li></ul></li></ul><hr><h2 id="class-definition-and-access-modifiers">类的定义及访问修饰符</h2><h3 id="3-1-类的基本结构"><a href="#3-1-类的基本结构" class="headerlink" title="3.1 类的基本结构"></a><strong>3.1 类的基本结构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量和方法</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="comment">// 受保护的成员变量和方法</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员变量和方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-示例：一个简单的盒子类"><a href="#3-2-示例：一个简单的盒子类" class="headerlink" title="3.2 示例：一个简单的盒子类"></a><strong>3.2 示例：一个简单的盒子类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 设置盒子的尺寸</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setDimensions</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span> </span>&#123;</span><br><span class="line">        length = len;</span><br><span class="line">        breadth = bre;</span><br><span class="line">        height = hei;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算盒子的体积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>私有成员变量</strong>：<code>length</code>、<code>breadth</code>、<code>height</code>，外部无法直接访问或修改。</li><li><strong>公有成员函数</strong>：<code>setDimensions()</code> 和 <code>getVolume()</code>，提供与外部交互的接口。</li></ul><hr><h2 id="difference-between-encapsulation-and-data-hiding">数据封装与数据隐藏的区别</h2><ul><li><strong>数据封装（Encapsulation）</strong>：将数据和操作数据的方法绑定在一起，形成一个类。</li><li><strong>数据隐藏（Data Hiding）</strong>：通过访问控制符，隐藏类的内部实现细节，只暴露必要的接口。</li></ul><p><strong>总结</strong>：数据封装强调的是将数据和方法封装在一起，数据隐藏强调的是对外部隐藏内部细节。两者共同实现了面向对象编程的封装特性。</p><hr><h2 id="example">数据封装的具体例子</h2><h3 id="5-1-示例代码：加法器类"><a href="#5-1-示例代码：加法器类" class="headerlink" title="5.1 示例代码：加法器类"></a><strong>5.1 示例代码：加法器类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化总和</span></span><br><span class="line">    <span class="built_in">Adder</span>(<span class="type">int</span> i = <span class="number">0</span>) &#123;</span><br><span class="line">        total = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加一个数字到总和</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        total += number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取总和</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getTotal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> total; <span class="comment">// 总和变量，外部不能直接修改</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Adder a;</span><br><span class="line"></span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">10</span>); <span class="comment">// 通过 addNum 添加数字</span></span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">20</span>);</span><br><span class="line">    a.<span class="built_in">addNum</span>(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Total: &quot;</span> &lt;&lt; a.<span class="built_in">getTotal</span>() &lt;&lt; endl; <span class="comment">// 输出 Total: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total: 60</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ol><li><strong>私有成员变量</strong>：<code>total</code>，用于存储总和，外部无法直接访问或修改。</li><li><strong>公有成员函数</strong>：<ul><li><code>addNum(int number)</code>：用于向总和添加数字。</li><li><code>getTotal()</code>：用于获取当前的总和。</li></ul></li><li><strong>好处</strong>：<ul><li><strong>保护性</strong>：防止外部直接修改 <code>total</code>，确保数据的安全性。</li><li><strong>灵活性</strong>：可以在 <code>addNum()</code> 中添加数据验证或其他逻辑，而不影响外部代码。</li></ul></li></ol><hr><h2 id="getter-and-setter">封装与访问器 (Getter) 和修改器 (Setter)</h2><h3 id="6-1-什么是-Getter-和-Setter"><a href="#6-1-什么是-Getter-和-Setter" class="headerlink" title="6.1 什么是 Getter 和 Setter"></a><strong>6.1 什么是 Getter 和 Setter</strong></h3><ul><li><strong>Getter（访问器）</strong>：用于获取私有成员变量的值。</li><li><strong>Setter（修改器）</strong>：用于设置私有成员变量的值，通常包含数据验证。</li></ul><h3 id="6-2-示例代码：学生类"><a href="#6-2-示例代码：学生类" class="headerlink" title="6.2 示例代码：学生类"></a><strong>6.2 示例代码：学生类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string studentName, <span class="type">int</span> studentAge) &#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">        <span class="built_in">setAge</span>(studentAge); <span class="comment">// 使用 Setter 进行数据验证</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取姓名（Getter）</span></span><br><span class="line">    <span class="function">string <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取年龄（Getter）</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改姓名（Setter）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setName</span><span class="params">(string studentName)</span> </span>&#123;</span><br><span class="line">        name = studentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 修改年龄（Setter）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setAge</span><span class="params">(<span class="type">int</span> studentAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (studentAge &gt; <span class="number">0</span> &amp;&amp; studentAge &lt; <span class="number">120</span>) &#123;</span><br><span class="line">            age = studentAge;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;年龄无效，设置为默认年龄 18。&quot;</span> &lt;&lt; endl;</span><br><span class="line">            age = <span class="number">18</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印学生信息</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, 年龄: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个 Student 对象</span></span><br><span class="line">    <span class="function">Student <span class="title">student1</span><span class="params">(<span class="string">&quot;Alice&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问和修改数据</span></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setName</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setAge</span>(<span class="number">22</span>);</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试设置无效年龄</span></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">setAge</span>(<span class="number">-5</span>);</span><br><span class="line"></span><br><span class="line">    student<span class="number">1.</span><span class="built_in">printInfo</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名: Alice, 年龄: 20</span><br><span class="line">姓名: Bob, 年龄: 22</span><br><span class="line">年龄无效，设置为默认年龄 18。</span><br><span class="line">姓名: Bob, 年龄: 18</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><strong>数据验证</strong>：<code>setAge()</code> 方法中添加了年龄范围的检查，确保数据合法性。</li><li><strong>信息隐藏</strong>：<code>name</code> 和 <code>age</code> 是私有的，外部无法直接访问，只能通过 Getter 和 Setter 方法操作。</li><li><strong>灵活性</strong>：可以在 Setter 方法中添加更多逻辑，如日志记录、通知等。</li></ul><hr><h2 id="advantages-of-encapsulation">数据封装的优点</h2><ol><li><strong>数据隐藏</strong>：防止外部直接访问和修改内部数据，保护对象的状态。</li><li><strong>增强安全性</strong>：通过 Getter 和 Setter，可以在修改数据时进行验证，防止非法输入。</li><li><strong>提高可维护性</strong>：内部实现可以随时更改，而不影响外部代码，只要公共接口保持不变。</li><li><strong>实现抽象</strong>：使用者只需了解如何使用公共接口，无需关心内部实现细节。</li><li><strong>降低耦合度</strong>：外部代码与类的内部实现解耦，提高代码的模块化和可重用性。</li></ol><hr><h2 id="design-recommendations">设计建议</h2><ol><li><strong>将类的成员变量设置为私有（<code>private</code>）</strong>：防止外部直接访问，保护数据完整性。</li><li><strong>通过公共接口（<code>public</code> 方法）操作数据</strong>：提供受控的方式与外部交互，便于添加验证和逻辑控制。</li><li><strong>使用 Getter 和 Setter</strong>：控制对数据的访问和修改，确保数据的合法性和一致性。</li><li><strong>隐藏实现细节</strong>：外部无需知道类的内部如何实现，只需了解如何使用公共接口。</li><li><strong>遵循单一职责原则</strong>：每个类只负责一项功能，保持代码的高内聚性和低耦合性。</li></ol><hr><h2 id="real-world-encapsulation-examples">数据封装的现实类比</h2>### **9.1 银行账户**<ul><li><strong>你可以做的操作</strong>：<ul><li>存款、取款、查询余额。</li></ul></li><li><strong>你无法做的操作</strong>：<ul><li>直接修改银行数据库中的账户余额。</li></ul></li><li><strong>解释</strong>：银行系统将账户余额等敏感数据封装起来，客户只能通过受控的方式（ATM、网上银行）进行操作，确保资金安全。</li></ul><h3 id="9-2-家用电器"><a href="#9-2-家用电器" class="headerlink" title="9.2 家用电器"></a><strong>9.2 家用电器</strong></h3><ul><li><strong>你可以做的操作</strong>：<ul><li>按下按钮打开或关闭设备，调整设置。</li></ul></li><li><strong>你无法做的操作</strong>：<ul><li>直接干涉设备内部的电路或程序。</li></ul></li><li><strong>解释</strong>：设备的内部实现对用户是隐藏的，用户只能通过提供的接口（按钮、遥控器）与设备交互。</li></ul><hr><h2 id="summary">总结</h2><p>数据封装是面向对象编程的重要特性，它通过将数据和操作数据的方法封装在一起，并隐藏内部实现细节，实现了数据的保护和代码的灵活性。</p><ul><li><strong>核心思想</strong>：将数据和方法绑定在一起，隐藏内部细节，只通过公共接口与外界交互。</li><li><strong>实现方式</strong>：使用类和访问控制符，定义私有成员和公有方法。</li><li><strong>优势</strong>：<ul><li>提高安全性，保护数据完整性。</li><li>增强代码的可维护性和可扩展性。</li><li>降低耦合度，实现模块化编程。</li><li>提供数据验证，确保数据合法性。</li></ul></li></ul><p>通过合理运用数据封装，我们可以编写出更健壮、更易于维护的代码，使程序具备更高的质量和灵活性。</p><hr><p><strong>如果你还有任何疑问，或者需要进一步的解释，欢迎随时提问！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据抽象</title>
      <link href="/2024/11/22/C-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
      <url>/2024/11/22/C-%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.tomatou.xyz/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><h1 id="C-数据抽象：只展示必要的，隐藏复杂的"><a href="#C-数据抽象：只展示必要的，隐藏复杂的" class="headerlink" title="C++ 数据抽象：只展示必要的，隐藏复杂的"></a><strong>C++ 数据抽象：只展示必要的，隐藏复杂的</strong></h1><p><strong>数据抽象</strong>是面向对象编程（OOP）中的一个基本概念，它有助于使程序更易于管理、更安全且更易于理解。核心思想是<strong>只向外界展示对象的必要特性，隐藏内部的实现细节</strong>。这使得类的使用者可以通过简单的接口与其交互，而无需了解其内部工作方式。</p><hr><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><strong>目录</strong></h2><ul><li><a href="#intro-what-is-abstraction">引言：什么是数据抽象？</a></li><li><a href="#real-life-examples">现实生活中的类比</a></li><li><a href="#cpp-implementation">C++ 中的数据抽象如何实现</a></li><li><a href="#cpp-access-control">C++ 的访问控制特性</a></li><li><a href="#benefits-of-abstraction">数据抽象的好处</a></li><li><a href="#example-bank-account">示例：构建一个简单的银行账户类</a></li><li><a href="#code-analysis">代码解析</a></li><li><a href="#design-strategies">数据抽象的设计策略</a></li><li><a href="#common-errors">常见错误及如何避免</a></li><li><a href="#summary">总结</a></li><li><a href="#Think">最后的思考</a></li></ul><hr><h2 id="intro-what-is-abstraction">引言：什么是数据抽象？</h2><p>在编程中，数据抽象指的是只向外界提供必要的信息，隐藏背景细节。这是一种通过隐藏底层细节来减少编程复杂性和工作量的方法。在 C++ 中，数据抽象是通过类和访问控制符来实现的。</p><hr><h2 id="real-life-examples">现实生活中的类比</h2><p>为了更好地理解数据抽象，我们来看一个现实生活中的例子：<strong>自动售货机</strong>。</p><ul><li><p><strong>你需要知道的：</strong></p><ul><li>投入硬币或纸币。</li><li>按下按钮选择商品。</li><li>取走商品和找零。</li></ul></li><li><p><strong>你不需要知道的：</strong></p><ul><li>机器如何识别货币。</li><li>机械臂如何将商品推到出口。</li><li>内部的库存管理系统如何运作。</li></ul></li></ul><p>自动售货机将复杂的内部流程抽象掉，提供了简单的界面（投币口、按钮和取货口）供你使用。</p><hr><h2 id="cpp-implementation">C++ 中的数据抽象如何实现</h2><p>在 C++ 中，数据抽象是通过<strong>类（class）</strong>来实现的。类将数据和操作数据的函数封装在一起。通过控制对类成员的访问，我们可以隐藏内部的工作方式，只暴露必要的部分。</p><h3 id="类的结构"><a href="#类的结构" class="headerlink" title="类的结构"></a><strong>类的结构</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 类名 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 公有成员（接口）</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员（实现细节）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="cpp-access-control">C++ 的访问控制符</h2><p>访问控制符定义了类成员的访问权限。C++ 提供了三个访问控制符：</p><h3 id="公有成员（public）"><a href="#公有成员（public）" class="headerlink" title="公有成员（public）"></a><strong>公有成员（public）</strong></h3><ul><li><strong>语法：</strong> <code>public:</code></li><li><strong>描述：</strong> 在 <code>public</code> 下声明的成员可以在任何地方访问，只要对象是可见的。</li><li><strong>用途：</strong> 定义类的接口，供外部使用的函数和变量。</li></ul><h3 id="私有成员（private）"><a href="#私有成员（private）" class="headerlink" title="私有成员（private）"></a><strong>私有成员（private）</strong></h3><ul><li><strong>语法：</strong> <code>private:</code></li><li><strong>描述：</strong> 在 <code>private</code> 下声明的成员只能在类的内部访问。</li><li><strong>用途：</strong> 存储内部数据和辅助函数，不希望被外部直接访问。</li></ul><h3 id="受保护成员（protected）"><a href="#受保护成员（protected）" class="headerlink" title="受保护成员（protected）"></a><strong>受保护成员（protected）</strong></h3><ul><li><strong>语法：</strong> <code>protected:</code></li><li><strong>描述：</strong> 在 <code>protected</code> 下声明的成员可以在类内部和派生类中访问，但不能在其他地方访问。</li><li><strong>用途：</strong> 当设计一个类的继承体系，需要子类访问某些但不希望公开的成员时使用。</li></ul><hr><h2 id="benefits-of-abstraction">数据抽象的好处</h2><ol><li><strong>安全性：</strong> 隐藏对象的内部状态，防止未经授权的访问和修改。</li><li><strong>简化：</strong> 用户可以通过简单的接口与对象交互，无需关心复杂的内部逻辑。</li><li><strong>可维护性：</strong> 内部实现的改变不会影响使用该类的代码。</li><li><strong>模块化：</strong> 鼓励关注点分离，使代码更加有组织。</li><li><strong>灵活性：</strong> 允许开发者在不改变外部交互方式的情况下更改内部工作方式。</li></ol><hr><h2 id="example-bank-account">示例：构建一个简单的银行账户类</h2><p>让我们创建一个 <code>BankAccount</code>（银行账户）类，来演示 C++ 中的数据抽象。</p><h3 id="BankAccount-类的规范"><a href="#BankAccount-类的规范" class="headerlink" title="BankAccount 类的规范"></a><strong>BankAccount 类的规范</strong></h3><ul><li><p><strong>公有接口：</strong></p><ul><li><code>deposit(double amount)</code>：存款</li><li><code>withdraw(double amount)</code>：取款</li><li><code>getBalance()</code>：获取余额</li></ul></li><li><p><strong>私有成员：</strong></p><ul><li><code>balance</code>（余额）：用于存储账户余额的变量</li></ul></li></ul><hr><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BankAccount</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 构造函数，初始化账户，默认余额为 0.0</span></span><br><span class="line">    <span class="built_in">BankAccount</span>(<span class="type">double</span> initialBalance = <span class="number">0.0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (initialBalance &gt;= <span class="number">0.0</span>) &#123;</span><br><span class="line">            balance = initialBalance;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            balance = <span class="number">0.0</span>;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;初始余额无效。已将余额设为 0.0\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：存款</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deposit</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">            balance += amount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;存款金额必须为正数。\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：取款</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">withdraw</span><span class="params">(<span class="type">double</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0.0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (amount &lt;= balance) &#123;</span><br><span class="line">                balance -= amount;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                std::cerr &lt;&lt; <span class="string">&quot;余额不足。\n&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;取款金额必须为正数。\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公有方法：获取余额</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getBalance</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> balance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 私有成员变量：余额</span></span><br><span class="line">    <span class="type">double</span> balance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h3 id="使用-BankAccount-类"><a href="#使用-BankAccount-类" class="headerlink" title="使用 BankAccount 类"></a><strong>使用 BankAccount 类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">BankAccount <span class="title">myAccount</span><span class="params">(<span class="number">100.0</span>)</span></span>;  <span class="comment">// 创建一个初始余额为 $100 的账户</span></span><br><span class="line"></span><br><span class="line">    myAccount.<span class="built_in">deposit</span>(<span class="number">50.0</span>);       <span class="comment">// 存款 $50</span></span><br><span class="line">    myAccount.<span class="built_in">withdraw</span>(<span class="number">20.0</span>);      <span class="comment">// 取款 $20</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;当前余额: $&quot;</span> &lt;&lt; myAccount.<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    myAccount.<span class="built_in">withdraw</span>(<span class="number">150.0</span>);     <span class="comment">// 尝试取款 $150（应当失败）</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最终余额: $&quot;</span> &lt;&lt; myAccount.<span class="built_in">getBalance</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>预期输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当前余额: $130</span><br><span class="line">余额不足。</span><br><span class="line">最终余额: $130</span><br></pre></td></tr></table></figure><hr><h2 id="code-analysis">代码解析</h2><h3 id="7-1-公有接口"><a href="#7-1-公有接口" class="headerlink" title="7.1 公有接口"></a><strong>7.1 公有接口</strong></h3><ul><li><p><strong>构造函数 <code>BankAccount(double initialBalance = 0.0)</code></strong></p><ul><li>用于初始化账户，允许指定初始余额。</li><li>验证初始余额是否为非负数。</li><li>如果初始余额无效，设置余额为 0.0，并输出错误信息。</li></ul></li><li><p><strong><code>deposit(double amount)</code></strong></p><ul><li>允许用户向账户存款。</li><li>验证存款金额为正数。</li><li>更新余额。</li><li>如果金额无效，输出错误信息。</li></ul></li><li><p><strong><code>withdraw(double amount)</code></strong></p><ul><li>允许用户从账户取款。</li><li>检查取款金额为正数且余额足够。</li><li>如果取款成功，更新余额。</li><li>如果金额无效或余额不足，输出错误信息。</li></ul></li><li><p><strong><code>getBalance() const</code></strong></p><ul><li>返回当前余额。</li><li>使用 <code>const</code>，表示此方法不会修改对象的状态。</li></ul></li></ul><h3 id="7-2-私有成员"><a href="#7-2-私有成员" class="headerlink" title="7.2 私有成员"></a><strong>7.2 私有成员</strong></h3><ul><li><strong><code>double balance</code></strong><ul><li>存储账户的当前余额。</li><li>声明为 <code>private</code>，防止外部代码直接修改。</li><li>确保所有对 <code>balance</code> 的更改都通过受控的方法进行。</li></ul></li></ul><h3 id="7-3-为什么要使用数据抽象？"><a href="#7-3-为什么要使用数据抽象？" class="headerlink" title="7.3 为什么要使用数据抽象？"></a><strong>7.3 为什么要使用数据抽象？</strong></h3><ul><li><p><strong>封装余额：</strong></p><ul><li>通过将 <code>balance</code> 设为私有，防止外部代码将其设置为无效值（例如负数）。</li><li>用户不能直接操作余额，必须通过提供的方法，这些方法包含了必要的验证。</li></ul></li><li><p><strong>受控访问：</strong></p><ul><li>所有对 <code>balance</code> 的操作都通过 <code>deposit</code>、<code>withdraw</code> 和 <code>getBalance</code> 进行。</li><li>确保数据完整性和对象状态的一致性。</li></ul></li><li><p><strong>灵活性：</strong></p><ul><li>如果将来需要更改 <code>balance</code> 的内部表示方式（例如从 <code>double</code> 改为更精确的类型），只要公有接口不变，外部代码就无需修改。</li></ul></li></ul><hr><h2 id="design-strategies">数据抽象的设计策略</h2><ol><li><p><strong>将数据成员设为私有：</strong></p><ul><li>始终将数据成员声明为 <code>private</code> 或 <code>protected</code>。</li><li>防止从类外部直接访问和修改，保护数据完整性。</li></ul></li><li><p><strong>提供公有方法进行交互：</strong></p><ul><li>使用 <code>public</code> 方法提供必要的功能。</li><li>这些方法应包含必要的验证和错误处理。</li><li>保持接口简洁易用。</li></ul></li><li><p><strong>接口与实现分离：</strong></p><ul><li>类的使用者只需与接口（公有方法）交互，无需了解实现细节。</li><li>这允许在不影响外部代码的情况下更改内部实现。</li><li>增强了模块化和可维护性。</li></ul></li><li><p><strong>正确使用 <code>const</code>：</strong></p><ul><li>对于不修改对象状态的方法，使用 <code>const</code> 修饰。</li><li>防止意外修改，提高代码安全性。</li><li>允许在 <code>const</code> 对象上调用这些方法。</li></ul></li><li><p><strong>为接口提供文档：</strong></p><ul><li>为公有方法提供清晰的注释和文档。</li><li>解释方法的功能、参数、返回值以及可能的错误情况。</li><li>提高代码的可读性和可用性。</li></ul></li></ol><hr><h2 id="common-errors">常见错误及如何避免</h2><h3 id="9-1-将数据成员设为公有"><a href="#9-1-将数据成员设为公有" class="headerlink" title="9.1 将数据成员设为公有"></a><strong>9.1 将数据成员设为公有</strong></h3><ul><li><strong>错误：</strong> 将数据成员声明为 <code>public</code>，允许外部代码直接访问和修改。</li><li><strong>问题：</strong> 可能导致数据处于无效状态，难以维护数据完整性。</li><li><strong>解决方案：</strong> 始终将数据成员声明为 <code>private</code> 或 <code>protected</code>，通过受控的公有方法访问。</li></ul><h3 id="9-2-未对输入进行验证"><a href="#9-2-未对输入进行验证" class="headerlink" title="9.2 未对输入进行验证"></a><strong>9.2 未对输入进行验证</strong></h3><ul><li><strong>错误：</strong> 在公有方法中未检查输入，可能导致对象处于无效状态（例如负余额）。</li><li><strong>问题：</strong> 会引发错误和意外行为。</li><li><strong>解决方案：</strong> 在所有修改对象状态的方法中实现输入验证，并提供有意义的错误信息。</li></ul><h3 id="9-3-暴露内部实现"><a href="#9-3-暴露内部实现" class="headerlink" title="9.3 暴露内部实现"></a><strong>9.3 暴露内部实现</strong></h3><ul><li><strong>错误：</strong> 设计的方法暴露或依赖于内部数据结构（例如返回私有成员的指针或引用）。</li><li><strong>问题：</strong> 打破了封装性，可能导致意外的副作用。</li><li><strong>解决方案：</strong> 保持内部实现的隐藏，方法应在更高的抽象层次上操作。</li></ul><h3 id="9-4-忽略-const-的使用"><a href="#9-4-忽略-const-的使用" class="headerlink" title="9.4 忽略 const 的使用"></a><strong>9.4 忽略 <code>const</code> 的使用</strong></h3><ul><li><strong>错误：</strong> 未在适当的地方使用 <code>const</code>，导致方法可能意外修改对象。</li><li><strong>问题：</strong> 可能引发副作用，使代码难以理解。</li><li><strong>解决方案：</strong> 使用 <code>const</code> 标记不修改对象状态的方法，提高代码安全性和清晰度。</li></ul><h3 id="9-5-接口过于复杂"><a href="#9-5-接口过于复杂" class="headerlink" title="9.5 接口过于复杂"></a><strong>9.5 接口过于复杂</strong></h3><ul><li><strong>错误：</strong> 提供过多的公有方法，或暴露不必要的功能。</li><li><strong>问题：</strong> 使类难以使用和理解。</li><li><strong>解决方案：</strong> 保持公有接口的简洁，专注于核心功能。</li></ul><hr><h2 id="summary">总结</h2><ul><li><strong>数据抽象</strong>是面向对象编程中的关键原则，允许开发者通过隐藏内部细节来简化复杂系统。</li><li><strong>类</strong>是 C++ 中实现数据抽象的主要方式，将数据和函数封装在一起。</li><li><strong>访问控制符</strong>（<code>public</code>、<code>private</code>、<code>protected</code>）控制类成员的访问方式，是实现抽象的关键。</li><li><strong>数据抽象的好处</strong>包括提高安全性、简化接口、增强可维护性和灵活性。</li><li><strong>设计策略</strong>包括仔细规划类的接口，将数据成员设为私有，提供公有方法进行必要的交互，以及正确使用 <code>const</code>。</li><li><strong>避免常见错误</strong>，遵循最佳实践，如正确使用访问控制符和输入验证。</li></ul><hr><h2 id="Think">最后的思考</h2><p>理解并有效地实现数据抽象，对于编写健壮、可维护和安全的 C++ 程序至关重要。通过精心设计类，只暴露必要的部分并隐藏其余内容，可以使代码更易于使用，减少错误的可能性。</p><p>在设计类时，始终自问：</p><ul><li><strong>使用者需要知道什么？</strong></li><li><strong>应该隐藏什么以防止误用或意外错误？</strong></li></ul><p>这种思维方式将指导你创建有效的抽象，使你的代码库更加强大，能够适应变化。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++多态</title>
      <link href="/2024/11/22/C-%E5%A4%9A%E6%80%81/"/>
      <url>/2024/11/22/C-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.tomatou.xyz/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong> </p><hr><h1 id="C-多态：让对象具备“多种形态”的能力"><a href="#C-多态：让对象具备“多种形态”的能力" class="headerlink" title="C++ 多态：让对象具备“多种形态”的能力"></a><strong>C++ 多态：让对象具备“多种形态”的能力</strong></h1><p><strong>多态</strong>，顾名思义，就是“多种形态”。在 C++ 中，多态是面向对象编程（OOP）的三大特性之一（另两个是封装和继承）。多态使得程序可以使用统一的接口来操纵不同类型的对象，从而实现代码的灵活性和可扩展性。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E6%80%81">什么是多态？</a></li><li><a href="#2-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%A6%82%E5%BF%B5">虚函数的概念</a></li><li><a href="#3-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A-vs-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A">动态绑定 vs 静态绑定</a></li><li><a href="#4-%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB">纯虚函数与抽象类</a></li><li><a href="#5-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86">多态的实现原理</a></li><li><a href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81">为什么要使用多态？</a></li><li><a href="#7-%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%80%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98">使用多态需要注意的问题</a></li><li><a href="#8-%E6%80%BB%E7%BB%93">总结</a></li></ul><hr><h2 id="1-什么是多态？"><a href="#1-什么是多态？" class="headerlink" title="1. 什么是多态？"></a><strong>1. 什么是多态？</strong></h2><p>多态是指程序中对象的多种表现形态，具体来说，就是<strong>使用基类指针或引用，在运行时根据对象的实际类型，调用对应的重写方法</strong>。这意味着<strong>同一个函数调用，根据对象类型的不同，会表现出不同的行为</strong>。</p><p>举个生活中的例子：</p><p>假设有一个“动物”这个概念，动物会“发出声音”。不同的动物，发出的声音不同。猫会“喵喵叫”，狗会“汪汪叫”。在程序中，我们可以通过一个统一的接口（如 <code>speak()</code> 方法）来让不同的动物发出各自的声音。</p><hr><h2 id="2-虚函数的概念"><a href="#2-虚函数的概念" class="headerlink" title="2. 虚函数的概念"></a><strong>2. 虚函数的概念</strong></h2><h3 id="2-1-什么是虚函数？"><a href="#2-1-什么是虚函数？" class="headerlink" title="2.1 什么是虚函数？"></a><strong>2.1 什么是虚函数？</strong></h3><p><strong>虚函数</strong>（virtual function）是使用 <code>virtual</code> 关键字声明的成员函数，目的是为了<strong>允许子类重写该函数，并在运行时通过基类指针或引用调用子类的实现</strong>。</p><h3 id="2-2-为什么需要虚函数？"><a href="#2-2-为什么需要虚函数？" class="headerlink" title="2.2 为什么需要虚函数？"></a><strong>2.2 为什么需要虚函数？</strong></h3><p>在基类中，如果某个函数可能会被子类重写，并且你希望通过基类指针调用子类的实现，就需要将该函数声明为虚函数。</p><h3 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a><strong>2.3 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;  <span class="comment">// 虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal makes a sound.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;  <span class="comment">// 重写虚函数</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Dog barks.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Cat meows.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-4-如何使用"><a href="#2-4-如何使用" class="headerlink" title="2.4 如何使用"></a><strong>2.4 如何使用</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Animal* animal1 = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">    Animal* animal2 = <span class="keyword">new</span> <span class="built_in">Cat</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(animal1);  <span class="comment">// 输出：Dog barks.</span></span><br><span class="line">    <span class="built_in">makeAnimalSpeak</span>(animal2);  <span class="comment">// 输出：Cat meows.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> animal1;</span><br><span class="line">    <span class="keyword">delete</span> animal2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，尽管我们使用的是 <code>Animal*</code> 类型的指针，但实际调用的是 <code>Dog</code> 和 <code>Cat</code> 各自的 <code>speak()</code> 方法。</p><hr><h2 id="3-动态绑定-vs-静态绑定"><a href="#3-动态绑定-vs-静态绑定" class="headerlink" title="3. 动态绑定 vs 静态绑定"></a><strong>3. 动态绑定 vs 静态绑定</strong></h2><h3 id="3-1-静态绑定"><a href="#3-1-静态绑定" class="headerlink" title="3.1 静态绑定"></a><strong>3.1 静态绑定</strong></h3><ul><li><strong>定义</strong>：函数调用在编译时就已经确定，称为<strong>静态绑定</strong>或<strong>早期绑定</strong>。</li><li><strong>特点</strong>：编译器根据对象的静态类型决定调用哪个函数。</li></ul><h3 id="3-2-动态绑定"><a href="#3-2-动态绑定" class="headerlink" title="3.2 动态绑定"></a><strong>3.2 动态绑定</strong></h3><ul><li><strong>定义</strong>：函数调用在运行时根据对象的实际类型来决定，称为<strong>动态绑定</strong>或<strong>晚期绑定</strong>。</li><li><strong>特点</strong>：需要通过基类指针或引用调用虚函数。</li></ul><h3 id="3-3-示例对比"><a href="#3-3-示例对比" class="headerlink" title="3.3 示例对比"></a><strong>3.3 示例对比</strong></h3><p><strong>静态绑定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog dog;</span><br><span class="line">dog.<span class="built_in">speak</span>();  <span class="comment">// 编译时决定调用 Dog::speak()</span></span><br></pre></td></tr></table></figure><p><strong>动态绑定</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 运行时决定调用 Dog::speak()</span></span><br></pre></td></tr></table></figure><p>如果 <code>speak()</code> 不是虚函数，那么即使使用基类指针，也会调用 <code>Animal::speak()</code>，这是因为没有动态绑定，函数调用在编译时已经确定。</p><hr><h2 id="4-纯虚函数与抽象类"><a href="#4-纯虚函数与抽象类" class="headerlink" title="4. 纯虚函数与抽象类"></a><strong>4. 纯虚函数与抽象类</strong></h2><h3 id="4-1-纯虚函数"><a href="#4-1-纯虚函数" class="headerlink" title="4.1 纯虚函数"></a><strong>4.1 纯虚函数</strong></h3><ul><li><strong>定义</strong>：没有实现的虚函数，声明时在函数签名后加 <code>= 0</code>。</li><li><strong>目的</strong>：要求派生类必须实现该函数，否则派生类也将是抽象类，无法实例化。</li></ul><h3 id="4-2-抽象类"><a href="#4-2-抽象类" class="headerlink" title="4.2 抽象类"></a><strong>4.2 抽象类</strong></h3><ul><li><strong>定义</strong>：包含纯虚函数的类称为<strong>抽象类</strong>。</li><li><strong>特点</strong>：<ul><li>不能创建抽象类的实例。</li><li>可以包含成员变量和已经实现的函数。</li><li>用于定义接口，供子类继承和实现。</li></ul></li></ul><h3 id="4-3-示例"><a href="#4-3-示例" class="headerlink" title="4.3 示例"></a><strong>4.3 示例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> </span>= <span class="number">0</span>;  <span class="comment">// 纯虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a circle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Drawing a rectangle.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="4-4-使用抽象类"><a href="#4-4-使用抽象类" class="headerlink" title="4.4 使用抽象类"></a><strong>4.4 使用抽象类</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">renderShape</span><span class="params">(Shape* shape)</span> </span>&#123;</span><br><span class="line">    shape-&gt;<span class="built_in">draw</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Shape* shape1 = <span class="keyword">new</span> <span class="built_in">Circle</span>();</span><br><span class="line">    Shape* shape2 = <span class="keyword">new</span> <span class="built_in">Rectangle</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">renderShape</span>(shape1);  <span class="comment">// 输出：Drawing a circle.</span></span><br><span class="line">    <span class="built_in">renderShape</span>(shape2);  <span class="comment">// 输出：Drawing a rectangle.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> shape1;</span><br><span class="line">    <span class="keyword">delete</span> shape2;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="5-多态的实现原理"><a href="#5-多态的实现原理" class="headerlink" title="5. 多态的实现原理"></a><strong>5. 多态的实现原理</strong></h2><h3 id="5-1-虚函数表（V-Table）"><a href="#5-1-虚函数表（V-Table）" class="headerlink" title="5.1 虚函数表（V-Table）"></a><strong>5.1 虚函数表（V-Table）</strong></h3><ul><li><strong>概念</strong>：编译器为每个包含虚函数的类创建一个虚函数表，记录该类的虚函数地址。</li><li><strong>作用</strong>：用于在运行时动态决定调用哪个函数。</li></ul><h3 id="5-2-虚函数指针（V-Ptr）"><a href="#5-2-虚函数指针（V-Ptr）" class="headerlink" title="5.2 虚函数指针（V-Ptr）"></a><strong>5.2 虚函数指针（V-Ptr）</strong></h3><ul><li><strong>概念</strong>：每个对象都有一个隐藏的指针，指向所属类的虚函数表。</li><li><strong>作用</strong>：通过虚函数指针找到虚函数表，从而调用正确的函数实现。</li></ul><h3 id="5-3-调用过程"><a href="#5-3-调用过程" class="headerlink" title="5.3 调用过程"></a><strong>5.3 调用过程</strong></h3><p>当通过基类指针或引用调用虚函数时：</p><ol><li>程序根据对象的虚函数指针找到对应的虚函数表。</li><li>在虚函数表中查找对应函数的地址。</li><li>调用该地址对应的函数实现。</li></ol><h3 id="5-4-示例图解"><a href="#5-4-示例图解" class="headerlink" title="5.4 示例图解"></a><strong>5.4 示例图解</strong></h3><ul><li><p><strong>类结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Animal</span><br><span class="line">├── speak() [virtual]</span><br><span class="line">↓</span><br><span class="line">Dog : public Animal</span><br><span class="line">    └── speak() [override]</span><br></pre></td></tr></table></figure></li><li><p><strong>对象内存布局</strong></p><ul><li><p><strong>Animal 对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ V-Ptr ] ---&gt; [ Animal V-Table ]</span><br><span class="line">                   ├── speak() --&gt; Animal::speak()</span><br></pre></td></tr></table></figure></li><li><p><strong>Dog 对象</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[ V-Ptr ] ---&gt; [ Dog V-Table ]</span><br><span class="line">                   ├── speak() --&gt; Dog::speak()</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="6-为什么要使用多态？"><a href="#6-为什么要使用多态？" class="headerlink" title="6. 为什么要使用多态？"></a><strong>6. 为什么要使用多态？</strong></h2><h3 id="6-1-代码复用性"><a href="#6-1-代码复用性" class="headerlink" title="6.1 代码复用性"></a><strong>6.1 代码复用性</strong></h3><ul><li><strong>统一接口</strong>：通过基类指针或引用，可以使用同一个函数操作不同类型的对象。</li><li><strong>减少重复代码</strong>：避免为每个子类编写重复的函数调用代码。</li></ul><h3 id="6-2-扩展性"><a href="#6-2-扩展性" class="headerlink" title="6.2 扩展性"></a><strong>6.2 扩展性</strong></h3><ul><li><strong>易于维护和扩展</strong>：添加新的子类无需修改现有代码，只需确保新子类实现了必要的虚函数。</li><li><strong>降低耦合度</strong>：模块之间依赖于抽象的接口，而非具体的实现。</li></ul><h3 id="6-3-灵活性"><a href="#6-3-灵活性" class="headerlink" title="6.3 灵活性"></a><strong>6.3 灵活性</strong></h3><ul><li><strong>运行时决定行为</strong>：程序可以在运行时根据实际对象类型执行不同的操作。</li><li><strong>支持多态容器</strong>：可以创建包含基类指针的容器，存储不同类型的对象。</li></ul><hr><h2 id="7-使用多态需要注意的问题"><a href="#7-使用多态需要注意的问题" class="headerlink" title="7. 使用多态需要注意的问题"></a><strong>7. 使用多态需要注意的问题</strong></h2><h3 id="7-1-析构函数应为虚函数"><a href="#7-1-析构函数应为虚函数" class="headerlink" title="7.1 析构函数应为虚函数"></a><strong>7.1 析构函数应为虚函数</strong></h3><ul><li><p><strong>原因</strong>：当通过基类指针删除子类对象时，如果基类析构函数不是虚函数，可能导致资源未正确释放。</p></li><li><p><strong>示例</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Animal destroyed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="7-2-对象切片"><a href="#7-2-对象切片" class="headerlink" title="7.2 对象切片"></a><strong>7.2 对象切片</strong></h3><ul><li><strong>概念</strong>：当将子类对象赋值给基类对象时，子类特有的数据会被“切掉”。</li><li><strong>避免方法</strong>：尽量使用指针或引用来处理对象。</li></ul><h3 id="7-3-性能开销"><a href="#7-3-性能开销" class="headerlink" title="7.3 性能开销"></a><strong>7.3 性能开销</strong></h3><ul><li><strong>动态绑定的成本</strong>：多态机制需要在运行时查找函数地址，略微增加了执行时间和内存开销。</li><li><strong>权衡</strong>：通常，这些开销是可以接受的，不会对性能产生显著影响。</li></ul><h3 id="7-4-虚函数不能是内联函数"><a href="#7-4-虚函数不能是内联函数" class="headerlink" title="7.4 虚函数不能是内联函数"></a><strong>7.4 虚函数不能是内联函数</strong></h3><ul><li><strong>原因</strong>：虚函数在运行时决定调用哪个版本，无法在编译时内联展开。</li></ul><hr><h2 id="8-总结"><a href="#8-总结" class="headerlink" title="8. 总结"></a><strong>8. 总结</strong></h2><p>多态是 C++ 面向对象编程的核心特性之一，它通过虚函数和动态绑定机制，使得程序可以在运行时根据对象的实际类型执行相应的操作。</p><p><strong>多态的优点</strong>：</p><ul><li>提高代码的复用性和可维护性。</li><li>增强程序的扩展性和灵活性。</li><li>使代码更符合面向对象的设计思想。</li></ul><p><strong>使用多态的关键</strong>：</p><ul><li>使用虚函数来允许子类重写基类方法。</li><li>通过基类指针或引用来调用虚函数。</li><li>当需要定义统一接口时，使用纯虚函数和抽象类。</li></ul><hr><p>希望以上内容能够帮助您更深入地理解 C++ 中的多态机制，并在实际编程中有效地应用它。多态虽然概念简单，但在大型项目中能够大大简化代码结构，提高开发效率。</p><p>如果您有任何疑问，或者需要进一步的解释，请随时提问！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吾爱破解大佬的新成果</title>
      <link href="/2024/11/21/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%B0%E6%88%90%E6%9E%9C/"/>
      <url>/2024/11/21/%E5%90%BE%E7%88%B1%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%A0%B4%E8%A7%A3%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%B0%E6%88%90%E6%9E%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>今天给大家分享一款非常好用的手机扫描软件，包不会后悔的😏</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：扫描王</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p><strong>软件的主页提供了一些核心功能，包括文档扫描、文本提取、身份证件的扫描以及表格的识别。这些功能都是直接集成在首页上，用户无需进行登录或注册，可以直接点击相应的选项在线使用这些服务</strong></p><div style="text-align:center">  <img src="/img_1/461597BB7A0BC066CD0D31B240D2BDCB.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>这个服务就像是你的个人数字助理，它对扫描有着广泛的“口味”，无论是纸质的还是电子的，都能轻松“消化”。它不仅能把任何东西变成PDF和图像，还能用它的OCR魔法棒一挥，把图片里的文字变活，让它们跳进PDF文件里。就像是给文字做了个“数字复活”，让它们从静态的图像中跳出来，变得可以编辑和复制。这不仅仅是扫描，这是一次文字的“数字化大逃亡”！</strong></p><div style="text-align:center">  <img src="/img_1/9320352FE7BDE691479066B62A57435D.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>这款软件是个多语言高手，能读懂中文、英文、日语和粤语等八种语言的文字，而且读得非常准确。用户只需轻轻一点，就能把识别出来的文字复制走，还能一键转换成Word文档。不仅如此，它还能把内容变成PDF、Word和TXT格式，就像是文字的变形金刚，想变什么格式就变什么格式</strong></p><div style="text-align:center">  <img src="/img_1/70C3B27DF29D0D37D92A53946A89D21E.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>该工具提供PDF转换服务，能够将PDF文件转换成Word、Excel以及图片格式。此外，它还具备PDF文件合并的功能，允许用户将多个PDF文档合并为一个。这项服务在没有电脑可用的情况下，为用户提供了一个便捷的应急解决方案，使得文件处理变得更加灵活和高效</strong></p><div style="text-align:center">  <img src="/img_1/0D98D74DECD28CC0432BECAEF10667E1.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="https://share.feijipan.com/s/a0DHTOoM">https://share.feijipan.com/s/a0DHTOoM</a></strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>想象一下，你手里拿着的不是手机，而是一台时光机，这台时光机能做什么呢？它能带你穿梭到任何文档的深处，提取文字，扫描证件，甚至还能识别表格，就像你有一个隐形的助手在帮你整理文件。不仅如此，它还能让你成为艺术家，AI绘画功能让你的创意飞起来；试卷擦除功能让你重温学生时代的“作弊”梦想（开个玩笑，我们还是诚实的好孩子）；口算批改功能让你瞬间变身数学老师；拍照翻译功能让你成为语言大师；图片修复功能让你成为修复大师。最重要的是，这台“时光机”不收你一分钱，就像是天上掉下来的馅饼，你只需要张嘴吃就行了。所以，别犹豫，拿起你的“时光机”，开始你的扫描之旅吧！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 扫描软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寒意深处，春的絮语</title>
      <link href="/2024/11/20/%E5%86%AC/"/>
      <url>/2024/11/20/%E5%86%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="今日分享"><a href="#今日分享" class="headerlink" title="今日分享"></a>今日分享</h1><p><strong>以下是拍摄图</strong></p><p><strong>冬，是万物蛰伏的季节，是大自然孕育新生的前奏。北风轻拂，染尽山河的苍茫，一抹赤红的枫叶与初雪相遇，似乎在低语着冬日悄然降临的讯息。那飘落的雪花，宛如时光的信笺，写满了季节的更迭与生命的诗意。</strong></p><div style="text-align:center">  <img src="/img_1/C5C2E05CE2FD27DECD2203AD5C48418C.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" >  <img src="/img_1/AAAD2D03CAEC17FA767E12470AF9F171.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>寒冷从不是希望的终结，而是希望的酝酿。冰封之下，生命的根脉正悄然积蓄力量。愿你在风雪中坚定前行，于冰冷中守住心底的温暖，去迎接那一场雪中的浪漫。</strong></p><div style="text-align:center">  <img src="/img_1/3382C3B8BC81FB7847B5B5E7CDEDE905.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div><p><strong>冬日是约定，春天是兑现。当雪融化成溪，寒意褪去，一切美好都将在阳光下蓬勃生长。请相信，今天的凛冽终会酝酿出明日的繁华。</strong></p><div style="text-align:center">  <img src="/img_1/8574FF6732FBEF1C2045836B08557343.jpg" alt="拍摄＆后期 By 码头" style="width:80%;" ></div>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 重载运算符和重载函数</title>
      <link href="/2024/11/20/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/"/>
      <url>/2024/11/20/C-%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E9%87%8D%E8%BD%BD%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从本节内容开始的内容，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">点击这里</a>重新温习一下,废话不多说，直接进入正题吧！</strong></p><h1 id="C-重载运算符和重载函数"><a href="#C-重载运算符和重载函数" class="headerlink" title="C++ 重载运算符和重载函数"></a>C++ 重载运算符和重载函数</h1><p>想象一下，你有一个多功能的瑞士军刀，每个工具都有自己的特定用途，但它们都藏在同一个刀柄里。在C++中，函数重载和运算符重载就像是这个瑞士军刀，允许你用同一个名字来执行不同的任务，只要你给它不同的“工具”。</p><ol><li><p><strong>函数重载</strong>：</p><ul><li>这就像是你告诉你的瑞士军刀，“当我需要切东西时，给我刀片；当我需要拧螺丝时，给我螺丝刀。”在C++中，你可以有多个同名的函数，但每个函数接受的参数类型或数量不同。比如，你可以有一个<code>print()</code>函数来打印整数，另一个<code>print()</code>函数来打印字符串。</li><li>当你调用<code>print(5)</code>时，编译器知道你想要打印一个整数，所以它会选择接受整数参数的那个<code>print()</code>函数。如果你调用<code>print(&quot;Hello&quot;)</code>，编译器会选择接受字符串参数的那个<code>print()</code>函数。</li></ul></li><li><p><strong>运算符重载</strong>：</p><ul><li>这就像是你对你的瑞士军刀说，“当我用加号时，如果我在加两个数字，就做数学加法；如果我在加两个我自定义的类对象，就按照我告诉你的特殊方式来加。”在C++中，你可以改变大多数内置运算符的行为，让它们也能用于你自定义的类。</li><li>例如，如果你有一个<code>Box</code>类，你可以重载加号运算符来定义两个<code>Box</code>对象相加意味着什么。你可能会决定它意味着把两个盒子的体积相加。</li></ul></li></ol><p><strong>重载决策</strong>：</p><ul><li>当你使用重载的函数或运算符时，编译器需要决定哪个版本是最佳匹配。这就像你对瑞士军刀说，“我要切这个苹果”，军刀就会决定给你刀片而不是螺丝刀。</li><li>编译器通过比较你使用的参数类型和函数或运算符定义中的参数类型来做出决定。这个过程就像是军刀在检查你想要做什么，然后选择最合适的工具。</li></ul><h2 id="C-中的函数重载"><a href="#C-中的函数重载" class="headerlink" title="C++ 中的函数重载"></a>C++ 中的函数重载</h2><p>在 C++ 中，<strong>函数重载</strong>指的是可以在同一个作用域中定义多个同名函数，但这些函数的参数列表必须不同（包括参数的数量、类型或顺序）。它允许我们使用一个名字来处理不同类型的操作。</p><p><strong>注意</strong>：</p><ul><li>函数重载的区分是基于参数的类型和数量。</li><li><strong>仅通过返回值的不同是不能实现重载的</strong>。</li></ul><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>假如我们有一个需求：输出不同类型的数据，比如整数、浮点数和字符串。每种数据类型需要一个特定的方法去输出，但我们不想使用不同的函数名（比如 <code>printInt()</code>、<code>printFloat()</code> 等），这时候可以使用<strong>函数重载</strong>。</p><p>下面是代码示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类 printData，包含多个同名函数 print()</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="comment">// 用于输出整数</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于输出浮点数</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 用于输出字符串</span></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">// 创建一个 printData 的对象</span></span><br><span class="line">   printData pd;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出整数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出浮点数</span></span><br><span class="line">   pd.<span class="built_in">print</span>(<span class="number">500.263</span>);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 调用 print 函数输出字符串</span></span><br><span class="line">   <span class="type">char</span> c[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">   pd.<span class="built_in">print</span>(c);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行的结果"><a href="#程序运行的结果" class="headerlink" title="程序运行的结果"></a>程序运行的结果</h3><p>运行上述代码会输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">整数为: 5</span><br><span class="line">浮点数为: 500.263</span><br><span class="line">字符串为: Hello C++</span><br></pre></td></tr></table></figure><h3 id="程序工作原理的详细解释"><a href="#程序工作原理的详细解释" class="headerlink" title="程序工作原理的详细解释"></a>程序工作原理的详细解释</h3><ol><li><p>**定义类 <code>printData</code>**：</p><ul><li>包含三个同名函数 <code>print()</code>。</li><li>每个函数的参数类型不同：一个接收 <code>int</code> 类型，一个接收 <code>double</code> 类型，一个接收 <code>char[]</code> 类型。</li><li>根据传递给 <code>print()</code> 的参数类型，C++ 编译器会选择调用相应的函数。</li></ul></li><li><p><strong>在 <code>main()</code> 函数中</strong>：</p><ul><li>创建了一个 <code>printData</code> 的对象 <code>pd</code>。</li><li>调用了不同参数版本的 <code>print()</code>：<ul><li>传入整数 <code>5</code>，调用接收 <code>int</code> 类型参数的函数。</li><li>传入浮点数 <code>500.263</code>，调用接收 <code>double</code> 类型参数的函数。</li><li>传入字符串 <code>&quot;Hello C++&quot;</code>，调用接收 <code>char[]</code> 类型参数的函数。</li></ul></li></ul></li></ol><h3 id="为什么函数重载很有用？"><a href="#为什么函数重载很有用？" class="headerlink" title="为什么函数重载很有用？"></a>为什么函数重载很有用？</h3><p>函数重载的好处包括：</p><ol><li><strong>统一接口</strong>：不同的操作共享同一个函数名，提高代码的可读性和易用性。</li><li><strong>自动匹配类型</strong>：根据传递的参数，自动调用对应的函数，无需手动区分函数名。</li><li><strong>避免混乱</strong>：不用为每种操作创建不同的函数名，减少记忆负担。</li></ol><h3 id="函数重载的核心规则"><a href="#函数重载的核心规则" class="headerlink" title="函数重载的核心规则"></a>函数重载的核心规则</h3><ol><li><p>参数列表必须不同，具体包括：</p><ul><li>参数的数量不同。</li><li>参数的类型不同。</li><li>参数的顺序不同（例如 <code>print(int, double)</code> 和 <code>print(double, int)</code> 是可以重载的）。</li></ul></li><li><p><strong>返回值的不同不能作为重载的条件</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">print</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">print</span><span class="params">()</span></span>; <span class="comment">// 错误：仅靠返回值不同，不能区分函数。</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="更直观的对比"><a href="#更直观的对比" class="headerlink" title="更直观的对比"></a>更直观的对比</h3><p><strong>不使用重载的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printInt</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;整数为: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printDouble</span><span class="params">(<span class="type">double</span> f)</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;浮点数为: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">printString</span><span class="params">(<span class="type">char</span> c[])</span> </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;字符串为: &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用这些方法时，需要记住不同的函数名，比如 <code>printInt()</code>、<code>printDouble()</code> 等。</p><p><strong>使用重载的方式</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">printData</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> i)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">double</span> f)</span></span>;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">char</span> c[])</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>调用时只需记住一个名字 <code>print()</code>，编译器根据参数自动调用合适的版本。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><p>函数重载是 C++ 提供的一种重要功能，用来让函数名称更简洁、统一，同时又支持多种类型的操作。在上面的例子中，<code>print()</code> 方法能够根据参数类型自动选择合适的版本，这是函数重载的核心优势。</p><h2 id="C-中的运算符重载"><a href="#C-中的运算符重载" class="headerlink" title="C++ 中的运算符重载"></a>C++ 中的运算符重载</h2><p>在 C++ 中，<strong>运算符重载</strong>允许我们为自定义的类定义运算符行为，使得可以像操作基本数据类型（例如整数、浮点数）一样，使用运算符对自定义的对象进行操作。</p><h3 id="1-运算符重载的基本概念"><a href="#1-运算符重载的基本概念" class="headerlink" title="1. 运算符重载的基本概念"></a>1. 运算符重载的基本概念</h3><p>运算符重载实际上是通过定义一个特殊的成员函数或者非成员函数，使得运算符能够适用于我们自定义的类。在 C++ 中，重载运算符的函数名由关键字 <code>operator</code> 加上运算符符号组成。这样做的好处是，运算符可以像普通函数一样处理对象，并实现自定义的行为。</p><h3 id="2-运算符重载的形式"><a href="#2-运算符重载的形式" class="headerlink" title="2. 运算符重载的形式"></a>2. 运算符重载的形式</h3><p>有两种常见的方式来定义运算符重载：</p><ul><li><strong>成员函数重载</strong>：运算符重载是类的成员函数，并且通常只需要一个参数（即右侧操作数）。</li><li><strong>非成员函数重载</strong>：运算符重载是类外部的普通函数，通常需要两个参数（即两个操作数）。</li></ul><h3 id="3-运算符重载实例：加法运算符"><a href="#3-运算符重载实例：加法运算符" class="headerlink" title="3. 运算符重载实例：加法运算符"></a>3. 运算符重载实例：加法运算符</h3><p>假设我们有一个 <code>Box</code> 类，它表示一个长方体。我们希望能够对两个 <code>Box</code> 对象进行加法操作，使得两个长方体的尺寸（长度、宽度、高度）相加，得到一个新的 <code>Box</code> 对象。</p><h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取长方体的体积</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getVolume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> length * breadth * height;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置长方体的长度、宽度和高度</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123; length = len; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setBreadth</span><span class="params">(<span class="type">double</span> bre)</span> </span>&#123; breadth = bre; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">double</span> hei)</span> </span>&#123; height = hei; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 重载加法运算符，用于将两个 Box 对象的尺寸相加</span></span><br><span class="line">    Box <span class="keyword">operator</span>+(<span class="type">const</span> Box&amp; b) &#123;</span><br><span class="line">        Box box; <span class="comment">// 新的 Box 对象</span></span><br><span class="line">        box.length = <span class="keyword">this</span>-&gt;length + b.length; <span class="comment">// 加法操作</span></span><br><span class="line">        box.breadth = <span class="keyword">this</span>-&gt;breadth + b.breadth;</span><br><span class="line">        box.height = <span class="keyword">this</span>-&gt;height + b.height;</span><br><span class="line">        <span class="keyword">return</span> box; <span class="comment">// 返回新创建的 Box 对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth; <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;  <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box Box1, Box2, Box3; <span class="comment">// 创建三个 Box 对象</span></span><br><span class="line">    <span class="type">double</span> volume = <span class="number">0.0</span>; <span class="comment">// 存储体积</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Box1 的尺寸</span></span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setLength</span>(<span class="number">6.0</span>);</span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setBreadth</span>(<span class="number">7.0</span>);</span><br><span class="line">    Box<span class="number">1.</span><span class="built_in">setHeight</span>(<span class="number">5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 Box2 的尺寸</span></span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setLength</span>(<span class="number">12.0</span>);</span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setBreadth</span>(<span class="number">13.0</span>);</span><br><span class="line">    Box<span class="number">2.</span><span class="built_in">setHeight</span>(<span class="number">10.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box1 的体积</span></span><br><span class="line">    volume = Box<span class="number">1.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box1: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box2 的体积</span></span><br><span class="line">    volume = Box<span class="number">2.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box2: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 Box1 和 Box2 相加，得到 Box3</span></span><br><span class="line">    Box3 = Box1 + Box2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 Box3 的体积</span></span><br><span class="line">    volume = Box<span class="number">3.</span><span class="built_in">getVolume</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Volume of Box3: &quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="代码解释："><a href="#代码解释：" class="headerlink" title="代码解释："></a>代码解释：</h4><ol><li><p><strong>定义 <code>Box</code> 类：</strong> <code>Box</code> 类有三个私有成员变量：<code>length</code>（长度）、<code>breadth</code>（宽度）和 <code>height</code>（高度）。我们通过公共成员函数 <code>setLength()</code>、<code>setBreadth()</code> 和 <code>setHeight()</code> 来设置它们的值。</p></li><li><p><strong>成员函数 <code>operator+</code>：</strong> 这个函数重载了加法运算符 <code>+</code>，它接受一个 <code>Box</code> 类型的对象 <code>b</code>，并将当前对象（通过 <code>this</code> 指针访问）和 <code>b</code> 的尺寸进行相加。相加的结果存储在一个新的 <code>Box</code> 对象中，并返回这个新的对象。</p></li><li><p><strong>计算体积：</strong> <code>getVolume()</code> 函数返回长方体的体积，即 <code>length * breadth * height</code>。</p></li><li><p><strong>主函数：</strong></p><ul><li>我们创建了三个 <code>Box</code> 对象：<code>Box1</code>、<code>Box2</code> 和 <code>Box3</code>。</li><li>给 <code>Box1</code> 和 <code>Box2</code> 设置了不同的尺寸。</li><li>使用重载的加法运算符将 <code>Box1</code> 和 <code>Box2</code> 相加，得到一个新的 <code>Box3</code>。</li><li>最后输出 <code>Box1</code>、<code>Box2</code> 和 <code>Box3</code> 的体积。</li></ul></li></ol><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a>输出结果：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Volume of Box1: 210</span><br><span class="line">Volume of Box2: 1560</span><br><span class="line">Volume of Box3: 5400</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>Box1</code> 的体积是 <code>6 * 7 * 5 = 210</code>。</li><li><code>Box2</code> 的体积是 <code>12 * 13 * 10 = 1560</code>。</li><li><code>Box3</code> 是 <code>Box1</code> 和 <code>Box2</code> 的尺寸相加，得到的新 Box 的体积是 <code>(6+12) * (7+13) * (5+10) = 18 * 20 * 15 = 5400</code>。</li></ul><h3 id="4-小结"><a href="#4-小结" class="headerlink" title="4. 小结"></a>4. 小结</h3><ul><li>运算符重载让我们能够自定义运算符行为，使得运算符可以对自定义类型的对象进行操作。</li><li>可以通过成员函数或者非成员函数来重载运算符。</li><li>运算符重载可以大大提高代码的可读性和可维护性，尤其是对于复杂的对象操作。</li></ul><h2 id="可重载运算符-不可重载运算符"><a href="#可重载运算符-不可重载运算符" class="headerlink" title="可重载运算符&#x2F;不可重载运算符"></a>可重载运算符&#x2F;不可重载运算符</h2><p>下面是可重载的运算符列表：</p><!DOCTYPE html><html><head>    <title>运算符重载</title></head><body>    <h2>可重载的运算符</h2>    <table border="1">        <thead>            <tr>                <th>类别</th>                <th>运算符</th>            </tr>        </thead>        <tbody>            <tr>                <td>双目算术运算符</td>                <td>+ (加)，- (减)，* (乘)，/ (除)，% (取模)</td>            </tr>            <tr>                <td>关系运算符</td>                <td>== (等于)，!= (不等于)，< (小于)，> (大于)，<= (小于等于)，>= (大于等于)</td>            </tr>            <tr>                <td>逻辑运算符</td>                <td>|| (逻辑或)，&& (逻辑与)，! (逻辑非)</td>            </tr>            <tr>                <td>单目运算符</td>                <td>+ (正)，- (负)，* (指针)，& (取地址)</td>            </tr>            <tr>                <td>自增自减运算符</td>                <td>++ (自增)，-- (自减)</td>            </tr>            <tr>                <td>位运算符</td>                <td>| (按位或)，& (按位与)，~ (按位取反)，^ (按位异或)，<< (左移)，>> (右移)</td>            </tr>            <tr>                <td>赋值运算符</td>                <td>=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=</td>            </tr>            <tr>                <td>空间申请与释放</td>                <td>new, delete, new[], delete[]</td>            </tr>            <tr>                <td>其他运算符</td>                <td>() (函数调用)，-> (成员访问)，, (逗号)，[] (下标)</td>            </tr>        </tbody>    </table></body></html><p>下面是不可重载的运算符列表：</p><table>  <tr>    <th>不可重载运算符</th>    <th>描述</th>  </tr>  <tr>    <td>. (点运算符)</td>    <td>成员访问运算符，用于访问对象的成员。</td>  </tr>  <tr>    <td>.* (点星运算符)</td>    <td>成员指针访问运算符，用于通过成员指针访问成员。</td>  </tr>  <tr>    <td>->* (箭头星运算符)</td>    <td>成员指针访问运算符，用于通过成员指针访问成员。</td>  </tr>  <tr>    <td>:: (域运算符)</td>    <td>用于指定某个类或命名空间的成员。</td>  </tr>  <tr>    <td>sizeof (长度运算符)</td>    <td>用于获取数据类型的大小。</td>  </tr>  <tr>    <td>?: (条件运算符)</td>    <td>用于进行条件选择。</td>  </tr>  <tr>    <td># (预处理符号)</td>    <td>用于预处理阶段的宏定义。</td>  </tr></table><h2 id="运算符重载实例"><a href="#运算符重载实例" class="headerlink" title="运算符重载实例"></a>运算符重载实例</h2><table border="1">  <tr>    <th>序号</th>    <th>运算符和实例</th>  </tr>  <tr>    <td>1</td>    <td>一元运算符重载</td>  </tr>  <tr>    <td>2</td>    <td>二元运算符重载</td>  </tr>  <tr>    <td>3</td>    <td>关系运算符重载</td>  </tr>  <tr>    <td>4</td>    <td>输入/输出运算符重载</td>  </tr>  <tr>    <td>5</td>    <td>++ 和 -- 运算符重载</td>  </tr>  <tr>    <td>6</td>    <td>赋值运算符重载</td>  </tr>  <tr>    <td>7</td>    <td>函数调用运算符 () 重载</td>  </tr>  <tr>    <td>8</td>    <td>下标运算符 [] 重载</td>  </tr>  <tr>    <td>9</td>    <td>类成员访问运算符 -> 重载</td>  </tr></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++继承</title>
      <link href="/2024/11/20/C-%E7%BB%A7%E6%89%BF/"/>
      <url>/2024/11/20/C-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>本节内容，将会用到前面类的相关知识以及<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a>以及<a href="https://blog.tomatou.xyz/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/">C++类&amp;对象</a>，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请重新温习一下</strong></p><h1 id="C-继承"><a href="#C-继承" class="headerlink" title="C++ 继承"></a>C++ 继承</h1><p>继承是面向对象编程中一个非常重要的概念。通过继承，一个类（称为派生类）可以直接使用另一个类（称为基类）的属性和方法，而无需重新编写。这种方式不仅能重用代码，还能让程序更易扩展和维护。</p><hr><h2 id="什么是继承？"><a href="#什么是继承？" class="headerlink" title="什么是继承？"></a><strong>什么是继承？</strong></h2><ol><li><p><strong>基类和派生类：</strong></p><ul><li><strong>基类</strong>：已有的类，其属性和方法可以被其他类继承。</li><li><strong>派生类</strong>：继承自基类的类，它可以拥有基类的所有公开和保护成员，同时还可以定义自己的成员。</li></ul></li><li><p><strong>继承的核心思想：</strong></p><ul><li>基类定义了一些通用的功能或特性。</li><li>派生类可以直接使用这些功能，同时根据需要添加新的功能或特性。</li></ul></li></ol><hr><h2 id="继承的现实类比"><a href="#继承的现实类比" class="headerlink" title="继承的现实类比"></a><strong>继承的现实类比</strong></h2><p>继承可以看作是“<strong>是一种（is-a）关系</strong>”。例如：</p><ul><li>哺乳动物是一种动物。</li><li>狗是一种哺乳动物。</li><li>因此，狗也是一种动物。</li></ul><p>这种逻辑反映在代码中，可以通过继承轻松实现：</p><hr><h2 id="继承的语法"><a href="#继承的语法" class="headerlink" title="继承的语法"></a><strong>继承的语法</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义基类（父类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在吃东西。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在睡觉。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类（子类）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;狗正在汪汪叫。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="代码解析："><a href="#代码解析：" class="headerlink" title="代码解析："></a><strong>代码解析：</strong></h2><ol><li><p><strong>基类 Animal：</strong></p><ul><li>包含了通用的方法 <code>eat()</code> 和 <code>sleep()</code>，它们适用于所有的动物。</li></ul></li><li><p><strong>派生类 Dog：</strong></p><ul><li>通过 <code>: public Animal</code> 继承了 <code>Animal</code> 类的所有公开成员。</li><li>在 <code>Dog</code> 类中添加了一个新的方法 <code>bark()</code>，用来描述狗特有的行为。</li></ul></li><li><p><strong>使用派生类对象：</strong></p><ul><li>派生类对象既可以使用自己的方法，也可以使用从基类继承的方法。</li></ul></li></ol><hr><h2 id="实例："><a href="#实例：" class="headerlink" title="实例："></a><strong>实例：</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在吃东西。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;动物正在睡觉。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;狗正在汪汪叫。&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Dog myDog;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用继承的方法</span></span><br><span class="line">    myDog.<span class="built_in">eat</span>();    <span class="comment">// 基类的 eat 方法</span></span><br><span class="line">    myDog.<span class="built_in">sleep</span>();  <span class="comment">// 基类的 sleep 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用派生类自己的方法</span></span><br><span class="line">    myDog.<span class="built_in">bark</span>();   <span class="comment">// Dog 类的 bark 方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">动物正在吃东西。</span><br><span class="line">动物正在睡觉。</span><br><span class="line">狗正在汪汪叫。</span><br></pre></td></tr></table></figure><hr><h2 id="继承的细节"><a href="#继承的细节" class="headerlink" title="继承的细节"></a><strong>继承的细节</strong></h2><ol><li><p><strong>访问权限控制：</strong></p><ul><li>使用 <code>public</code> 继承时，基类的 <code>public</code> 成员仍然是派生类的 <code>public</code> 成员。</li><li>使用 <code>private</code> 继承时，基类的成员即使是 <code>public</code>，在派生类中也会变成 <code>private</code>。</li></ul></li><li><p><strong>is-a 关系的本质：</strong></p><ul><li>派生类对象可以看作是基类对象的一种。例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal* animal = <span class="keyword">new</span> <span class="built_in">Dog</span>();</span><br><span class="line">animal-&gt;<span class="built_in">eat</span>();  <span class="comment">// 可以通过基类指针调用基类的方法</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>重载与扩展：</strong></p><ul><li>派生类可以覆盖基类的方法，提供更具体的实现。</li></ul></li></ol><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ul><li>继承是为了实现代码复用和逻辑组织。</li><li>基类提供通用功能，派生类可以直接使用这些功能，同时扩展自己特有的功能。</li><li>继承建立的是一种“<strong>是一种（is-a）</strong>”的关系，比如“狗是一种动物”。</li></ul><h2 id="类的继承详解：基类与派生类"><a href="#类的继承详解：基类与派生类" class="headerlink" title="类的继承详解：基类与派生类"></a>类的继承详解：基类与派生类</h2><p>在编程中，一个类可以从其他类继承，这种机制让我们可以复用代码并增强类的功能。继承关系中，<strong>被继承的类称为“基类”</strong>，<strong>继承的类称为“派生类”</strong>。</p><hr><h2 id="定义派生类"><a href="#定义派生类" class="headerlink" title="定义派生类"></a>定义派生类</h2><p>派生类继承基类的数据和函数。定义派生类的格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 派生类名: 访问修饰符 基类名 &#123;</span><br><span class="line">   <span class="comment">// 派生类的成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="关键点："><a href="#关键点：" class="headerlink" title="关键点："></a>关键点：</h3><ol><li><strong>访问修饰符</strong>（<code>public</code>、<code>protected</code> 或 <code>private</code>）：控制基类成员在派生类中的访问权限。</li><li><strong>默认访问修饰符</strong>：如果没有写访问修饰符，默认是 <code>private</code>。</li></ol><hr><h2 id="一个例子：Shape-和-Rectangle"><a href="#一个例子：Shape-和-Rectangle" class="headerlink" title="一个例子：Shape 和 Rectangle"></a>一个例子：Shape 和 Rectangle</h2><p>假设我们有一个表示形状的基类 <code>Shape</code>，它可以设置宽度和高度；然后，我们定义一个 <code>Rectangle</code> 类继承自 <code>Shape</code>，并添加计算面积的功能。</p><h3 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 基类：Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 设置宽度和高度</span></span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span> </span>&#123; width = w; &#125;</span><br><span class="line">   <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span> </span>&#123; height = h; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">   <span class="type">int</span> width;  <span class="comment">// 受保护的成员</span></span><br><span class="line">   <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 派生类：Rectangle</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="comment">// 计算矩形的面积</span></span><br><span class="line">   <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> (width * height); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Rectangle rect;</span><br><span class="line"></span><br><span class="line">   rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);   <span class="comment">// 设置宽度</span></span><br><span class="line">   rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);  <span class="comment">// 设置高度</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 输出矩形的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Total area: 35</span><br></pre></td></tr></table></figure><hr><h2 id="访问权限与继承规则"><a href="#访问权限与继承规则" class="headerlink" title="访问权限与继承规则"></a>访问权限与继承规则</h2><h3 id="成员访问权限："><a href="#成员访问权限：" class="headerlink" title="成员访问权限："></a>成员访问权限：</h3><p>基类的成员根据访问修饰符分为三类：<code>public</code>、<code>protected</code> 和 <code>private</code>。这会影响派生类和外部类能否访问这些成员。</p><table><thead><tr><th><strong>访问范围</strong></th><th><strong>public</strong></th><th><strong>protected</strong></th><th><strong>private</strong></th></tr></thead><tbody><tr><td><strong>同一个类</strong></td><td>可以</td><td>可以</td><td>可以</td></tr><tr><td><strong>派生类</strong></td><td>可以</td><td>可以</td><td>不可以</td></tr><tr><td><strong>外部类</strong></td><td>可以</td><td>不可以</td><td>不可以</td></tr></tbody></table><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li><code>private</code> 成员只能在基类内部访问，派生类和外部类无法访问。</li><li><code>protected</code> 成员可以被派生类访问，但不能被外部类直接访问。</li><li><code>public</code> 成员任何地方都可以访问。</li></ul><h3 id="访问修饰符对派生类的影响："><a href="#访问修饰符对派生类的影响：" class="headerlink" title="访问修饰符对派生类的影响："></a>访问修饰符对派生类的影响：</h3><p>基类的访问修饰符在派生类中继承的访问权限，取决于派生类的定义方式：</p><table><thead><tr><th><strong>派生方式</strong></th><th><strong>基类 public 成员</strong></th><th><strong>基类 protected 成员</strong></th><th><strong>基类 private 成员</strong></th></tr></thead><tbody><tr><td><code>public</code></td><td>保持 public</td><td>保持 protected</td><td>不可访问</td></tr><tr><td><code>protected</code></td><td>降为 protected</td><td>保持 protected</td><td>不可访问</td></tr><tr><td><code>private</code></td><td>降为 private</td><td>降为 private</td><td>不可访问</td></tr></tbody></table><hr><h2 id="特殊情况：派生类中不能继承的内容"><a href="#特殊情况：派生类中不能继承的内容" class="headerlink" title="特殊情况：派生类中不能继承的内容"></a>特殊情况：派生类中不能继承的内容</h2><p>即使派生类继承了基类的大部分内容，但以下几种特殊情况除外：</p><ol><li><strong>基类的构造函数、析构函数和拷贝构造函数</strong>：这些函数不能被派生类直接继承。</li><li><strong>基类的运算符重载函数</strong>：例如，重载的 <code>operator+</code>，派生类不会直接继承。</li><li><strong>基类的友元函数</strong>：友元函数只对声明它们的类开放，不会被派生类直接继承。</li></ol><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li><strong>继承让代码复用更高效</strong>：基类定义通用的功能，派生类在此基础上扩展。</li><li><strong>控制访问权限</strong>：通过访问修饰符确保数据的安全性。</li><li><strong>继承有例外</strong>：构造函数等特殊成员无法继承，需要在派生类中重新定义。</li></ul><blockquote><p>这个机制强大而灵活，是面向对象编程的重要特性！</p></blockquote><h2 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h2><p>想象一下，我们有一个家族，基类就像是家族中的长辈，而派生类则是晚辈。长辈的财产和技能可以传给晚辈，但是传给的方式不同，晚辈对这些财产和技能的拥有和使用方式也会有所不同。</p><ol><li><p><strong>公有继承（public）</strong>：</p><ul><li>这就像是长辈公开宣布：“我所有的财产和技能，我的孩子们都可以自由使用。”在这种情况下，如果一个类（我们称之为子类）是从另一个公开的类（基类）继承来的，那么基类中所有公开的成员（比如财产和技能）在子类中也是公开的，可以被外界直接访问。同时，基类中的保护成员（比如一些只有家族内部才能使用的技能）在子类中也保持保护状态，只能被家族内部（也就是子类及其派生类）访问。</li></ul></li><li><p><strong>保护继承（protected）</strong>：</p><ul><li>这就像是长辈说：“我有一些财产和技能，只允许我的孩子们使用，外人不能直接使用，但我的孩子们可以自由地使用。”在保护继承中，基类中的公开和保护成员都会变成子类的保护成员。这意味着这些成员不能被外界直接访问，但是可以在子类及其派生类中被访问。</li></ul></li><li><p><strong>私有继承（private）</strong>：</p><ul><li>这就像是长辈说：“我有一些东西，只留给我的孩子们，而且他们也只能自己使用，不能给外人用，也不能让他们的孩子（也就是孙子辈）使用。”在私有继承中，基类中的公开和保护成员都会变成子类的私有成员。这意味着这些成员只能在子类内部使用，不能被外界或子类的派生类访问。</li></ul></li></ol><p>总结一下，继承类型决定了基类的成员在派生类中的可见性和可访问性。公有继承让基类的成员在派生类中保持原有的访问级别；保护继承将基类的成员都变为派生类的保护成员；私有继承则将基类的成员变为派生类的私有成员。在实际编程中，公有继承是最常用的，因为它允许派生类最大程度地利用基类的功能，同时也保持了灵活性。</p><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><h3 id="什么是多继承？"><a href="#什么是多继承？" class="headerlink" title="什么是多继承？"></a>什么是多继承？</h3><p>多继承指的是一个子类可以同时继承多个父类，从而获得这些父类的属性和方法。在 C++ 中，允许通过多继承来创建更强大的类。这种特性可以通过以下语法实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> &lt;派生类名&gt;:&lt;继承方式<span class="number">1</span>&gt; &lt;基类名<span class="number">1</span>&gt;, &lt;继承方式<span class="number">2</span>&gt; &lt;基类名<span class="number">2</span>&gt;, …</span><br><span class="line">&#123;</span><br><span class="line">    &lt;派生类内容&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中：</p><ul><li><strong>继承方式</strong>可以是 <code>public</code>、<code>protected</code> 或 <code>private</code>，它决定了从父类继承过来的成员在子类中的访问权限。</li><li><strong>基类名</strong>是父类的名字。</li><li>多个父类之间用逗号分隔。</li></ul><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><p>假设我们要设计一个程序，涉及计算矩形的面积，并估算将矩形涂上油漆的总花费。这种情况下，可以通过多继承实现如下功能：</p><ol><li>**一个基类 <code>Shape</code>**：用来保存矩形的宽度和高度，并提供设置宽高的方法。</li><li>**另一个基类 <code>PaintCost</code>**：用来计算油漆的花费。</li><li>**派生类 <code>Rectangle</code>**：同时继承自 <code>Shape</code> 和 <code>PaintCost</code>，可以直接使用这两个基类的功能，并添加自己的功能，比如计算面积。</li></ol><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 Shape：处理形状的宽和高</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;  <span class="comment">// 宽度</span></span><br><span class="line">      <span class="type">int</span> height; <span class="comment">// 高度</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost：计算油漆的总花费</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>; <span class="comment">// 每平方米花费 $70</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类 Rectangle：继承 Shape 和 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> width * height; <span class="comment">// 计算矩形的面积</span></span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 设置矩形的宽和高</span></span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 计算矩形的面积</span></span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 输出面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">// 输出油漆总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="程序运行的结果"><a href="#程序运行的结果" class="headerlink" title="程序运行的结果"></a>程序运行的结果</h3><p>当运行上述代码时，会输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Total area: 35</span><br><span class="line">Total paint cost: $2450</span><br></pre></td></tr></table></figure><h3 id="详细解释代码的逻辑"><a href="#详细解释代码的逻辑" class="headerlink" title="详细解释代码的逻辑"></a>详细解释代码的逻辑</h3><ol><li><p><strong><code>Shape</code> 类的功能</strong>：</p><ul><li>它包含两个成员变量：<code>width</code> 和 <code>height</code>，分别表示矩形的宽度和高度。</li><li>提供了两个公共方法：<code>setWidth(int w)</code> 和 <code>setHeight(int h)</code>，用来设置宽度和高度的值。</li></ul></li><li><p><strong><code>PaintCost</code> 类的功能</strong>：</p><ul><li>包含一个方法 <code>getCost(int area)</code>，它接受面积作为参数，并返回涂上油漆的总费用。</li><li>每平方米油漆的费用为 <code>$70</code>。</li></ul></li><li><p><strong><code>Rectangle</code> 类的功能</strong>：</p><ul><li>它继承了 <code>Shape</code> 和 <code>PaintCost</code>，因此可以直接使用 <code>Shape</code> 类的方法（如 <code>setWidth</code> 和 <code>setHeight</code>），以及 <code>PaintCost</code> 类的方法（如 <code>getCost</code>）。</li><li>它还定义了一个自己的方法 <code>getArea()</code>，用来计算矩形的面积。</li></ul></li><li><p><strong><code>main()</code> 函数的执行流程</strong>：</p><ul><li>创建一个 <code>Rectangle</code> 对象 <code>Rect</code>。</li><li>调用 <code>setWidth(5)</code> 和 <code>setHeight(7)</code>，设置矩形的宽度为 5、高度为 7。</li><li>调用 <code>getArea()</code> 方法，计算矩形的面积为 ( 5 \times 7 &#x3D; 35 )。</li><li>调用 <code>getCost(area)</code>，计算油漆费用为 ( 35 \times 70 &#x3D; 2450 )。</li><li>最终输出面积和总费用。</li></ul></li></ol><h3 id="为什么多继承很有用？"><a href="#为什么多继承很有用？" class="headerlink" title="为什么多继承很有用？"></a>为什么多继承很有用？</h3><p>在本例中，通过继承 <code>Shape</code> 和 <code>PaintCost</code>，<code>Rectangle</code> 类不需要重新定义宽度、高度的管理方法或油漆费用的计算逻辑，这样可以减少代码的重复，同时增加了代码的可读性和可维护性。这种功能组合的方式是多继承的一个典型应用场景。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++类&amp;对象</title>
      <link href="/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/"/>
      <url>/2024/11/20/C-%E7%B1%BB-%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从本节内容开始，我将分享一些关于C++面向对象的知识，这部分的内容，需要你具备前面的知识，如果你还有不会的或者说不熟悉的地方，请<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">点击这里</a>重新温习一下,废话不多说，直接进入正题吧！</strong></p><h1 id="C-类＆对象"><a href="#C-类＆对象" class="headerlink" title="C++ 类＆对象"></a>C++ 类＆对象</h1><p><strong>C++ 是在 C 语言基础上增加了面向对象编程的功能，其中 <strong>类</strong> 是 C++ 的核心概念。你可以把类理解成一种自定义的“蓝图”或者“模板”，用来描述一类对象的特性（数据）和能力（功能）。类里面的变量叫“成员变量”，负责保存数据，而函数叫“成员函数”，用来定义这些对象可以做的事情。有了类，就能很方便地创建多个“长得一样”的对象。</strong></p><h2 id="C-类定义"><a href="#C-类定义" class="headerlink" title="C++ 类定义"></a>C++ 类定义</h2><p>在 C++ 中，<strong>类（class）</strong> 是一种用来组织数据和行为的结构。定义一个类就像是在创建一个蓝图，告诉程序我们要描述一个什么样的东西（数据）以及它可以做些什么（操作）。理解类的定义会让你轻松上手面向对象编程。</p><h3 id="如何定义一个类？"><a href="#如何定义一个类？" class="headerlink" title="如何定义一个类？"></a><strong>如何定义一个类？</strong></h3><ol><li><p><strong>关键字 <code>class</code>：</strong><br>使用 <code>class</code> 关键字告诉程序我们要定义一个类。</p></li><li><p><strong>类名：</strong><br>给类起一个有意义的名字，就像给变量取名一样。</p></li><li><p><strong>花括号 <code>&#123;&#125;</code>：</strong><br>用 <code>&#123;&#125;</code> 包围住类的内容，内容包括：</p><ul><li><strong>成员变量（属性）</strong>：用来存储对象的特性或数据。</li><li><strong>成员函数（方法）</strong>：用来描述对象的行为或操作。</li></ul></li><li><p><strong>访问权限（<code>public</code>）：</strong><br>在类中，数据和函数可以有不同的访问权限，比如 <code>public</code>、<code>private</code> 和 <code>protected</code>。其中：</p><ul><li>**<code>public</code>**：外部代码可以访问这些成员。</li><li>**<code>private</code>**：外部代码无法直接访问这些成员（稍后会详细说明）。</li></ul></li></ol><h3 id="举个例子：定义一个盒子类"><a href="#举个例子：定义一个盒子类" class="headerlink" title="举个例子：定义一个盒子类"></a><strong>举个例子：定义一个盒子类</strong></h3><p>以下是一个简单的类定义，用来描述一个盒子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 盒子的长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 盒子的宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 盒子的高度</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="细节解析："><a href="#细节解析：" class="headerlink" title="细节解析："></a><strong>细节解析：</strong></h4><ol><li><p><strong>类名 <code>Box</code>：</strong></p><ul><li>这个类名表示我们要定义的是“盒子”。</li><li>以后我们可以用这个类创建具体的“盒子对象”。</li></ul></li><li><p><strong><code>public</code> 访问权限：</strong></p><ul><li>在 <code>public</code> 下定义的变量是<strong>公开的</strong>，也就是说，外部代码可以直接访问这些变量。</li><li>如果不写 <code>public</code>，默认情况下，类的成员是 <code>private</code>，外部代码将无法直接访问它们。</li></ul></li><li><p><strong>成员变量：</strong></p><ul><li><code>length</code>、<code>breadth</code> 和 <code>height</code> 是盒子的属性，它们描述了盒子的长度、宽度和高度。</li><li>它们的数据类型是 <code>double</code>，表示这些属性可以存储带小数的数字。</li></ul></li></ol><h3 id="类是蓝图，对象是实物"><a href="#类是蓝图，对象是实物" class="headerlink" title="类是蓝图，对象是实物"></a><strong>类是蓝图，对象是实物</strong></h3><p>定义类之后，你可以通过类来创建实际的对象。比如，<code>Box</code> 类是一个蓝图，而对象就是你用这个蓝图制作出的具体“盒子”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Box myBox;  <span class="comment">// 创建一个盒子对象</span></span><br><span class="line">myBox.length = <span class="number">10.5</span>;  <span class="comment">// 给盒子对象的长度赋值</span></span><br><span class="line">myBox.breadth = <span class="number">5.5</span>;  <span class="comment">// 给盒子对象的宽度赋值</span></span><br><span class="line">myBox.height = <span class="number">3.2</span>;   <span class="comment">// 给盒子对象的高度赋值</span></span><br></pre></td></tr></table></figure><p>通过这种方式，<code>myBox</code> 成为了一个具体的盒子，它有了自己的长、宽、高。</p><h3 id="总结：类的作用"><a href="#总结：类的作用" class="headerlink" title="总结：类的作用"></a><strong>总结：类的作用</strong></h3><ol><li><strong>定义属性</strong>：类中包含的变量（如 <code>length</code>、<code>breadth</code>、<code>height</code>）用于存储对象的数据。</li><li><strong>定义行为</strong>：类中还可以包含函数，描述对象可以完成哪些动作（这里暂时未涉及函数）。</li><li><strong>灵活性</strong>：通过类，你可以方便地创建多个对象，每个对象可以有自己独特的数据。</li></ol><blockquote><p>类的核心是将数据和操作封装在一起，使得程序更加模块化和易于维护。</p></blockquote><h2 id="C-定义对象"><a href="#C-定义对象" class="headerlink" title="C++定义对象"></a>C++定义对象</h2><p>在 C++ 中，<strong>对象（object）</strong> 是类的具体实现。类就像一张设计图，而对象就是根据设计图实际“生产”出来的东西。通过对象，我们可以操作和使用类中定义的属性和方法。</p><p>下面，我们一步步来理解如何创建对象、如何操作对象的成员，以及如何通过实例加深理解。</p><hr><h3 id="1-创建对象"><a href="#1-创建对象" class="headerlink" title="1. 创建对象"></a><strong>1. 创建对象</strong></h3><p>要创建一个对象，就像声明一个变量一样简单。假设我们有一个类 <code>Box</code>，可以这样声明对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box Box1;  <span class="comment">// 创建一个类型为 Box 的对象 Box1</span></span><br><span class="line">Box Box2;  <span class="comment">// 创建一个类型为 Box 的对象 Box2</span></span><br></pre></td></tr></table></figure><p>每个对象都有自己的独立数据。换句话说，<code>Box1</code> 和 <code>Box2</code> 是两个不同的盒子，它们可以有不同的长度、宽度和高度。</p><hr><h3 id="2-访问对象的成员"><a href="#2-访问对象的成员" class="headerlink" title="2. 访问对象的成员"></a><strong>2. 访问对象的成员</strong></h3><h4 id="直接访问公共成员"><a href="#直接访问公共成员" class="headerlink" title="直接访问公共成员"></a><strong>直接访问公共成员</strong></h4><p>类的公共成员（<code>public</code>）可以通过 <strong>点操作符（<code>.</code>）</strong> 来访问和操作。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box<span class="number">1.l</span>ength = <span class="number">6.0</span>;  <span class="comment">// 设置 Box1 的长度为 6.0</span></span><br><span class="line">Box<span class="number">1.</span>breadth = <span class="number">7.0</span>; <span class="comment">// 设置 Box1 的宽度为 7.0</span></span><br><span class="line">Box<span class="number">1.</span>height = <span class="number">5.0</span>;  <span class="comment">// 设置 Box1 的高度为 5.0</span></span><br></pre></td></tr></table></figure><h4 id="通过成员函数访问成员"><a href="#通过成员函数访问成员" class="headerlink" title="通过成员函数访问成员"></a><strong>通过成员函数访问成员</strong></h4><p>有时候，我们会用成员函数来设置和获取对象的属性。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Box<span class="number">1.</span><span class="built_in">set</span>(<span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">5.0</span>);  <span class="comment">// 调用 set 函数一次性设置 Box1 的长宽高</span></span><br><span class="line"><span class="type">double</span> volume = Box<span class="number">1.</span><span class="built_in">get</span>();  <span class="comment">// 调用 get 函数获取 Box1 的体积</span></span><br></pre></td></tr></table></figure><p>这种方式不仅简洁，还能让我们在函数中添加额外的逻辑，比如检查输入值是否合法。</p><hr><h3 id="3-实例代码解析"><a href="#3-实例代码解析" class="headerlink" title="3. 实例代码解析"></a><strong>3. 实例代码解析</strong></h3><p>下面是一个完整的例子，我们结合类和对象来计算多个盒子的体积。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><strong>代码：</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;   <span class="comment">// 长度</span></span><br><span class="line">    <span class="type">double</span> breadth;  <span class="comment">// 宽度</span></span><br><span class="line">    <span class="type">double</span> height;   <span class="comment">// 高度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员函数声明</span></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">get</span><span class="params">()</span></span>;                 <span class="comment">// 计算体积</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span></span>;  <span class="comment">// 设置盒子的长宽高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义</span></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Box::get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> length * breadth * height;  <span class="comment">// 返回体积</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Box::set</span><span class="params">(<span class="type">double</span> len, <span class="type">double</span> bre, <span class="type">double</span> hei)</span> </span>&#123;</span><br><span class="line">    length = len;</span><br><span class="line">    breadth = bre;</span><br><span class="line">    height = hei;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Box Box1, Box2, Box3;  <span class="comment">// 创建 3 个 Box 对象</span></span><br><span class="line">    <span class="type">double</span> volume = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接设置 Box1 的属性</span></span><br><span class="line">    Box<span class="number">1.l</span>ength = <span class="number">6.0</span>;</span><br><span class="line">    Box<span class="number">1.</span>breadth = <span class="number">7.0</span>;</span><br><span class="line">    Box<span class="number">1.</span>height = <span class="number">5.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 直接设置 Box2 的属性</span></span><br><span class="line">    Box<span class="number">2.l</span>ength = <span class="number">12.0</span>;</span><br><span class="line">    Box<span class="number">2.</span>breadth = <span class="number">13.0</span>;</span><br><span class="line">    Box<span class="number">2.</span>height = <span class="number">10.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算并输出 Box1 和 Box2 的体积</span></span><br><span class="line">    volume = Box<span class="number">1.l</span>ength * Box<span class="number">1.</span>breadth * Box<span class="number">1.</span>height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box1 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    volume = Box<span class="number">2.l</span>ength * Box<span class="number">2.</span>breadth * Box<span class="number">2.</span>height;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box2 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 set 和 get 方法设置 Box3 的属性并获取体积</span></span><br><span class="line">    Box<span class="number">3.</span><span class="built_in">set</span>(<span class="number">16.0</span>, <span class="number">8.0</span>, <span class="number">12.0</span>);</span><br><span class="line">    volume = Box<span class="number">3.</span><span class="built_in">get</span>();</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Box3 的体积：&quot;</span> &lt;&lt; volume &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出结果："><a href="#输出结果：" class="headerlink" title="输出结果："></a><strong>输出结果：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Box1 的体积：210</span><br><span class="line">Box2 的体积：1560</span><br><span class="line">Box3 的体积：1536</span><br></pre></td></tr></table></figure><hr><h3 id="4-细节说明"><a href="#4-细节说明" class="headerlink" title="4. 细节说明"></a><strong>4. 细节说明</strong></h3><h4 id="成员函数的作用"><a href="#成员函数的作用" class="headerlink" title="成员函数的作用"></a><strong>成员函数的作用</strong></h4><ul><li><code>set()</code> 函数：用来一次性设置盒子的长度、宽度和高度。</li><li><code>get()</code> 函数：用来计算盒子的体积。</li></ul><p>这两个函数的好处是可以让代码更规范、更清晰，同时也能避免直接操作数据成员可能带来的错误。</p><h4 id="为什么要用点操作符（-）？"><a href="#为什么要用点操作符（-）？" class="headerlink" title="为什么要用点操作符（.）？"></a><strong>为什么要用点操作符（<code>.</code>）？</strong></h4><p>点操作符 <code>.</code> 的作用是连接对象和它的成员（属性或函数）。例如：</p><ul><li><code>Box1.length</code> 表示访问 <code>Box1</code> 的长度属性。</li><li><code>Box3.get()</code> 表示调用 <code>Box3</code> 的 <code>get()</code> 函数。</li></ul><h4 id="关于访问权限："><a href="#关于访问权限：" class="headerlink" title="关于访问权限："></a><strong>关于访问权限：</strong></h4><ul><li><strong>公共成员（<code>public</code>）</strong>：<ul><li>例如 <code>length</code>、<code>breadth</code>、<code>height</code>，可以直接通过对象访问。</li></ul></li><li><strong>私有成员（<code>private</code>）</strong>：<ul><li>私有成员不能直接访问，通常需要通过函数（如 <code>set()</code> 和 <code>get()</code>）来间接操作。</li></ul></li></ul><hr><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a><strong>5. 总结</strong></h3><ol><li><strong>对象是类的具体实例</strong>：<ul><li>类是设计图，对象是根据设计图创建的实际东西。</li></ul></li><li><strong>访问对象的成员</strong>：<ul><li>通过点操作符直接访问公共成员。</li><li>通过成员函数间接访问私有或公共成员。</li></ul></li><li><strong>使用成员函数的优势</strong>：<ul><li>更加安全、规范，能够控制数据的合法性。</li></ul></li><li><strong>分离定义和实现</strong>：<ul><li>在类中声明函数，在类外实现函数，有助于让代码结构更清晰。</li></ul></li></ol><h2 id="类＆对象详解"><a href="#类＆对象详解" class="headerlink" title="类＆对象详解"></a>类＆对象详解</h2><h3 id="C-类与对象深入理解"><a href="#C-类与对象深入理解" class="headerlink" title="C++ 类与对象深入理解"></a>C++ 类与对象深入理解</h3><p>C++ 的类和对象不仅包括我们之前学到的基础知识，还有许多高级概念。这些概念可以帮助我们更高效、更灵活地编写代码。下面是一些重要的类和对象相关概念的通俗解释和用途。</p><h4 id="C-类与对象相关概念总结"><a href="#C-类与对象相关概念总结" class="headerlink" title="C++ 类与对象相关概念总结"></a><strong>C++ 类与对象相关概念总结</strong></h4><table><thead><tr><th><strong>概念</strong></th><th><strong>描述（通俗易懂的解释）</strong></th></tr></thead><tbody><tr><td><strong>类成员函数</strong></td><td>类中的函数称为成员函数，它是用来操作类中数据的函数。它们就像工具，帮助你操作和处理类的属性，比如设置值或计算结果。</td></tr><tr><td><strong>类访问修饰符</strong></td><td>类的属性和函数可以设置为：<br>- <code>public</code>：可以被外部直接访问。<br>- <code>private</code>：只能在类内部使用，外部不能直接访问。<br>- <code>protected</code>：继承时的特殊访问方式。</td></tr><tr><td><strong>构造函数 &amp; 析构函数</strong></td><td>构造函数是在创建对象时自动调用的特殊函数，用于初始化对象的属性。<br>析构函数则是在对象被销毁时调用，用于清理资源。它们是一对让对象创建和销毁更方便的函数。</td></tr><tr><td><strong>拷贝构造函数</strong></td><td>拷贝构造函数用于用一个已有的对象来创建新的对象，就像“克隆”一样。比如将对象 A 的值赋给对象 B 时会调用拷贝构造函数。</td></tr><tr><td><strong>友元函数</strong></td><td>友元函数是类的“朋友”，它可以访问类的私有和受保护成员。虽然它不是类的成员，但它能帮助实现更复杂的操作。</td></tr><tr><td><strong>内联函数</strong></td><td>内联函数是编译器直接把函数代码插入到调用点，省去了函数调用的开销，适合用在短小的函数上。</td></tr><tr><td><strong>this 指针</strong></td><td>每个对象都有一个特殊指针 <code>this</code>，它指向对象本身。通过 <code>this</code> 指针可以访问或操作当前对象的属性。</td></tr><tr><td><strong>指向类的指针</strong></td><td>类的指针就像指向结构体的指针一样。它允许你通过指针访问对象的属性和方法，适合处理动态创建的对象或需要共享对象的情况。</td></tr><tr><td><strong>静态成员</strong></td><td>静态成员属于整个类而不是某个对象。静态变量可以被所有对象共享，静态函数可以在没有对象的情况下调用。比如计数器、全局配置等。</td></tr></tbody></table><hr><h4 id="深入理解概念：举例说明"><a href="#深入理解概念：举例说明" class="headerlink" title="深入理解概念：举例说明"></a><strong>深入理解概念：举例说明</strong></h4><h5 id="1-类成员函数"><a href="#1-类成员函数" class="headerlink" title="1. 类成员函数"></a><strong>1. 类成员函数</strong></h5><p>类的成员函数用于操作类的属性，例如设置值和获取值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 公共成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123;  <span class="comment">// 成员函数</span></span><br><span class="line">        length = len;  <span class="comment">// 设置长度</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;  <span class="comment">// 成员函数</span></span><br><span class="line">        <span class="keyword">return</span> length;  <span class="comment">// 获取长度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="2-类访问修饰符"><a href="#2-类访问修饰符" class="headerlink" title="2. 类访问修饰符"></a><strong>2. 类访问修饰符</strong></h5><p>控制类成员的访问权限：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> length;  <span class="comment">// 私有变量，外部无法直接访问</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setLength</span><span class="params">(<span class="type">double</span> len)</span> </span>&#123;  <span class="comment">// 公共函数，用于设置 length</span></span><br><span class="line">        length = len;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getLength</span><span class="params">()</span> </span>&#123;  <span class="comment">// 公共函数，用于获取 length</span></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="3-构造函数-析构函数"><a href="#3-构造函数-析构函数" class="headerlink" title="3. 构造函数 &amp; 析构函数"></a><strong>3. 构造函数 &amp; 析构函数</strong></h5><p>构造函数和析构函数会自动执行，无需手动调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Box</span>() &#123;  <span class="comment">// 构造函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象被创建！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Box</span>() &#123;  <span class="comment">// 析构函数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;对象被销毁！&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-拷贝构造函数"><a href="#4-拷贝构造函数" class="headerlink" title="4. 拷贝构造函数"></a><strong>4. 拷贝构造函数</strong></h5><p>通过已有对象创建新对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">double</span> length;</span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">double</span> len) : <span class="built_in">length</span>(len) &#123;&#125;  <span class="comment">// 普通构造函数</span></span><br><span class="line">    <span class="built_in">Box</span>(<span class="type">const</span> Box&amp; obj) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">        length = obj.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-静态成员"><a href="#5-静态成员" class="headerlink" title="5. 静态成员"></a><strong>5. 静态成员</strong></h5><p>静态成员变量和函数属于整个类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Box</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count;  <span class="comment">// 静态变量</span></span><br><span class="line">    <span class="built_in">Box</span>() &#123; count++; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Box::count = <span class="number">0</span>;  <span class="comment">// 初始化静态变量</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++面向对象 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>50MB大小的黑科技</title>
      <link href="/2024/11/16/50MB%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
      <url>/2024/11/16/50MB%E5%A4%A7%E5%B0%8F%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>在我的的手机里有个超级英雄——工具箱类app，它就像是手机里的瑞士军刀，啥都能干，把那些偶尔才用一次的“独行侠”软件都给比下去了。😏</strong></p><p><strong>说到这个，不得不提“一个木函”，这个下载量破千万的大佬，用起来简直就像吃了德芙一样顺滑。但是，时间这把杀猪刀，不仅让人变老，也让软件变“贵”了。一个木函开始收费了，而且价格还不便宜，让人心疼钱包。</strong></p><p><strong>于是，一群用户开始了一场“逃离木函”的大逃亡，他们四处寻找新的避风港，希望找到一个既能省钱又能省心的新伙伴。这场景，简直就像是一部手机应用界的《泰坦尼克号》，只不过这次，冰山是付费墙，而救生艇是其他免费的替代软件。</strong></p><h1 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h1><p><strong>软件名称：小尼工具箱</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：–MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><p><strong>这款工具箱app简直就是安卓手机的“瑞士军刀”Plus版，它把你想要的所有小工具都塞进了一个应用里，就像是手机界的“多啦A梦”口袋，应有尽有，简直是全能战士。</strong></p><p><strong>而且，这个宝贝是完全免费的，没有任何使用限制，就像是一个慷慨的圣诞老人，给你一大堆礼物，却不要求你唱一首圣诞歌作为交换。安装后，你就能立刻开始使用，方便得就像是找到了遥控器，一键开启懒人模式。</strong></p><p><strong>用这款软件，你可以根据自己的需求，像点菜一样挑选功能，它就是你的私人订制“手机大厨”，为你的手机生活增添无限风味。这不仅仅是一个应用，这是你手机上的“生活小能手”，让你的手机生活更加多姿多彩，就像是给手机装上了“智慧的翅膀”，飞得更高，玩得更嗨！😋</strong></p><div style="text-align:center">  <img src="/img_2/E9BAE44C56853501A9C792F9A0C2E17C.jpg" alt="主页面" ></div><p><strong>这款应用里有个超酷的功能，叫做视频短片解析器，它就像是视频界的“变形金刚”，能处理视频也能搞定图片。这个功能有三个强大的解析通道，就像是三头六臂的哪吒，让用户能够轻松拿到视频封面图。更棒的是，它还能把视频下载成1080P的高清版，清晰得就像是你亲眼所见，画质确实很不错😊</strong></p><div style="text-align:center">  <img src="/img_2/842B3DEB54D50E65B7C6A916459D5190.jpg" alt="" ></div><p><strong>甚至还有内置音乐下载功能，资源很齐全，大家懂的都懂😏</strong></p><div style="text-align:center">  <img src="/img_2/33E293ACB7E723E92422477F9038976F.jpg" alt="" ></div><p><strong>这款软件里头，壁纸资源多得就像个宝藏库，有十几种分类任你挑，还能用搜索功能精准定位到你的“心动壁纸”。每张壁纸都是高清大图，质量杠杠的，而且你想保存多少就保存多少，无限制</strong></p><p><strong>但这款软件的本事可不止这些，它还有一大堆实用功能，就像个多功能的瑞士军刀。不过，有些功能因为一些原因，咱们这里就不多说了，免得说多了都是泪。有兴趣的朋友们，不妨亲自下载来试试，探索一下这个软件的奥秘，说不定会有意想不到的惊喜等着你!</strong></p><div style="text-align:center">  <img src="/img_2/501326FD62944FA191451DBD80476F68.jpg" alt="" ></div><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong><a href="https://wwso.lanzoub.com/iVv6v2f1a0gf">https://wwso.lanzoub.com/iVv6v2f1a0gf</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 工具类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数据结构</title>
      <link href="/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容是<code>C++ 基础教程</code>的最后一部分，对于这一节的内容，看不懂也没关系，等大家学习数据结构以后再来看就能够懂了。说说之后的安排吧，这一节内容结束以后，我将会分享更加深入的知识，也就是<code>C++ 面向对象</code>的相关内容，对于<code>C++ 基础教程</code>这一部分的内容如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数据结构"><a href="#C-数据结构" class="headerlink" title="C++ 数据结构"></a>C++ 数据结构</h1><p>在 C++ 中，数据结构是用来组织和管理数据的重要工具。C++ 提供了从简单到复杂的多种数据结构，既包括基础的数组、结构体，也包括强大的 STL（Standard Template Library）容器，如 <code>vector</code>、<code>map</code> 等。这些数据结构各有优缺点，适合不同的场景。以下是对这些数据结构的详细介绍。</p><hr><h2 id="1-数组（Array）"><a href="#1-数组（Array）" class="headerlink" title="1. 数组（Array）"></a><strong>1. 数组（Array）</strong></h2><h3 id="什么是数组？"><a href="#什么是数组？" class="headerlink" title="什么是数组？"></a><strong>什么是数组？</strong></h3><p>数组是一组存储相同类型数据的连续内存块，可以通过索引访问元素。数组的大小在声明时固定，不能动态改变。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>连续存储</strong>：所有元素在内存中是连续分布的。</li><li><strong>固定大小</strong>：声明时确定大小，运行时无法更改。</li><li><strong>快速访问</strong>：通过索引直接访问元素，时间复杂度为 O(1)。</li><li><strong>适用场景</strong>：适合存储已知大小的同类型数据集合。</li></ul><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 定义一个整型数组</span></span><br><span class="line">cout &lt;&lt; arr[<span class="number">0</span>]; <span class="comment">// 输出第一个元素 1</span></span><br><span class="line">arr[<span class="number">2</span>] = <span class="number">10</span>;    <span class="comment">// 修改第三个元素为 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>访问速度快（随机访问 O(1)）。  </li><li>内存紧凑。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法动态调整大小。  </li><li>插入和删除效率低（需要移动元素）。</li></ul></li></ul><h3 id="典型应用"><a href="#典型应用" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数值统计（如存储分数列表）。</li><li>固定大小的矩阵或表格。</li></ul><hr><h2 id="2-结构体（Struct）"><a href="#2-结构体（Struct）" class="headerlink" title="2. 结构体（Struct）"></a><strong>2. 结构体（Struct）</strong></h2><h3 id="什么是结构体？"><a href="#什么是结构体？" class="headerlink" title="什么是结构体？"></a><strong>什么是结构体？</strong></h3><p>结构体是一种自定义数据类型，可以将不同类型的数据组合在一起。它可以看作是“迷你数据库”，用来描述某些实体或对象。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>可以组合多种数据类型。</li><li>成员变量可以是基本类型或复杂类型。</li><li>提供基本的封装，但功能有限。</li></ul><h3 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person p = &#123;<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>&#125;;</span><br><span class="line">cout &lt;&lt; p.name &lt;&lt; endl; <span class="comment">// 输出 &quot;Alice&quot;</span></span><br><span class="line">p.age = <span class="number">30</span>; <span class="comment">// 修改年龄</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>逻辑清晰，适合组织复杂数据。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不支持继承和多态，功能比类弱。</li></ul></li></ul><h3 id="典型应用-1"><a href="#典型应用-1" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>用于表示实体对象，如学生、员工等。</li></ul><hr><h2 id="3-类（Class）"><a href="#3-类（Class）" class="headerlink" title="3. 类（Class）"></a><strong>3. 类（Class）</strong></h2><h3 id="什么是类？"><a href="#什么是类？" class="headerlink" title="什么是类？"></a><strong>什么是类？</strong></h3><p>类是面向对象编程的核心，可以定义数据（成员变量）和行为（成员函数）。与结构体类似，但功能更强大，支持继承、多态、封装等特性。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>成员变量默认是私有的（<code>private</code>）。</li><li>支持方法、构造函数、析构函数等。</li><li>支持继承和多态。</li></ul><h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string name;</span><br><span class="line">    <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string n, <span class="type">int</span> a) : <span class="built_in">name</span>(n), <span class="built_in">age</span>(a) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">printInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Name: &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot;, Age: &quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">p.<span class="built_in">printInfo</span>(); <span class="comment">// 输出: Name: Bob, Age: 30</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>功能强大，适合大型项目。</li></ul></li><li><strong>缺点</strong>：  <ul><li>开发复杂度较高。</li></ul></li></ul><h3 id="典型应用-2"><a href="#典型应用-2" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>面向对象设计中，如实现用户类、产品类等。</li></ul><hr><h2 id="4-链表（Linked-List）"><a href="#4-链表（Linked-List）" class="headerlink" title="4. 链表（Linked List）"></a><strong>4. 链表（Linked List）</strong></h2><h3 id="什么是链表？"><a href="#什么是链表？" class="headerlink" title="什么是链表？"></a><strong>什么是链表？</strong></h3><p>链表是一种动态数据结构，由节点组成，每个节点包含数据和指向下一个节点的指针。</p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：可以在运行时动态调整大小。</li><li><strong>高效插入&#x2F;删除</strong>：在链表头部或尾部操作的时间复杂度为 O(1)。</li><li><strong>线性查找</strong>：访问某个元素需要从头开始查找，时间复杂度为 O(n)。</li></ul><h3 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Node* head = <span class="literal">nullptr</span>;            <span class="comment">// 链表头指针</span></span><br><span class="line">Node* newNode = <span class="keyword">new</span> Node&#123;<span class="number">10</span>, <span class="literal">nullptr</span>&#125;; <span class="comment">// 新节点</span></span><br><span class="line">head = newNode;                  <span class="comment">// 将新节点插入链表</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-3"><a href="#优缺点-3" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态大小，插入&#x2F;删除效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>查找效率低，随机访问效率远不如数组。</li></ul></li></ul><h3 id="典型应用-3"><a href="#典型应用-3" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>数据流处理。</li><li>实现队列、栈等动态数据结构。</li></ul><hr><h2 id="5-栈（Stack）"><a href="#5-栈（Stack）" class="headerlink" title="5. 栈（Stack）"></a><strong>5. 栈（Stack）</strong></h2><h3 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a><strong>什么是栈？</strong></h3><p>栈是一种后进先出（LIFO）的数据结构，像“弹簧盒”，只能从顶部插入和删除。</p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>只能操作栈顶元素。</li><li>插入和删除的时间复杂度为 O(1)。</li></ul><h3 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">1</span>);       <span class="comment">// 压栈</span></span><br><span class="line">s.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; s.<span class="built_in">top</span>(); <span class="comment">// 输出 2</span></span><br><span class="line">s.<span class="built_in">pop</span>();         <span class="comment">// 弹栈</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-4"><a href="#优缺点-4" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>操作简单，效率高。</li></ul></li><li><strong>缺点</strong>：  <ul><li>不能随机访问。</li></ul></li></ul><h3 id="典型应用-4"><a href="#典型应用-4" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>递归调用栈。</li><li>表达式求值。</li></ul><hr><h2 id="6-队列（Queue）"><a href="#6-队列（Queue）" class="headerlink" title="6. 队列（Queue）"></a><strong>6. 队列（Queue）</strong></h2><h3 id="什么是队列？"><a href="#什么是队列？" class="headerlink" title="什么是队列？"></a><strong>什么是队列？</strong></h3><p>队列是一种先进先出（FIFO）的数据结构，像排队的队伍。</p><h3 id="特点-5"><a href="#特点-5" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li>从队尾插入元素，从队头删除元素。</li><li>时间复杂度为 O(1)。</li></ul><h3 id="实例-5"><a href="#实例-5" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);        <span class="comment">// 入队</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; q.<span class="built_in">front</span>(); <span class="comment">// 输出 1</span></span><br><span class="line">q.<span class="built_in">pop</span>();          <span class="comment">// 出队</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-5"><a href="#优缺点-5" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>按顺序处理数据，适合任务调度等场景。</li></ul></li><li><strong>缺点</strong>：  <ul><li>无法随机访问。</li></ul></li></ul><h3 id="典型应用-5"><a href="#典型应用-5" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>任务调度。</li><li>广度优先搜索（BFS）。</li></ul><hr><h2 id="7-动态数组（Vector）"><a href="#7-动态数组（Vector）" class="headerlink" title="7. 动态数组（Vector）"></a><strong>7. 动态数组（Vector）</strong></h2><h3 id="什么是动态数组？"><a href="#什么是动态数组？" class="headerlink" title="什么是动态数组？"></a><strong>什么是动态数组？</strong></h3><p><code>vector</code> 是 C++ 标准库提供的动态数组实现，可以根据需要自动扩展大小。</p><h3 id="特点-6"><a href="#特点-6" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>动态大小</strong>：内存不足时会自动扩容。</li><li><strong>随机访问</strong>：支持通过索引访问元素，时间复杂度为 O(1)。</li></ul><h3 id="实例-6"><a href="#实例-6" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; v[<span class="number">0</span>]; <span class="comment">// 输出 1</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-6"><a href="#优缺点-6" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>动态调整大小，使用方便。</li></ul></li><li><strong>缺点</strong>：  <ul><li>插入&#x2F;删除中间元素效率较低。</li></ul></li></ul><h3 id="典型应用-6"><a href="#典型应用-6" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>动态增长的数据集合。</li></ul><hr><h2 id="8-哈希表（Hash-Table）"><a href="#8-哈希表（Hash-Table）" class="headerlink" title="8. 哈希表（Hash Table）"></a><strong>8. 哈希表（Hash Table）</strong></h2><h3 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a><strong>什么是哈希表？</strong></h3><p>哈希表是一种通过键值对存储数据的结构，使用哈希函数快速定位元素。</p><h3 id="特点-7"><a href="#特点-7" class="headerlink" title="特点"></a><strong>特点</strong></h3><ul><li><strong>快速操作</strong>：查找、插入和删除的时间复杂度为 O(1)。</li><li><strong>无序存储</strong>：元素存储顺序不固定。</li></ul><h3 id="实例-7"><a href="#实例-7" class="headerlink" title="实例"></a><strong>实例</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;string, <span class="type">int</span>&gt; hashTable;</span><br><span class="line">hashTable[<span class="string">&quot;apple&quot;</span>] = <span class="number">10</span>;</span><br><span class="line">cout &lt;&lt; hashTable[<span class="string">&quot;apple&quot;</span>]; <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><h3 id="优缺点-7"><a href="#优缺点-7" class="headerlink" title="优缺点"></a><strong>优缺点</strong></h3><ul><li><strong>优点</strong>：  <ul><li>高效查找和操作。</li></ul></li><li><strong>缺点</strong>：  <ul><li>可能发生哈希冲突。</li></ul></li></ul><h3 id="典型应用-7"><a href="#典型应用-7" class="headerlink" title="典型应用"></a><strong>典型应用</strong></h3><ul><li>实现键值对存储，如字典。</li></ul><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><table><thead><tr><th>数据结构</th><th>特点</th><th>典型场景</th></tr></thead><tbody><tr><td>数组（Array）</td><td>连续存储，固定大小，快速随机访问</td><td>固定大小的数据集合</td></tr><tr><td>结构体（Struct）</td><td>组合不同类型的数据</td><td>实体对象描述</td></tr><tr><td>类（Class）</td><td>支持面向对象编程，封装数据与行为</td><td>复杂对象建模</td></tr><tr><td>链表（Linked List）</td><td>动态大小，高效插入&#x2F;删除，但查找效率低</td><td>数据流，动态数据集合</td></tr><tr><td>栈（Stack）</td><td>后进先出，操作简单</td><td>表达式求值，递归处理</td></tr><tr><td>队列（Queue）</td><td>先进先出，适合按顺序处理数据</td><td>任务调度</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ vector容器</title>
      <link href="/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/"/>
      <url>/2024/11/16/C-vector%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-vector容器"><a href="#C-vector容器" class="headerlink" title="C++ vector容器"></a>C++ vector容器</h1><p>在 C++ 中，<code>vector</code> 是一种非常强大的数据结构，它和数组类似，但功能更灵活。<strong>它是一个可以动态调整大小的数组</strong>，不需要你手动管理内存，是 C++ 标准模板库（STL）的一部分。</p><p>如果你需要一个可以自动扩展的数组来存储数据，<code>vector</code> 是你的首选。</p><hr><h2 id="为什么用-vector-而不是数组？"><a href="#为什么用-vector-而不是数组？" class="headerlink" title="为什么用 vector 而不是数组？"></a><strong>为什么用 <code>vector</code> 而不是数组？</strong></h2><p>数组虽然可以存储元素，但有几个缺点：</p><ol><li><strong>固定大小</strong>：数组在创建时必须指定大小，无法动态扩展或缩小。</li><li><strong>手动管理内存</strong>：如果需要动态数组，你必须手动分配和释放内存，容易出错。</li><li><strong>功能有限</strong>：数组没有直接提供添加、删除、查找等功能。</li></ol><p>而 <code>vector</code> 可以解决这些问题：</p><ul><li><strong>动态大小</strong>：<code>vector</code> 可以根据需要自动增长或缩小。</li><li><strong>连续存储</strong>：<code>vector</code> 的元素存储在连续的内存中，因此访问速度快。</li><li><strong>灵活接口</strong>：提供了丰富的操作方法，如添加、删除、清空等。</li></ul><hr><h2 id="如何使用-vector？"><a href="#如何使用-vector？" class="headerlink" title="如何使用 vector？"></a><strong>如何使用 <code>vector</code>？</strong></h2><h3 id="1-引入头文件"><a href="#1-引入头文件" class="headerlink" title="1. 引入头文件"></a>1. <strong>引入头文件</strong></h3><p>要使用 <code>vector</code>，必须包含 <code>&lt;vector&gt;</code> 头文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br></pre></td></tr></table></figure><hr><h3 id="2-创建-vector"><a href="#2-创建-vector" class="headerlink" title="2. 创建 vector"></a>2. <strong>创建 <code>vector</code></strong></h3><p>创建 <code>vector</code> 和声明普通变量一样简单。</p><h4 id="示例：创建一个存储整数的-vector"><a href="#示例：创建一个存储整数的-vector" class="headerlink" title="示例：创建一个存储整数的 vector"></a>示例：创建一个存储整数的 <code>vector</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector; <span class="comment">// 创建一个空的整数向量</span></span><br></pre></td></tr></table></figure><h4 id="示例：创建时指定大小"><a href="#示例：创建时指定大小" class="headerlink" title="示例：创建时指定大小"></a>示例：创建时指定大小</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，初始值为默认值（0）</span></span><br><span class="line"><span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">5</span>, <span class="number">10</span>)</span></span>; <span class="comment">// 创建一个大小为5的向量，每个元素初始值为10</span></span><br></pre></td></tr></table></figure><h4 id="示例：使用列表初始化"><a href="#示例：使用列表初始化" class="headerlink" title="示例：使用列表初始化"></a>示例：使用列表初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;; <span class="comment">// 创建一个包含元素1, 2, 3, 4, 5的向量</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-向-vector-添加元素"><a href="#3-向-vector-添加元素" class="headerlink" title="3. 向 vector 添加元素"></a>3. <strong>向 <code>vector</code> 添加元素</strong></h3><p>使用 <code>push_back</code> 方法，可以在 <code>vector</code> 的末尾添加元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">push_back</span>(<span class="number">7</span>); <span class="comment">// 向向量末尾添加元素7</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-访问-vector-中的元素"><a href="#4-访问-vector-中的元素" class="headerlink" title="4. 访问 vector 中的元素"></a>4. <strong>访问 <code>vector</code> 中的元素</strong></h3><p>你可以通过两种方式访问元素：</p><ul><li>**下标操作符 <code>[]</code>**：直接通过下标访问元素（从 0 开始计数）。</li><li><strong><code>at()</code> 方法</strong>：更安全的访问方法，会检查下标是否合法。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = myVector[<span class="number">0</span>];      <span class="comment">// 获取第一个元素</span></span><br><span class="line"><span class="type">int</span> y = myVector.<span class="built_in">at</span>(<span class="number">1</span>);   <span class="comment">// 获取第二个元素</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-获取-vector-的大小"><a href="#5-获取-vector-的大小" class="headerlink" title="5. 获取 vector 的大小"></a>5. <strong>获取 <code>vector</code> 的大小</strong></h3><p>使用 <code>size()</code> 方法可以得到 <code>vector</code> 中的元素数量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> size = myVector.<span class="built_in">size</span>(); <span class="comment">// 获取向量大小</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-遍历-vector"><a href="#6-遍历-vector" class="headerlink" title="6. 遍历 vector"></a>6. <strong>遍历 <code>vector</code></strong></h3><p>你可以用多种方式遍历 <code>vector</code>：</p><h4 id="方法-1：普通-for-循环"><a href="#方法-1：普通-for-循环" class="headerlink" title="方法 1：普通 for 循环"></a>方法 1：普通 for 循环</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; myVector.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">    std::cout &lt;&lt; myVector[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-2：迭代器"><a href="#方法-2：迭代器" class="headerlink" title="方法 2：迭代器"></a>方法 2：迭代器</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myVector.<span class="built_in">begin</span>(); it != myVector.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="方法-3：范围循环（推荐）"><a href="#方法-3：范围循环（推荐）" class="headerlink" title="方法 3：范围循环（推荐）"></a>方法 3：范围循环（推荐）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">    std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="7-删除元素"><a href="#7-删除元素" class="headerlink" title="7. 删除元素"></a>7. <strong>删除元素</strong></h3><p>使用 <code>erase()</code> 方法可以删除某个位置的元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>); <span class="comment">// 删除第三个元素（下标为2）</span></span><br></pre></td></tr></table></figure><hr><h3 id="8-清空-vector"><a href="#8-清空-vector" class="headerlink" title="8. 清空 vector"></a>8. <strong>清空 <code>vector</code></strong></h3><p>使用 <code>clear()</code> 方法可以清空 <code>vector</code> 中的所有元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myVector.<span class="built_in">clear</span>(); <span class="comment">// 清空向量</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整实例"><a href="#完整实例" class="headerlink" title="完整实例"></a><strong>完整实例</strong></h2><p>以下代码展示了如何创建一个 <code>vector</code>，添加、访问、删除、清空元素，并输出其内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个空的整数向量</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加元素到向量中</span></span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">7</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">11</span>);</span><br><span class="line">    myVector.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出向量中的元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 访问第一个和第二个元素</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;First element: &quot;</span> &lt;&lt; myVector[<span class="number">0</span>] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Second element: &quot;</span> &lt;&lt; myVector.<span class="built_in">at</span>(<span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取向量大小</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除第三个元素</span></span><br><span class="line">    myVector.<span class="built_in">erase</span>(myVector.<span class="built_in">begin</span>() + <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出删除后的向量</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Elements in the vector after erasing: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> element : myVector) &#123;</span><br><span class="line">        std::cout &lt;&lt; element &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空向量</span></span><br><span class="line">    myVector.<span class="built_in">clear</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Size of the vector after clearing: &quot;</span> &lt;&lt; myVector.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Elements in the vector: 3 7 11 5</span><br><span class="line">First element: 3</span><br><span class="line">Second element: 7</span><br><span class="line">Size of the vector: 4</span><br><span class="line">Elements in the vector after erasing: 3 7 5</span><br><span class="line">Size of the vector after clearing: 0</span><br></pre></td></tr></table></figure><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><ol><li><strong><code>vector</code> 是一个动态数组</strong>，可以根据需要自动扩展或缩小。</li><li>使用方便：<ul><li>添加元素：<code>push_back()</code></li><li>删除元素：<code>erase()</code></li><li>访问元素：<code>[]</code> 或 <code>at()</code></li><li>遍历：普通循环、迭代器、范围循环。</li></ul></li><li><strong>适用场景</strong>：<ul><li>需要动态调整大小的数组。</li><li>需要频繁在末尾添加或移除元素。</li><li>需要高效的随机访问操作。</li></ul></li></ol><p><code>vector</code> 是 C++ 开发中最常用的容器之一，简单易用且功能强大，几乎可以胜任所有需要动态数组的场景。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 结构体(struct)</title>
      <link href="/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/"/>
      <url>/2024/11/16/C-%E7%BB%93%E6%9E%84%E4%BD%93-struct/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-结构体-struct"><a href="#C-结构体-struct" class="headerlink" title="C++ 结构体(struct)"></a>C++ 结构体(struct)</h1><p>在C++中，<strong>结构体（<code>struct</code>）</strong> 是一种非常有用的数据类型，它可以把多种类型的数据组合在一起，形成一个整体。简单来说，<strong>结构体就是一个容器，可以存放不同类型的变量，这些变量称为结构体的“成员”</strong>。</p><hr><h2 id="为什么需要结构体？"><a href="#为什么需要结构体？" class="headerlink" title="为什么需要结构体？"></a><strong>为什么需要结构体？</strong></h2><p>假设我们要管理一本书的信息，比如：</p><ul><li><strong>标题（Title）</strong>：比如《C++ 教程》</li><li><strong>作者（Author）</strong>：比如“张三”</li><li><strong>类别（Subject）</strong>：比如“编程”</li><li><strong>编号（Book ID）</strong>：比如“12345”</li></ul><p>这些属性的数据类型是不同的：</p><ul><li>标题和作者是<strong>字符串</strong>，</li><li>编号是<strong>整数</strong>。</li></ul><p>如果用普通的变量来存储这些信息，代码会变得杂乱无章：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string title1 = <span class="string">&quot;C++ 教程&quot;</span>;</span><br><span class="line">string author1 = <span class="string">&quot;张三&quot;</span>;</span><br><span class="line">string subject1 = <span class="string">&quot;编程&quot;</span>;</span><br><span class="line"><span class="type">int</span> bookID1 = <span class="number">12345</span>;</span><br></pre></td></tr></table></figure><p>每增加一本书，就需要定义四个变量，管理起来非常麻烦。<br><strong>结构体</strong>解决了这个问题：它允许我们把这些相关的数据组合起来，作为一个整体来管理。</p><hr><h2 id="如何定义结构体？"><a href="#如何定义结构体？" class="headerlink" title="如何定义结构体？"></a><strong>如何定义结构体？</strong></h2><p>用 <code>struct</code> 关键字来定义结构体，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">StructName</span> &#123;</span><br><span class="line">    DataType MemberName1; <span class="comment">// 第一个成员</span></span><br><span class="line">    DataType MemberName2; <span class="comment">// 第二个成员</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例如，定义一个用于表示“书籍”的结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><strong><code>Book</code></strong> 是结构体类型的名字。</li><li>结构体里包含的成员有：<code>title</code>、<code>author</code>、<code>subject</code> 和 <code>book_id</code>。</li></ul><hr><h2 id="如何使用结构体？"><a href="#如何使用结构体？" class="headerlink" title="如何使用结构体？"></a><strong>如何使用结构体？</strong></h2><p>定义了结构体后，可以用它来创建“结构体变量”，表示具体的对象（如一本书）：</p><h3 id="1-创建结构体变量"><a href="#1-创建结构体变量" class="headerlink" title="1. 创建结构体变量"></a><strong>1. 创建结构体变量</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Book book1, book2;</span><br></pre></td></tr></table></figure><p>上面创建了两个结构体变量 <code>book1</code> 和 <code>book2</code>，分别表示两本书。</p><h3 id="2-访问结构体成员"><a href="#2-访问结构体成员" class="headerlink" title="2. 访问结构体成员"></a><strong>2. 访问结构体成员</strong></h3><p>结构体的成员可以通过 <strong><code>.</code> 运算符</strong> 来访问或赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">book<span class="number">1.</span>book_id = <span class="number">12345</span>;               <span class="comment">// 设置编号</span></span><br><span class="line"><span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);     <span class="comment">// 设置标题</span></span><br><span class="line">cout &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;         <span class="comment">// 输出标题</span></span><br></pre></td></tr></table></figure><hr><h2 id="完整示例：存储并输出两本书的信息"><a href="#完整示例：存储并输出两本书的信息" class="headerlink" title="完整示例：存储并输出两本书的信息"></a><strong>完整示例：存储并输出两本书的信息</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串处理函数</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];    <span class="comment">// 标题</span></span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];   <span class="comment">// 作者</span></span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>]; <span class="comment">// 类别</span></span><br><span class="line">    <span class="type">int</span> book_id;       <span class="comment">// 编号</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建两个书的结构体变量</span></span><br><span class="line">    Book book1, book2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第一本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置第二本书的信息</span></span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>title, <span class="string">&quot;CSS 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>author, <span class="string">&quot;李四&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">2.</span>subject, <span class="string">&quot;前端开发&quot;</span>);</span><br><span class="line">    book<span class="number">2.</span>book_id = <span class="number">12346</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第一本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书标题: &quot;</span> &lt;&lt; book<span class="number">1.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书作者: &quot;</span> &lt;&lt; book<span class="number">1.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书类别: &quot;</span> &lt;&lt; book<span class="number">1.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第一本书编号: &quot;</span> &lt;&lt; book<span class="number">1.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出第二本书的信息</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书标题: &quot;</span> &lt;&lt; book<span class="number">2.</span>title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书作者: &quot;</span> &lt;&lt; book<span class="number">2.</span>author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书类别: &quot;</span> &lt;&lt; book<span class="number">2.</span>subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;第二本书编号: &quot;</span> &lt;&lt; book<span class="number">2.</span>book_id &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a><strong>运行结果：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一本书标题: C++ 教程</span><br><span class="line">第一本书作者: 张三</span><br><span class="line">第一本书类别: 编程</span><br><span class="line">第一本书编号: 12345</span><br><span class="line">第二本书标题: CSS 教程</span><br><span class="line">第二本书作者: 李四</span><br><span class="line">第二本书类别: 前端开发</span><br><span class="line">第二本书编号: 12346</span><br></pre></td></tr></table></figure><hr><h2 id="结构体的高级用法"><a href="#结构体的高级用法" class="headerlink" title="结构体的高级用法"></a><strong>结构体的高级用法</strong></h2><h3 id="1-结构体作为函数参数"><a href="#1-结构体作为函数参数" class="headerlink" title="1. 结构体作为函数参数"></a><strong>1. 结构体作为函数参数</strong></h3><p>可以把结构体传递给函数，用来操作结构体成员数据。</p><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义结构体</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">    <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义函数，打印书的信息</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printBook</span><span class="params">(Book book)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;标题: &quot;</span> &lt;&lt; book.title &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;作者: &quot;</span> &lt;&lt; book.author &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;类别: &quot;</span> &lt;&lt; book.subject &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; book.book_id &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Book book1;</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>title, <span class="string">&quot;C++ 教程&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>author, <span class="string">&quot;张三&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(book<span class="number">1.</span>subject, <span class="string">&quot;编程&quot;</span>);</span><br><span class="line">    book<span class="number">1.</span>book_id = <span class="number">12345</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printBook</span>(book1); <span class="comment">// 调用函数打印书的信息</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-指针操作结构体"><a href="#2-指针操作结构体" class="headerlink" title="2. 指针操作结构体"></a><strong>2. 指针操作结构体</strong></h3><p>用指针操作结构体变量，可以通过 <code>-&gt;</code> 运算符访问成员。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Book book1;</span><br><span class="line">Book* bookPtr = &amp;book1; <span class="comment">// 定义一个指向 book1 的指针</span></span><br><span class="line"></span><br><span class="line">bookPtr-&gt;book_id = <span class="number">12345</span>; <span class="comment">// 通过指针设置编号</span></span><br><span class="line">cout &lt;&lt; bookPtr-&gt;book_id; <span class="comment">// 通过指针获取编号</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-结构体中添加构造函数"><a href="#3-结构体中添加构造函数" class="headerlink" title="3. 结构体中添加构造函数"></a><strong>3. 结构体中添加构造函数</strong></h3><p>像类一样，结构体也可以有构造函数，用来初始化数据。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Book</span> &#123;</span><br><span class="line">    string title;</span><br><span class="line">    string author;</span><br><span class="line">    string subject;</span><br><span class="line">    <span class="type">int</span> book_id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Book</span>(string t, string a, string s, <span class="type">int</span> id)</span><br><span class="line">        : <span class="built_in">title</span>(t), <span class="built_in">author</span>(a), <span class="built_in">subject</span>(s), <span class="built_in">book_id</span>(id) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建对象</span></span><br><span class="line"><span class="function">Book <span class="title">book1</span><span class="params">(<span class="string">&quot;C++ 教程&quot;</span>, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;编程&quot;</span>, <span class="number">12345</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="结构体和类的区别"><a href="#结构体和类的区别" class="headerlink" title="结构体和类的区别"></a><strong>结构体和类的区别</strong></h2><ul><li><p><strong>默认访问权限不同</strong>：</p><ul><li><code>struct</code> 的成员默认是 <strong>public</strong>。</li><li><code>class</code> 的成员默认是 <strong>private</strong>。</li></ul></li><li><p><strong>适用场景</strong>：</p><ul><li><strong>结构体</strong>：用于简单数据的封装，比如存储图书信息、学生信息等。</li><li><strong>类</strong>：用于更复杂的场景，比如需要继承、封装和多态的情况下。</li></ul></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ol><li><strong>结构体</strong> 是一种用户自定义的数据类型，用来把不同类型的数据组合成一个整体。</li><li>结构体可以用来管理复杂的数据，比如图书馆的书籍、学生的成绩等。</li><li>可以通过 <strong><code>.</code> 运算符</strong> 访问成员，也可以通过 <strong><code>-&gt;</code> 运算符</strong> 用指针访问。</li><li>结构体支持函数传参、构造函数、指针操作等高级用法。</li><li>和类类似，但结构体更轻量，适合简单的数据封装任务。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本的输入输出</title>
      <link href="/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/"/>
      <url>/2024/11/16/C-%E5%9F%BA%E6%9C%AC%E7%9A%84%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="C-基本的输入输出"><a href="#C-基本的输入输出" class="headerlink" title="C++ 基本的输入输出"></a>C++ 基本的输入输出</h1><p><strong>C++ 标准库提供了一组丰富的输入&#x2F;输出功能，我们将在后续的章节进行介绍。本章将讨论 C++ 编程中最基本和最常见的 I&#x2F;O 操作。</strong><br><strong>C++ 的 I&#x2F;O 发生在流中，流是字节序列。如果字节流是从设备（如键盘、磁盘驱动器、网络连接等）流向内存，这叫做输入操作。如果字节流是从内存流向设备（如显示屏、打印机、磁盘驱动器、网络连接等），这叫做输出操作。</strong></p><p><strong>在C++中，有一些专门用来处理输入输出的头文件，它们让我们能够与用户交互，或处理文件。以下是最常用的输入输出头文件以及它们的用途：</strong></p><hr><h2 id="头文件及作用"><a href="#头文件及作用" class="headerlink" title="头文件及作用"></a>头文件及作用</h2><ol><li><p><strong><code>&lt;iostream&gt;</code></strong><br>提供 <strong>标准输入输出功能</strong>，例如用 <code>cin</code> 从键盘输入数据，<code>cout</code> 在屏幕输出数据。</p></li><li><p><strong><code>&lt;iomanip&gt;</code></strong><br>提供 <strong>格式化输出功能</strong>，比如设置小数点精度、对齐输出等操作，常用函数有 <code>setw</code> 和 <code>setprecision</code>。</p></li><li><p><strong><code>&lt;fstream&gt;</code></strong><br>提供 <strong>文件读写功能</strong>，用于从文件中读取数据或向文件写入数据。</p></li></ol><hr><h2 id="标准输出流（cout）"><a href="#标准输出流（cout）" class="headerlink" title="标准输出流（cout）"></a><strong>标准输出流（<code>cout</code>）</strong></h2><ul><li><p><strong><code>cout</code></strong> 用来在屏幕输出内容，通常和 <code>&lt;&lt;</code>（流插入运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Hello C++&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;输出内容是：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出内容是：Hello C++</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&lt;&lt;</code> 操作符会根据变量类型自动选择适合的输出格式。</li><li><code>endl</code> 用于换行，相当于 <code>\n</code>，并且刷新输出缓冲区。</li></ul></li></ul><hr><h2 id="标准输入流（cin）"><a href="#标准输入流（cin）" class="headerlink" title="标准输入流（cin）"></a><strong>标准输入流（<code>cin</code>）</strong></h2><ul><li><p><strong><code>cin</code></strong> 用来从键盘输入数据，通常和 <code>&gt;&gt;</code>（流提取运算符）一起使用。</p></li><li><p>示例代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> name[<span class="number">50</span>];</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;请输入您的名称： &quot;</span>;</span><br><span class="line">    cin &gt;&gt; name;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;您的名称是：&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行过程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">请输入您的名称： cplusplus</span><br><span class="line">您的名称是： cplusplus</span><br></pre></td></tr></table></figure></li><li><p><strong>特点：</strong></p><ul><li><code>&gt;&gt;</code> 会根据变量的类型读取输入数据。</li><li>如果需要输入多个数据，可以像这样使用：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cin &gt;&gt; name &gt;&gt; age;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="标准错误流（cerr）"><a href="#标准错误流（cerr）" class="headerlink" title="标准错误流（cerr）"></a><strong>标准错误流（<code>cerr</code>）</strong></h2><ul><li><strong><code>cerr</code></strong> 用来输出错误消息，特点是 <strong>不经过缓冲，直接输出</strong>，适合需要立即显示的错误信息。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    cerr &lt;&lt; <span class="string">&quot;错误信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="标准日志流（clog）"><a href="#标准日志流（clog）" class="headerlink" title="标准日志流（clog）"></a><strong>标准日志流（<code>clog</code>）</strong></h2><ul><li><strong><code>clog</code></strong> 用来输出日志信息，和 <code>cerr</code> 不同的是，<strong>它是缓冲的</strong>，日志信息会先存入缓冲区，等缓冲区满了或刷新时才会输出。</li><li>示例代码：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str[] = <span class="string">&quot;Unable to read...&quot;</span>;</span><br><span class="line">    clog &lt;&lt; <span class="string">&quot;日志信息：&quot;</span> &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><strong>运行结果：</strong><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">日志信息：Unable to read...</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><strong><code>cout</code></strong>: 用于正常输出，比如结果或普通信息。</li><li><strong><code>cin</code></strong>: 用于从键盘输入数据。</li><li><strong><code>cerr</code></strong>: 用于立即输出错误信息，适合显示错误日志。</li><li><strong><code>clog</code></strong>: 用于输出普通日志信息，会经过缓冲区，适合较少实时性的消息。</li></ol><p>尽管在小程序中 <code>cout</code>、<code>cerr</code> 和 <code>clog</code> 的区别不明显，但在复杂系统中，合理区分这些流有助于调试和维护代码。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 日期＆时间</title>
      <link href="/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/"/>
      <url>/2024/11/16/C-%E6%97%A5%E6%9C%9F%EF%BC%86%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="http://localhost:4000/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-日期＆时间"><a href="#C-日期＆时间" class="headerlink" title="C++ 日期＆时间"></a>C++ 日期＆时间</h1><p>在C++编程中，我们可以通过标准库来操作日期和时间，但它没有专门的“日期类型”。取而代之的是通过结构和函数来处理。这些功能是从C语言继承而来的，需要使用 <code>&lt;ctime&gt;</code> 头文件。</p><p>C++ 提供了几种与时间相关的类型和结构：</p><ul><li><strong><code>time_t</code></strong>: 用于存储系统时间，表示从1970年1月1日开始的秒数。</li><li><strong><code>tm</code></strong>: 是一个结构体，用来表示更详细的日期和时间信息，比如年、月、日、时、分、秒等。</li></ul><h2 id="tm结构体长什么样？"><a href="#tm结构体长什么样？" class="headerlink" title="tm结构体长什么样？"></a><code>tm</code>结构体长什么样？</h2><p><code>tm</code> 是一个保存日期和时间信息的结构，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">tm</span> &#123;</span><br><span class="line">    <span class="type">int</span> tm_sec;   <span class="comment">// 秒，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_min;   <span class="comment">// 分钟，范围 0-59</span></span><br><span class="line">    <span class="type">int</span> tm_hour;  <span class="comment">// 小时，范围 0-23</span></span><br><span class="line">    <span class="type">int</span> tm_mday;  <span class="comment">// 一月中的第几天，范围 1-31</span></span><br><span class="line">    <span class="type">int</span> tm_mon;   <span class="comment">// 月，范围 0-11（0表示1月）</span></span><br><span class="line">    <span class="type">int</span> tm_year;  <span class="comment">// 从 1900 年起的年数（比如2024年对应值为124）</span></span><br><span class="line">    <span class="type">int</span> tm_wday;  <span class="comment">// 一周中的第几天，范围 0-6（0表示星期日）</span></span><br><span class="line">    <span class="type">int</span> tm_yday;  <span class="comment">// 一年中的第几天，范围 0-365</span></span><br><span class="line">    <span class="type">int</span> tm_isdst; <span class="comment">// 是否是夏令时</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="常见日期和时间的操作函数"><a href="#常见日期和时间的操作函数" class="headerlink" title="常见日期和时间的操作函数"></a>常见日期和时间的操作函数</h2><table><thead><tr><th>函数</th><th>作用</th></tr></thead><tbody><tr><td><code>time()</code></td><td>获取当前时间（从1970年到现在的秒数）</td></tr><tr><td><code>localtime()</code></td><td>将时间转换为本地时间，并返回 <code>tm</code> 结构</td></tr><tr><td><code>gmtime()</code></td><td>将时间转换为 UTC 时间（格林威治时间），返回 <code>tm</code> 结构</td></tr><tr><td><code>ctime()</code></td><td>将时间转换为可读的字符串，比如 <code>Mon Jan 1 12:34:56 2024</code></td></tr><tr><td><code>asctime()</code></td><td>将 <code>tm</code> 结构转换为字符串形式</td></tr><tr><td><code>difftime()</code></td><td>计算两个时间点的秒差</td></tr><tr><td><code>strftime()</code></td><td>自定义格式化输出时间</td></tr></tbody></table><hr><h2 id="实例1：获取当前日期和时间"><a href="#实例1：获取当前日期和时间" class="headerlink" title="实例1：获取当前日期和时间"></a>实例1：获取当前日期和时间</h2><p>以下代码演示如何获取并打印系统的当前时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    <span class="type">char</span>* dt = <span class="built_in">ctime</span>(&amp;now); <span class="comment">// 转换为字符串形式</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;本地日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    tm *gmtm = <span class="built_in">gmtime</span>(&amp;now); <span class="comment">// 转换为 UTC 时间</span></span><br><span class="line">    dt = <span class="built_in">asctime</span>(gmtm);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;UTC 日期和时间：&quot;</span> &lt;&lt; dt &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">本地日期和时间：Sat Nov 16 15:35:21 2024</span><br><span class="line">UTC 日期和时间：Sat Nov 16 07:35:21 2024</span><br></pre></td></tr></table></figure><hr><h2 id="实例2：格式化日期和时间"><a href="#实例2：格式化日期和时间" class="headerlink" title="实例2：格式化日期和时间"></a>实例2：格式化日期和时间</h2><p>使用 <code>tm</code> 结构可以详细访问时间信息，比如年、月、日等：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">time_t</span> now = <span class="built_in">time</span>(<span class="number">0</span>); <span class="comment">// 获取当前时间</span></span><br><span class="line">    tm *ltm = <span class="built_in">localtime</span>(&amp;now); <span class="comment">// 转换为本地时间结构</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打印时间的各个组成部分</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1970到现在经过的秒数：&quot;</span> &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;当前时间：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;年: &quot;</span> &lt;&lt; <span class="number">1900</span> + ltm-&gt;tm_year &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;月: &quot;</span> &lt;&lt; <span class="number">1</span> + ltm-&gt;tm_mon &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;日: &quot;</span> &lt;&lt; ltm-&gt;tm_mday &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;时间: &quot;</span> &lt;&lt; ltm-&gt;tm_hour &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_min &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; ltm-&gt;tm_sec &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1970到现在经过的秒数：1737093321</span><br><span class="line">当前时间：</span><br><span class="line">年: 2024</span><br><span class="line">月: 11</span><br><span class="line">日: 16</span><br><span class="line">时间: 15:35:21</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li><strong><code>time_t</code></strong> 是一个简单的整数类型，用来表示时间戳。</li><li><strong><code>tm</code></strong> 是一个更复杂的结构，用来处理年月日等详细信息。</li><li>我们可以通过函数（如 <code>localtime</code> 或 <code>gmtime</code>）来获取和转换时间，然后打印出想要的格式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++引用</title>
      <link href="/2024/11/16/C-%E5%BC%95%E7%94%A8/"/>
      <url>/2024/11/16/C-%E5%BC%95%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-引用"><a href="#C-引用" class="headerlink" title="C++引用"></a>C++引用</h1><h2 id="什么是引用？"><a href="#什么是引用？" class="headerlink" title="什么是引用？"></a>什么是引用？</h2><p>在 C++ 中，<strong>引用</strong> 就是变量的另一个名字（别名）。<br>可以把它理解成一个“昵称”：通过这个昵称，和直接用变量名字效果是一样的，操作的都是同一个数据。<br>一旦给变量起了这个“昵称”，就不能再改了，引用会一直绑定在这个变量上。</p><hr><h2 id="引用与指针的区别"><a href="#引用与指针的区别" class="headerlink" title="引用与指针的区别"></a>引用与指针的区别</h2><p>虽然引用和指针都能用来间接访问变量的内容，但它们有以下重要区别：</p><ol><li><p><strong>引用必须合法</strong>：  </p><ul><li>引用在创建时，必须绑定到一个有效的变量。  </li><li>指针可以为空（指向 <code>NULL</code>），或者在以后指向其他变量。</li></ul></li><li><p><strong>绑定不可更改</strong>：  </p><ul><li>引用一旦和某个变量绑定，就不能改为绑定其他变量。  </li><li>指针可以随时指向其他变量。</li></ul></li><li><p><strong>必须初始化</strong>：  </p><ul><li>引用在创建时，必须立刻绑定到某个变量。  </li><li>指针可以在创建时不赋值，稍后再初始化。</li></ul></li></ol><hr><h2 id="如何创建引用？"><a href="#如何创建引用？" class="headerlink" title="如何创建引用？"></a>如何创建引用？</h2><p>想象变量是贴在内存位置上的标签，引用就是这个标签的第二个名字。<br>用法很简单，直接用符号 <code>&amp;</code> 创建一个引用。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">17</span>;  <span class="comment">// 定义一个变量 i</span></span><br><span class="line"><span class="type">int</span>&amp; r = i;  <span class="comment">// 给 i 起了一个别名 r</span></span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><code>r</code> 是变量 <code>i</code> 的引用。</li><li>无论是用 <code>i</code> 还是用 <code>r</code>，操作的都是同一个数据。</li></ul><hr><h2 id="一个完整例子"><a href="#一个完整例子" class="headerlink" title="一个完整例子"></a>一个完整例子</h2><p>来看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明简单变量</span></span><br><span class="line">    <span class="type">int</span> i;        <span class="comment">// 一个整型变量</span></span><br><span class="line">    <span class="type">double</span> d;     <span class="comment">// 一个 double 型变量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 声明引用变量</span></span><br><span class="line">    <span class="type">int</span>&amp; r = i;   <span class="comment">// r 是 i 的引用</span></span><br><span class="line">    <span class="type">double</span>&amp; s = d; <span class="comment">// s 是 d 的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给 i 和 d 赋值</span></span><br><span class="line">    i = <span class="number">5</span>;</span><br><span class="line">    d = <span class="number">11.7</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过变量名和引用名访问值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i: &quot;</span> &lt;&lt; i &lt;&lt; endl;         <span class="comment">// 直接用 i</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of i reference: &quot;</span> &lt;&lt; r &lt;&lt; endl; <span class="comment">// 用引用 r</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d: &quot;</span> &lt;&lt; d &lt;&lt; endl;         <span class="comment">// 直接用 d</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of d reference: &quot;</span> &lt;&lt; s &lt;&lt; endl; <span class="comment">// 用引用 s</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Value of i: 5</span><br><span class="line">Value of i reference: 5</span><br><span class="line">Value of d: 11.7</span><br><span class="line">Value of d reference: 11.7</span><br></pre></td></tr></table></figure><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li><p><strong><code>int&amp; r = i;</code></strong>  </p><ul><li>这里 <code>r</code> 是变量 <code>i</code> 的别名。之后，无论是通过 <code>r</code> 还是通过 <code>i</code> 修改值，结果都是一样的，因为它们指向同一块内存。</li></ul></li><li><p><strong><code>double&amp; s = d;</code></strong>  </p><ul><li>这里 <code>s</code> 是变量 <code>d</code> 的别名，类似上面。</li></ul></li></ul><p><strong>总结</strong>：引用就是变量的另一个名字，引用名和变量名操作的是同一个值。</p><hr><h2 id="引用的两个重要用法"><a href="#引用的两个重要用法" class="headerlink" title="引用的两个重要用法"></a>引用的两个重要用法</h2><ol><li><p><strong>引用作为函数参数</strong>  </p><ul><li>在函数参数中使用引用，可以让函数直接操作传入的变量，而不是创建一个副本。  </li><li>这种方法既高效，又可以避免不必要的数据拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>&amp; x, <span class="type">int</span>&amp; y)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> temp = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>, b = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">swap</span>(a, b);  <span class="comment">// 交换 a 和 b 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; endl;  <span class="comment">// 输出 a: 10, b: 5</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>swap</code> 函数的参数是引用，因此可以直接修改 <code>a</code> 和 <code>b</code> 的值，而不需要返回值。</li></ul></li><li><p><strong>引用作为函数返回值</strong>  </p><ul><li>可以从函数中返回一个引用，这样可以直接操作返回的值，而不需要拷贝。</li></ul><p><strong>例子</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getReference</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[index];  <span class="comment">// 返回数组元素的引用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> numbers[<span class="number">3</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="built_in">getReference</span>(numbers, <span class="number">1</span>) = <span class="number">50</span>;  <span class="comment">// 修改数组的第二个元素</span></span><br><span class="line">    cout &lt;&lt; numbers[<span class="number">1</span>] &lt;&lt; endl;     <span class="comment">// 输出 50</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>getReference</code> 返回的是数组元素的引用，因此可以直接修改数组内容，而不需要拷贝数据。</li></ul></li></ol><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ol><li><p><strong>什么是引用？</strong><br>引用是变量的另一个名字（昵称），操作引用就等于操作变量本身。</p></li><li><p><strong>引用有什么用？</strong>  </p><ul><li>减少不必要的数据拷贝，提高效率。</li><li>让代码更简洁，比如用在函数参数或返回值中。</li></ul></li><li><p><strong>引用和指针的区别？</strong>  </p><ul><li>引用更安全，因为它不能是空引用，且绑定后不能改变。</li><li>指针更灵活，因为它可以为空，也可以随时指向其他变量。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++指针</title>
      <link href="/2024/11/16/C-%E6%8C%87%E9%92%88/"/>
      <url>/2024/11/16/C-%E6%8C%87%E9%92%88/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容我们将正式进入指针的学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-指针"><a href="#C-指针" class="headerlink" title="C++ 指针"></a>C++ 指针</h1><p>C++ 中的 <strong>指针</strong> 就像一个“地址簿”，它记录了存储某个值的“房子”（内存位置）的地址。学习指针是 C++ 编程的重要部分，因为它不仅可以让你写出更高效的代码，还能完成像 <strong>动态内存分配</strong> 这样的高级操作，这些是没有指针无法实现的。</p><h3 id="什么是地址？"><a href="#什么是地址？" class="headerlink" title="什么是地址？"></a>什么是地址？</h3><p>每个变量（比如 <code>int</code>、<code>char</code> 等）在计算机的内存中都占据一个“房子”（内存位置）。这个房子有自己的“地址”，就像你家的门牌号一样，唯一且能指引我们找到这个变量存储在哪里。</p><p>在 C++ 中，可以使用符号 <code>&amp;</code>（取地址符）来获取变量的地址。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var1;         <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">char</span> var2[<span class="number">10</span>];    <span class="comment">// 定义一个字符数组</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var1 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;var2 变量的地址： &quot;</span>;</span><br><span class="line">    cout &lt;&lt; &amp;var2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="输出的地址是什么？"><a href="#输出的地址是什么？" class="headerlink" title="输出的地址是什么？"></a>输出的地址是什么？</h3><p>当这段代码运行时，会输出类似下面的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var1 变量的地址： 0xbfebd5c0</span><br><span class="line">var2 变量的地址： 0xbfebd5b6</span><br></pre></td></tr></table></figure><p>这些看起来像一串奇怪的数字（比如 <code>0xbfebd5c0</code>），其实是计算机给变量分配的“内存地址”。通过这些地址，程序可以快速找到变量的位置，访问或者操作它的值。</p><h3 id="更通俗的比喻"><a href="#更通俗的比喻" class="headerlink" title="更通俗的比喻"></a>更通俗的比喻</h3><p>假设你的内存是一个巨大的公寓楼，每个房间都有一个房号（内存地址）：</p><ul><li><code>var1</code> 是住在某个房间的小明，他的房间号是 <code>0xbfebd5c0</code>。</li><li><code>var2</code> 是住在另一个房间的小红，她的房间号是 <code>0xbfebd5b6</code>。</li></ul><p>如果你想找小明或小红，只需要知道他们的房间号（地址），然后直接去找就可以了。</p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>变量</strong> 是房间里的住户。</li><li><strong>内存地址</strong> 是房间号。</li><li>用 <code>&amp;</code> 可以查到变量住在哪个房间（内存地址）。</li></ul><p>指针就是“记住房间号”的一种方式，后面你会学习如何用指针操作变量的值，让编程更加灵活和高效！</p><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针是一个变量，存放着另一个变量的“地址”（类似于一个门牌号）。通过这个门牌号，我们可以找到并操作那个变量。<br>想象一下，一个指针就像地图上的标记，指向某个具体位置（变量所在的内存地址）。</p><hr><h3 id="如何声明一个指针？"><a href="#如何声明一个指针？" class="headerlink" title="如何声明一个指针？"></a>如何声明一个指针？</h3><p>在 C++ 中，声明指针的方式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type *var-name;</span><br></pre></td></tr></table></figure><p>这里：</p><ul><li><strong><code>type</code></strong> 是指针指向的变量类型，比如 <code>int</code>、<code>float</code> 等。</li><li><strong><code>*</code></strong> 告诉编译器这个变量是一个指针，而不是普通变量。</li><li><strong><code>var-name</code></strong> 是指针变量的名称。</li></ul><p>例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>    *ip;    <span class="comment">// 一个整型指针</span></span><br><span class="line"><span class="type">double</span> *dp;    <span class="comment">// 一个 double 型指针</span></span><br><span class="line"><span class="type">float</span>  *fp;    <span class="comment">// 一个浮点型指针</span></span><br><span class="line"><span class="type">char</span>   *ch;    <span class="comment">// 一个字符型指针</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：<code>*</code> 在这里的作用是“定义指针”，而不是数学中的乘号。</p><hr><h3 id="指针的用法"><a href="#指针的用法" class="headerlink" title="指针的用法"></a>指针的用法</h3><p>指针的主要操作可以分为以下几步：</p><ol><li><strong>定义指针变量</strong>：告诉编译器，你要存储某个变量的地址。</li><li><strong>存储地址到指针变量</strong>：通过取地址符 <code>&amp;</code>，获取变量的内存地址，并存储到指针中。</li><li><strong>访问地址对应的值</strong>：通过解引用符 <code>*</code>，获取指针指向的变量的值。</li></ol><hr><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>我们通过一个简单的程序来说明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> var = <span class="number">20</span>;    <span class="comment">// 定义一个整数变量</span></span><br><span class="line">    <span class="type">int</span> *ip;         <span class="comment">// 定义一个指向整数的指针</span></span><br><span class="line"></span><br><span class="line">    ip = &amp;var;       <span class="comment">// 将 var 的地址赋值给指针 ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of var variable: &quot;</span> &lt;&lt; var &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出存储在指针 ip 中的地址</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Address stored in ip variable: &quot;</span> &lt;&lt; ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过指针访问 var 的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Value of *ip variable: &quot;</span> &lt;&lt; *ip &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Value of var variable: 20</span><br><span class="line">Address stored in ip variable: 0xbfc601ac</span><br><span class="line">Value of *ip variable: 20</span><br></pre></td></tr></table></figure><hr><h3 id="程序的核心解释"><a href="#程序的核心解释" class="headerlink" title="程序的核心解释"></a>程序的核心解释</h3><ol><li><p><strong><code>int var = 20;</code></strong><br>定义一个整数变量，值为 20。</p></li><li><p><strong><code>int *ip;</code></strong><br>定义了一个指针变量 <code>ip</code>，它可以存储一个整数变量的地址。</p></li><li><p><strong><code>ip = &amp;var;</code></strong><br>使用取地址符 <code>&amp;</code>，获取变量 <code>var</code> 的地址，并存储到指针 <code>ip</code> 中。<br>此时，<code>ip</code> 的值就是 <code>var</code> 在内存中的地址。</p></li><li><p><strong>输出指针指向的值</strong><br>使用解引用符 <code>*ip</code>，可以通过指针访问变量 <code>var</code> 的值。<br>也就是说，<code>*ip</code> 等价于 <code>var</code>。</p></li></ol><hr><h3 id="指针的本质"><a href="#指针的本质" class="headerlink" title="指针的本质"></a>指针的本质</h3><p>无论指针指向的是整数、浮点数还是字符，<strong>指针的实际值都是内存地址</strong>（一个十六进制数）。<br>指针的类型（比如 <code>int*</code> 或 <code>char*</code>）是为了告诉编译器，指针指向的变量是什么类型，从而正确操作。</p><hr><h3 id="C-中的一些指针概念"><a href="#C-中的一些指针概念" class="headerlink" title="C++ 中的一些指针概念"></a>C++ 中的一些指针概念</h3><table><thead><tr><th><strong>概念</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>空指针</strong></td><td>指向“空地址”的指针（<code>NULL</code>）。如果指针未初始化，最好设为 NULL，避免意外使用。</td></tr><tr><td><strong>指针运算</strong></td><td>可以对指针做加减法（比如指向下一个元素）。</td></tr><tr><td><strong>指针与数组</strong></td><td>数组的名称本质上是一个指向数组第一个元素的指针。</td></tr><tr><td><strong>指针数组</strong></td><td>数组可以存储多个指针，称为“指针数组”。</td></tr><tr><td><strong>指向指针的指针</strong></td><td>一个指针可以指向另一个指针，称为“二级指针”或“指向指针的指针”。</td></tr><tr><td><strong>传递指针给函数</strong></td><td>通过指针传参，可以直接操作原始数据，而不是拷贝数据。</td></tr><tr><td><strong>从函数返回指针</strong></td><td>函数可以返回一个指针，指向局部变量、静态变量或动态分配的内存。</td></tr></tbody></table><hr><h3 id="通俗总结"><a href="#通俗总结" class="headerlink" title="通俗总结"></a>通俗总结</h3><ol><li><p><strong>指针是什么？</strong><br>它是“一个变量的地址”。</p></li><li><p><strong>指针能干什么？</strong>  </p><ul><li>指向一个变量，间接操作它的值。</li><li>动态管理内存（比如数组的大小可以运行时确定）。</li></ul></li><li><p><strong>如何理解指针？</strong>  </p><ul><li>想象成地图上的标记：指针记录了某个地点（变量）的地址。通过标记，我们可以访问这个地点的内容。</li></ul></li><li><p><strong>为什么要用指针？</strong><br>指针让代码更高效，可以节省内存，快速定位变量，实现复杂的数据结构（如链表、树等）。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++字符串</title>
      <link href="/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2024/11/16/C-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-字符串"><a href="#C-字符串" class="headerlink" title="C++ 字符串"></a>C++ 字符串</h1><p>C++ 提供了以下两种类型的字符串表示形式：</p><p><em><strong>C 风格字符串</strong></em><br><strong>C++ 引入的 string 类类型</strong></p><h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a><strong>C风格字符串</strong></h2><p>在 C 和 C++ 中，字符串实际上是用来存放文字或字符的一种特殊的 <strong>字符数组</strong>，并在最后加上一个 **特殊符号 <code>\0</code>**（表示字符串结束）。我们称这种字符串为 <strong>C 风格字符串</strong>。</p><hr><h3 id="字符串的本质：字符数组"><a href="#字符串的本质：字符数组" class="headerlink" title="字符串的本质：字符数组"></a><strong>字符串的本质：字符数组</strong></h3><ul><li>就像一个储物柜，里面每个格子存放一个字符。</li><li>字符串的末尾会有一个 **隐藏的结束符 <code>\0</code>**，告诉程序「字符串到这里就结束了」。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>这里 <code>site</code> 是一个字符数组，包含：</p><ul><li><strong>6 个字符</strong>：<code>R</code>、<code>U</code>、<code>N</code>、<code>O</code>、<code>O</code>、<code>B</code></li><li><strong>1 个结束符</strong>：<code>&#39;\0&#39;</code></li></ul><p>储存结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">位置：  [0]  [1]  [2]  [3]  [4]  [5]  [6]</span><br><span class="line">字符：  &#x27;R&#x27;  &#x27;U&#x27;  &#x27;N&#x27;  &#x27;O&#x27;  &#x27;O&#x27;  &#x27;B&#x27;  &#x27;\0&#x27;</span><br></pre></td></tr></table></figure><p>因为有 <code>\0</code>，字符串的大小比字符数多 1。</p><hr><h3 id="字符串的简化写法"><a href="#字符串的简化写法" class="headerlink" title="字符串的简化写法"></a><strong>字符串的简化写法</strong></h3><p>你可以用更简单的方式直接初始化字符串，程序会自动在末尾加上 <code>\0</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>等同于</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> site[<span class="number">7</span>] = &#123;<span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure><p>所以 <code>site</code> 中存储的内容依然是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;RUNOOB\0&quot;</span><br></pre></td></tr></table></figure><hr><h3 id="字符串的打印"><a href="#字符串的打印" class="headerlink" title="字符串的打印"></a><strong>字符串的打印</strong></h3><p>在 C++ 中，<code>cout</code> 遇到字符串时，会从第一个字符开始输出，一直到碰到 <code>\0</code> 结束。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> site[] = <span class="string">&quot;RUNOOB&quot;</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;网站名: &quot;</span> &lt;&lt; site &lt;&lt; endl; <span class="comment">// 输出 &quot;RUNOOB&quot;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网站名: RUNOOB</span><br></pre></td></tr></table></figure><hr><h3 id="常用的字符串操作函数"><a href="#常用的字符串操作函数" class="headerlink" title="常用的字符串操作函数"></a><strong>常用的字符串操作函数</strong></h3><p>C++ 提供了一些常用的函数来操作 C 风格字符串，这些函数都在 <code>&lt;cstring&gt;</code> 头文件中。</p><h3 id="1-strcpy：字符串复制"><a href="#1-strcpy：字符串复制" class="headerlink" title="1. strcpy：字符串复制"></a><strong>1. <code>strcpy</code>：字符串复制</strong></h3><p>把一个字符串复制到另一个字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[<span class="number">20</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(str2, str1); <span class="comment">// 把 str1 的内容复制到 str2</span></span><br><span class="line">cout &lt;&lt; str2;       <span class="comment">// 输出：runoob</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-strcat：字符串拼接"><a href="#2-strcat：字符串拼接" class="headerlink" title="2. strcat：字符串拼接"></a><strong>2. <code>strcat</code>：字符串拼接</strong></h3><p>把一个字符串追加到另一个字符串的末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="built_in">strcat</span>(str1, str2); <span class="comment">// 拼接：str1 = &quot;runoobgoogle&quot;</span></span><br><span class="line">cout &lt;&lt; str1;       <span class="comment">// 输出：runoobgoogle</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-strlen：字符串长度"><a href="#3-strlen：字符串长度" class="headerlink" title="3. strlen：字符串长度"></a><strong>3. <code>strlen</code>：字符串长度</strong></h3><p>计算字符串的长度（不包括 <code>\0</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">int</span> len = <span class="built_in">strlen</span>(str); <span class="comment">// 长度是 6</span></span><br><span class="line">cout &lt;&lt; len;           <span class="comment">// 输出：6</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-strcmp：字符串比较"><a href="#4-strcmp：字符串比较" class="headerlink" title="4. strcmp：字符串比较"></a><strong>4. <code>strcmp</code>：字符串比较</strong></h3><p>比较两个字符串的大小：</p><ul><li>如果相等，返回 <code>0</code></li><li>如果第一个字符串比第二个小，返回负值</li><li>如果第一个字符串比第二个大，返回正值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">int</span> result = <span class="built_in">strcmp</span>(str1, str2); <span class="comment">// 返回正值，因为 &quot;runoob&quot; &gt; &quot;google&quot;</span></span><br></pre></td></tr></table></figure><hr><h3 id="5-strchr：查找字符"><a href="#5-strchr：查找字符" class="headerlink" title="5. strchr：查找字符"></a><strong>5. <code>strchr</code>：查找字符</strong></h3><p>在字符串中查找某个字符的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strchr</span>(str, <span class="string">&#x27;n&#x27;</span>); <span class="comment">// 找到 &#x27;n&#x27;，返回其地址</span></span><br><span class="line">cout &lt;&lt; *pos;                <span class="comment">// 输出：n</span></span><br></pre></td></tr></table></figure><hr><h3 id="6-strstr：查找子字符串"><a href="#6-strstr：查找子字符串" class="headerlink" title="6. strstr：查找子字符串"></a><strong>6. <code>strstr</code>：查找子字符串</strong></h3><p>在字符串中查找某个子字符串的第一次出现，并返回其地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str1[] = <span class="string">&quot;runoobgoogle&quot;</span>;</span><br><span class="line"><span class="type">char</span> str2[] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"><span class="type">char</span> *pos = <span class="built_in">strstr</span>(str1, str2); <span class="comment">// 找到 &quot;google&quot;，返回其地址</span></span><br><span class="line">cout &lt;&lt; pos;                    <span class="comment">// 输出：google</span></span><br></pre></td></tr></table></figure><hr><h3 id="完整示例：操作-C-风格字符串"><a href="#完整示例：操作-C-风格字符串" class="headerlink" title="完整示例：操作 C 风格字符串"></a><strong>完整示例：操作 C 风格字符串</strong></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span> <span class="comment">// 包含字符串操作函数头文件</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> str1[<span class="number">20</span>] = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str2[<span class="number">20</span>] = <span class="string">&quot;google&quot;</span>;</span><br><span class="line">    <span class="type">char</span> str3[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制 str1 到 str3</span></span><br><span class="line">    <span class="built_in">strcpy</span>(str3, str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;复制后 str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接 str2 到 str1</span></span><br><span class="line">    <span class="built_in">strcat</span>(str1, str2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后 str1: &quot;</span> &lt;&lt; str1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 计算 str1 的长度</span></span><br><span class="line">    len = <span class="built_in">strlen</span>(str1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str1 长度: &quot;</span> &lt;&lt; len &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">复制后 str3: runoob</span><br><span class="line">拼接后 str1: runoobgoogle</span><br><span class="line">str1 长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="C-的-string-类（现代方式）"><a href="#C-的-string-类（现代方式）" class="headerlink" title="C++ 的 string 类（现代方式）"></a><strong>C++ 的 <code>string</code> 类（现代方式）</strong></h2><p>C++ 提供了 <code>string</code> 类，操作字符串更简单，推荐使用：</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string str1 = <span class="string">&quot;runoob&quot;</span>;</span><br><span class="line">    string str2 = <span class="string">&quot;google&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 复制字符串</span></span><br><span class="line">    string str3 = str1;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;str3: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 拼接字符串</span></span><br><span class="line">    str3 = str1 + str2;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;拼接后: &quot;</span> &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 获取长度</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;长度: &quot;</span> &lt;&lt; str<span class="number">3.</span><span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str3: runoob</span><br><span class="line">拼接后: runoobgoogle</span><br><span class="line">长度: 12</span><br></pre></td></tr></table></figure><hr><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a><strong>小总结</strong></h2><ul><li><strong>C 风格字符串</strong>：用字符数组实现，需注意 <code>\0</code> 结束符。</li><li><strong>字符串操作函数</strong>：如 <code>strcpy</code>、<code>strcat</code>、<code>strlen</code> 提供基本功能。</li><li><strong>C++ <code>string</code> 类</strong>：更现代化，更灵活，推荐在 C++ 中使用。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数组</title>
      <link href="/2024/11/16/C-%E6%95%B0%E7%BB%84/"/>
      <url>/2024/11/16/C-%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数组"><a href="#C-数组" class="headerlink" title="C++数组"></a>C++数组</h1><p>C++ 中的数组可以看作是一个「容器」，专门用来存储一组相同类型的数据，就像一个排成一列的储物柜。每个储物柜都有一个编号（索引），你可以通过这个编号来取出或者放入对应位置的数据。</p><h3 id="用通俗的例子来理解："><a href="#用通俗的例子来理解：" class="headerlink" title="用通俗的例子来理解："></a>用通俗的例子来理解：</h3><p>假设你有 100 本书，不想给每本书都取个名字（比如 book1、book2、book3… book100），这会非常麻烦。这时，你可以用一个「书架」（数组），把这些书按照顺序摆放在书架上，然后给每本书一个位置编号，比如：</p><ul><li>第一本书在位置 <code>0</code>，第二本书在位置 <code>1</code>，以此类推。</li></ul><p>在 C++ 里，你可以通过「书架名字 + 编号」直接访问书的位置，比如：</p><ul><li><code>books[0]</code> 就是第 1 本书。</li><li><code>books[99]</code> 就是第 100 本书。</li></ul><h3 id="数组的本质："><a href="#数组的本质：" class="headerlink" title="数组的本质："></a>数组的本质：</h3><ol><li><strong>连续的存储空间</strong>：就像这些书在书架上是紧挨着摆放的，每个位置依次存储数据。</li><li><strong>索引从 0 开始</strong>：C++ 习惯用 <code>0</code> 表示第一个位置。</li><li><strong>方便操作</strong>：你只需要知道位置编号，就能快速找到书（数据）。</li></ol><h3 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h3><p>数组是把一堆同类数据放到一个「共享的容器」里，用编号（索引）来区分每个数据，既节省了管理多个变量的麻烦，也让操作更高效。</p><h2 id="1-声明数组"><a href="#1-声明数组" class="headerlink" title="1. 声明数组"></a><strong>1. 声明数组</strong></h2><p>数组是用来存储一组数据的，就像一本多格笔记本，每个格子都可以用来记数据。要告诉电脑这个数组需要存储什么类型的数据（比如数字或文字）以及需要多少格（大小）。</p><p>声明格式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type arrayName[arraySize];</span><br></pre></td></tr></table></figure><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><ul><li><strong><code>double</code></strong> 表示每个格子存放小数。</li><li><strong><code>balance</code></strong> 是这个数组的名字。</li><li><strong><code>[10]</code></strong> 表示有 10 个格子。</li></ul><p><strong>想象一下：</strong><br>你有一个存放 10 个数字的储物柜，每个柜子大小都一样，按顺序编号：<code>0</code> 到 <code>9</code>。</p><hr><h2 id="2-初始化数组"><a href="#2-初始化数组" class="headerlink" title="2. 初始化数组"></a><strong>2. 初始化数组</strong></h2><p><strong>方式 1：逐个存放</strong><br>就像你一格一格手动往柜子里放东西：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">0</span>] = <span class="number">1000.0</span>;</span><br><span class="line">balance[<span class="number">1</span>] = <span class="number">2.0</span>;</span><br><span class="line"><span class="comment">// 依次放入其他值...</span></span><br></pre></td></tr></table></figure><p><strong>方式 2：一次性存放</strong><br>如果你已经知道每格要存什么，可以一次性写完：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><p>这就像直接打包好了 5 件东西，放进 5 个柜子。</p><p><strong>省略大小：</strong><br>如果你不想提前指定柜子数量，C++ 会根据数据的个数自动分配大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> balance[] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="3-访问数组中的数据"><a href="#3-访问数组中的数据" class="headerlink" title="3. 访问数组中的数据"></a><strong>3. 访问数组中的数据</strong></h2><p>你可以通过柜子的编号（索引）取出或修改里面的东西，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">balance[<span class="number">4</span>] = <span class="number">50.0</span>;  <span class="comment">// 改变第 5 个柜子的值为 50.0</span></span><br><span class="line"><span class="type">double</span> salary = balance[<span class="number">9</span>]; <span class="comment">// 获取第 10 个柜子的值</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>柜子编号从 <strong>0</strong> 开始。</li><li>如果数组大小是 <code>10</code>，最后一个柜子的编号是 <code>9</code>。</li></ul><hr><h2 id="4-使用数组举例"><a href="#4-使用数组举例" class="headerlink" title="4. 使用数组举例"></a><strong>4. 使用数组举例</strong></h2><p>以下程序会创建一个数组 <code>n</code>，存储从 <code>100</code> 开始的 10 个数字，并输出它们的值：</p><p><strong>代码：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n[<span class="number">10</span>]; <span class="comment">// 创建一个大小为 10 的整数数组</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给数组的每个柜子存值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        n[i] = i + <span class="number">100</span>; <span class="comment">// 每个柜子的值 = 编号 + 100</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数组中的值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Element\tValue&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; j &lt;&lt; <span class="string">&quot;\t&quot;</span> &lt;&lt; n[j] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Element    Value</span><br><span class="line">0          100</span><br><span class="line">1          101</span><br><span class="line">2          102</span><br><span class="line">3          103</span><br><span class="line">4          104</span><br><span class="line">5          105</span><br><span class="line">6          106</span><br><span class="line">7          107</span><br><span class="line">8          108</span><br><span class="line">9          109</span><br></pre></td></tr></table></figure><hr><h2 id="5-更高级的数组概念"><a href="#5-更高级的数组概念" class="headerlink" title="5. 更高级的数组概念"></a><strong>5. 更高级的数组概念</strong></h2><table><thead><tr><th><strong>概念</strong></th><th><strong>通俗解释</strong></th></tr></thead><tbody><tr><td><strong>多维数组</strong></td><td>就像一个表格或一个盒子，可以存储二维或多维的数据。比如二维数组就像一个 Excel 表格，有行和列。</td></tr><tr><td><strong>指向数组的指针</strong></td><td>数组的名字本身就是一个指向第一个格子的「地址」。这就像你有一个地图，可以用地图快速找到第一个储物柜。</td></tr><tr><td><strong>传递数组给函数</strong></td><td>你可以把整个数组传递给函数，就像把储物柜的地图交给别人，让他们根据地图找到所有东西。</td></tr><tr><td><strong>从函数返回数组</strong></td><td>函数也可以返回一个数组，就像别人帮你装满东西后，把一个新的储物柜还给你。</td></tr></tbody></table><hr><h2 id="小总结：-1"><a href="#小总结：-1" class="headerlink" title="小总结："></a>小总结：</h2><ol><li><strong>声明</strong>：定义一个装东西的储物柜（数组），指定它能装什么类型、装多少。</li><li><strong>初始化</strong>：往柜子里放东西，可以逐个放，也可以一次性全放。</li><li><strong>访问</strong>：通过编号（索引）取柜子里的东西或改它的值。</li><li><strong>进阶用法</strong>：数组还可以做更多复杂的操作，比如作为表格、多维容器、或通过函数共享数据。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数字</title>
      <link href="/2024/11/16/C-%E6%95%B0%E5%AD%97/"/>
      <url>/2024/11/16/C-%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节内容可能会涉及到一些之前所学习的相关知识，如果你还有不明白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-数字"><a href="#C-数字" class="headerlink" title="C++数字"></a>C++数字</h1><p>通常，当我们需要用到数字时，我们会使用原始的数据类型，如 int、short、long、float 和 double 等等。这些用于数字的数据类型，其可能的值和数值范围，我们已经在 <a href="https://blog.tomatou.xyz/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">C++ 数据类型</a>一节中讨论过。</p><h2 id="1-定义数字"><a href="#1-定义数字" class="headerlink" title="1. 定义数字"></a><strong>1. 定义数字</strong></h2><p>在 C++ 中，我们可以定义多种类型的数字，具体的数字类型取决于数值的大小和精度。下面是常用的数字类型：</p><ul><li>**<code>short</code>**：用于存储较小的整数（通常为 2 字节）。</li><li>**<code>int</code>**：用于存储整数（通常为 4 字节）。</li><li>**<code>long</code>**：用于存储较大的整数（通常为 4 或 8 字节，取决于平台）。</li><li>**<code>float</code>**：用于存储单精度浮点数，通常用于存储小数（4 字节）。</li><li>**<code>double</code>**：用于存储双精度浮点数，通常用于存储精度较高的小数（8 字节）。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种类型的数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;     <span class="comment">// 小整数</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">1000</span>;     <span class="comment">// 整数</span></span><br><span class="line">    <span class="type">long</span> l = <span class="number">1000000</span>; <span class="comment">// 大整数</span></span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>; <span class="comment">// 单精度小数</span></span><br><span class="line">    <span class="type">double</span> d = <span class="number">30949.374</span>; <span class="comment">// 双精度小数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出数字值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;short  s: &quot;</span> &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;int    i: &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;long   l: &quot;</span> &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;float  f: &quot;</span> &lt;&lt; f &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;double d: &quot;</span> &lt;&lt; d &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">short  s: 10</span><br><span class="line">int    i: 1000</span><br><span class="line">long   l: 1000000</span><br><span class="line">float  f: 230.47</span><br><span class="line">double d: 30949.4</span><br></pre></td></tr></table></figure><h2 id="2-数学运算"><a href="#2-数学运算" class="headerlink" title="2. 数学运算"></a><strong>2. 数学运算</strong></h2><p>C++ 提供了很多内置的数学函数，可以帮助我们做各种数学计算。要使用这些函数，我们需要引入 <code>&lt;cmath&gt;</code> 头文件。</p><p>以下是一些常见的数学函数：</p><ul><li>**<code>cos(double)</code>**：计算角度的余弦值。</li><li>**<code>sin(double)</code>**：计算角度的正弦值。</li><li>**<code>tan(double)</code>**：计算角度的正切值。</li><li>**<code>log(double)</code>**：计算参数的自然对数。</li><li>**<code>pow(double, double)</code>**：计算第一个数的第二个数次方（幂运算）。</li><li>**<code>sqrt(double)</code>**：计算平方根。</li><li>**<code>abs(int)</code>**：计算整数的绝对值。</li><li>**<code>fabs(double)</code>**：计算浮点数的绝对值。</li><li>**<code>floor(double)</code>**：向下取整，返回小于或等于给定数字的最大整数。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span>  <span class="comment">// 引入数学库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义各种数字</span></span><br><span class="line">    <span class="type">short</span> s = <span class="number">10</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">-1000</span>;</span><br><span class="line">    <span class="type">long</span> l = <span class="number">100000</span>;</span><br><span class="line">    <span class="type">float</span> f = <span class="number">230.47</span>;</span><br><span class="line">    <span class="type">double</span> d = <span class="number">200.374</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数学函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sin(d): &quot;</span> &lt;&lt; <span class="built_in">sin</span>(d) &lt;&lt; endl;        <span class="comment">// 计算正弦</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;abs(i): &quot;</span> &lt;&lt; <span class="built_in">abs</span>(i) &lt;&lt; endl;        <span class="comment">// 计算绝对值</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;floor(d): &quot;</span> &lt;&lt; <span class="built_in">floor</span>(d) &lt;&lt; endl;    <span class="comment">// 向下取整</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;sqrt(f): &quot;</span> &lt;&lt; <span class="built_in">sqrt</span>(f) &lt;&lt; endl;      <span class="comment">// 计算平方根</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;pow(d, 2): &quot;</span> &lt;&lt; <span class="built_in">pow</span>(d, <span class="number">2</span>) &lt;&lt; endl;  <span class="comment">// 计算平方</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sin(d): -0.634939</span><br><span class="line">abs(i): 1000</span><br><span class="line">floor(d): 200</span><br><span class="line">sqrt(f): 15.1812</span><br><span class="line">pow(d, 2): 40149.7</span><br></pre></td></tr></table></figure><h2 id="3-随机数生成"><a href="#3-随机数生成" class="headerlink" title="3. 随机数生成"></a><strong>3. 随机数生成</strong></h2><p>在一些应用场景中，我们需要生成随机数。C++ 提供了 <code>rand()</code> 函数来生成伪随机数，但需要注意的是，<code>rand()</code> 每次程序运行时生成的随机数是固定的，类似于一个固定的序列。为了让每次生成的随机数不同，我们可以使用 <code>srand()</code> 函数设置随机数种子。</p><p>通常，<code>srand()</code> 的参数是当前的系统时间，这样每次运行程序时，生成的随机数都不相同。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span>   <span class="comment">// 引入时间库</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span> <span class="comment">// 引入随机数库</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置随机数种子为当前时间</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成并输出 10 个随机数</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        j = <span class="built_in">rand</span>();  <span class="comment">// 获取一个随机数</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;随机数： &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出示例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">随机数： 1748144778</span><br><span class="line">随机数： 630873888</span><br><span class="line">随机数： 2134540646</span><br><span class="line">随机数： 219404170</span><br><span class="line">随机数： 902129458</span><br><span class="line">随机数： 920445370</span><br><span class="line">随机数： 1319072661</span><br><span class="line">随机数： 257938873</span><br><span class="line">随机数： 1256201101</span><br><span class="line">随机数： 580322989</span><br></pre></td></tr></table></figure><h2 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h2><ul><li>C++ 中可以定义不同类型的数字（如整数、浮点数等）来存储不同类型的数值。</li><li>通过引入 <code>&lt;cmath&gt;</code> 库，我们可以使用 C++ 提供的丰富数学函数来进行各种数学运算。</li><li>通过 <code>rand()</code> 和 <code>srand()</code> 函数，我们可以生成随机数并控制随机数序列的不同。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++函数</title>
      <link href="/2024/11/16/C-%E5%87%BD%E6%95%B0/"/>
      <url>/2024/11/16/C-%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将正式进入函数的相关学习，这一节内容很重要！！！可能会涉及到一些之前所学习的相关知识，如果你还有不明不白的，可以去温习一下之前所学<a href="https://blog.tomatou.xyz/categories/%E7%BC%96%E7%A8%8B/C-%E6%95%99%E7%A8%8B/C-%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/">C++基础教程</a></strong></p><h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p><strong>在C++中，函数就像是一个小助手，它负责完成一个特定的任务。你可以把一段代码想象成是一个小助手，当你需要它的时候，就可以召唤它来帮你做事，而不需要每次都从头开始写这段代码。</strong></p><p><strong>每个C++程序至少会有一个主函数，也就是<code>main()</code>函数，它是程序的起点。但是，你还可以定义更多的函数来帮助你完成不同的任务。</strong></p><p><strong>函数声明就像是给小助手起个名字，告诉计算机它叫什么，能帮你做什么，以及你需要给它什么信息（参数）。函数定义则是真正告诉计算机这个小助手具体应该怎么做。</strong></p><p><strong>C++标准库就像是一个有很多小助手的团队，它们已经准备好了，你可以直接召唤它们来帮你做事，比如<code>strcat()</code>可以把两个字符串连在一起，<code>memcpy()</code>可以帮你复制一段内存。</strong></p><p><strong>函数还有其他的名字，比如方法、子例程或者程序，它们都是做同样的事情：帮你完成任务。</strong></p><p><strong>总结一下，函数就是一段可以重复使用的代码，它负责完成一个特定的任务。你可以通过声明和定义来创建自己的函数，也可以使用C++标准库中已经定义好的函数。这样可以让你的程序更加整洁和高效。</strong></p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a><strong>函数的定义</strong></h2><p>一个函数的基本结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表) &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>组成部分：</strong></p><ul><li><strong>返回类型（Return Type）：</strong> 指定函数完成任务后返回的数据类型。如果函数不返回任何值，使用 <code>void</code>。</li><li><strong>函数名（Function Name）：</strong> 函数的标识符，用于调用函数。</li><li><strong>参数列表（Parameter List）：</strong> 函数接受的输入，类似占位符。在调用函数时，实际参数的值会传递给这些参数。参数可以有多个，也可以没有。</li><li><strong>函数体（Function Body）：</strong> 包含实现函数功能的代码块。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回两个数中较大的一个</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a><strong>函数声明</strong></h2><p>函数声明告诉编译器函数的名称和如何调用它，实际的函数体可以在别处定义。</p><p><strong>格式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(参数列表);</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br></pre></td></tr></table></figure><p>参数名在函数声明中是可选的，只要指定类型即可：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span>, <span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><hr><h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a><strong>调用函数</strong></h2><p>当我们需要使用函数时，通过函数名和参数来调用它。</p><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取较大的值</span></span><br><span class="line">    ret = <span class="built_in">max</span>(a, b);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;最大值是：&quot;</span> &lt;&lt; ret &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">max</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    <span class="keyword">if</span> (num1 &gt; num2)</span><br><span class="line">        result = num1;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        result = num2;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大值是：200</span><br></pre></td></tr></table></figure><hr><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a><strong>函数参数</strong></h2><p>函数可以通过参数接受输入，有三种传递参数的方式：</p><ol><li><strong>值传递（Pass by Value）：</strong> 将实际参数的值复制一份传递给函数。函数内对参数的修改不会影响实际参数。</li><li><strong>指针传递（Pass by Pointer）：</strong> 将实际参数的地址传递给函数。函数可以通过指针修改实际参数的值。</li><li><strong>引用传递（Pass by Reference）：</strong> 传递参数的引用，函数内对参数的修改会直接影响实际参数。</li></ol><p><strong>注意：</strong> 默认情况下，C++ 使用值传递。</p><hr><h2 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a><strong>参数的默认值</strong></h2><p>函数参数可以有默认值，如果在调用函数时未提供该参数的值，将使用默认值。</p><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b = <span class="number">20</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line">    result = a + b;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">100</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">200</span>;</span><br><span class="line">    <span class="type">int</span> result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用两个参数</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a, b);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用一个参数，b 使用默认值</span></span><br><span class="line">    result = <span class="built_in">sum</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;总和是：&quot;</span> &lt;&lt; result &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">总和是：300</span><br><span class="line">总和是：120</span><br></pre></td></tr></table></figure><hr><h2 id="Lambda-函数与表达式"><a href="#Lambda-函数与表达式" class="headerlink" title="Lambda 函数与表达式"></a><strong>Lambda 函数与表达式</strong></h2><p>C++11 引入了匿名函数，称为 Lambda 函数或 Lambda 表达式。它们使您可以在代码中定义简短的内联函数。</p><p><strong>基本形式：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture](参数列表) -&gt; 返回类型 &#123;</span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>[capture]（捕获列表）：</strong> 指定哪些外部变量可以在 Lambda 中使用。</li><li><strong>(参数列表)：</strong> Lambda 接受的参数。</li><li><strong>返回类型（可选）：</strong> 如果编译器无法推断返回类型，可以显式指定。</li><li><strong>函数体：</strong> Lambda 执行的代码。</li></ul><p><strong>示例：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单的比较函数</span></span><br><span class="line"><span class="keyword">auto</span> compare = [](<span class="type">int</span> x, <span class="type">int</span> y) &#123; <span class="keyword">return</span> x &lt; y; &#125;;</span><br></pre></td></tr></table></figure><p><strong>无参数的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不接受参数的 Lambda</span></span><br><span class="line"><span class="keyword">auto</span> increment = [] &#123; ++global_x; &#125;;</span><br></pre></td></tr></table></figure><p><strong>指定返回类型的 Lambda：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显式指定返回类型</span></span><br><span class="line"><span class="keyword">auto</span> sum = [](<span class="type">int</span> x, <span class="type">int</span> y) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">    <span class="type">int</span> z = x + y;</span><br><span class="line">    <span class="keyword">return</span> z + x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="捕获列表（Capture-List）"><a href="#捕获列表（Capture-List）" class="headerlink" title="捕获列表（Capture List）"></a><strong>捕获列表（Capture List）</strong></h2><p>Lambda 可以捕获其所在作用域的变量，有多种方式：</p><ul><li><strong>[]：</strong> 不捕获任何变量。尝试使用外部变量会导致错误。</li><li><strong>[x, &amp;y]：</strong> 捕获 <code>x</code> 的值，捕获 <code>y</code> 的引用。</li><li><strong>[&amp;]：</strong> 引用捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&#x3D;]：</strong> 值捕获所有在 Lambda 中使用的外部变量。</li><li><strong>[&amp;, x]：</strong> 引用捕获除 <code>x</code> 之外的所有变量，<code>x</code> 值捕获。</li><li><strong>[&#x3D;, &amp;z]：</strong> 值捕获除 <code>z</code> 之外的所有变量，<code>z</code> 引用捕获。</li></ul><p><strong>注意使用 <code>this</code> 指针：</strong></p><ul><li><p>对于 <code>[=]</code> 或 <code>[&amp;]</code>，<code>this</code> 指针会被自动捕获，可直接使用成员变量和函数。</p></li><li><p>对于 <code>[]</code>，如果需要使用 <code>this</code>，必须显式捕获：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">this</span>]() &#123; <span class="keyword">this</span>-&gt;<span class="built_in">someFunc</span>(); &#125;();</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++判断</title>
      <link href="/2024/11/16/C-%E5%88%A4%E6%96%AD/"/>
      <url>/2024/11/16/C-%E5%88%A4%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习判断的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明不白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-判断"><a href="#C-判断" class="headerlink" title="C++判断"></a>C++判断</h1><p>在编程中，判断结构就像是做选择题。程序员需要设定一些问题（条件），然后告诉计算机：</p><ol><li>如果问题的答案是肯定的（条件为真），那么计算机应该做什么（执行哪些语句）。</li><li>如果问题的答案是否定的（条件为假），那么计算机可以做什么（执行哪些语句，这部分是可选的）。</li></ol><p>简单来说，判断结构就是让计算机根据条件来决定下一步做什么的一种方法。这就像是我们日常生活中做决定的过程：如果天气好，我们就去公园；如果天气不好，我们就待在家里。在编程中，我们用代码来实现这样的逻辑。</p><p><strong>在 C++ 编程语言中，判断语句就是用来根据条件来决定代码如何执行的一种方式。以下是几种判断语句，用简单的方式解释它们的功能：</strong></p><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. <strong>if 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时，执行一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就会显示“a 比 b 大”。如果条件不成立，就什么也不做。</em></li></ul><hr><h2 id="2-if…else-语句"><a href="#2-if…else-语句" class="headerlink" title="2. if…else 语句"></a>2. <strong>if…else 语句</strong></h2><ul><li><strong>功能：</strong> 当条件为“真”时执行一段代码，否则执行另一段代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 比 b 大&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a 不比 b 大&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，就输出第一句话；否则，输出第二句话。</em></li></ul><hr><h2 id="3-嵌套-if-语句"><a href="#3-嵌套-if-语句" class="headerlink" title="3. 嵌套 if 语句"></a>3. <strong>嵌套 if 语句</strong></h2><ul><li><strong>功能：</strong> 如果需要多个条件，可以把一个 <code>if</code> 放到另一个 <code>if</code> 里面。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a &gt; b) &#123;</span><br><span class="line">    <span class="keyword">if</span> (b &gt; c) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 最大&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 比 <code>b</code> 大，同时 <code>b</code> 比 <code>c</code> 大，就输出“a 最大”。</em></li></ul><hr><h2 id="4-switch-语句"><a href="#4-switch-语句" class="headerlink" title="4. switch 语句"></a>4. <strong>switch 语句</strong></h2><ul><li><strong>功能：</strong> 检查一个变量的值，并根据值执行不同的代码。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (grade) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;A&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;优秀&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;B&#x27;</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;良好&quot;</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>grade</code> 是 <code>&#39;A&#39;</code>，就显示“优秀”；如果是 <code>&#39;B&#39;</code>，就显示“良好”；其他情况显示“其他”。</em></li></ul><hr><h2 id="5-嵌套-switch-语句"><a href="#5-嵌套-switch-语句" class="headerlink" title="5. 嵌套 switch 语句"></a>5. <strong>嵌套 switch 语句</strong></h2><ul><li><strong>功能：</strong> 可以在一个 <code>switch</code> 语句里嵌套另一个 <code>switch</code>，用于复杂的判断。</li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (animal) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;dog&#x27;</span>:</span><br><span class="line">        <span class="keyword">switch</span> (size) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;big&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;大狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;小狗&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;其他动物&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><em>如果 <code>animal</code> 是 <code>&#39;dog&#39;</code> 并且 <code>size</code> 是 <code>&#39;big&#39;</code>，就输出“大狗”。</em></li></ul><hr><h2 id="6-条件运算符"><a href="#6-条件运算符" class="headerlink" title="6. 条件运算符 (? :)"></a>6. <strong>条件运算符 (<code>? :</code>)</strong></h2><ul><li><strong>功能：</strong> 用于替代简单的 <code>if...else</code>，结构更紧凑。</li><li><strong>格式：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">条件 ? 真值 : 假值;</span><br></pre></td></tr></table></figure></li><li><strong>例子：</strong><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> max = (a &gt; b) ? a : b;</span><br></pre></td></tr></table></figure><em>如果 <code>a</code> 大于 <code>b</code>，就把 <code>a</code> 的值赋给 <code>max</code>；否则，把 <code>b</code> 的值赋给 <code>max</code>。</em></li></ul><hr><h2 id="小总结："><a href="#小总结：" class="headerlink" title="小总结："></a>小总结：</h2><ul><li><code>if</code> 和 <code>if...else</code>：判断一件事情是否成立。</li><li>嵌套 <code>if</code> 和 <code>switch</code>：用于处理多个条件。</li><li><code>switch</code>：更适合检查一个变量的多种可能值。</li><li>条件运算符：用最短的方式写简单的判断，通常用在赋值或输出语句里。</li></ul><p><strong>这样解释是不是更清晰？ 😊</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++循环</title>
      <link href="/2024/11/16/C-%E5%BE%AA%E7%8E%AF/"/>
      <url>/2024/11/16/C-%E5%BE%AA%E7%8E%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习循环的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-循环"><a href="#C-循环" class="headerlink" title="C++循环"></a>C++循环</h1><p><strong>在编程中，我们经常会遇到需要重复做同一件事情的情况。通常，代码是按照顺序一行一行执行的：先执行第一行，然后是第二行，以此类推。但是，有时候我们想让某段代码重复执行多次，而不是只执行一次。这时候，就需要用到编程语言提供的控制结构，它们可以让代码的执行路径变得更加灵活和复杂。</strong><br><strong>简单来说，控制结构就像是代码的“交通规则”，它们告诉我们代码应该如何“行驶”。在C++中，有几种常用的控制结构可以帮助我们实现代码的重复执行，比如循环。循环就像是设置了“循环播放”模式，让某段代码可以按照我们指定的次数或者条件，一遍又一遍地执行。</strong><br><strong>通过使用循环，我们可以更高效地处理重复的任务，而不需要手动复制粘贴大量的代码。这样不仅可以节省时间，还可以减少错误，让代码更加简洁和易于维护。</strong></p><h2 id="循环类型"><a href="#循环类型" class="headerlink" title="循环类型"></a>循环类型</h2><hr><h3 id="循环类型-1"><a href="#循环类型-1" class="headerlink" title="循环类型"></a><strong>循环类型</strong></h3><p>在编程中，<strong>循环</strong>用于重复执行一段代码，直到满足某个条件为止。C++ 提供了几种常用的循环结构，让我们来一一了解它们。</p><h4 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a><strong>1. <code>while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>while</code> 循环会在<strong>每次执行循环体之前</strong>，先检查一个条件。如果条件为真（<code>true</code>），就执行循环体的代码；如果条件为假（<code>false</code>），就结束循环。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件) &#123;</span><br><span class="line">    <span class="comment">// 循环体（要重复执行的代码）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环会从 <code>i = 0</code> 开始，每次输出 <code>i</code> 的值，然后将 <code>i</code> 加 1，直到 <code>i</code> 不小于 5。</p></li></ul><h4 id="2-for-循环"><a href="#2-for-循环" class="headerlink" title="2. for 循环"></a><strong>2. <code>for</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>for</code> 循环适合在你<strong>知道要循环多少次</strong>的情况下使用。它把循环变量的初始化、条件判断和更新都放在一行，便于管理。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (初始化; 条件; 更新) &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环与上面的 <code>while</code> 循环功能相同，但写法更紧凑。</p></li></ul><h4 id="3-do-while-循环"><a href="#3-do-while-循环" class="headerlink" title="3. do...while 循环"></a><strong>3. <code>do...while</code> 循环</strong></h4><ul><li><p><strong>基本概念</strong>：<code>do...while</code> 循环会<strong>先执行一次</strong>循环体，然后再检查条件是否满足。这意味着即使条件一开始为假，循环体也会执行一次。</p></li><li><p><strong>语法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 循环体</span></span><br><span class="line">&#125; <span class="keyword">while</span> (条件);</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：即使 <code>i</code> 一开始就不小于 5，循环体也会执行一次。</p></li></ul><h4 id="4-嵌套循环"><a href="#4-嵌套循环" class="headerlink" title="4. 嵌套循环"></a><strong>4. 嵌套循环</strong></h4><ul><li><p><strong>基本概念</strong>：你可以在一个循环内部再放入一个循环，称为<strong>嵌套循环</strong>。这在需要遍历多维数据时非常有用。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;, j = &quot;</span> &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：外层循环控制 <code>i</code>，内层循环控制 <code>j</code>，总共会输出 6 组组合。</p></li></ul><hr><h3 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a><strong>循环控制语句</strong></h3><p>有时候，我们需要在循环过程中改变正常的执行流程，比如提前结束循环或跳过某次循环。C++ 提供了以下控制语句。</p><h4 id="1-break-语句"><a href="#1-break-语句" class="headerlink" title="1. break 语句"></a><strong>1. <code>break</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>break</code> 用于<strong>立即退出</strong>所在的循环或 <code>switch</code> 语句，程序会继续执行循环或 <code>switch</code> 后面的代码。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="keyword">break</span>; <span class="comment">// 当 i 等于 5 时，退出循环</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这个循环在 <code>i</code> 等于 5 时，会提前结束，不再继续循环。</p></li></ul><h4 id="2-continue-语句"><a href="#2-continue-语句" class="headerlink" title="2. continue 语句"></a><strong>2. <code>continue</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>continue</code> 用于<strong>跳过当前循环的剩余代码</strong>，立即开始下一次循环的判断。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 跳过当前循环，i == 2 时不执行下面的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：当 <code>i</code> 等于 2 时，<code>continue</code> 会跳过 <code>cout</code>，因此不会输出 <code>i = 2</code>。</p></li></ul><h4 id="3-goto-语句"><a href="#3-goto-语句" class="headerlink" title="3. goto 语句"></a><strong>3. <code>goto</code> 语句</strong></h4><ul><li><p><strong>基本概念</strong>：<code>goto</code> 可以无条件地<strong>跳转</strong>到程序中标记的位置。但由于它可能导致代码难以阅读和维护，一般<strong>不推荐使用</strong>。</p></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">start:</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">goto</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：这段代码使用 <code>goto</code> 模拟了一个循环。</p></li></ul><hr><h3 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a><strong>无限循环</strong></h3><ul><li><p><strong>基本概念</strong>：如果循环的条件永远为真，那么循环将永远执行下去，这就是<strong>无限循环</strong>。</p></li><li><p><strong>用法</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="comment">// 无限循环的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;This loop will run forever.&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：<code>for</code> 循环的三个部分（初始化、条件、更新）都可以省略，如果条件部分被省略，默认视为真，所以循环会无限执行。</p></li><li><p><strong>注意</strong>：在实际编程中，需要确保有机制能跳出无限循环，比如在循环体内使用 <code>break</code>，或者在某种条件下退出。否则，程序可能会卡住。</p></li><li><p><strong>终止无限循环的方法</strong>：在命令行环境下，可以按 <code>Ctrl + C</code> 终止程序的执行。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++运算符</title>
      <link href="/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2024/11/16/C-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习运算符的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域、C++常量等的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%B8%B8%E9%87%8F/">C++常量</a>这里温故一下</strong></p><h1 id="C-运算符"><a href="#C-运算符" class="headerlink" title="C++运算符"></a>C++运算符</h1><p>在C++编程中，运算符就像是数学中的加减乘除符号，它们告诉计算机执行特定的操作。C++提供了很多这样的符号，我们可以将它们分为几大类：</p><ol><li><p><strong>算术运算符</strong>：就像我们在数学课上学的那样，用来做加法（+）、减法（-）、乘法（*）、除法（&#x2F;）等计算的符号。</p></li><li><p><strong>关系运算符</strong>：这些符号用来比较两个值，比如看一个值是否大于（&gt;）、小于（&lt;）、等于（&#x3D;&#x3D;）另一个值。</p></li><li><p><strong>逻辑运算符</strong>：这些符号用来处理真（true）或假（false）的情况，比如“并且”（&amp;&amp;）表示两个条件都必须为真，结果才为真；“或者”（||）表示只要有一个条件为真，结果就为真。</p></li><li><p><strong>位运算符</strong>：这些符号在二进制层面上操作数据，比如将两个数的二进制表示进行“与”（&amp;）、“或”（|）操作。</p></li><li><p><strong>赋值运算符</strong>：这个符号（&#x3D;）用来给变量赋值，比如将一个值赋给一个变量。</p></li><li><p><strong>杂项运算符</strong>：还有一些其他的符号，比如访问对象成员的点（.）运算符，或者取地址的与（&amp;）运算符。</p></li></ol><p>接下来的内容会详细解释这些运算符是如何工作的，帮助你更好地理解如何在C++中使用它们。简而言之，运算符就是编程语言中的“动词”，它们告诉计算机要执行什么样的操作。</p><p><strong>在学习 C++ 编程时，我们经常需要使用各种运算符来进行计算和逻辑判断。下面，我们来解释一下这些常见的运算符。</strong></p><hr><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a><strong>算术运算符</strong></h2><p>这些运算符用于基本的数学计算，就像我们日常生活中的加减乘除。</p><ul><li><p><strong><code>+</code> 加号</strong>：把两个数相加。</p><p>例子：<code>A + B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，那么结果是 <strong>30</strong>。</p></li><li><p><strong><code>-</code> 减号</strong>：从第一个数中减去第二个数。</p><p>例子：<code>A - B</code>，结果是 <strong>-10</strong>。</p></li><li><p><strong><code>*</code> 乘号</strong>：把两个数相乘。</p><p>例子：<code>A * B</code>，结果是 <strong>200</strong>。</p></li><li><p><strong><code>/</code> 除号</strong>：用第一个数除以第二个数。</p><p>例子：<code>B / A</code>，结果是 <strong>2</strong>。</p></li><li><p><strong><code>%</code> 取模</strong>：求两个整数相除的余数。</p><p>例子：<code>B % A</code>，结果是 <strong>0</strong>。</p></li><li><p><strong><code>++</code> 自增</strong>：把变量的值增加 1。</p><p>例子：<code>A++</code>，如果 <code>A</code> 原本是 10，执行后变为 <strong>11</strong>。</p></li><li><p><strong><code>--</code> 自减</strong>：把变量的值减少 1。</p><p>例子：<code>A--</code>，执行后 <code>A</code> 变为 <strong>9</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a + b = &quot;</span> &lt;&lt; a + b &lt;&lt; endl; <span class="comment">// 输出 31</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a - b = &quot;</span> &lt;&lt; a - b &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a * b = &quot;</span> &lt;&lt; a * b &lt;&lt; endl; <span class="comment">// 输出 210</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a / b = &quot;</span> &lt;&lt; a / b &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a % b = &quot;</span> &lt;&lt; a % b &lt;&lt; endl; <span class="comment">// 输出 1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c++ = &quot;</span> &lt;&lt; c++ &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 11</span></span><br><span class="line">    c = <span class="number">10</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c-- = &quot;</span> &lt;&lt; c-- &lt;&lt; endl; <span class="comment">// 输出 10，然后 c 变为 9</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a><strong>关系运算符</strong></h2><p>这些运算符用于比较两个值之间的大小关系，结果是 <strong>真（true）</strong> 或 <strong>假（false）</strong>。</p><ul><li><p><strong><code>==</code> 等于</strong>：判断两个值是否相等。</p><p>例子：<code>A == B</code>，如果 <code>A</code> 是 10，<code>B</code> 是 20，结果为 <strong>false</strong>。</p></li><li><p><strong><code>!=</code> 不等于</strong>：判断两个值是否不相等。</p><p>例子：<code>A != B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;</code> 大于</strong>：判断左边的值是否大于右边的值。</p><p>例子：<code>A &gt; B</code>，结果为 <strong>false</strong>。</p></li><li><p><strong><code>&lt;</code> 小于</strong>：判断左边的值是否小于右边的值。</p><p>例子：<code>A &lt; B</code>，结果为 <strong>true</strong>。</p></li><li><p><strong><code>&gt;=</code> 大于等于</strong>：判断左边的值是否大于或等于右边的值。</p></li><li><p><strong><code>&lt;=</code> 小于等于</strong>：判断左边的值是否小于或等于右边的值。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不小于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &gt; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 不大于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">5</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &lt;= b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 小于或等于 b&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (b &gt;= a)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;b 大于或等于 a&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a><strong>逻辑运算符</strong></h2><p>这些运算符用于连接多个条件，形成更复杂的逻辑判断。</p><ul><li><p><strong><code>&amp;&amp;</code> 逻辑与</strong>：当 <strong>两个条件都为真</strong>，结果才为真。</p><p>例子：<code>(A &amp;&amp; B)</code>，只有当 <code>A</code> 和 <code>B</code> 都为真，结果才为 <strong>true</strong>。</p></li><li><p><strong><code>||</code> 逻辑或</strong>：当 <strong>至少一个条件为真</strong>，结果为真。</p><p>例子：<code>(A || B)</code>，只要 <code>A</code> 或 <code>B</code> 其中一个为真，结果就是 <strong>true</strong>。</p></li><li><p><strong><code>!</code> 逻辑非</strong>：对条件取反，<strong>真变假，假变真</strong>。</p><p>例子：<code>!(A &amp;&amp; B)</code>，如果 <code>(A &amp;&amp; B)</code> 为真，取反后结果为 <strong>false</strong>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a || b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 或 b 至少一个为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    a = <span class="number">0</span>;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a &amp;&amp; b)</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 都为真&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!(a &amp;&amp; b))</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;a 和 b 不全为真（取反后为真）&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a><strong>位运算符</strong></h2><p>位运算符用于直接操作二进制位，常用于底层编程或性能优化。</p><ul><li><p><strong><code>&amp;</code> 按位与</strong>：对应位都为 1，结果才为 1。</p></li><li><p><strong><code>|</code> 按位或</strong>：对应位只要有一个为 1，结果就是 1。</p></li><li><p><strong><code>^</code> 按位异或</strong>：对应位不同，结果为 1，相同为 0。</p></li><li><p><strong><code>~</code> 按位取反</strong>：把每一位都取反，0 变 1，1 变 0。</p></li><li><p><strong><code>&lt;&lt;</code> 左移</strong>：把二进制位向左移动，右边补 0。</p></li><li><p><strong><code>&gt;&gt;</code> 右移</strong>：把二进制位向右移动，左边根据符号位补 0 或 1。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">60</span>; <span class="comment">// 二进制：0011 1100</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = <span class="number">13</span>; <span class="comment">// 二进制：0000 1101</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    c = a &amp; b; <span class="comment">// 12，二进制：0000 1100</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &amp; b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a | b; <span class="comment">// 61，二进制：0011 1101</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a | b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a ^ b; <span class="comment">// 49，二进制：0011 0001</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a ^ b = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = ~a; <span class="comment">// 对 a 取反</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;~a = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &lt;&lt; <span class="number">2</span>; <span class="comment">// 左移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &lt;&lt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    c = a &gt;&gt; <span class="number">2</span>; <span class="comment">// 右移 2 位</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;a &gt;&gt; 2 = &quot;</span> &lt;&lt; c &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a><strong>赋值运算符</strong></h2><p>这些运算符用于给变量赋值，并可以结合其他操作。</p><ul><li><p><strong><code>=</code> 赋值</strong>：把右边的值赋给左边的变量。</p><p>例子：<code>c = a + b</code>。</p></li><li><p><strong><code>+=</code> 加且赋值</strong>：<code>c += a</code> 等同于 <code>c = c + a</code>。</p></li><li><p><strong><code>-=</code> 减且赋值</strong>：<code>c -= a</code> 等同于 <code>c = c - a</code>。</p></li><li><p><strong><code>*=</code> 乘且赋值</strong>：<code>c *= a</code> 等同于 <code>c = c * a</code>。</p></li><li><p><strong><code>/=</code> 除且赋值</strong>：<code>c /= a</code> 等同于 <code>c = c / a</code>。</p></li><li><p><strong><code>%=</code> 取模且赋值</strong>：<code>c %= a</code> 等同于 <code>c = c % a</code>。</p></li><li><p><strong><code>&lt;&lt;=</code> 左移且赋值</strong>：<code>c &lt;&lt;= 2</code> 等同于 <code>c = c &lt;&lt; 2</code>。</p></li><li><p><strong><code>&gt;&gt;=</code> 右移且赋值</strong>：<code>c &gt;&gt;= 2</code> 等同于 <code>c = c &gt;&gt; 2</code>。</p></li><li><p><strong><code>&amp;=</code> 按位与且赋值</strong>：<code>c &amp;= 2</code> 等同于 <code>c = c &amp; 2</code>。</p></li><li><p><strong><code>^=</code> 按位异或且赋值</strong>：<code>c ^= 2</code> 等同于 <code>c = c ^ 2</code>。</p></li><li><p><strong><code>|=</code> 按位或且赋值</strong>：<code>c |= 2</code> 等同于 <code>c = c | 2</code>。</p></li></ul><p><strong>示例程序：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">21</span>;</span><br><span class="line">    <span class="type">int</span> c;</span><br><span class="line"></span><br><span class="line">    c = a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c += a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c += a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 42</span></span><br><span class="line"></span><br><span class="line">    c -= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c -= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c *= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c *= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 441</span></span><br><span class="line"></span><br><span class="line">    c /= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c /= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 21</span></span><br><span class="line"></span><br><span class="line">    c = <span class="number">200</span>;</span><br><span class="line">    c %= a;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c %= a，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &lt;&lt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 44</span></span><br><span class="line"></span><br><span class="line">    c &gt;&gt;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &gt;&gt;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 11</span></span><br><span class="line"></span><br><span class="line">    c &amp;= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c &amp;= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    c ^= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c ^= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 0</span></span><br><span class="line"></span><br><span class="line">    c |= <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;c |= 2，c = &quot;</span> &lt;&lt; c &lt;&lt; endl; <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a><strong>其他运算符</strong></h2><ul><li><p><strong><code>sizeof</code> 求大小</strong>：返回数据类型或变量所占的字节数。</p><p>例子：<code>sizeof(int)</code> 返回 <strong>4</strong>。</p></li><li><p><strong><code>?:</code> 条件运算符（三目运算符）</strong>：根据条件返回不同的值。</p><p>例子：<code>int max = (a &gt; b) ? a : b;</code>，如果 <code>a &gt; b</code> 为真，<code>max</code> 等于 <code>a</code>，否则等于 <code>b</code>。</p></li><li><p><strong><code>,</code> 逗号运算符</strong>：可以在一行中执行多个表达式，返回最后一个表达式的值。</p></li><li><p><strong><code>.</code> 和 <code>-&gt;</code> 成员访问运算符</strong>：用于访问对象或指针的成员。</p><p>例子：<code>object.member</code>，<code>pointer-&gt;member</code>。</p></li><li><p><strong><code>(type)</code> 类型转换</strong>：将一个值转换为指定的类型。</p><p>例子：<code>int x = (int)3.14;</code>，<code>x</code> 的值为 <strong>3</strong>。</p></li><li><p><strong><code>&amp;</code> 取地址运算符</strong>：获取变量的内存地址。</p><p>例子：<code>int *p = &amp;a;</code>，<code>p</code> 指向 <code>a</code> 的地址。</p></li><li><p><strong><code>*</code> 指针解引用运算符</strong>：访问指针所指向的变量的值。</p><p>例子：<code>int value = *p;</code>，<code>value</code> 等于 <code>p</code> 所指向的变量的值。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++存储类</title>
      <link href="/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/"/>
      <url>/2024/11/16/C-%E5%AD%98%E5%82%A8%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-存储类型"><a href="#C-存储类型" class="headerlink" title="C++存储类型"></a>C++存储类型</h1><hr><h2 id="什么是存储类？"><a href="#什么是存储类？" class="headerlink" title="什么是存储类？"></a>什么是存储类？</h2><p>存储类决定了变量或函数的<strong>作用范围</strong>（在哪里可以访问）和<strong>生命周期</strong>（何时创建、何时销毁）。在C++中，存储类的关键字会放在变量或函数类型的前面，用来改变它们的默认行为。</p><hr><h3 id="C-中常见的存储类说明符"><a href="#C-中常见的存储类说明符" class="headerlink" title="C++中常见的存储类说明符"></a>C++中常见的存储类说明符</h3><p>以下是C++存储类关键字的通俗解释：</p><h4 id="1-auto（自动存储期，默认行为）"><a href="#1-auto（自动存储期，默认行为）" class="headerlink" title="1. auto（自动存储期，默认行为）"></a>1. <strong>auto</strong>（自动存储期，默认行为）</h4><ul><li><strong>定义</strong>：这是C++的默认存储类说明符，通常可以省略不写。它表示变量的生命周期仅限于它所在的块（如函数内部）。</li><li><strong>特点</strong>：<ul><li>变量会在块结束时自动销毁。</li><li>在C++11后，<code>auto</code>更多用于自动推导变量类型，而不是存储类。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量，块结束后自动销毁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="2-register（寄存器变量）"><a href="#2-register（寄存器变量）" class="headerlink" title="2. register（寄存器变量）"></a>2. <strong>register</strong>（寄存器变量）</h4><ul><li><strong>定义</strong>：建议编译器将变量存储在CPU寄存器中以提高访问速度。</li><li><strong>特点</strong>：<ul><li>在现代C++中（C++11及以后），<code>register</code>已经被废弃，编译器会自动优化变量的存储。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// x 是建议存储在寄存器中的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="3-static（静态存储期）"><a href="#3-static（静态存储期）" class="headerlink" title="3. static（静态存储期）"></a>3. <strong>static</strong>（静态存储期）</h4><ul><li><strong>定义</strong>：表示变量的生命周期贯穿整个程序的运行期。</li><li><strong>特点</strong>：<ul><li><strong>函数内部的static变量</strong>：只初始化一次，函数多次调用时会保留上次的值。</li><li><strong>全局变量或函数的static</strong>：限制变量或函数只能在当前文件中使用。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count;  <span class="comment">// 多次调用会保留上次的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h4 id="4-extern（外部链接）"><a href="#4-extern（外部链接）" class="headerlink" title="4. extern（外部链接）"></a>4. <strong>extern</strong>（外部链接）</h4><ul><li><strong>定义</strong>：声明全局变量或函数，可以跨多个文件使用。</li><li><strong>特点</strong>：<ul><li><code>extern</code>告诉编译器变量或函数是在别的文件中定义的。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> globalVar = <span class="number">10</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalVar; <span class="comment">// 引用 file1.cpp 中的变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="5-mutable（可变成员变量）"><a href="#5-mutable（可变成员变量）" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong>mutable</strong>（可变成员变量）</h4><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，也允许修改这个变量。</li><li><strong>特点</strong>：<ul><li>通常用于需要在<code>const</code>成员函数中更新的变量，比如缓存或计数器。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// counter 可以在 const 函数中修改</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h4 id="6-thread-local（线程局部存储期，C-11-引入）"><a href="#6-thread-local（线程局部存储期，C-11-引入）" class="headerlink" title="6. thread_local（线程局部存储期，C++11 引入）"></a>6. <strong>thread_local</strong>（线程局部存储期，C++11 引入）</h4><ul><li><strong>定义</strong>：表示每个线程都有变量的独立副本，变量的生命周期与线程一致。</li><li><strong>特点</strong>：<ul><li>适合多线程编程中需要每个线程独立数据的场景。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>; <span class="comment">// 每个线程都有自己的 threadVar</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="示例总结"><a href="#示例总结" class="headerlink" title="示例总结"></a>示例总结</h3><p>以下代码展示了不同存储类的用法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> globalVar; <span class="comment">// 全局变量，默认是 extern</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> <span class="type">int</span> localVar = <span class="number">10</span>;  <span class="comment">// 局部变量，块结束后销毁</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticVar = <span class="number">20</span>; <span class="comment">// 静态变量，函数多次调用保留值</span></span><br><span class="line">    <span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">30</span>; <span class="comment">// 每个线程有独立的变量副本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="keyword">mutable</span> <span class="type">int</span> mutableVar; <span class="comment">// 可变变量，即使对象是 const 也可以修改</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">            mutableVar = <span class="number">50</span>; <span class="comment">// 合法</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><table><thead><tr><th><strong>关键字</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>默认存储类，生命周期随块结束，现代C++更多用于类型推导。</td></tr><tr><td><code>register</code></td><td>提示编译器优化变量存储（C++11后废弃）。</td></tr><tr><td><code>static</code></td><td>生命周期贯穿整个程序，但作用范围受限。</td></tr><tr><td><code>extern</code></td><td>允许跨文件共享全局变量或函数。</td></tr><tr><td><code>mutable</code></td><td>允许修改<code>const</code>对象的成员变量。</td></tr><tr><td><code>thread_local</code></td><td>每个线程有独立变量副本，生命周期与线程一致（C++11后引入）。</td></tr></tbody></table><hr><h2 id="常见存储类及其用途"><a href="#常见存储类及其用途" class="headerlink" title="常见存储类及其用途"></a>常见存储类及其用途</h2><h3 id="1-auto（自动推导类型）"><a href="#1-auto（自动推导类型）" class="headerlink" title="1. auto（自动推导类型）"></a>1. <strong><code>auto</code>（自动推导类型）</strong></h3><ul><li><strong>定义</strong>：自动根据初始化的值推断变量的类型。</li><li><strong>特点</strong>：<ul><li>省去了手动写类型的麻烦。</li><li>适合用在复杂类型的变量上，比如迭代器。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> a = <span class="number">10</span>;     <span class="comment">// 推断为 int</span></span><br><span class="line"><span class="keyword">auto</span> b = <span class="number">3.14</span>;   <span class="comment">// 推断为 double</span></span><br><span class="line"><span class="keyword">auto</span> c = <span class="string">&quot;hello&quot;</span>; <span class="comment">// 推断为 const char*</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="2-register（寄存器变量，C-11后已废弃）"><a href="#2-register（寄存器变量，C-11后已废弃）" class="headerlink" title="2. register（寄存器变量，C++11后已废弃）"></a>2. <strong><code>register</code>（寄存器变量，C++11后已废弃）</strong></h3><ul><li><strong>定义</strong>：建议将变量存储在CPU寄存器中，以便快速访问。</li><li><strong>特点</strong>：<ul><li>提高访问速度，适合频繁使用的变量。</li><li>在现代编译器中，<code>register</code>的效果已被优化算法替代。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">register</span> <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">// 提示编译器将 i 存储在寄存器中</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-static（静态变量）"><a href="#3-static（静态变量）" class="headerlink" title="3. static（静态变量）"></a>3. <strong><code>static</code>（静态变量）</strong></h3><ul><li><strong>定义</strong>：变量的生命周期贯穿程序始终，无论它在局部还是全局作用域。</li><li><strong>特点</strong>：<ul><li><strong>局部静态变量</strong>：函数内部的<code>static</code>变量只初始化一次，值会在函数调用之间保留。</li><li><strong>全局静态变量</strong>：只能在当前文件中使用，其他文件无法访问。</li><li><strong>类静态变量</strong>：类中所有对象共享一个静态变量。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">counter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 只初始化一次</span></span><br><span class="line">    count++;</span><br><span class="line">    std::cout &lt;&lt; count &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="4-extern（外部变量）"><a href="#4-extern（外部变量）" class="headerlink" title="4. extern（外部变量）"></a>4. <strong><code>extern</code>（外部变量）</strong></h3><ul><li><strong>定义</strong>：声明一个全局变量或函数，使其在多个文件之间共享。</li><li><strong>特点</strong>：<ul><li>通常用于跨文件访问变量或函数。</li><li><strong>示例</strong>：<br>文件1：<code>file1.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sharedVar = <span class="number">42</span>; <span class="comment">// 定义全局变量</span></span><br></pre></td></tr></table></figure>文件2：<code>file2.cpp</code><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> sharedVar; <span class="comment">// 引用 file1 中的变量</span></span><br><span class="line">std::cout &lt;&lt; sharedVar;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="5-mutable（可变成员变量）-1"><a href="#5-mutable（可变成员变量）-1" class="headerlink" title="5. mutable（可变成员变量）"></a>5. <strong><code>mutable</code>（可变成员变量）</strong></h3><ul><li><strong>定义</strong>：修饰类的成员变量，即使类对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>特点</strong>：<ul><li>通常用于缓存、计数器等需要在<code>const</code>上下文中改变状态的场景。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> counter; <span class="comment">// 可变变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        counter++; <span class="comment">// 合法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-thread-local（线程本地存储，C-11引入）"><a href="#6-thread-local（线程本地存储，C-11引入）" class="headerlink" title="6. thread_local（线程本地存储，C++11引入）"></a>6. <strong><code>thread_local</code>（线程本地存储，C++11引入）</strong></h3><ul><li><strong>定义</strong>：每个线程都有一个独立的变量副本，线程之间互不干扰。</li><li><strong>特点</strong>：<ul><li>适用于多线程编程。</li><li>每个线程的<code>thread_local</code>变量在线程结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">thread_local</span> <span class="type">int</span> threadVar = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">threadFunc</span><span class="params">(<span class="type">int</span> id)</span> </span>&#123;</span><br><span class="line">    threadVar = id; <span class="comment">// 每个线程有独立的变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="使用场景总结"><a href="#使用场景总结" class="headerlink" title="使用场景总结"></a>使用场景总结</h3><table><thead><tr><th><strong>存储类</strong></th><th><strong>适用场景</strong></th></tr></thead><tbody><tr><td><code>auto</code></td><td>自动推断变量类型，简化复杂类型的声明。</td></tr><tr><td><code>register</code></td><td>提示频繁使用的变量（现代C++中已废弃）。</td></tr><tr><td><code>static</code></td><td>保留局部变量值、限制全局变量访问范围、类成员共享变量。</td></tr><tr><td><code>extern</code></td><td>跨文件共享全局变量和函数。</td></tr><tr><td><code>mutable</code></td><td>在<code>const</code>对象中允许修改成员变量（如缓存或计数器）。</td></tr><tr><td><code>thread_local</code></td><td>线程安全，每个线程都有独立的变量副本。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++修饰符类型</title>
      <link href="/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/16/C-%E4%BF%AE%E9%A5%B0%E7%AC%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习修饰符类型的的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型、C++变量作用域的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>、<a href="https://blog.tomatou.xyz/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/">C++变量作用域</a>这里温故一下</strong></p><h1 id="C-修饰符类型"><a href="#C-修饰符类型" class="headerlink" title="C++修饰符类型"></a>C++修饰符类型</h1><hr><h2 id="什么是修饰符类型？"><a href="#什么是修饰符类型？" class="headerlink" title="什么是修饰符类型？"></a>什么是修饰符类型？</h2><p>修饰符是用来调整变量的存储范围和行为的关键字。例如：</p><ul><li>变量是否能存储负数？</li><li>变量的存储范围是更大还是更小？</li></ul><p>C++ 提供了多个修饰符来满足不同的需求</p><hr><h3 id="常见修饰符"><a href="#常见修饰符" class="headerlink" title="常见修饰符"></a>常见修饰符</h3><ol><li><p><strong>signed（有符号）</strong></p><ul><li>变量可以存储正数和负数。</li><li><strong>默认情况下</strong>，整型变量（<code>int</code>）都是有符号的，所以<code>int</code>和<code>signed int</code>是一样的。</li></ul></li><li><p><strong>unsigned（无符号）</strong></p><ul><li>变量只能存储正数。</li><li>因为没有负数，存储范围扩大了一倍（范围从0开始）。</li></ul></li><li><p><strong>short（短整型）</strong></p><ul><li>比<code>int</code>的存储范围更小，通常用来节省存储空间。</li></ul></li><li><p><strong>long（长整型）</strong></p><ul><li>比<code>int</code>的存储范围更大，适合表示更大的数字。</li><li><strong>C++11</strong> 增加了<code>long long</code>，存储范围比<code>long</code>还要大。</li></ul></li><li><p><strong>float（单精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度较低。</li></ul></li><li><p><strong>double（双精度浮点数）</strong></p><ul><li>用来表示带小数的数字，精度比<code>float</code>更高。</li></ul></li><li><p><strong>bool（布尔类型）</strong></p><ul><li>只有两个值：<code>true</code>和<code>false</code>，常用于条件判断。</li></ul></li><li><p><strong>char（字符类型）</strong></p><ul><li>用来存储单个字符，比如<code>&#39;a&#39;</code>。</li></ul></li><li><p><strong>wchar_t（宽字符类型）</strong></p><ul><li>用来存储Unicode字符，可以表示多国语言的字符。</li></ul></li></ol><hr><h3 id="修饰符的组合"><a href="#修饰符的组合" class="headerlink" title="修饰符的组合"></a>修饰符的组合</h3><ul><li><p>修饰符可以组合使用，例如：</p><ul><li><code>unsigned long int</code>：无符号长整型。</li><li><code>short unsigned int</code>：无符号短整型。</li></ul></li><li><p><strong>简写方式</strong>：</p><ul><li>省略<code>int</code>是允许的，例如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> num1 = <span class="number">10</span>; <span class="comment">// 无符号整型变量</span></span><br><span class="line"><span class="type">short</span> num2 = <span class="number">5</span>;     <span class="comment">// 短整型变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h3 id="实际例子"><a href="#实际例子" class="headerlink" title="实际例子"></a>实际例子</h3><h4 id="示例-1：普通变量的定义"><a href="#示例-1：普通变量的定义" class="headerlink" title="示例 1：普通变量的定义"></a>示例 1：普通变量的定义</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">int</span> num1 = <span class="number">-10</span>;    <span class="comment">// 有符号整型，值为 -10</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> num2 = <span class="number">20</span>;   <span class="comment">// 无符号整型，值为 20</span></span><br><span class="line"></span><br><span class="line"><span class="type">short</span> num3 = <span class="number">10</span>;          <span class="comment">// 短整型，值为 10</span></span><br><span class="line"><span class="type">long</span> num4 = <span class="number">100000</span>;       <span class="comment">// 长整型，值为 100000</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> num5 = <span class="number">10000000000</span>; <span class="comment">// 长长整型，值为 10000000000</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> pi = <span class="number">3.14f</span>;         <span class="comment">// 单精度浮点数，值为 3.14</span></span><br><span class="line"><span class="type">double</span> e = <span class="number">2.71828</span>;       <span class="comment">// 双精度浮点数，值为 2.71828</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">true</span>;         <span class="comment">// 布尔值，表示真</span></span><br><span class="line"><span class="type">char</span> ch = <span class="string">&#x27;A&#x27;</span>;            <span class="comment">// 字符，值为 &#x27;A&#x27;</span></span><br><span class="line"><span class="type">wchar_t</span> wideChar = <span class="string">L&#x27;你&#x27;</span>; <span class="comment">// 宽字符，值为 &#x27;你&#x27;</span></span><br></pre></td></tr></table></figure><hr><h4 id="示例-2：有符号和无符号的区别"><a href="#示例-2：有符号和无符号的区别" class="headerlink" title="示例 2：有符号和无符号的区别"></a>示例 2：有符号和无符号的区别</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">short</span> <span class="type">int</span> i;          <span class="comment">// 有符号短整型</span></span><br><span class="line">    <span class="type">short</span> <span class="type">unsigned</span> <span class="type">int</span> j; <span class="comment">// 无符号短整型</span></span><br><span class="line"></span><br><span class="line">    j = <span class="number">50000</span>; <span class="comment">// 无符号变量 j 存储 50000</span></span><br><span class="line">    i = j;     <span class="comment">// i 将 j 的位模式解释为有符号数</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; j; <span class="comment">// 输出 -15536 和 50000</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><ul><li><code>j</code>存储的值是<code>50000</code>，它的二进制表示不会改变。</li><li>当将<code>j</code>的值赋给<code>i</code>时，二进制位模式被解释为有符号数，因此显示为<code>-15536</code>。</li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>有符号（signed）</strong>：可以存储正数和负数。</li><li><strong>无符号（unsigned）</strong>：只能存储正数，存储范围更大。</li><li><strong>short 和 long</strong>：分别表示更小或更大的整型范围。</li><li><strong>float 和 double</strong>：用于存储小数，<code>double</code>的精度更高。</li><li><strong>bool 和 char</strong>：布尔值表示真&#x2F;假，字符表示单个字符。</li><li><strong>wchar_t</strong>：表示Unicode字符。<br>通过修饰符，C++ 能够更灵活地定义变量类型，适应不同的存储需求。</li></ul><h2 id="C-中的类型限定符"><a href="#C-中的类型限定符" class="headerlink" title="C++中的类型限定符"></a>C++中的类型限定符</h2><hr><h3 id="什么是类型限定符？"><a href="#什么是类型限定符？" class="headerlink" title="什么是类型限定符？"></a>什么是类型限定符？</h3><p>类型限定符是C++中的关键字，用来给变量或函数添加额外的“行为限制”或“说明”。它们可以改变变量的默认行为，使其更适应特定需求。</p><hr><h3 id="常见的类型限定符"><a href="#常见的类型限定符" class="headerlink" title="常见的类型限定符"></a>常见的类型限定符</h3><table><thead><tr><th><strong>限定符</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td><code>const</code></td><td>表示变量是<strong>常量</strong>，定义后它的值不能被修改。</td></tr><tr><td><code>volatile</code></td><td>告诉编译器，这个变量的值可能会被外部（如硬件或其他线程）改变，因此不能对它的访问进行优化。</td></tr><tr><td><code>restrict</code></td><td><strong>仅在C99标准中</strong>：表示一个指针是访问它所指向对象的唯一方式，用于优化指针操作。</td></tr><tr><td><code>mutable</code></td><td>用于修饰类的成员变量，即使类对象是<code>const</code>的，也允许修改这个变量。</td></tr><tr><td><code>static</code></td><td>表示变量是静态的，它的生命周期贯穿整个程序，并且作用范围有限。</td></tr><tr><td><code>register</code></td><td>提示编译器将变量存储在CPU寄存器中，以提高访问速度（实际效果由编译器决定）。</td></tr></tbody></table><hr><h3 id="示例解释"><a href="#示例解释" class="headerlink" title="示例解释"></a>示例解释</h3><h4 id="1-const（常量）"><a href="#1-const（常量）" class="headerlink" title="1. const（常量）"></a>1. <strong><code>const</code>（常量）</strong></h4><ul><li>定义后变量的值不能被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">10</span>; <span class="comment">// NUM 是一个常量，不能被改变</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr = &amp;NUM; <span class="comment">// ptr 是指向常量的指针，指针所指向的值不能修改</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li><code>NUM</code>是一个固定的值，就像刻在石头上的数字，无法更改。</li><li><code>ptr</code>是指向这块石头的指针，你可以看它，但不能刻字。</li></ul></li></ul><hr><h4 id="2-volatile（易变变量）"><a href="#2-volatile（易变变量）" class="headerlink" title="2. volatile（易变变量）"></a>2. <strong><code>volatile</code>（易变变量）</strong></h4><ul><li>告诉编译器，这个变量的值可能会在程序以外被修改（如硬件或多线程）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> num = <span class="number">20</span>; <span class="comment">// num 的值可能会被硬件改变</span></span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>这个变量是一个随时可能“被动”变化的数字，比如硬件设备传回来的数据。</li></ul></li></ul><hr><h4 id="3-mutable（可变成员变量）"><a href="#3-mutable（可变成员变量）" class="headerlink" title="3. mutable（可变成员变量）"></a>3. <strong><code>mutable</code>（可变成员变量）</strong></h4><ul><li>修饰类成员变量时，即使对象是<code>const</code>，这个变量也可以被修改。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">set_value</span><span class="params">(<span class="type">int</span> value)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        value_ = value; <span class="comment">// 允许修改 value_，即使这个函数是 const 的</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="type">int</span> value_; <span class="comment">// value_ 是可变的</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>一个“特别许可”的变量，即使在“禁止修改”的情况下，也可以被改变。</li></ul></li></ul><hr><h4 id="4-static（静态变量）"><a href="#4-static（静态变量）" class="headerlink" title="4. static（静态变量）"></a>4. <strong><code>static</code>（静态变量）</strong></h4><ul><li>静态变量的生命周期贯穿整个程序，作用范围却受限。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// count 的值在整个程序中保留</span></span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>静态变量就像一个“长期储存”的数据，即使函数结束，它的值也会保留。</li></ul></li></ul><hr><h4 id="5-register（寄存器变量）"><a href="#5-register（寄存器变量）" class="headerlink" title="5. register（寄存器变量）"></a>5. <strong><code>register</code>（寄存器变量）</strong></h4><ul><li>建议编译器将变量存储在CPU的寄存器中，以提高访问速度（是否采纳由编译器决定）。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">example_function</span><span class="params">(<span class="keyword">register</span> <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提示编译器将 num 存储在寄存器中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>通俗解释</strong>：<ul><li>把一个变量放在“最快的储物柜”里，方便程序快速访问。</li></ul></li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li>**<code>const</code>**：值不能改动，就像固定的规则。</li><li>**<code>volatile</code>**：值可能会被外部修改，比如实时更新的数据。</li><li>**<code>mutable</code>**：给特别变量的“修改许可”。</li><li>**<code>static</code>**：数据长期有效，即使函数多次调用也保留值。</li><li>**<code>register</code>**：请求把变量放到“快速通道”，提高访问速度。<br>可以看出，这些限定符让C++中的变量更灵活、更高效地适应不同的需求。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++常量</title>
      <link href="/2024/11/16/C-%E5%B8%B8%E9%87%8F/"/>
      <url>/2024/11/16/C-%E5%B8%B8%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-常量"><a href="#C-常量" class="headerlink" title="C++常量"></a>C++常量</h1><p>在C++编程语言中，常量指的是那些一旦被设定就不能再改变的值，它们就像是被冻结的数据，始终保持不变。这些值就像是直接写在代码里的字面量，比如数字、字母或者特定的文本。</p><p>常量可以是各种基本数据类型，包括：</p><ol><li><strong>整型数字</strong>：比如整数123。</li><li><strong>浮点数字</strong>：比如带有小数点的数字3.14。</li><li><strong>字符</strong>：单个字母或符号，比如’A’或’#’。</li><li><strong>字符串</strong>：一系列字符组成的文本，比如”Hello, World!”。</li><li><strong>布尔值</strong>：只有两个可能的值，true（真）或false（假）。</li></ol><p><strong>注意：常量和变量类似，但关键的区别在于常量一旦被赋予一个值，这个值就不能被改变。这意味着，如果你在程序中声明了一个常量，你就必须在声明时给它一个值，并且在程序的其余部分，这个值是不可更改的。这样的设计可以帮助避免在程序运行过程中意外改变重要的数据，确保程序的稳定性和可靠性。</strong></p><hr><h2 id="整数常量"><a href="#整数常量" class="headerlink" title="整数常量"></a>整数常量</h2><ul><li><p><strong>定义</strong>：整数常量是没有小数部分的数字，可以是十进制、八进制或十六进制。</p></li><li><p><strong>进制表示</strong>：</p><ul><li><strong>十进制</strong>：直接写数字，比如 <code>85</code>。</li><li><strong>八进制</strong>：以 <code>0</code> 开头，比如 <code>0213</code>。</li><li><strong>十六进制</strong>：以 <code>0x</code> 或 <code>0X</code> 开头，比如 <code>0x4B</code>。</li></ul></li><li><p><strong>后缀</strong>：整数常量可以带后缀，表示类型：</p><ul><li><code>U</code>：无符号整数（Unsigned）。</li><li><code>L</code>：长整数（Long）。</li><li>顺序不重要，比如 <code>30U</code> 和 <code>30u</code> 都可以。</li></ul></li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">212</span>         <span class="comment">// 合法的十进制整数</span></span><br><span class="line"><span class="number">215u</span>        <span class="comment">// 合法的无符号整数</span></span><br><span class="line"><span class="number">0xFeeL</span>      <span class="comment">// 合法的十六进制长整数</span></span><br><span class="line"><span class="number">07</span>8         <span class="comment">// 非法：8 不是八进制数字</span></span><br><span class="line"><span class="number">032U</span>U       <span class="comment">// 非法：不能重复后缀</span></span><br></pre></td></tr></table></figure><hr><h2 id="浮点常量"><a href="#浮点常量" class="headerlink" title="浮点常量"></a>浮点常量</h2><ul><li><strong>定义</strong>：浮点常量是带小数点的数，或者用科学计数法表示的数。</li><li><strong>表示方式</strong>：<ul><li><strong>小数形式</strong>：同时包含整数部分和小数部分，比如 <code>3.14</code>。</li><li><strong>指数形式</strong>：用 <code>e</code> 或 <code>E</code> 表示，比如 <code>314E-2</code>（等于 3.14）。</li></ul></li></ul><h4 id="注意事项："><a href="#注意事项：" class="headerlink" title="注意事项："></a>注意事项：</h4><ul><li>小数形式必须包含整数或小数部分，比如 <code>3.</code> 或 <code>.141</code>。</li><li>指数形式必须包含 <code>e</code> 或 <code>E</code>，后面跟一个指数值。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3.14159</span>       <span class="comment">// 合法的小数形式</span></span><br><span class="line"><span class="number">314159E-5L</span>    <span class="comment">// 合法的指数形式</span></span><br><span class="line"><span class="number">510</span>E          <span class="comment">// 非法：缺少指数</span></span><br><span class="line">.e55          <span class="comment">// 非法：缺少整数部分</span></span><br></pre></td></tr></table></figure><hr><h2 id="布尔常量"><a href="#布尔常量" class="headerlink" title="布尔常量"></a>布尔常量</h2><ul><li><strong>定义</strong>：布尔常量只有两个值，用于表示“真”和“假”：<ul><li><code>true</code>：表示“真”。</li><li><code>false</code>：表示“假”。</li></ul></li><li><strong>注意</strong>：虽然 <code>true</code> 和 <code>false</code> 在底层分别表示 <code>1</code> 和 <code>0</code>，但我们不应该直接把它们当成数字使用。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> isActive = <span class="literal">true</span>;</span><br><span class="line"><span class="type">bool</span> isComplete = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><hr><h2 id="字符常量"><a href="#字符常量" class="headerlink" title="字符常量"></a>字符常量</h2><ul><li><strong>定义</strong>：字符常量是用单引号包裹的单个字符，比如 <code>&#39;a&#39;</code>。</li><li><strong>宽字符</strong>：<ul><li>如果以 <code>L</code> 开头（如 <code>L&#39;x&#39;</code>），则表示宽字符，存储在 <code>wchar_t</code> 类型变量中。</li></ul></li><li><strong>窄字符</strong>：<ul><li>普通字符（如 <code>&#39;x&#39;</code>）存储在 <code>char</code> 类型变量中。</li></ul></li></ul><h4 id="特殊字符（转义序列）："><a href="#特殊字符（转义序列）：" class="headerlink" title="特殊字符（转义序列）："></a>特殊字符（转义序列）：</h4><ul><li><strong>转义字符</strong>：用反斜杠 <code>\</code> 开头，表示特殊含义的字符。</li><li><strong>常见转义字符</strong>：<table><thead><tr><th>转义序列</th><th>含义</th></tr></thead><tbody><tr><td><code>\\</code></td><td>反斜杠 <code>\</code></td></tr><tr><td><code>\&#39;</code></td><td>单引号 <code>&#39;</code></td></tr><tr><td><code>\&quot;</code></td><td>双引号 <code>&quot;</code></td></tr><tr><td><code>\n</code></td><td>换行符</td></tr><tr><td><code>\t</code></td><td>制表符</td></tr><tr><td><code>\r</code></td><td>回车符</td></tr></tbody></table></li></ul><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello\tWorld\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello   World</span><br></pre></td></tr></table></figure><h2 id="字符串常量"><a href="#字符串常量" class="headerlink" title="字符串常量"></a>字符串常量</h2><ul><li><strong>定义</strong>：字符串常量是用双引号<code>&quot;&quot;</code>包裹的一段文本内容。</li><li><strong>组成</strong>：它可以包含普通字符、特殊字符（通过转义序列如<code>\n</code>表示换行）以及通用字符（如Unicode字符）。</li></ul><hr><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>如何表示字符串</strong>：  </p><ul><li>只需要用双引号包裹内容，例如：<code>&quot;Hello, World!&quot;</code>。</li><li>字符串中可以包含字母、数字、符号，以及通过转义序列表示的特殊字符。</li></ul></li><li><p><strong>分行显示字符串</strong>：  </p><ul><li>如果字符串太长，可以使用反斜杠<code>\</code>将其分成多行书写，但显示时仍会显示为一行。</li></ul></li></ol><hr><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下代码展示了如何使用字符串常量：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个普通的字符串常量</span></span><br><span class="line">    string greeting = <span class="string">&quot;hello, runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting &lt;&lt; endl;  <span class="comment">// 输出字符串并换行</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个分行的字符串常量</span></span><br><span class="line">    string greeting2 = <span class="string">&quot;hello, \</span></span><br><span class="line"><span class="string">                       runoob&quot;</span>;</span><br><span class="line">    cout &lt;&lt; greeting2 &lt;&lt; endl;  <span class="comment">// 显示为一行输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, runoob</span><br><span class="line">hello, runoob</span><br></pre></td></tr></table></figure><hr><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><code>greeting</code>是一个普通的字符串，直接赋值并输出。</li><li><code>greeting2</code>使用了反斜杠<code>\</code>来分行写字符串，但显示时仍为一行，因为<code>\</code>只是告诉编译器“这是一行字符串，书写上分为了多行”。</li></ol><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>整数常量</strong>：表示整数，可以加后缀指定类型，支持十进制、八进制和十六进制。</li><li><strong>浮点常量</strong>：表示带小数的数，支持小数形式和指数形式。</li><li><strong>布尔常量</strong>：表示逻辑上的真或假，分别为 <code>true</code> 和 <code>false</code>。</li><li><strong>字符常量</strong>：用单引号表示单个字符，支持转义字符表示特殊符号。</li><li><strong>字符串常量</strong>是用双引号括起来的文本。</li><li>如果字符串太长，可以用反斜杠<code>\</code>进行分行，输出时仍显示为一行。</li><li>字符串可以包含特殊字符，比如<code>\n</code>表示换行符，<code>\t</code>表示制表符。</li></ul><p>以下是对“定义常量”更通俗易懂的解释：</p><hr><h2 id="定义常量"><a href="#定义常量" class="headerlink" title="定义常量"></a>定义常量</h2><ul><li>如前面所说，<strong>常量</strong>是值在程序运行过程中<strong>不会改变</strong>的变量。</li><li>在C++中，我们可以通过两种简单的方法定义常量：<ol><li>使用<code>#define</code>预处理器。</li><li>使用<code>const</code>关键字。</li></ol></li></ul><hr><h3 id="方法一：使用-define预处理器"><a href="#方法一：使用-define预处理器" class="headerlink" title="方法一：使用#define预处理器"></a>方法一：使用<code>#define</code>预处理器</h3><ul><li><code>#define</code> 是一种直接替换文本的工具，在编译前会将程序中所有出现的标识符替换为指定的值。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 标识符 值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LENGTH 10  <span class="comment">// 定义常量 LENGTH 为 10</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WIDTH  5   <span class="comment">// 定义常量 WIDTH 为 5</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEWLINE <span class="string">&#x27;\n&#x27;</span>  <span class="comment">// 定义换行符常量</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h4><ul><li>程序运行前，所有的<code>LENGTH</code>都会被替换为<code>10</code>，<code>WIDTH</code>会被替换为<code>5</code>，<code>NEWLINE</code>会被替换为换行符。</li><li><code>#define</code>没有类型约束，是一种简单直接的方法。</li></ul><hr><h3 id="方法二：使用const关键字"><a href="#方法二：使用const关键字" class="headerlink" title="方法二：使用const关键字"></a>方法二：使用<code>const</code>关键字</h3><ul><li><code>const</code> 是一种更严格的方式，用于定义带类型的常量。</li><li>格式：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> 数据类型 变量名 = 值;</span><br></pre></td></tr></table></figure></li></ul><h4 id="示例代码：-1"><a href="#示例代码：-1" class="headerlink" title="示例代码："></a>示例代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> LENGTH = <span class="number">10</span>;  <span class="comment">// 定义一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">5</span>;    <span class="comment">// 定义另一个整型常量</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> NEWLINE = <span class="string">&#x27;\n&#x27;</span>;  <span class="comment">// 定义换行符常量</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> area = LENGTH * WIDTH;  <span class="comment">// 计算面积</span></span><br><span class="line">    cout &lt;&lt; area;               <span class="comment">// 输出 50</span></span><br><span class="line">    cout &lt;&lt; NEWLINE;            <span class="comment">// 换行</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-2"><a href="#输出：-2" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">50</span><br></pre></td></tr></table></figure><h4 id="说明：-1"><a href="#说明：-1" class="headerlink" title="说明："></a>说明：</h4><ul><li>使用<code>const</code>定义的常量有类型约束，更加安全。</li><li><code>const</code>可以直接参与类型检查，这对大型程序更有帮助。</li></ul><hr><h3 id="哪种方式更好？"><a href="#哪种方式更好？" class="headerlink" title="哪种方式更好？"></a>哪种方式更好？</h3><ul><li><p>**<code>#define</code>**：</p><ul><li>优点：简单直接，没有类型约束。</li><li>缺点：在大型项目中，缺乏类型检查，可能会引发难以追踪的错误。</li></ul></li><li><p>**<code>const</code>**：</p><ul><li>优点：具有类型约束，更加安全；现代C++中更推荐使用。</li><li>缺点：相较于<code>#define</code>，书写稍显繁琐。</li></ul></li></ul><hr><h3 id="编程实践"><a href="#编程实践" class="headerlink" title="编程实践"></a>编程实践</h3><ul><li>通常，我们会将常量的名字用<strong>大写字母</strong>表示，这样可以让代码更容易阅读和维护。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_SPEED = <span class="number">120</span>;  <span class="comment">// 推荐的命名方式</span></span><br></pre></td></tr></table></figure>通过以上两种方式，你可以选择适合自己需求的方式来定义常量。对于现代C++程序，推荐优先使用<code>const</code>关键字。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量作用域</title>
      <link href="/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
      <url>/2024/11/16/C-%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量作用域的相关知识，可能会涉及到一些C++的基本语法以及C++变量类型的相关知识，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>和<a href="https://blog.tomatou.xyz/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/">C++变量类型</a>这里温故一下</strong></p><h1 id="C-变量作用域"><a href="#C-变量作用域" class="headerlink" title="C++变量作用域"></a>C++变量作用域</h1><h3 id="1-变量的定义位置"><a href="#1-变量的定义位置" class="headerlink" title="1. 变量的定义位置"></a>1. 变量的定义位置</h3><p>在C++中，根据变量定义的位置，变量可以分为以下几类：</p><ul><li><strong>局部变量</strong>：在函数或代码块中声明的变量，只能在该函数或块中使用。</li><li><strong>形式参数</strong>：函数的参数，它是函数调用时用来接收外部传入数据的变量。</li><li><strong>全局变量</strong>：在所有函数之外声明的变量，可以在整个程序中使用。</li></ul><hr><h3 id="2-什么是作用域？"><a href="#2-什么是作用域？" class="headerlink" title="2. 什么是作用域？"></a>2. 什么是作用域？</h3><p>作用域是一个变量可以被访问的“范围”或“区域”。根据变量的定义位置，它的作用域可以分为以下几种：</p><h4 id="（1）局部作用域"><a href="#（1）局部作用域" class="headerlink" title="（1）局部作用域"></a>（1）局部作用域</h4><ul><li><strong>定义位置</strong>：在函数内部声明。</li><li><strong>特点</strong>：<ul><li>只能在函数内部访问，函数外部无法使用。</li><li>每次调用函数时，局部变量都会被创建；函数结束后，局部变量会被销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// x 是局部变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（2）全局作用域"><a href="#（2）全局作用域" class="headerlink" title="（2）全局作用域"></a>（2）全局作用域</h4><ul><li><strong>定义位置</strong>：在所有函数之外。</li><li><strong>特点</strong>：<ul><li>全局变量可以被程序中的任何函数访问。</li><li>全局变量在程序启动时创建，程序结束时销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">20</span>; <span class="comment">// x 是全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 可以访问全局变量 x</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="（3）块作用域"><a href="#（3）块作用域" class="headerlink" title="（3）块作用域"></a>（3）块作用域</h4><ul><li><strong>定义位置</strong>：在代码块 <code>&#123;&#125;</code> 内部。</li><li><strong>特点</strong>：<ul><li>只能在块内部访问，块外部无法使用。</li><li>每次执行代码块时，块作用域的变量都会被创建，执行完后销毁。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">30</span>; <span class="comment">// x 是块作用域变量</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里无法访问 x</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="（4）类作用域"><a href="#（4）类作用域" class="headerlink" title="（4）类作用域"></a>（4）类作用域</h4><ul><li><strong>定义位置</strong>：在类的内部。</li><li><strong>特点</strong>：<ul><li>类作用域的变量可以被类的所有成员函数访问。</li><li>它的生命周期与类的对象相同。</li></ul></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> x; <span class="comment">// x 是类作用域的变量</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        x = value; <span class="comment">// 可以访问类的变量 x</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="3-特殊情况：变量重名"><a href="#3-特殊情况：变量重名" class="headerlink" title="3. 特殊情况：变量重名"></a>3. 特殊情况：变量重名</h3><p>如果在内部作用域中声明的变量与外部作用域中的变量同名，内部作用域的变量会覆盖外部作用域的变量。</p><ul><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">50</span>; <span class="comment">// 全局变量 x</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myFunction</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">10</span>; <span class="comment">// 局部变量 x，覆盖了全局变量 x</span></span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; std::endl; <span class="comment">// 输出 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li><strong>局部变量</strong>：在函数或代码块中声明，只能在内部使用。</li><li><strong>全局变量</strong>：在所有函数之外声明，可以在程序的任何地方使用。</li><li><strong>块作用域变量</strong>：在 <code>&#123;&#125;</code> 中声明，只能在块内部使用。</li><li><strong>类作用域变量</strong>：在类内部声明，可以被类的所有成员函数使用。</li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><hr><h3 id="什么是局部变量？"><a href="#什么是局部变量？" class="headerlink" title="什么是局部变量？"></a>什么是局部变量？</h3><ul><li>局部变量是<strong>在函数或代码块内部声明的变量</strong>，它们的作用范围仅限于声明它们的那个函数或代码块。</li><li>当函数执行结束时，局部变量就会被销毁。</li></ul><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a, b, c; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化变量</span></span><br><span class="line">    a = <span class="number">10</span>;</span><br><span class="line">    b = <span class="number">20</span>;</span><br><span class="line">    c = a + b;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; c;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>a</code>, <code>b</code>, <code>c</code> 是局部变量，它们只能在<code>main()</code>函数中使用。</li><li>当程序运行到<code>return 0;</code>时，<code>a</code>, <code>b</code>, <code>c</code>会被销毁，无法在<code>main()</code>之外访问。</li></ul><hr><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><h3 id="什么是全局变量？"><a href="#什么是全局变量？" class="headerlink" title="什么是全局变量？"></a>什么是全局变量？</h3><ul><li>全局变量是在<strong>所有函数之外</strong>定义的变量。</li><li>它们的作用范围是整个程序，可以在任何函数中使用。</li><li>全局变量在程序开始时创建，在程序结束时销毁。</li></ul><h4 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    g = a + b;  <span class="comment">// 赋值给全局变量 g</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>g</code>是全局变量，<code>a</code>和<code>b</code>是局部变量。</li><li><code>g</code>可以被程序中的任何函数访问，比如<code>main()</code>。</li></ul><hr><h3 id="局部变量和全局变量同名时的情况"><a href="#局部变量和全局变量同名时的情况" class="headerlink" title="## 局部变量和全局变量同名时的情况"></a>## 局部变量和全局变量同名时的情况</h3><ul><li>如果局部变量和全局变量同名，在函数内部使用的是局部变量，<strong>局部变量会覆盖全局变量的值</strong>。</li></ul><h4 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line"><span class="type">int</span> g = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 局部变量</span></span><br><span class="line">    <span class="type">int</span> g = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; g;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>全局变量<code>g</code>的值是<code>20</code>，但在<code>main()</code>函数中，局部变量<code>g</code>的值是<code>10</code>。</li><li>当程序运行到<code>cout &lt;&lt; g;</code>时，优先使用局部变量<code>g</code>，所以输出是<code>10</code>。</li></ul><hr><h3 id="小总结-1"><a href="#小总结-1" class="headerlink" title="小总结"></a>小总结</h3><ul><li><p><strong>局部变量</strong>：</p><ul><li>定义在函数或代码块内部。</li><li>只能在声明它的地方使用，离开作用域就无法访问。</li><li>在函数结束时销毁。</li></ul></li><li><p><strong>全局变量</strong>：</p><ul><li>定义在所有函数外部。</li><li>作用范围是整个程序，任何函数都可以访问。</li><li>在程序运行期间一直存在。</li></ul></li></ul><h2 id="局部变量和全局变量的初始化"><a href="#局部变量和全局变量的初始化" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h2><hr><h3 id="局部变量和全局变量的初始化-1"><a href="#局部变量和全局变量的初始化-1" class="headerlink" title="局部变量和全局变量的初始化"></a>局部变量和全局变量的初始化</h3><h4 id="局部变量-1"><a href="#局部变量-1" class="headerlink" title="局部变量"></a>局部变量</h4><ul><li>局部变量是定义在函数或代码块内部的变量。</li><li><strong>特点</strong>：<ul><li>局部变量<strong>不会自动初始化</strong>，如果没有赋值，变量的值是随机的，可能会导致意外的结果。</li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x;  <span class="comment">// 局部变量未初始化</span></span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出随机值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="全局变量-1"><a href="#全局变量-1" class="headerlink" title="全局变量"></a>全局变量</h4><ul><li>全局变量是定义在所有函数之外的变量。</li><li><strong>特点</strong>：<ul><li>全局变量<strong>会自动初始化</strong>，默认值取决于数据类型：<table><thead><tr><th><strong>数据类型</strong></th><th><strong>默认值</strong></th></tr></thead><tbody><tr><td><code>int</code></td><td>0</td></tr><tr><td><code>char</code></td><td><code>&#39;\0&#39;</code></td></tr><tr><td><code>float</code></td><td>0.0</td></tr><tr><td><code>double</code></td><td>0.0</td></tr><tr><td>指针</td><td><code>NULL</code></td></tr></tbody></table></li><li><strong>示例</strong>：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;  <span class="comment">// 全局变量自动初始化为 0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; x;  <span class="comment">// 输出 0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><hr><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>块作用域指的是在代码块 <code>&#123;&#125;</code> 内部定义的变量，这些变量只在该块内有效。</p><h4 id="示例：-3"><a href="#示例：-3" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;  <span class="comment">// 外部变量</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">20</span>;  <span class="comment">// 块作用域变量，覆盖外部变量 a</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;块变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 20</span></span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;外部变量: &quot;</span> &lt;&lt; a &lt;&lt; std::endl;  <span class="comment">// 输出 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">块变量: 20</span><br><span class="line">外部变量: 10</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li>在块 <code>&#123;&#125;</code> 内部声明的变量 <code>a</code> 是一个新的变量，覆盖了外部变量 <code>a</code>。</li><li>块执行完后，内部变量 <code>a</code> 被销毁，外部变量 <code>a</code> 重新生效。</li></ul><hr><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>类作用域指的是在类中声明的变量，这些变量属于类，可以被类的所有成员函数访问。</p><h4 id="示例：-4"><a href="#示例：-4" class="headerlink" title="示例："></a>示例：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> class_var;  <span class="comment">// 类作用域变量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义类变量并初始化</span></span><br><span class="line"><span class="type">int</span> MyClass::class_var = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;类变量: &quot;</span> &lt;&lt; MyClass::class_var &lt;&lt; std::endl;  <span class="comment">// 输出 30</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="输出：-1"><a href="#输出：-1" class="headerlink" title="输出："></a>输出：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类变量: 30</span><br></pre></td></tr></table></figure><p><strong>解释</strong>：</p><ul><li><code>class_var</code> 是类的一个静态变量，属于整个类，而不是某个对象。</li><li>使用类名和作用域解析符号 <code>::</code> 可以直接访问它，无需创建类的实例。</li></ul><hr><h3 id="小总结-2"><a href="#小总结-2" class="headerlink" title="小总结"></a>小总结</h3><ol><li><strong>局部变量</strong>：需要手动初始化；仅在函数或代码块内有效。</li><li><strong>全局变量</strong>：自动初始化；在整个程序中都可访问。</li><li><strong>块作用域</strong>：块内的变量会覆盖外部变量，块结束后自动销毁。</li><li><strong>类作用域</strong>：类中的变量可以通过类名访问，生命周期与类相关。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人新作</title>
      <link href="/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/"/>
      <url>/2024/11/15/%E4%B8%AA%E4%BA%BA%E6%96%B0%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>看到这个标题想必大家也知晓今天的内容是什么了😏，没错，今天我带来的是我的新作，一首纯音乐，歌名叫做《Sunrise》。由于github不支持超过100MB的文件，所以我上传的视频只是部分内容，如果有想要看完整内容的小伙伴，可以通过文章底部的链接下载哦~</strong><br><strong>废话不多说，开始吧！</strong><br><strong>自制歌曲：Sunrise</strong><br><strong>音频制作与处理：码头</strong><br><strong>后期：码头</strong><br><strong>工具：</strong><br><strong>音频制作：Fruity Loops Studio</strong><br><strong>音频处理：Adobe Audition</strong><br><strong>图片：Photoshop</strong><br><strong>动画特效：Adobe After Effects</strong><br><strong>剪辑：Adobe Premiere Pro</strong></p><h1 id="作品"><a href="#作品" class="headerlink" title="作品"></a>作品</h1><h2 id="音频"><a href="#音频" class="headerlink" title="音频"></a>音频</h2><p><strong>以下是音频文件。温馨提示：戴上耳机效果更佳哦！😋</strong><br><audio controls><br>    <source src="/music/Sunrise.wav" type="audio/wav"><br>    您的浏览器不支持 audio 元素。<br></audio></p><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p><strong>以下是视频文件，与上面一样，戴上耳机效果更佳！</strong><br><video controls><br>  <source src="/video/20241115182839517.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA">https://pan.baidu.com/s/1zvFN259RmbnFI7ApmHx_VA</a></strong><br><strong>提取码:yb77</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++变量类型</title>
      <link href="/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习变量类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++变量类型"></a>C++变量类型</h1><p>在程序中，<strong>变量</strong>就是存储数据的容器。它们是程序可以操作的存储位置，每个变量都有一个名字和特定的数据类型。</p><hr><h3 id="变量类型的作用"><a href="#变量类型的作用" class="headerlink" title="变量类型的作用"></a>变量类型的作用</h3><ul><li><strong>变量类型</strong>定义了：<ol><li><strong>占用的内存大小和布局</strong>：不同类型的数据需要不同大小的内存空间。</li><li><strong>可以存储的值范围</strong>：例如，整数型不能存储小数，布尔型只能存储 <code>true</code> 或 <code>false</code>。</li><li><strong>适用的运算</strong>：变量类型决定了哪些运算符可以对它们进行操作。</li></ol></li></ul><hr><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ol><li><strong>可以使用的字符</strong>：变量名可以由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线（_）</strong>组成。</li><li><strong>开头限制</strong>：变量名必须以<strong>字母</strong>或<strong>下划线</strong>开头，不能以数字开头。</li><li><strong>区分大小写</strong>：C++ 是<strong>区分大小写</strong>的语言，所以 <code>Var</code> 和 <code>var</code> 是两个不同的变量名。</li><li><strong>建议使用有意义的名称</strong>：例如，用 <code>age</code> 表示年龄，比用 <code>a</code> 更直观。</li></ol><hr><h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>C++ 中有多种变量类型，每种类型适用于不同种类的数据，例如：</p><ul><li><strong>整数型</strong>存储整数。</li><li><strong>浮点型</strong>存储小数。</li><li><strong>字符型</strong>存储单个字符。</li><li><strong>布尔型</strong>存储逻辑值（<code>true</code> 或 <code>false</code>）。</li></ul><p>在后续章节中，我们将具体介绍这些变量类型的使用和特点！</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Data Types Description</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>Data Types Description</h2><table>    <tr>        <th>类型</th>        <th>描述</th>    </tr>    <tr>        <td>bool</td>        <td>布尔类型，存储值 true 或 false，占用 1 个字节。</td>    </tr>    <tr>        <td>char</td>        <td>字符类型，用于存储 ASCII 字符，通常占用 1 个字节。</td>    </tr>    <tr>        <td>int</td>        <td>整数类型，通常用于存储普通整数，通常占用 4 个字节。</td>    </tr>    <tr>        <td>float</td>        <td>单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。</td>    </tr>    <tr>        <td>double</td>        <td>双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。</td>    </tr>    <tr>        <td>void</td>        <td>表示类型的缺失。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。</td>    </tr></table></body></html><h2 id="C-中的变量类型"><a href="#C-中的变量类型" class="headerlink" title="C++中的变量类型"></a>C++中的变量类型</h2><p>在 C++ 中，你可以定义各种类型的变量来存储不同种类的数据，以下是常见的几种类型：</p><h3 id="整数类型-Integer-Types"><a href="#整数类型-Integer-Types" class="headerlink" title="整数类型 (Integer Types)"></a>整数类型 (Integer Types)</h3><ul><li><strong>int</strong>：存储整数，通常占用 4 个字节。</li><li><strong>short</strong>：存储较小的整数，通常占用 2 个字节。</li><li><strong>long</strong>：存储较大的整数，通常占用 4 个字节。</li><li><strong>long long</strong>：存储更大的整数，通常占用 8 个字节。</li></ul><h3 id="浮点类型-Floating-Point-Types"><a href="#浮点类型-Floating-Point-Types" class="headerlink" title="浮点类型 (Floating-Point Types)"></a>浮点类型 (Floating-Point Types)</h3><ul><li><strong>float</strong>：存储单精度浮点数（带小数的数），通常占用 4 个字节。</li><li><strong>double</strong>：存储双精度浮点数，精度比 <code>float</code> 高，通常占用 8 个字节。</li><li><strong>long double</strong>：存储更高精度的浮点数，字节数依编译器和系统而不同。</li></ul><h3 id="字符类型-Character-Types"><a href="#字符类型-Character-Types" class="headerlink" title="字符类型 (Character Types)"></a>字符类型 (Character Types)</h3><ul><li><strong>char</strong>：存储一个字符，通常占用 1 个字节。</li><li><strong>wchar_t</strong>：存储宽字符（用于表示更复杂的字符），占用 2 或 4 个字节。</li><li><strong>char16_t</strong>：存储 16 位 Unicode 字符，占用 2 个字节。</li><li><strong>char32_t</strong>：存储 32 位 Unicode 字符，占用 4 个字节。</li></ul><h3 id="布尔类型-Boolean-Type"><a href="#布尔类型-Boolean-Type" class="headerlink" title="布尔类型 (Boolean Type)"></a>布尔类型 (Boolean Type)</h3><ul><li><strong>bool</strong>：存储布尔值，只能是 <code>true</code> 或 <code>false</code>。</li></ul><h3 id="枚举类型-Enumeration-Types"><a href="#枚举类型-Enumeration-Types" class="headerlink" title="枚举类型 (Enumeration Types)"></a>枚举类型 (Enumeration Types)</h3><ul><li><strong>enum</strong>：定义一组命名的整数常量，通常用来表示具有多个固定值的变量。</li></ul><h3 id="指针类型-Pointer-Types"><a href="#指针类型-Pointer-Types" class="headerlink" title="指针类型 (Pointer Types)"></a>指针类型 (Pointer Types)</h3><ul><li><strong>type</strong>*：存储指向某个类型变量的地址。</li></ul><h3 id="数组类型-Array-Types"><a href="#数组类型-Array-Types" class="headerlink" title="数组类型 (Array Types)"></a>数组类型 (Array Types)</h3><ul><li><strong>type[] 或 type[size]：</strong>存储多个相同类型的元素。</li></ul><h3 id="结构体类型-Structure-Types"><a href="#结构体类型-Structure-Types" class="headerlink" title="结构体类型 (Structure Types)"></a>结构体类型 (Structure Types)</h3><ul><li><strong>struct</strong>：存储多个不同类型的数据（可以是整数、字符等的组合）。</li></ul><h3 id="类类型-Class-Types"><a href="#类类型-Class-Types" class="headerlink" title="类类型 (Class Types)"></a>类类型 (Class Types)</h3><ul><li><strong>class</strong>：存储具有属性和方法的自定义数据类型。</li></ul><h3 id="共用体类型-Union-Types"><a href="#共用体类型-Union-Types" class="headerlink" title="共用体类型 (Union Types)"></a>共用体类型 (Union Types)</h3><ul><li><strong>union</strong>：存储多种类型的数据，但它们共享同一块内存空间，这意味着同一时刻只能存储其中一种类型。</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>C++ 标准规定了这些类型的最小大小，但实际占用的字节数可能会因为编译器或计算机架构的不同而有所差异。例如，<code>int</code> 在许多现代计算机上占用 4 字节，<code>long</code> 有时占用 8 字节。</li><li>了解这些变量类型及其占用内存的特点有助于更好地管理程序中的数据和内存。</li></ul><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++中的变量定义"></a>C++中的变量定义</h2><p>在 C++ 中，<strong>变量定义</strong>是指告诉编译器在内存中为变量分配空间，并指定变量的数据类型。</p><h3 id="变量定义的基本形式："><a href="#变量定义的基本形式：" class="headerlink" title="变量定义的基本形式："></a>变量定义的基本形式：</h3><p>定义一个变量时，需要指定它的数据类型和变量的名称，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><p>这里，<code>type</code> 是你要定义的变量的数据类型，例如 <code>int</code>（整数）、<code>char</code>（字符）等，<code>variable_list</code> 是你要定义的变量名，多个变量名用逗号分隔。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;   <span class="comment">// 定义了三个整数变量 i, j, k</span></span><br><span class="line"><span class="type">char</span> c, ch;     <span class="comment">// 定义了两个字符变量 c 和 ch</span></span><br><span class="line"><span class="type">float</span> f, salary; <span class="comment">// 定义了两个浮点数变量 f 和 salary</span></span><br><span class="line"><span class="type">double</span> d;       <span class="comment">// 定义了一个双精度浮点数变量 d</span></span><br></pre></td></tr></table></figure><p>这行代码表示在内存中为 <code>i</code>、<code>j</code>、<code>k</code>、<code>c</code>、<code>ch</code>、<code>f</code>、<code>salary</code> 和 <code>d</code> 这些变量分配空间，并且每个变量的类型已经被明确指定。</p><h3 id="变量初始化："><a href="#变量初始化：" class="headerlink" title="变量初始化："></a>变量初始化：</h3><p>你可以在定义变量时，给它们一个初始值，这叫做<strong>初始化</strong>。格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;    <span class="comment">// 定义并初始化了两个整数变量 d 和 f</span></span><br><span class="line">byte z = <span class="number">22</span>;         <span class="comment">// 定义并初始化了一个名为 z 的变量</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>;        <span class="comment">// 定义了一个字符变量 x，其值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>这里，<code>d</code> 被初始化为 3，<code>f</code> 被初始化为 5，<code>z</code> 被初始化为 22，而 <code>x</code> 被初始化为字符 <code>&#39;x&#39;</code>。</p><h3 id="未初始化的变量："><a href="#未初始化的变量：" class="headerlink" title="未初始化的变量："></a>未初始化的变量：</h3><p>如果你定义变量时没有给它们初始值，那么对于<strong>静态存储持续时间的变量</strong>，它们会被自动初始化为 0（空值）；而对于<strong>局部变量</strong>，它们没有初始值，可能包含不确定的值，这样的变量会被称为“未定义值”。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>变量定义时，你要指定数据类型和变量名。</li><li>可以在定义时给变量初始化一个值。</li><li>如果没有初始化，静态变量会被自动初始化为 0，而其他变量没有初始值。</li></ul><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++中的变量声明"></a>C++中的变量声明</h2><p>在 C++ 中，<strong>变量声明</strong>告诉编译器你将在某个地方使用某个变量，但不需要在此时提供变量的具体内容。简单来说，声明只是告诉编译器“这个变量存在”。而<strong>变量定义</strong>则是真正分配内存空间并给变量赋值的过程。</p><h3 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h3><p>声明一个变量时，使用<code>extern</code>关键字告诉编译器该变量在其他地方定义，不需要在当前代码中重复定义。声明的目的是为了让编译器知道该变量的类型和名称，以便在编译时不会出错。</p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> type variable_name;</span><br></pre></td></tr></table></figure><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;   <span class="comment">// 声明了 a 和 b，表示它们将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c;      <span class="comment">// 声明了 c，表示它将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> f;    <span class="comment">// 声明了 f，表示它将在其他地方定义</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 变量定义和初始化</span></span><br><span class="line">  <span class="type">int</span> a, b;         <span class="comment">// 定义变量 a 和 b</span></span><br><span class="line">  <span class="type">int</span> c;            <span class="comment">// 定义变量 c</span></span><br><span class="line">  <span class="type">float</span> f;          <span class="comment">// 定义变量 f</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;   <span class="comment">// 输出 c 的值</span></span><br><span class="line"></span><br><span class="line">  f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl;   <span class="comment">// 输出 f 的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>我们在代码的开头声明了<code>a</code>、<code>b</code>、<code>c</code>和<code>f</code>这几个变量，告诉编译器它们将在其他地方定义。</li><li>然后，在<code>main</code>函数中，我们实际上定义了这些变量并初始化了它们。</li></ul><h3 id="重要注意点："><a href="#重要注意点：" class="headerlink" title="重要注意点："></a>重要注意点：</h3><ol><li><strong>声明</strong>：只是告诉编译器变量存在，不会分配内存。例如，<code>extern int a;</code> 声明了变量<code>a</code>，但它没有给<code>a</code>分配内存。</li><li><strong>定义</strong>：才会为变量分配内存，并且可以给它一个初始值。例如，<code>int a = 10;</code> 会定义变量<code>a</code>，并给它分配内存和初始值。</li><li><strong>多个声明，单次定义</strong>：你可以在多个地方声明同一个变量，但只应该在一个地方定义它。定义时会分配内存并赋值。</li></ol><h3 id="类似函数声明："><a href="#类似函数声明：" class="headerlink" title="类似函数声明："></a>类似函数声明：</h3><p>就像变量声明一样，函数也可以先声明再定义。你可以在程序的其他地方声明一个函数，而函数的定义可以放在程序的任何位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">func</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数<code>func</code>先声明，在<code>main</code>函数中调用它，实际的定义可以放在程序的任何地方。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>变量声明</strong>只是告诉编译器变量存在，并不分配内存。</li><li><strong>变量定义</strong>才会分配内存，并可以赋初值。</li><li><strong>函数声明</strong>告诉编译器函数存在，函数的实际实现可以在其他地方。</li></ul><h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues）"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>在 C++ 中，<strong>左值</strong>（Lvalue）和 <strong>右值</strong>（Rvalue）是两种不同类型的表达式，它们的区别在于是否可以被赋值，以及它们代表的内存位置。</p><h3 id="左值（Lvalue）："><a href="#左值（Lvalue）：" class="headerlink" title="左值（Lvalue）："></a>左值（Lvalue）：</h3><ul><li><strong>定义</strong>：左值表示一个可以出现在赋值符号（&#x3D;）左边的表达式，通常是一个可以定位到内存地址的对象。</li><li><strong>特点</strong>：左值表示一个存储位置，可以对其进行赋值，因为它表示内存中的一个具体位置。</li><li><strong>例子</strong>：变量、数组元素、解引用的指针等都是左值。例如，<code>g = 20;</code> 中的 <code>g</code> 是左值，因为它可以接受赋值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;  <span class="comment">// g 是左值</span></span><br><span class="line">g = <span class="number">30</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="右值（Rvalue）："><a href="#右值（Rvalue）：" class="headerlink" title="右值（Rvalue）："></a>右值（Rvalue）：</h3><ul><li><strong>定义</strong>：右值通常是一个没有明确内存地址的表达式。它表示一个临时的值或常量，通常只出现在赋值符号的右边。</li><li><strong>特点</strong>：右值不能出现在赋值符号的左边，因为它没有可以存储的内存位置，不能被赋值。</li><li><strong>例子</strong>：常量、字面值、表达式的计算结果（如 <code>10 + 5</code>）等都是右值。例如，<code>10 = 20;</code> 是非法的，因为 <code>10</code> 是右值，不能作为赋值的左边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能出现在赋值符号的左边</span></span><br></pre></td></tr></table></figure><h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul><li><strong>左值</strong>：可以出现在赋值符号的左边，表示一个可以被修改的内存位置（如变量）。</li><li><strong>右值</strong>：只能出现在赋值符号的右边，表示一个临时的、无法修改的值（如常量或表达式的结果）。</li></ul><p><strong>正确的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// a 是左值，10 是右值</span></span><br><span class="line">a = <span class="number">20</span>;       <span class="comment">// 可以对 a（左值）赋值</span></span><br></pre></td></tr></table></figure><p><strong>错误的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能作为赋值的左边</span></span><br></pre></td></tr></table></figure><p>通过这种方式，你可以理解左值是可以被赋值和修改的存储位置，而右值则是一次性的值，不能直接进行赋值。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的关键字（保留字）完整介绍</title>
      <link href="/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        body {            text-align: left; /* 使整个页面内容居中 */        }        table {            margin: 0 auto; /* 使表格在页面中居中 */            border-collapse: collapse;            font-weight: bold; /* 字体加粗 */        }        th, td {            border: 1px solid #ddd;            padding: 8px;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>保留字(关键字)</h2><p>C++系统中预定义的、在语言或编译系统的实现中具有特殊含义的单词:</p><table>    <tr>        <td>if</td>        <td>else</td>        <td>while</td>        <td>signed</td>        <td>throw</td>        <td>union</td>        <td>this</td>    </tr>    <tr>        <td>int</td>        <td>char</td>        <td>double</td>        <td>unsigned</td>        <td>const</td>        <td>goto</td>        <td>virtual</td>    </tr>    <tr>        <td>for</td>        <td>float</td>        <td>break</td>        <td>auto</td>        <td>class</td>        <td>operator</td>        <td>case</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>typedef</td>        <td>static</td>        <td>friend</td>        <td>template</td>        <td>default</td>    </tr>    <tr>        <td>new</td>        <td>void</td>        <td>register</td>        <td>extern</td>        <td>return</td>        <td>enum</td>        <td>inline</td>    </tr>    <tr>        <td>try</td>        <td>short</td>        <td>continue</td>        <td>sizeof</td>        <td>switch</td>        <td>private</td>        <td>protected</td>    </tr>    <tr>        <td>asm</td>        <td>while</td>        <td>catch</td>        <td>delete</td>        <td>public</td>        <td>volatile</td>        <td>struct</td>    </tr></table></body></html><p><strong>以下是对上述C++关键字的解释：</strong></p><hr><h3 id="1-asm（汇编指令）"><a href="#1-asm（汇编指令）" class="headerlink" title="1. asm（汇编指令）"></a>1. <strong>asm（汇编指令）</strong></h3><ul><li><code>asm</code>允许在C++程序中直接嵌入汇编代码。  </li><li>用法场景：需要执行底层硬件相关的指令时，可以使用它。</li></ul><hr><h3 id="2-auto（自动存储类型）"><a href="#2-auto（自动存储类型）" class="headerlink" title="2. auto（自动存储类型）"></a>2. <strong>auto（自动存储类型）</strong></h3><ul><li><code>auto</code>用来声明变量的存储类型是“自动的”，这意味着变量的生命周期受限于它所在的代码块（比如函数、循环等）。  </li><li>通常可以省略，因为这是默认行为。</li></ul><hr><h3 id="3-bool（布尔类型）"><a href="#3-bool（布尔类型）" class="headerlink" title="3. bool（布尔类型）"></a>3. <strong>bool（布尔类型）</strong></h3><ul><li><code>bool</code>表示“真或假”的值。  </li><li>有两个有效值：<code>true</code>（真）和<code>false</code>（假）。  </li><li>示例：<code>bool isActive = true;</code>  </li><li>在条件判断中很常用，比如<code>if</code>语句。</li></ul><hr><h3 id="4-break（跳出语句）"><a href="#4-break（跳出语句）" class="headerlink" title="4. break（跳出语句）"></a>4. <strong>break（跳出语句）</strong></h3><ul><li><code>break</code>用于终止循环或退出<code>switch</code>语句。  </li><li>当程序遇到<code>break</code>时，会直接跳到代码块的外面继续执行。  </li><li>示例：在<code>for</code>循环中提前停止迭代。</li></ul><hr><h3 id="5-case（条件分支）"><a href="#5-case（条件分支）" class="headerlink" title="5. case（条件分支）"></a>5. <strong>case（条件分支）</strong></h3><ul><li><code>case</code>用在<code>switch</code>语句中，表示不同的条件。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-catch（异常捕获）"><a href="#6-catch（异常捕获）" class="headerlink" title="6. catch（异常捕获）"></a>6. <strong>catch（异常捕获）</strong></h3><ul><li><code>catch</code>和<code>try</code>配合使用，用于处理程序运行时的异常。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-char（字符类型）"><a href="#7-char（字符类型）" class="headerlink" title="7. char（字符类型）"></a>7. <strong>char（字符类型）</strong></h3><ul><li><code>char</code>表示一个字符，比如字母或符号。  </li><li>数据范围是0到255，对应ASCII码表的值。  </li><li>示例：<code>char letter = &#39;A&#39;;</code></li></ul><hr><h3 id="8-class（类）"><a href="#8-class（类）" class="headerlink" title="8. class（类）"></a>8. <strong>class（类）</strong></h3><ul><li><code>class</code>是C++面向对象编程的核心，用来定义对象的模板或蓝图。  </li><li>类中可以包含属性和方法，用于模拟现实世界中的事物。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string brand;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 驾驶行为</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-const（常量）"><a href="#9-const（常量）" class="headerlink" title="9. const（常量）"></a>9. <strong><code>const</code>（常量）</strong></h3><ul><li><p><code>const</code>表示“不可更改”。  </p></li><li><p>用<code>const</code>修饰的变量或对象，其值在程序运行中不能被改变。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// pi 是一个常量，不能修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数</strong>：<br>如果<code>const</code>修饰一个函数，则该函数不能修改外部变量，也不能调用非<code>const</code>函数。<br>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// getValue不能修改任何变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：<br>相较于<code>#define</code>，<code>const</code>不仅可以定义常量，还具有类型检查功能，使用更安全。</p></li></ul><hr><h3 id="10-const-cast（类型转换运算符）"><a href="#10-const-cast（类型转换运算符）" class="headerlink" title="10. const_cast（类型转换运算符）"></a>10. <strong><code>const_cast</code>（类型转换运算符）</strong></h3><ul><li><p><code>const_cast</code>用来去除<code>const</code>属性，允许对原本不可修改的对象进行更改。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* px = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x); <span class="comment">// 去掉 x 的 const 性质</span></span><br><span class="line">*px = <span class="number">100</span>;                     <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：使用<code>const_cast</code>需要小心，错误的使用可能导致程序未定义行为。</p></li></ul><hr><h3 id="11-continue（跳过当前循环）"><a href="#11-continue（跳过当前循环）" class="headerlink" title="11. continue（跳过当前循环）"></a>11. <strong><code>continue</code>（跳过当前循环）</strong></h3><ul><li><p><code>continue</code>用在循环中，跳过本次循环剩下的代码，直接开始下一次循环。  </p></li><li><p><strong>与<code>break</code>的区别</strong>：  </p><ul><li><code>break</code>会结束整个循环。</li><li><code>continue</code>只跳过当前循环的后续部分，继续执行下一次循环。</li></ul></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过 i == 2 的情况</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 3 4</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="12-default（默认分支）"><a href="#12-default（默认分支）" class="headerlink" title="12. default（默认分支）"></a>12. <strong><code>default</code>（默认分支）</strong></h3><ul><li><p><code>default</code>是<code>switch</code>语句中的默认分支。  </p></li><li><p>当所有的<code>case</code>条件都不满足时，执行<code>default</code>部分的代码。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 5&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 8&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：x is something else</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>default</code>是可选的，可以没有。</p></li></ul><hr><h3 id="13-delete（释放内存）"><a href="#13-delete（释放内存）" class="headerlink" title="13. delete（释放内存）"></a>13. <strong><code>delete</code>（释放内存）</strong></h3><ul><li><code>delete</code>用于释放通过<code>new</code>关键字动态分配的内存空间。</li><li>释放的对象可以是单个变量或数组，但必须与分配时的形式匹配。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 动态分配一个整数</span></span><br><span class="line"><span class="keyword">delete</span> ptr;             <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 动态分配一个数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：释放内存后不能再次使用，否则会导致“悬空指针”。</li></ul><hr><h3 id="14-do（循环结构）"><a href="#14-do（循环结构）" class="headerlink" title="14. do（循环结构）"></a>14. <strong><code>do</code>（循环结构）</strong></h3><ul><li><code>do</code>是<code>do-while</code>循环的一部分，与<code>while</code>循环类似，但它<strong>至少执行一次循环体</strong>，因为条件是在循环体执行之后才检查的。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i is 0</span><br><span class="line">i is 1</span><br><span class="line">i is 2</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="15-double（双精度浮点数）"><a href="#15-double（双精度浮点数）" class="headerlink" title="15. double（双精度浮点数）"></a>15. <strong><code>double</code>（双精度浮点数）</strong></h3><ul><li><code>double</code>是C++中表示浮点数的一种数据类型，用于存储带小数点的数值，精度比<code>float</code>更高。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi is &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li>通常用于需要更高精度的数学计算。</li></ul><hr><h3 id="16-dynamic-cast（动态类型转换）"><a href="#16-dynamic-cast（动态类型转换）" class="headerlink" title="16. dynamic_cast（动态类型转换）"></a>16. <strong><code>dynamic_cast</code>（动态类型转换）</strong></h3><ul><li><code>dynamic_cast</code>用于在运行时将基类指针或引用转换为派生类指针或引用，确保类型安全。</li><li>适用于有<strong>继承关系</strong>的类之间的转换。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 必须有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion successful!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：<ul><li>如果转换失败，返回<code>nullptr</code>（对于指针）或抛出异常（对于引用）。</li></ul></li></ul><hr><h3 id="17-else（条件分支）"><a href="#17-else（条件分支）" class="headerlink" title="17. else（条件分支）"></a>17. <strong><code>else</code>（条件分支）</strong></h3><ul><li><code>else</code>和<code>if</code>配合使用，用于处理<code>if</code>条件为<code>false</code>时的操作。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is non-positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is positive</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="18"><li><strong>enum（枚举）</strong><br><code>enum</code>（枚举）类型用于定义一组固定的值，值的选择只能在这些预定义的选项中进行。例如，你可以使用枚举类型来表示一周的七天，每天对应一个固定的值：<code>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</code>。每个枚举值都代表一个常量，确保只能选择这些特定的值。</li></ol><hr><ol start="19"><li><strong>explicit（显式的）</strong><br><code>explicit</code>关键字的作用是“禁止单参数构造函数”在自动类型转换中被使用。简单来说，它防止编译器在进行类型转换时，自动将一个类型转换成这个构造函数的类型。例如，某些容器类型的构造函数可能接收一个数字作为初始大小，如果没有<code>explicit</code>，那么编译器可能会错误地将一个整数自动转换成容器类型。通过显式标记构造函数，可以避免这种自动转换。</li></ol><hr><ol start="20"><li><strong>export（导出）</strong><br>当你想访问其他代码文件中的变量或对象时，如果是普通类型（如基本数据类型、结构体或类），可以使用<code>extern</code>来引用。但是对于模板类型（如模板类或模板函数），你需要使用<code>export</code>来声明它们。在这种情况下，<code>export</code>告诉编译器这些模板是为了在其他文件中使用而被定义的。</li></ol><hr><ol start="21"><li><strong>extern（外部的）</strong><br><code>extern</code>关键字用于声明一个变量或函数是“外部链接”的，意思是它在其他文件中可以被访问和使用。这意味着这个变量或函数并没有在当前文件中定义，而是在程序的其他部分定义的。使用<code>extern</code>声明的变量或函数会在程序开始时分配空间，结束时释放。它们的定义应该出现在其他文件或同一文件的其他地方。如果要使用其他语言编写的代码，可以用<code>extern &quot;C&quot;</code>来声明，指明用C语言的方式进行链接。</li></ol><hr><ol start="22"><li><strong>false（假的）</strong><br><code>false</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“假”。它等价于整数类型中的0。在C++中，<code>bool</code>类型的变量可以是<code>true</code>（真）或<code>false</code>（假）。</li></ol><hr><ol start="23"><li><strong>float（浮点数）</strong><br><code>float</code>是C++中的一种数据类型，用于表示小数（浮点数）。它的精度比<code>double</code>低，适用于对精度要求不高的情况。比如，如果你只需要表示一位小数，使用<code>float</code>可以节省内存。</li></ol><hr><ol start="24"><li><strong>for（循环）</strong><br><code>for</code>是C++中的一种循环结构，用来反复执行一段代码，直到满足特定的条件为止。通常用于已知需要循环多少次的场景。例如，遍历数组或从1加到10。</li></ol><hr><ol start="25"><li><strong>friend（友元）</strong><br><code>friend</code>关键字用来声明友元关系，它允许其他函数或类访问当前类的私有（<code>private</code>）和保护（<code>protected</code>）成员。通过友元，某些函数或类可以直接操作本应隐藏的成员，从而提高效率或简化代码。友元可以是函数、类或特定的成员函数。</li></ol><hr><ol start="26"><li><strong>goto（转到）</strong><br><code>goto</code>是C++中的一种语句，用于跳转到程序中的另一个位置。虽然它可以改变程序的执行流，但通常不推荐使用，因为它会让程序的逻辑变得混乱。现代编程中，常用其他控制流结构（如<code>for</code>、<code>while</code>、<code>if</code>等）来替代<code>goto</code>。</li></ol><hr><ol start="27"><li><strong>if（如果）</strong><br><code>if</code>是C++中的条件语句，用于判断某个条件是否为真。如果条件为真，程序就会执行相应的代码块；如果为假，则跳过这个代码块。它是实现程序决策和分支逻辑的基础。</li></ol><hr><ol start="28"><li><strong>inline（内联函数）</strong><br><code>inline</code>用于定义内联函数，即编译器在调用该函数时，将函数的代码直接插入调用处，而不是进行常规的函数调用。内联函数通常很小，且频繁调用，使用<code>inline</code>可以提高程序执行效率，减少函数调用的开销。</li></ol><hr><ol start="29"><li><strong>int（整型）</strong><br><code>int</code>是C++中的基本数据类型，用来表示整数（没有小数的数）。它的范围通常较小，比<code>long</code>类型的整数范围要窄一些。</li></ol><hr><ol start="30"><li><strong>long（长整型）</strong><br><code>long</code>是C++中的另一种整型数据类型，用来表示比<code>int</code>类型范围更大的整数。它可以存储更大的数值。</li></ol><hr><ol start="31"><li><strong>mutable（易变的）</strong><br><code>mutable</code>是C++中的一个特殊关键字，通常用于类中的成员变量。它允许即使在<code>const</code>函数中，也可以修改被声明为<code>mutable</code>的成员变量。换句话说，它让类的常量成员函数能够修改某些成员变量，这通常用于需要记录某些信息但又不能改变对象状态的情况。</li></ol><hr><ol start="32"><li><strong>namespace（命名空间）</strong><br><code>namespace</code>用于组织和区分类。它是一种比类更大的组织结构，允许你将不同的类、函数等进行分组，避免命名冲突。你可以把它看作一个容器，帮助管理代码。</li></ol><hr><ol start="33"><li><strong>new（新建）</strong><br><code>new</code>是C++中的一个运算符，用于动态创建对象。它会在内存中为对象分配空间，并返回指向该对象的指针。也就是说，<code>new</code>会返回一个指向新创建对象的指针。</li></ol><hr><ol start="34"><li><strong>operator（操作符）</strong><br><code>operator</code>用于操作符重载，它让你可以为C++中的操作符（比如加号、减号等）定义自定义的行为。通过操作符重载，你可以让这些操作符在你的类对象上起作用。</li></ol><hr><ol start="35"><li><strong>private（私有的）</strong><br><code>private</code>是C++中的访问控制符之一，表示一个类的成员（如变量和函数）只能在该类的内部或者其友元类中访问。外部代码不能直接访问这些私有成员。</li></ol><hr><ol start="36"><li><strong>protected（受保护的）</strong><br><code>protected</code>也是C++中的访问控制符之一。被<code>protected</code>标记的成员只能在当前类、派生类（继承的类）以及友元类中访问。外部代码无法直接访问这些受保护的成员。</li></ol><hr><ol start="37"><li><strong>public（公有的）</strong><br><code>public</code>是C++中的访问控制符之一，表示一个类的成员可以被任何代码访问。它没有访问限制，可以在类的外部直接访问这些公有成员。</li></ol><hr><ol start="38"><li><strong>register（寄存器）</strong><br><code>register</code>是C++中的一个关键字，表示请求编译器将某个变量存放在CPU的寄存器中（而不是内存中），以提高访问速度。这个优化仅适用于局部变量，但在现代编译器中，它通常会根据实际情况自动优化，因此在32位编译器中作用较小。</li></ol><hr><ol start="39"><li><strong>reinterpret_cast（重新解释转换）</strong><br><code>reinterpret_cast</code>是C++中的一种类型转换，它可以把一个类型转换成完全不同的另一个类型。例如，它可以把指针转换成整数，或者把整数转换成指针。它的作用是直接重解释数据的二进制表示，而不考虑数据的实际类型，因此需要谨慎使用。</li></ol><hr><ol start="40"><li><strong>return（返回）</strong><br><code>return</code>关键字用于从函数中返回一个值，并结束函数的执行。一旦程序执行到<code>return</code>语句，函数会立即返回结果，之后的代码不会再执行。</li></ol><hr><ol start="41"><li><strong>short（短整型）</strong><br><code>short</code>是C++中的一种整型数据类型，用于表示比<code>int</code>类型范围小的整数。它占用的内存空间比<code>int</code>小，适用于存储较小范围的整数。</li></ol><hr><ol start="42"><li><strong>signed（有符号）</strong><br><code>signed</code>表示数字类型（如整型）是有符号的，也就是说它可以表示正数和负数。与之相对的是<code>unsigned</code>，即无符号类型，表示只有正数和零。大多数数值类型默认就是<code>signed</code>，所以通常不需要显式声明。</li></ol><hr><ol start="43"><li><strong>sizeof（大小）</strong><br><code>sizeof</code>是一个运算符，用来获取数据类型占用的内存大小（以字节为单位）。由于不同系统和编译器可能会有不同的内存分配，使用<code>sizeof</code>可以确保程序的可移植性。</li></ol><hr><ol start="44"><li><strong>static（静态的）</strong><br><code>static</code>关键字用于声明静态变量或静态函数。静态变量在程序开始时分配内存，并且在程序结束时释放。它的作用范围限于定义它的文件或类，在其他文件中不可访问。对于类的静态成员，它是由类的所有实例共享的，所有对象共享同一个静态变量。静态成员变量必须在类外部进行初始化。</li></ol><p>好的，下面是这些概念的更简洁易懂的解释：</p><hr><ol start="45"><li><strong>static_cast（静态转换）</strong><br><code>static_cast</code>是C++中的一种类型转换方式，它把表达式转换为指定的类型。它没有运行时的类型检查，所以开发者需要确保转换是安全的。常见的用法包括：</li></ol><ul><li><strong>类层次转换</strong>：在继承关系中，可以将子类指针&#x2F;引用转换为基类类型（安全），也可以把基类转换为子类（不安全，因为没有检查）。</li><li><strong>基本类型转换</strong>：在不同基本类型之间转换，比如<code>int</code>转换为<code>char</code>或枚举类型。  </li><li><strong>空指针转换</strong>：可以将空指针转换为其他类型的空指针。</li><li><strong>转换为<code>void</code>类型</strong>：可以将任何类型转换为<code>void</code>，用于不返回任何内容。</li></ul><p>需要注意的是，<code>static_cast</code>无法移除<code>const</code>、<code>volatile</code>或<code>__unaligned</code>属性。</p><hr><ol start="46"><li><strong>struct（结构体）</strong><br><code>struct</code>是C++中用于定义结构体的一种数据类型，与<code>class</code>类似，但与C语言兼容。它可以用来定义面向对象的程序，且所有成员默认是公有的（<code>public</code>），在实现上类似于<code>class</code>。</li></ol><hr><ol start="47"><li><strong>switch（选择）</strong><br><code>switch</code>是C++中的一种条件语句，用于在多个可能的分支中选择执行一条。它的用法类似于<code>if-else</code>链，但更简洁。<code>switch</code>的条件表达式必须是整型（如<code>int</code>或<code>char</code>）。<code>switch</code>语句通常包括一个可选的<code>default</code>分支，以处理没有匹配的情况。</li></ol><hr><ol start="48"><li><strong>template（模板）</strong><br><code>template</code>是C++中实现泛型编程的关键字。通过模板，可以定义适用于多种数据类型的通用函数或类，使代码更灵活、可重用。</li></ol><hr><ol start="49"><li><strong>this</strong><br><code>this</code>是C++中的一个指针，用于指向当前对象，也就是正在调用该成员函数的对象本身。通过<code>this</code>，对象可以访问它自己的数据成员和其他成员函数。</li></ol><hr><ol start="50"><li><strong>throw（抛出）</strong><br><code>throw</code>关键字用于C++中的异常处理。当程序遇到错误情况时，可以使用<code>throw</code>来抛出一个异常，通知调用者出错。<code>throw</code>的值可以是任意类型的异常对象。</li></ol><hr><ol start="51"><li><strong>true（真的）</strong><br><code>true</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“真”，等价于整数的非零值。布尔类型<code>bool</code>的值可以是<code>true</code>或<code>false</code>。</li></ol><hr><ol start="52"><li><strong>try（尝试）</strong><br><code>try</code>是C++异常处理机制的一部分。它用于包围可能会抛出异常的代码块，并与<code>catch</code>语句搭配使用，以捕获并处理异常。</li></ol><hr><ol start="53"><li><strong>typedef（类型定义）</strong><br><code>typedef</code>用于为已有数据类型创建一个新的别名。例如，可以用<code>typedef</code>给<code>int</code>类型取一个新的名字。这样可以使代码更易读，但并不会创建新的数据类型。</li></ol><hr><ol start="54"><li><strong>typeid</strong><br><code>typeid</code>用于在运行时获得某个对象或指针的实际类型（比如某个指针或引用指向的派生类型），常用于了解继承关系中的具体类型信息。</li></ol><hr><ol start="55"><li><strong>typename（类型名）</strong><br><code>typename</code>关键字告诉编译器，某个名称代表的是一种类型。主要用于模板代码中，以便让编译器正确地理解该名称的含义，尤其当该名称嵌套在其他类型中或依赖于模板参数时。</li></ol><hr><ol start="56"><li><strong>union（联合体）</strong><br><code>union</code>是一种数据结构，允许存储不同类型的数据，但同一时刻只存储一种。所有成员共享同一段内存，大小取决于最大的数据成员。这与<code>enum</code>不同，<code>enum</code>只能用于整数类型。</li></ol><hr><ol start="57"><li><strong>unsigned（无符号）</strong><br><code>unsigned</code>表示无符号类型，只能存储非负数。与<code>signed</code>（有符号）相对，<code>unsigned</code>省去了负数部分，使得同样的空间可以存储更大的正数。</li></ol><hr><ol start="58"><li><strong>using</strong><br><code>using</code>用于简化命名空间的引用。通过<code>using</code>声明，可以直接使用某命名空间的内容，而不必每次都写命名空间前缀。</li></ol><hr><ol start="59"><li><strong>virtual（虚函数）</strong><br><code>virtual</code>用于实现多态性，允许在基类中声明虚函数，从而可以在派生类中实现不同的行为。这样，通过基类指针或引用调用函数时，会执行派生类中的实际实现。</li></ol><hr><ol start="60"><li><strong>void（空）</strong><br><code>void</code>是一种特殊类型，表示“没有类型”或“空”。它可以用于：</li></ol><ul><li><strong>函数返回类型</strong>：表示函数不返回值。</li><li><strong>函数参数</strong>：表示没有参数传入。</li><li><strong>指针类型</strong>：<code>void*</code>表示一个通用指针，可以指向任意类型的数据。</li></ul><hr><ol start="61"><li><strong>volatile（易变的）</strong><br><code>volatile</code>用于标记变量的值可能会随时被系统或其他进程修改，防止编译器对它进行优化。常用于异步处理，如中断程序中涉及的变量。</li></ol><hr><ol start="62"><li><strong>wchar_t（宽字符）</strong><br><code>wchar_t</code>是一种数据类型，用于表示宽字符（即多字节字符）。每个<code>wchar_t</code>占用两个字节，适合表示Unicode字符，例如汉字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据类型</title>
      <link href="/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这一节我们将学习数据类型的相关知识，可能会涉及到一些C++的基本语法，如果你还有不明白的，请到<a href="https://blog.tomatou.xyz/2024/11/14/C++%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">C++基本语法</a>这里温故一下</strong></p><h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h1><p><strong>在编写程序时，我们经常需要用到变量来保存各种信息。变量其实是内存中的一块空间，用来存储特定的数据。创建变量时，计算机会根据变量的类型，分配合适大小的内存，并决定存储的数据格式。</strong></p><p>不同的数据类型可以用来保存不同种类的信息，比如：  </p><ul><li><strong>字符类型</strong>：用来存储单个字符，比如<code>&#39;A&#39;</code>。  </li><li><strong>宽字符类型</strong>：用于存储多字节字符，比如Unicode字符。  </li><li><strong>整数类型</strong>：用来存储整数，比如<code>10</code>或<code>-5</code>。  </li><li><strong>浮点数类型</strong>：用来存储小数，比如<code>3.14</code>。  </li><li><strong>双精度浮点数类型</strong>：精度更高的小数，比如<code>3.1415926</code>。  </li><li><strong>布尔类型</strong>：用来存储<code>true</code>（真）或<code>false</code>（假）。</li></ul><p>操作系统会根据变量的类型，确定分配多少内存以及如何处理存储的数据。这样，可以更高效地利用系统资源并保证数据正确存储。</p><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>数据类型和关键字</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>数据类型和关键字</h2><table>    <tr>        <th>类型</th>        <th>关键字</th>    </tr>    <tr>        <td>布尔型</td>        <td>bool</td>    </tr>    <tr>        <td>字符型</td>        <td>char</td>    </tr>    <tr>        <td>整型</td>        <td>int</td>    </tr>    <tr>        <td>浮点型</td>        <td>float</td>    </tr>    <tr>        <td>双浮点型</td>        <td>double</td>    </tr>    <tr>        <td>无类型</td>        <td>void</td>    </tr>    <tr>        <td>宽字符型</td>        <td>wchar_t</td>    </tr></table></body></html><p><code>wchar_t</code> 其实是通过定义类型别名实现的，具体是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>这意味着，<code>wchar_t</code> 实际上占用的空间和 <code>short int</code> 一样，通常是 2 个字节。</p><p>C++ 中的一些基本数据类型可以通过修饰符来修改它们的属性，包括：</p><ul><li><strong>signed</strong>：表示带符号（可以是正数或负数，默认情况下大多数整数类型是带符号的）。</li><li><strong>unsigned</strong>：表示无符号，只能是正数。</li><li><strong>short</strong>：表示短整型，通常占用比 <code>int</code> 更少的内存（通常是 2 个字节）。</li><li><strong>long</strong>：表示长整型，通常占用比 <code>int</code> 更多的内存（通常是 8 个字节）。</li></ul><p>不同的数据类型在内存中占用的空间（字节数）会有所不同，而且它们能存储的最大值和最小值也会根据系统有所不同。通常情况下，1 字节等于 8 位。</p><h3 id="默认情况下："><a href="#默认情况下：" class="headerlink" title="默认情况下："></a>默认情况下：</h3><ul><li><code>int</code>、<code>short</code>、<code>long</code> 类型都是带符号的（<code>signed</code>），可以表示负数和正数。</li></ul><h3 id="关于-long-int-和-int-的大小："><a href="#关于-long-int-和-int-的大小：" class="headerlink" title="关于 long int 和 int 的大小："></a>关于 <code>long int</code> 和 <code>int</code> 的大小：</h3><ul><li>在一些早期的编译器中，<code>long int</code> 占 4 个字节，<code>int</code> 占 2 个字节。但是现代的 C&#x2F;C++ 标准已经兼容这种设定，通常在较新的系统中，<code>long int</code> 占 8 个字节，<code>int</code> 占 4 个字节。<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Data Types and Ranges</title>  <style>      table {          width: 100%;          border-collapse: collapse;      }      th, td {          border: 1px solid #ddd;          padding: 8px;          text-align: left;      }      th {          background-color: #add8e6; /* 浅蓝色背景 */          color: #000; /* 文本颜色，可以根据需要调整 */      }  </style></head><body></li></ul><h2>Data Types and Ranges</h2><table>    <tr>        <th>类型</th>        <th>位</th>        <th>范围</th>    </tr>    <tr>        <td>char</td>        <td>1个字节</td>        <td>-128到127或者0到255</td>    </tr>    <tr>        <td>unsigned char</td>        <td>1个字节</td>        <td>0到255</td>    </tr>    <tr>        <td>signed char</td>        <td>1个字节</td>        <td>-128到127</td>    </tr>    <tr>        <td>int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>unsigned int</td>        <td>4个字节</td>        <td>0到4294967295</td>    </tr>    <tr>        <td>signed int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>unsigned short int</td>        <td>2个字节</td>        <td>0到65,535</td>    </tr>    <tr>        <td>signed short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>signed long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>unsigned long int</td>        <td>8个字节</td>        <td>0到18,446,744,073,709,551,615</td>    </tr>    <tr>        <td>float</td>        <td>4个字节</td>        <td>精度型占4个字节(32位)内存空间,+/-3.4e+/-38(~7个数字)</td>    </tr>    <tr>        <td>double</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,+/-1.7e+/-308(~15个数字)</td>    </tr>    <tr>        <td>long long</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,表示-9,223,372,036,854,775,807到9,223,372,036,854,775,807的范围</td>    </tr>    <tr>        <td>long double</td>        <td>16个字节</td>        <td>长双精度型16个字节(128位)内存空间,可提供18-19位有效数字。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>2或4个字节</td>        <td>1个宽字符</td>    </tr></table></body></html><h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>在 C++ 中，<code>typedef</code> 关键字可以用来给已有的类型起一个新的名字。这相当于创建一个类型的别名，让代码更清晰或者更方便。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原类型 新名字;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>如果想给 <code>int</code> 类型起一个新名字 <code>feet</code>，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet;</span><br></pre></td></tr></table></figure><p>从现在起，<code>feet</code> 就和 <code>int</code> 完全等价，表示同一种类型。比如下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance; <span class="comment">// 等同于 int distance;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>distance</code> 是一个整型变量，但通过 <code>feet</code> 这个名字，它更直观地表示变量的意义，比如“表示距离”。这让代码更容易阅读和理解。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>枚举类型（<code>enumeration</code>）是 C++ 中一种用户自定义的数据类型，用来定义一组固定的值。它非常适合表示只有有限可能取值的变量。通过枚举，可以为变量列举出所有合法值，变量的取值范围就被限制在这些列举的值中。</strong></p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举用关键字 <code>enum</code> 定义，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; </span><br><span class="line">    标识符<span class="number">1</span>[=整型常数], </span><br><span class="line">    标识符<span class="number">2</span>[=整型常数], </span><br><span class="line">    ...</span><br><span class="line">    标识符n[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>如果没有为标识符赋值（即省略 <code>=整型常数</code>），枚举会默认从 0 开始，后续值依次加 1。</li><li>也可以为部分或全部标识符指定具体的值。未指定的标识符会自动比前一个值大 1。</li></ul><h3 id="示例-1：默认值"><a href="#示例-1：默认值" class="headerlink" title="示例 1：默认值"></a>示例 1：默认值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125;; <span class="comment">// red=0, green=1, blue=2</span></span><br><span class="line">color c;  <span class="comment">// 定义变量 c，类型为 color</span></span><br><span class="line">c = blue; <span class="comment">// c 的值为 blue（等价于 2）</span></span><br></pre></td></tr></table></figure><h3 id="示例-2：自定义值"><a href="#示例-2：自定义值" class="headerlink" title="示例 2：自定义值"></a>示例 2：自定义值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;; <span class="comment">// red=0, green=5, blue=6</span></span><br><span class="line">color c = green;  <span class="comment">// c 的值为 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>red</code> 的值为 0。</li><li><code>green</code> 的值被设置为 5。</li><li><code>blue</code> 自动被赋值为 6，因为它比前一个值大 1。</li></ul><h3 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h3><ol><li><strong>代码更易读</strong>：通过枚举名称表达变量的意义（如 <code>red</code> 和 <code>green</code>）。</li><li><strong>更安全</strong>：变量的取值被限制在定义的枚举值范围内，避免了非法值的出现。</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换是指将一种数据类型的值转换成另一种数据类型的值。在 C++ 中，主要有四种类型转换方式：<strong>静态转换、动态转换、常量转换</strong>和<strong>重新解释转换</strong>。下面我们用更简单的语言解释这些转换方式。</p><hr><h3 id="1-静态转换（Static-Cast）"><a href="#1-静态转换（Static-Cast）" class="headerlink" title="1. 静态转换（Static Cast）"></a>1. <strong>静态转换（Static Cast）</strong></h3><ul><li><strong>作用</strong>：在编译时，将一种类型强制转换成另一种类型。</li><li><strong>特点</strong>：没有运行时检查，所以如果转换不合理，可能会导致程序运行时出错。</li><li><strong>用途</strong>：通常用在类型之间有一定相似性的场景，比如 <code>int</code> 和 <code>float</code> 的转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 把 int 类型的值转换为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-动态转换（Dynamic-Cast）"><a href="#2-动态转换（Dynamic-Cast）" class="headerlink" title="2. 动态转换（Dynamic Cast）"></a>2. <strong>动态转换（Dynamic Cast）</strong></h3><ul><li><strong>作用</strong>：在运行时将基类的指针或引用转换为派生类的指针或引用。</li><li><strong>特点</strong>：会进行运行时类型检查，如果转换不合法，会返回空指针或抛出异常。</li><li><strong>用途</strong>：主要用于带有<strong>继承关系的类</strong>之间的指针或引用转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 转换成派生类指针</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-常量转换（Const-Cast）"><a href="#3-常量转换（Const-Cast）" class="headerlink" title="3. 常量转换（Const Cast）"></a>3. <strong>常量转换（Const Cast）</strong></h3><ul><li><strong>作用</strong>：用于移除变量的 <code>const</code> 属性，允许对其进行修改。</li><li><strong>特点</strong>：只能去掉 <code>const</code>，不会改变数据类型。</li><li><strong>用途</strong>：在特定场景下需要修改 <code>const</code> 修饰的变量时使用。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;  <span class="comment">// 一个常量</span></span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 将 const int 转换为普通 int</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-重新解释转换（Reinterpret-Cast）"><a href="#4-重新解释转换（Reinterpret-Cast）" class="headerlink" title="4. 重新解释转换（Reinterpret Cast）"></a>4. <strong>重新解释转换（Reinterpret Cast）</strong></h3><ul><li><strong>作用</strong>：直接将一种类型的值按二进制格式解释为另一种类型。</li><li><strong>特点</strong>：不做任何检查，可能会导致未定义行为。</li><li><strong>用途</strong>：通常用于需要对内存内容重新解释的场景（如底层编程）。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 强行把 int 的内存解释为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th><strong>转换方式</strong></th><th><strong>特点</strong></th><th><strong>主要用途</strong></th></tr></thead><tbody><tr><td><strong>静态转换</strong></td><td>编译时转换，无运行时检查</td><td>类型相似的普通数据类型转换（如 <code>int</code> 转 <code>float</code>）</td></tr><tr><td><strong>动态转换</strong></td><td>运行时检查，安全但速度稍慢</td><td>基类与派生类之间的指针或引用转换</td></tr><tr><td><strong>常量转换</strong></td><td>去掉 <code>const</code> 属性，只修改可变性</td><td>修改 <code>const</code> 变量的值</td></tr><tr><td><strong>重新解释转换</strong></td><td>直接按内存内容重新解释类型，不安全</td><td>内存地址、类型的低级转换（如底层硬件编程）</td></tr></tbody></table><p>需要注意的是，<strong>尽量避免不必要的类型转换</strong>，特别是动态转换和重新解释转换，因为它们可能引发潜在的问题或性能损耗。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
      <url>/2024/11/14/C-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.tomatou.xyz/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/">面向对象与面向过程</a>，本节我将正式开始讲解关于C++的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>C++ 程序可以看作是由一组对象组成的，每个对象都有自己的特性和行为。这些对象通过互相调用方法来交流。现在让我们用简单的方式理解一下<strong>类</strong>、<strong>对象</strong>、<strong>方法</strong>和<strong>实例变量</strong>。</p><ol><li><p><strong>对象</strong>  </p><ul><li>对象就像是生活中的实物，它既有特性，也有行为。  <ul><li>比如：一只狗。  <ul><li><strong>特性</strong>：颜色（白色）、名字（小白）、品种（牧羊犬）。  </li><li><strong>行为</strong>：摇尾巴、叫、吃东西。</li></ul></li><li><strong>在程序中，对象是根据类创建出来的“实例”。</strong></li></ul></li></ul></li><li><p><strong>类</strong>  </p><ul><li>类可以看作是创建对象的“设计图”或者“模板”。  <ul><li>比如，“狗”这个类就描述了所有狗的共性（颜色、名字、品种）和它们可以做的事（摇尾巴、叫、吃东西）。  </li><li><strong>具体的狗（如小白、小黑）就是从这个类生成的对象。</strong></li></ul></li></ul></li><li><p><strong>方法</strong>  </p><ul><li>方法就是对象可以执行的“动作”或者“功能”。  <ul><li>对狗来说，方法可以是“叫”（bark()）、“吃”（eat()）。  </li><li><strong>方法中包含程序逻辑，定义了对象可以做的事情。</strong></li></ul></li></ul></li><li><p><strong>实例变量</strong>  </p><ul><li>实例变量是对象的“特性值”，每个对象都有自己的值。  <ul><li>比如，狗类中可能有变量“颜色”、“名字”。小白的颜色是白色，名字是“小白”；而小黑的颜色是黑色，名字是“小黑”。这些特性值存储在实例变量中，决定了对象的状态。</li></ul></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把类比作“模板”，对象是根据模板创建的“具体实例”，方法定义了对象的“行为”，而实例变量存储了对象的“特性值”。通过这种方式，我们可以用编程模拟真实世界中的事物和它们之间的交互。</p><h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h1><p>让我们看一段简单的代码，可以输出单词 Hello World</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来我们讲解一下这个程序:</strong></p><ol><li><p><strong>头文件 <code>&lt;iostream&gt;</code></strong>  </p><ul><li><code>&lt;iostream&gt;</code> 是一个标准库，提供输入输出功能。  </li><li>在这个程序中，它允许我们使用 <code>cout</code> 输出信息到屏幕上。</li></ul></li><li><p><strong><code>using namespace std;</code></strong>  </p><ul><li>告诉编译器我们要使用标准命名空间 <code>std</code>。  </li><li>这样，我们可以直接写 <code>cout</code> 而不用每次都写成 <code>std::cout</code>。</li></ul></li><li><p><strong>单行注释 <code>//</code></strong>  </p><ul><li>以 <code>//</code> 开头的部分是注释，它的作用是让程序员记录说明，编译器会忽略这些内容。  </li><li>比如 <code>// main() 是程序的开始</code>，是为了帮助人类理解程序的结构。</li></ul></li><li><p><strong>主函数 <code>int main()</code></strong>  </p><ul><li><code>main()</code> 是程序的入口点，每个 C++ 程序都需要这个函数。  </li><li>程序从这里开始运行。</li></ul></li><li><p><strong>输出语句 <code>cout &lt;&lt; &quot;Hello World&quot;;</code></strong>  </p><ul><li><code>cout</code> 是 C++ 用来输出信息到屏幕的工具。  </li><li>这句代码会在屏幕上打印 <code>Hello World</code>。</li></ul></li><li><p><strong><code>return 0;</code></strong>  </p><ul><li>这句话的意思是：程序运行结束，并返回一个值 <code>0</code> 给系统。  </li><li>在 C++ 中，返回 <code>0</code> 通常表示程序正常结束。</li></ul></li></ol><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤:</p><ol><li><p><strong>编写代码</strong>  </p><ul><li>打开一个文本编辑器，比如记事本或代码编辑器（如 VS Code、Sublime Text）。  </li><li>将前面写好的代码粘贴进去。</li></ul></li><li><p><strong>保存文件</strong>  </p><ul><li>将文件保存为 <code>hello.cpp</code>（扩展名必须是 <code>.cpp</code>，表示这是一个 C++ 程序）。</li></ul></li><li><p><strong>打开命令提示符</strong>  </p><ul><li>在 Windows 系统中，可以通过按下 <code>Win + R</code>，输入 <code>cmd</code> 打开命令提示符。  </li><li>使用 <code>cd</code> 命令进入保存 <code>hello.cpp</code> 文件的文件夹。<br>例如，如果文件在桌面上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编译代码</strong>  </p><ul><li>输入以下命令，按下回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure></li><li>如果代码没有错误，编译器会生成一个可执行文件，默认命名为 <code>a.exe</code>（在 Windows 中）或 <code>a.out</code>（在 Linux&#x2F;macOS 中）。</li></ul></li><li><p><strong>运行程序</strong>  </p><ul><li>在命令提示符中输入以下命令，运行生成的可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.exe    <span class="comment"># Windows 系统</span></span><br><span class="line">./a.out  <span class="comment"># Linux/macOS 系统</span></span><br></pre></td></tr></table></figure></li><li>你将看到屏幕上显示 <code>Hello World</code>。</li></ul></li></ol><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li><strong>什么是编译？</strong><br>编译是将我们写的 C++ 代码转换成机器能理解的二进制文件（可执行文件）的过程。  </li><li><strong>为什么需要编译？</strong><br>计算机只能理解二进制代码，因此必须先将源代码“翻译”成计算机语言，才能运行。<br>通过以上步骤，你的第一个 C++ 程序就成功运行了！</li></ul><h2 id="C-中的分号-语句块"><a href="#C-中的分号-语句块" class="headerlink" title="C++ 中的分号 &amp; 语句块"></a>C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束</p><h3 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h3><ol><li><p><strong>分号是语句结束的标志</strong>：  </p><ul><li>每条C++语句都需要以分号结尾，用来告诉编译器“这句话结束了”。</li><li>你可以把分号看成是句号，表示一个完整的逻辑结束。</li></ul></li><li><p><strong>示例</strong>：<br>下面是三条独立的语句，每条语句都以分号结束：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;         <span class="comment">// 把 y 的值赋给 x</span></span><br><span class="line">y = y + <span class="number">1</span>;     <span class="comment">// y 加 1 后赋值给 y</span></span><br><span class="line"><span class="built_in">add</span>(x, y);     <span class="comment">// 调用函数 add，把 x 和 y 作为参数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="语句块的作用"><a href="#语句块的作用" class="headerlink" title="语句块的作用"></a>语句块的作用</h3><ol><li><p><strong>语句块是逻辑上的一组代码</strong>：  </p><ul><li>使用大括号 <code>&#123;&#125;</code> 将多条语句包裹在一起，这些语句作为一个整体，通常用于函数、条件语句、循环等结构中。</li></ul></li><li><p><strong>示例</strong>：<br>下面是一个语句块，它包含两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 返回值 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同一行的多个语句"><a href="#同一行的多个语句" class="headerlink" title="同一行的多个语句"></a>同一行的多个语句</h3><ol><li><p><strong>C++ 不限制每行只能写一条语句</strong>：  </p><ul><li>你可以在同一行放置多条语句，只要每条语句以分号结束即可。</li></ul></li><li><p><strong>示例</strong>：<br>以下两种写法是等价的：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y; y = y + <span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>分号</strong>：是C++的语句结束符，必须添加。</li><li><strong>语句块</strong>：是一组用大括号 <code>&#123;&#125;</code> 包裹的语句，用于逻辑上的分组。</li><li><strong>多语句</strong>：C++允许多条语句写在一行，只需确保用分号分隔即可。<br>通过这些规则，你可以更灵活地组织代码。</li></ul><h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用于命名变量、函数、类等的符号，用来帮助程序员在代码中识别不同的内容。下面是一些详细解释：</p><ol><li><p><strong>命名规则</strong>：</p><ul><li>标识符必须以字母（A-Z或a-z）或下划线（_）开头。</li><li>后面可以跟字母、数字（0-9）或下划线的组合。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能包含特殊字符，如 <code>@</code>、<code>&amp;</code>、<code>%</code> 等。</li><li>C++ 区分大小写，也就是说 <code>apple</code> 和 <code>Apple</code> 是两个不同的标识符。</li></ul></li><li><p><strong>有效的标识符示例</strong>：</p><ul><li><code>mohd</code>, <code>zara</code>, <code>move_name</code>, <code>a_123</code>, <code>_temp</code> 等，符合规则。<br>通过这些规则，C++ 程序员可以创建各种命名来组织代码，使代码更有条理。</li></ul></li></ol><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h2><p>下面出了一些在 C++ 中的保留字，这些保留字不能作为常量名、变量名或其他标识符名称。<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>C++ Keywords</h2><table>    <tr>        <td>asm</td>        <td>else</td>        <td>new</td>        <td>this</td>    </tr>    <tr>        <td>auto</td>        <td>enum</td>        <td>operator</td>        <td>throw</td>    </tr>    <tr>        <td>bool</td>        <td>explicit</td>        <td>private</td>        <td>true</td>    </tr>    <tr>        <td>break</td>        <td>export</td>        <td>protected</td>        <td>try</td>    </tr>    <tr>        <td>case</td>        <td>extern</td>        <td>public</td>        <td>typedef</td>    </tr>    <tr>        <td>catch</td>        <td>false</td>        <td>register</td>        <td>typeid</td>    </tr>    <tr>        <td>char</td>        <td>float</td>        <td>reinterpret_cast</td>        <td>typename</td>    </tr>    <tr>        <td>class</td>        <td>for</td>        <td>return</td>        <td>union</td>    </tr>    <tr>        <td>const</td>        <td>friend</td>        <td>short</td>        <td>unsigned</td>    </tr>    <tr>        <td>const_cast</td>        <td>goto</td>        <td>signed</td>        <td>using</td>    </tr>    <tr>        <td>continue</td>        <td>if</td>        <td>sizeof</td>        <td>virtual</td>    </tr>    <tr>        <td>default</td>        <td>inline</td>        <td>static</td>        <td>void</td>    </tr>    <tr>        <td>delete</td>        <td>int</td>        <td>static_cast</td>        <td>volatile</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>struct</td>        <td>wchar_t</td>    </tr>    <tr>        <td>double</td>        <td>mutable</td>        <td>switch</td>        <td>while</td>    </tr>    <tr>        <td>dynamic_cast</td>        <td>namespace</td>        <td>template</td>        <td></td>    </tr></table></body></html><p>若要查看完整关键字介绍可查阅：<a href="https://blog.tomatou.xyz/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">C++ 的关键字（保留字）完整介绍</a></p><h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><h3 id="什么是三字符组？"><a href="#什么是三字符组？" class="headerlink" title="什么是三字符组？"></a>什么是三字符组？</h3><p>三字符组是用三个特定字符组合来表示其他字符的一种方法，通常以??开头。这是早期为了解决一些键盘上缺少特定字符的问题而设计的。虽然现代编译器和键盘已经不需要这个功能，但它仍然是C++标准的一部分。</p><h3 id="三字符组的常用替换规则"><a href="#三字符组的常用替换规则" class="headerlink" title="三字符组的常用替换规则"></a>三字符组的常用替换规则</h3><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>字符替换表</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>字符替换表</h2><table>    <tr>        <th>三字符组</th>        <th>替换</th>    </tr>    <tr>        <td>??=</td>        <td>#</td>    </tr>    <tr>        <td>??/</td>        <td>\</td>    </tr>    <tr>        <td>??'</td>        <td>^</td>    </tr>    <tr>        <td>??(</td>        <td>[</td>    </tr>    <tr>        <td>??)</td>        <td>]</td>    </tr>    <tr>        <td>??!</td>        <td>|</td>    </tr>    <tr>        <td>??&lt;</td>        <td>{</td>    </tr>    <tr>        <td>??&gt;</td>        <td>}</td>    </tr>    <tr>        <td>??-</td>        <td>~</td>    </tr></table></body></html><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用三字符组代替常规符号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> ??! std::endl;  <span class="comment">// ??! 替换成 |</span></span><br><span class="line">    <span class="type">int</span> arr??(<span class="number">3</span>??) = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">// ??( 和 ??) 替换成 [ 和 ]</span></span><br><span class="line">    std::cout &lt;&lt; arr??(<span class="number">0</span>??) &lt;&lt; std::endl;       <span class="comment">// 输出数组第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="三字符组的注意事项"><a href="#三字符组的注意事项" class="headerlink" title="三字符组的注意事项"></a>三字符组的注意事项</h3><p><strong>特殊情况避免替换</strong>：</p><p>如果你需要在字符串、字符常量或者注释中保留两个连续的问号，而不被自动替换，可以用以下方式：<br>转义序列：”???“。<br>字符串拼接：”??””?”。</p><p><strong>现代编译器支持：</strong></p><p>Microsoft Visual C++：从2010版开始，默认不再支持三字符组。如果需要启用，可以使用命令行选项&#x2F;Zc:trigraphs。<br>GCC编译器：仍支持三字符组，但会提示编译警告，表明这种用法已经过时。</p><h3 id="为什么了解三字符组？"><a href="#为什么了解三字符组？" class="headerlink" title="为什么了解三字符组？"></a>为什么了解三字符组？</h3><p>虽然三字符组在现代开发中极少使用，但在维护一些古老的代码时可能会遇到。这是一个有趣的历史遗留特性，了解它有助于更全面地理解C++语言的设计。</p><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><p>以下是对“C++ 中的空格”更通俗易懂的解释：</p><h3 id="空白行和空格"><a href="#空白行和空格" class="headerlink" title="空白行和空格"></a>空白行和空格</h3><ol><li><p><strong>空白行</strong>：只有空格或注释的行称为“空白行”。C++ 编译器会自动忽略这些行，它们不会影响代码运行。</p></li><li><p><strong>空格的作用</strong>：</p><ul><li>空格不仅指空白符，还包括制表符（Tab）、换行符和注释，它们都属于“空白符号”。</li><li>空格帮助编译器区分不同部分，比如在<code>int age;</code>这行代码中，<code>int</code>和<code>age</code>之间需要空格，这样编译器才能知道<code>int</code>是数据类型，<code>age</code>是变量名。</li></ul></li><li><p><strong>代码的可读性</strong>：</p><ul><li>在一些地方，空格不是必需的，比如在 <code>fruit = apples + oranges;</code> 中，<code>fruit</code> 和 <code>=</code> 之间不强制要求空格，但适当添加空格可以让代码更清晰，便于阅读。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>空格让代码更易读，帮助编译器识别代码中的不同部分。虽然有些地方空格不是必须的，但为了让代码更美观，推荐合理使用空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与面向过程</title>
      <link href="/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从现在开始我将正式开始分享一些C++程序的讲解，相信大家对于C语言并不陌生，我们接下来需要去学习的C++这个编程语言也跟C语言有关系，但是它与C语言有很大的区别，本节内容不会有代码的讲解，作为一个引文的作用，目的在于让大家认识到C++与C语言的区别，或者说面向对象程序设计语言与面向过程程序设计语言的区别，以便于之后更好的去理解代码、语法等等</strong></p><h1 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h1><h2 id="一-面向过程-OOP"><a href="#一-面向过程-OOP" class="headerlink" title="一.面向过程(OOP)"></a>一.面向过程(OOP)</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p><strong>面向过程是一种以步骤为核心的编程方式，逻辑比较线性。可以理解为<u>以完成任务为目标</u>，通过一系列有序的指令来操作数据，逐步完成任务。我们来具体谈谈：</strong></p><h4 id="游戏中的面向过程"><a href="#游戏中的面向过程" class="headerlink" title="游戏中的面向过程"></a>游戏中的面向过程</h4><p><strong>设想我们要设计一个战斗游戏，有以下角色和功能：</strong></p><p><strong>角色：玩家、怪物</strong><br><strong>功能：攻击、逃跑、升级</strong></p><p><strong>在面向过程的思维中，我们可以按照以下步骤实现：</strong></p><p><strong>1.定义玩家的属性：生命值、攻击力、防御力</strong><br><strong>2.定义怪物的属性：生命值、攻击力、防御力</strong><br><strong>3.编写函数：</strong><br><strong>玩家攻击函数——playerAttackMonster()：玩家攻击怪物，怪物的生命值减少</strong><br><strong>怪物攻击函数——monsterAttackPlayer()：怪物攻击玩家，玩家的生命值减少</strong><br><strong>升级函数——upgradePlayer()：玩家升级时提升攻击力和防御力</strong><br><strong>4.游戏逻辑：通过调用这些函数来实现游戏流程，如玩家攻击、怪物攻击、玩家升级等</strong>。<br><strong>我们可以看到，<u>游戏的主要逻辑由一系列的函数组成，这些函数一个接一个地执行</u></strong></p><p><strong>所以可以得到面向过程的特点：</strong><br><strong>1.步骤清晰：逐步执行代码，如先定义角色，再实现攻击功能</strong><br><strong>2.数据分散：每个角色的数据和行为都是分开的，玩家和怪物的属性、函数不相关</strong><br><strong>3.适合小型项目：如果游戏简单，面向过程的逻辑非常直观</strong></p><p><strong>但这也带来了面向过程的劣势：</strong><br><strong>1.代码重复：不同的角色可能要定义相似的属性（如生命值、攻击力等）</strong><br><strong>2.维护困难：如果要新增一个角色，如“弓箭手”，需要增加很多函数和属性，工作量增加</strong></p><h2 id="二-面向对象-POP"><a href="#二-面向对象-POP" class="headerlink" title="二.面向对象(POP)"></a>二.面向对象(POP)</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向对象是一种以数据和行为组合为核心的编程方式，结构较为模块化。它强调将数据和操作结合在一起，通过“类”和“对象”将复杂的任务组织为独立的模块，还是以游戏为例：</strong></p><h4 id="游戏中的面向对象"><a href="#游戏中的面向对象" class="headerlink" title="游戏中的面向对象"></a>游戏中的面向对象</h4><p><strong>在面向对象的思维中，我们可以通过创建类来封装角色和行为：</strong></p><p><strong>1.定义一个“玩家”类（Player）：</strong><br><strong>属性：生命值、攻击力、防御力等</strong><br><strong>方法：攻击怪物（attack()）、升级（levelUp()）</strong></p><p><strong>2.继承和扩展：</strong><br><strong>如果有不同类型的玩家角色，比如战士（Warrior）、法师（Mage），我们可以让Warrior和Mage继承Player类，这样它们就自动拥有了生命值、攻击力等属性和攻击、升级等方法</strong><br><strong>我们可以为Warrior增加“近战攻击”方法（meleeAttack()），为Mage增加“施法”方法（castSpell()），这样每种角色都有独特的行为，而不需要重复编写基础属性</strong></p><p><strong>3.怪物类（Monster）：</strong><br><strong>我们也可以定义一个Monster类，包含怪物的生命值和攻击力</strong><br><strong>通过定义方法如attackPlayer()，实现怪物对玩家的攻击</strong></p><p><strong>4.道具类（Item）：</strong><br><strong>还可以定义道具类，包含道具名称、效果等属性</strong><br><strong>比如药水类可以恢复玩家的生命值，而武器类可以提升玩家的攻击力</strong></p><p><strong>从上面的例子我们不难看出面向过程的特点：</strong><br><strong>1.模块化：每个类都包含属性和行为，Player类中的方法直接操作Player的数据，怪物则自成一体</strong><br><strong>2.继承性：Warrior、Mage继承自Player，只需扩展各自的特性，而无需重复代码</strong><br><strong>3.封装性：属性和行为封装在类内，外部代码无需关心具体实现，只需调用方法</strong><br><strong>4.扩展性：可以轻松添加新角色或功能，如增加“弓箭手”类，继承Player类，扩展新技能，不影响已有代码</strong></p><h2 id="三-面向对象-vs-面向过程：对比分析"><a href="#三-面向对象-vs-面向过程：对比分析" class="headerlink" title="三.面向对象 vs. 面向过程：对比分析"></a>三.面向对象 vs. 面向过程：对比分析</h2><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><strong>1.面向对象是对面向过程的进一步抽象，结构上更清晰，适合管理复杂系统</strong><br><strong>2.二者的基本逻辑相同，但面向对象在逻辑结构和扩展性上更优</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>1.核心思维：面向过程以步骤和流程为主，逐步实现目标。面向对象通过类和对象组织代码，模块化更高</strong><br><strong>2.代码结构：面向过程的代码较分散，面向对象将数据和操作结合，封装在类中，结构更紧密</strong><br><strong>3.适用场景：面向过程适合简单、线性逻辑；面向对象适合复杂系统，方便维护和扩展</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>通过面向对象编程，我们可以更轻松地在游戏中管理不同角色、怪物、道具的行为和状态。这种模块化的设计方式不仅让代码更易读，还使得后续扩展和维护更加简单。在C++中，面向对象为我们提供了丰富的表达能力，从而使游戏设计更具灵活性和扩展性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站 www.______.com😏</title>
      <link href="/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>先问大家一个问题：大家的浏览器收藏夹里面有多少好东西呢？😋</strong></p><p><strong>我收藏夹里藏着不少“古董级”的宝贝网站，就像那些被遗忘在阁楼角落里的旧玩具，虽然不常拿出来玩，但偶尔翻出来，总能发现一些意想不到的乐趣。这些网站可能平时默默无闻，但说不定在某个无聊的下午，它们就能给你带来惊喜，让你的浏览器收藏夹不再是“尘封的记忆”，而是“宝藏的宝库”。那么，这次我为大家带来了哪些新奇有趣的网站呢？让我们一起来看看，说不定能发现一些被我们忽略的“隐藏版”乐趣哦！</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p><strong>使用设备：电脑</strong><br><strong>获取方式：文章底部(每一个推荐网站的底部)</strong></p><h3 id="1-懒盘搜索——聚合搜索神器"><a href="#1-懒盘搜索——聚合搜索神器" class="headerlink" title="1. 懒盘搜索——聚合搜索神器"></a>1. 懒盘搜索——聚合搜索神器</h3><p><strong>这是一个非常好用的网盘搜索工具，包括音乐、电影、动漫、小说等等内容都能搜索到</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120117.png" alt="主页面" >  <img src="/img_2/QQ截图20241111120126.png" alt="聚合搜索界面" ></div><p><strong>电影搜索</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120237.png" alt="电影搜素" ></div><p><strong>学习资源</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120246.png" alt="学习资源" >  <img src="/img_2/QQ截图20241111121051.png" alt="学习资源" ></div><h4 id="懒盘搜索官网链接：https-www-lzpan-com"><a href="#懒盘搜索官网链接：https-www-lzpan-com" class="headerlink" title="懒盘搜索官网链接：https://www.lzpan.com/"></a>懒盘搜索官网链接：<a href="https://www.lzpan.com/">https://www.lzpan.com/</a></h4><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p><strong>虫部落是一个集结了海量资源的搜索平台。在这里，你能找到的资源大多是通过网盘链接分享的。只要你拥有相应的网盘账户，轻轻一点，就能迅速将资源保存到你的网盘中，然后直接下载，方便快捷</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111121454.png" alt="主页面" >  <img src="/img_2/QQ截图20241111121853.png" alt="部分内容" >  <img src="/img_2/QQ截图20241111121916.png" alt="部分内容" ></div><p><strong>这个平台就像是一个资源宝库，让寻找各类资料变得轻而易举。它极大地简化了我的日常搜索任务，让我能够快速获取所需资源，真是一个值得向大家推荐的实用工具</strong></p><h4 id="虫部落官网链接：http-www-chongbuluo-com"><a href="#虫部落官网链接：http-www-chongbuluo-com" class="headerlink" title="虫部落官网链接：http://www.chongbuluo.com/"></a>虫部落官网链接：<a href="http://www.chongbuluo.com/">http://www.chongbuluo.com/</a></h4><h3 id="3-考研百科网"><a href="#3-考研百科网" class="headerlink" title="3.考研百科网"></a>3.考研百科网</h3><p><strong>这个平台致力于为准备考研的学生提供全方位的支持，让他们能够提前掌握所需的学习资源和准备工作。该平台划分为四个核心板块，分别是考研入门知识、考研流程指导、考研目标规划和备考技巧建议</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111122642.png" alt="主页面" >  <img src="/img_2/QQ截图20241111122656.png" alt="部分内容" ></div><p><strong>这个网站提供了非常全面的资源，我就不在这里一一列举了。正在准备考研或者有意向考研的朋友们，可以查看下面的图表，或者直接访问这个网站来获取更多信息</strong></p><h4 id="考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk"><a href="#考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk" class="headerlink" title="考研百科官网链接：https://yz.chsi.com.cn/yzzt/kybk"></a>考研百科官网链接：<a href="https://yz.chsi.com.cn/yzzt/kybk">https://yz.chsi.com.cn/yzzt/kybk</a></h4><h3 id="一键抠图——在线图片处理神器"><a href="#一键抠图——在线图片处理神器" class="headerlink" title="一键抠图——在线图片处理神器"></a>一键抠图——在线图片处理神器</h3><p><strong>一键抠图是一个卓越的网络图像编辑工具，它提供了众多的图片处理功能，包括但不限于图像抠图、证件照制作、照片修复、文件格式转换、全面编辑以及图片裁剪等，这些功能全面覆盖了日常工作中可能遇到的图像编辑需求</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111123156.png" alt="主页面" ></div><p><strong>抠图功能使用起来非常简单便捷，即使是初学者也能快速掌握。用户只需选择相应的功能，上传图片，系统便会自动进行识别并提取图片中的核心元素，整个过程轻松无压力</strong><br><video controls><br>  <source src="/img_2/bandicam 2024-11-11 12-34-06-243.mp4" type="video/mp4"><br></video></p><h4 id="一键抠图官网链接：https-www-yijiankoutu-com"><a href="#一键抠图官网链接：https-www-yijiankoutu-com" class="headerlink" title="一键抠图官网链接：https://www.yijiankoutu.com/"></a>一键抠图官网链接：<a href="https://www.yijiankoutu.com/">https://www.yijiankoutu.com/</a></h4><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，我们每个人的周围其实都有着不少宝贵的资源，无论是知识、技能、人脉还是物质条件。这些资源就像是我们生活中的宝藏，等待着我们去发掘和利用。不要害怕去探索和尝试，因为每一次的尝试都可能开启新的可能性。让我们勇敢地迈出步伐，用开放的心态去学习，用智慧的眼光去发现，用创新的思维去整合。记住，善于利用身边的资源，不仅能帮助我们解决问题，还能让我们在成长的道路上走得更远。所以，请用好每一份资源，让它们成为我们成功的助力！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
            <tag> 宝藏网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对不住了，Steam！Steam 游戏发烧友必备😏</title>
      <link href="/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/"/>
      <url>/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>说到 Steam，那可是游戏爱好者心中的圣地，就像图书馆之于书虫，糖果店之于小朋友，那是一个应有尽有，让人眼花缭乱的地方。你想要最新的 3A 大作？没问题！在线游戏？小菜一碟！但问题是，这些游戏可不是免费派发的糖果，你得先掏腰包才能把它们领回家</strong><br><strong>如果你偶尔心血来潮，买一两个游戏，那钱包还能勉强保持微笑。但如果你是个游戏收藏家，那可就得小心了，你的钱包可能会因为过度兴奋而 “心脏病发作”</strong><br><strong>当然，如果游戏能让你爱不释手，那花点钱也值了。但最怕的就是，你花了钱，结果发现这游戏跟你八字不合，那可真是让人哭笑不得</strong><br><strong>所以，今天给大家介绍一个神奇的游戏下载盒子，它能让你在 Steam 的海洋里畅游，而不用掏空你的口袋。这可不是普通的盒子，它能让你免费享受那些让人垂涎三尺的游戏大餐。这就好比你走进了一家自助餐厅，却发现老板说：“今天免费，随便吃！” 这等好事，你怎能错过呢？</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：游戏盒子 (game box)</strong><br><strong>使用设备：电脑</strong><br><strong>软件大小：130.04MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p><strong>软件已经出了新版本，但是大家不需要进行更新，我觉得这个版本也是没啥问题，并且也是可以正常使用的，大家想更新的也可以选择更新试试看！然后大家也是能看到内置了超多的游戏资源～</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-41-37-709.mp4" type="video/mp4"><br></video></p><h3 id="游戏搜索"><a href="#游戏搜索" class="headerlink" title="游戏搜索"></a>游戏搜索</h3><p><strong>软件支持直接搜索，你可以通过搜索游戏并下载，下方也是有内置各种分类可供选择，可以在不同类别里发掘自己喜欢的游戏</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-43-08-343.mp4" type="video/mp4"><br></video></p><h3 id="安装路径与下载"><a href="#安装路径与下载" class="headerlink" title="安装路径与下载"></a>安装路径与下载</h3><p><strong>软件提供了一系列精彩的游戏资源，包括许多高品质的 3A 级作品。在开始下载之前，需要先登录天翼云网盘 (免费注册的)，再通过设置选项来指定下载和安装的位置，这样可以确保一切顺利进行。只需点击界面右上角的 “设置” 图标，就可以轻松地自定义您的下载和安装路径了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-04-45-737.mp4" type="video/mp4"><br></video></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p><strong>安装的方式也简单，找到自己喜欢的游戏后，点击安装按钮，然后选择游戏的版本号即可一键下载安装该游戏了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-12-23-001.mp4" type="video/mp4"><br></video></p><h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><strong>测试了一下游戏的下载速度，非常不错，开发大佬优化了下载速度，可以让大家快速的下载完成</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-15-17-955.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>通过网盘分享的文件：gamebox.exe</strong><br><strong>链接: <a href="https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg">https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg</a></strong><br><strong>提取码: e5sa</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>对于这些无私地提供免费软件的开发者们，我们应当怀有敬意和感激之情，向他们致敬🫡</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的歌曲</title>
      <link href="/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是我最近这段时间做的曲子，偏励志的歌曲，希望大家能够喜欢</strong></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="以下是歌词"><a href="#以下是歌词" class="headerlink" title="以下是歌词"></a>以下是歌词</h3><p><strong>歌名：Step By step</strong></p><p><strong>In the race of life, we take our place,</strong><br><strong>With hopes aflame, in this timeless chase.</strong><br><strong>Through storms we walk, lessons deep and wise,</strong><br><strong>With each dawn’s light, a new dream arises.</strong></p><p><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we claim the prize,</strong><br><strong>Eyes set forward, on dreams that rise.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step</strong><br><strong>Step by step</strong><br><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we’ll mark our way.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step, beyond the fear,</strong><br><strong>Through shadows cast, our way is clear.is clear</strong><br><strong>Step by step, we’re redefined,</strong><br><strong>Into a strength of heart and mind.</strong></p><p><strong>Lift your gaze, the world awaits,</strong><br><strong>The dawn of dreams, through future gates.</strong><br><strong>Step by step, we’ll mark our way,</strong><br><strong>Leaving echoes in history’s sway.</strong></p><h3 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h3><video controls>  <source src="/img_1/bandicam 2024-11-09 21-43-51-757.mp4" type="video/mp4"></video><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>进化是万物的自然法则 ，不问因由、不辨方向，只因适应便是生存的唯一。【成长】却是内心深处的觉醒，为更坚定的信念，心向未来，带着无悔的初心启程。 在探索中我们成长，不再因未知而迷茫，在风雨中我们成长，所有的挑战都将迎刃而解，跌倒的站起 ，彷徨的找到归途，仰望那片无际的星空，成长的力量化为无形的支柱，筑起我们心中坚不可摧的信念，成为那份无论何时都不曾动摇的守望！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以使用到下架的音乐软件</title>
      <link href="/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在这个快节奏的世界里，音乐无疑是我们心灵的慰藉，它如同一股清泉，滋润着我们的灵魂。今天想与大家分享的，不仅仅是一款音乐软件，而是一段音乐旅程的开始。这是一款简约而不简单的音乐应用。🙂</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：酷狗概念版</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：124.33MB</strong><br><strong>获取方式：文章底部</strong></p><div style="text-align:center">  <img src="/img_1/55CF549DC97727664019811146FF1E35.jpg" alt="主页面" ></div><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p><strong>想象一下，当你在繁忙的日常中寻找一丝宁静，这款软件就像是一位老朋友，静静地等待你的召唤。它的界面相对于其它几个平台的软件较为简洁，操作直观，只需轻轻一点，就能带你进入音乐的海洋。</strong></p><div style="text-align:center">  <img src="/img_1/5D3400BE1891D4531BD075F73B1F69E2.jpg" alt="播放界面" style="width:50%;">  <img src="/img_1/8BC982518DF64AE8D876DA37D4E8F6D1.jpg" alt="播放界面" style="width:50%;"></div><p><strong>与其他音乐平台相比，这款软件的独特之处在于它的“音乐故事”功能。在这里，每一首歌曲都不仅仅是旋律的堆砌，它们背后的故事，如同珍珠般串联起来，让你在聆听的同时，也能感受到音乐的深度与温度。</strong></p><p><strong>官方还更新了开屏画面，各位可以按照下面的方式去根据自己喜欢的风格壁纸设置</strong></p><div style="text-align:center">  <img src="/img_1/83885ACB3D60D33140B471BD706C4A9A.jpg" alt="" >  <img src="/img_1/1100F28525ACE1DC8B3B740DFFEF4C3A.jpg" alt="效果展示" style="width:50%;"></div><p><strong>值得一提的是这个软件的好处在于，每日都可以领取一日的VIP，只需要看五秒的广告，理论上可以一直不收费的听下去，这绝对是白嫖党的福利😀!</strong></p><div style="text-align:center">  <img src="/img_1/0C8331419A6D582631E22F5406EA3CF6.jpg" alt="" style="width:50%;">  <img src="/img_1/C92DEA934D74627728C5CF99FFA655FC.jpg" alt="" style="width:50%;"></div><p><strong>各位音乐爱好者们，如果你渴望在音乐的世界里寻找一份纯粹，那么这款软件定会是你的不二之选。让我们一起，随着音符跳跃，随着旋律起舞，不要错过这场音乐的盛宴。😆</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA">https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA</a></strong> <br><strong>提取码:iay2</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星际之舞：宇宙的诗篇</title>
      <link href="/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/img_1/9E0BE8E969CAC462282B28BDB3DF1AFE.jpg" alt="马头星云"></p><h3 id="星河璀璨"><a href="#星河璀璨" class="headerlink" title="星河璀璨"></a>星河璀璨</h3><p>  <strong>在浩瀚无垠的宇宙中，每一个星系都是一个独特的存在，它们以自己的方式讲述着宇宙的故事。 这张图片捕捉到了一个遥远星系的壮丽景象，它的中心散发出耀眼的光芒，仿佛是宇宙的灯塔，指引着迷失在星际间的旅者</strong></p><div style="text-align:center">  <img src="/img_1/7318400BB81BE3610CB7C214222D802A.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="旋舞银河"><a href="#旋舞银河" class="headerlink" title="旋舞银河"></a>旋舞银河</h3><p><strong>星系的旋臂如同宇宙的舞者，优雅地旋转着，上面点缀着无数的恒星，每一颗都在以自己的生命节奏闪烁。这些恒星的诞生、演化和死亡，构成了宇宙生命的交响曲。而那些暗淡的尘埃和气体，则是新恒星的摇篮，孕育着未来的光明</strong></p><div style="text-align:center">  <img src="/img_1/F872DED84FC80417240DFAA73466AD77.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/C880F01E01FF0D0849D9AFBB44BA7CA6.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="微光感悟"><a href="#微光感悟" class="headerlink" title="微光感悟"></a>微光感悟</h3><p> <strong>在这片星海中，我们不仅看到了宇宙的壮丽，也感受到了自己的渺小。然而，正是这种渺小，让我们对宇宙的探索充满了无限的好奇和渴望。每一次对星空的凝视，都是对未知的一次致敬，也是对人类探索精神的一次肯定。</strong></p><div style="text-align:center">  <img src="/img_1/34E6F253E9EB266011351DBB9C2F2082.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/39DC3EE370E1BC8F31E5739ED3707C34.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="远征"><a href="#远征" class="headerlink" title="远征"></a>远征</h3><p> <strong>每一颗星星都可能是一个新世界的开始。在这个无尽的宇宙之旅中，我们都是勇敢的探险者，追寻着知识的光，照亮前行的路。</strong></p><div style="text-align:center">  <img src="/img_1/CAA771D7E2B3AE60CE7475CD17304335.jpg" alt="拍摄＆后期 By 码头"></div><p><strong>自己拍摄的图，分享给大家，希望每个人都可以在自己的追寻的道路上走的足够远，成为有所建树的人😃</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款好用的音乐软件</title>
      <link href="/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在数字时代的浪潮中，音乐软件如同璀璨的星辰，点缀着我们的生活。今天我要向大家介绍的，是一款与众不同的音乐应用，它以其独特的魅力，悄然走进了我们的世界</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：速悦音乐</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：31.01MB</strong><br><strong>获取方式：文章底部</strong></p><p><strong>这款音乐软件如同一股清新的风，吹散了繁琐的注册登录流程(你可以不需要注册或登录就可以直接使用)，让你无需任何门槛，甚至可以下载音乐，即可直接沉浸在音乐的海洋中。它的首界面，简洁至极，如同一张白纸，等待着你用指尖的魔法，绘制出属于自己的音乐天地</strong></p><div style="text-align:center">  <img src="/img_1/488C7C60ED9CA57D5F062D06E558EBC5.jpg" alt="主页面" >  <img src="/img_1/42F2AA03FF2EF5FB741F2B8A6BADF78D.jpg" alt="播放界面" style="width:50%;" ></div><p><strong>顺带一提，下载音乐只需要分享就可以下载了(你可以不直接分享，点击分享按钮，再退出就好了，不过为了支持原作者，建议还是分享一下吧😁)，具体操作如下图</strong></p><div style="text-align:center">  <img src="/img_1/CA1AA8F8B40A78F3E4CD9932426B3C99.gif" alt="播放界面" ></div><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>不仅如此，这款软件还赋予了你无限的创造力。你可以根据自己的喜好，自定义界面，让每一次打开应用，都成为一场视觉与听觉的双重盛宴。无论是色彩的搭配，还是布局的调整，都能随心所欲，打造出一个完全属于你的音乐空间</strong><br><strong>你也可以设置界面是否为深色模式，以及背景的模糊度和透明度等，具体参照下图，这里就不再演示，可自行探索</strong></p><div style="text-align:center">  <img src="/img_1/7F3CFD25EB3A4E1502F4330A748F859C.jpg" alt="主题切换演示" >  <img src="/img_1/11259F93D8B82874CE5AE29E1C52F5D5.jpg" alt="这是我的主题" style="width:50%;" ></div><p><strong>朋友们，如果你厌倦了复杂的操作，渴望一份简单而纯粹的音乐体验，那么这款软件无疑是你的最佳选择。让我们一起，在这个小小的屏幕上，探索无限的音乐世界，享受那份只属于你的宁静与自由</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg">https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg</a></strong><br><strong>提取码:nt24</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>在我们国内不缺乏一些好用的音乐软甲，但很可惜的是，由于动了别人的蛋糕，难免会遭受排挤，诸如歌词适配，洛雪等老牌软件也未能幸免，想要找到一款好用的软件实属不易，但仍然有许多为爱发电的大佬开发的软件依旧在坚挺，向他们致敬🫡！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><p><strong>在此之前，我们先来聊聊递归的思想</strong><br><strong>递归是计算的基本思想之一，想象一下，你是一个老师，要解释什么是“递归”，你可能会说：“递归就是我给你们举的例子，这个例子就是递归的一个实例。” 这就是递归的本质：用递归自身来解释递归</strong></p><h2 id="递归的工作原理"><a href="#递归的工作原理" class="headerlink" title="递归的工作原理"></a>递归的工作原理</h2><p><strong>递归的工作原理可以想象成俄罗斯套娃，每个娃娃里面都有一个更小的娃娃，直到最小的那个。在编程中，这就像是函数A调用自己A，函数A又调用自己A，如此继续，直到达到最小的娃娃（也就是递归的基本情况），然后开始一层层解开，直到回到最初的那个函数A</strong><br><strong>再换一个例子，想象一下，你正在爬楼梯，每爬一阶，你就离顶层更近一步。递归也是这样，每次函数调用自己时，都会更接近基本情况（base case），也就是递归结束的条件</strong></p><h2 id="递归的两个关键部分"><a href="#递归的两个关键部分" class="headerlink" title="递归的两个关键部分"></a>递归的两个关键部分</h2><p><strong>1.基本情况（Base Case）：这是递归停止的条件，就像最小的俄罗斯套娃，没有更小的娃娃了。或则说，类似于你爬到顶层，就不再爬了在编程中，这通常是最简单的问题，可以直接解决，不需要进一步递归</strong><br><strong>递推关系（Recursive Case）：这是函数如何调用自己的部分，每次调用都应该让问题更接近基本情况</strong></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><h3 id="1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120"><a href="#1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120" class="headerlink" title="1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120"></a>1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120</h3><p>以下是C语言的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为0或1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回n乘以(n-1)的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u 的阶乘是 %llu\n&quot;</span>, num, factorial(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><p><strong>斐波那契数列是这样的数列：0, 1, 1, 2, 3, 5, 8, 13, …，其中每个数是前两个数的和。</strong></p><p>以下是C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 基本情况：如果n为0，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为1，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回前两个斐波那契数的和</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, num, fibonacci(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>递归在编程中是一种强大的编程技术，它通过函数自我调用来解决问题。在使用递归时，确保有明确的基本情况和递推关系，这样可以避免无限递归和栈溢出的问题。希望这些例子能帮助你理解递归的概念和应用</strong></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><strong>通过上面的例子你应该大致理解了递归的思想了，那么接下来我们回到本次要讲的正题————二叉树的遍历。相信学数据结构的同学对它一定不陌生！二叉树的遍历是按照某种规则，依次访问二叉树中的每个节点，每个节点只访问一次。主要有三种遍历方式：先序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）</strong></p><h2 id="先序遍历（Preorder-Traversal）"><a href="#先序遍历（Preorder-Traversal）" class="headerlink" title="先序遍历（Preorder Traversal）"></a>先序遍历（Preorder Traversal）</h2><p><strong>定义：先访问根节点，然后遍历左子树，最后遍历右子树</strong>。<br><strong>递归算法：访问根节点，然后对左子树和右子树递归执行先序遍历。</strong><br><strong>非递归算法：使用栈来模拟递归过程。首先将根节点入栈，然后循环执行以下步骤：弹出栈顶节点，访问它，然后将它的右子节点和左子节点依次入栈（注意顺序，先右后左）</strong></p><p><strong>假设我们有如下的二叉树：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于先序遍历，简单来说就是指按照“根节点 -&gt; 左子树 -&gt; 右子树”的顺序访问二叉树的每个节点,以下是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它打印根节点的值，然后递归地遍历左子树和右子树</strong><br><strong>遍历下来的结果就是：1, 2, 4, 5, 3</strong></p><p><strong>接下来是非递归的遍历算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode* node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.push(node-&gt;right); <span class="comment">// 先右后左，保持顺序</span></span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将根节点压入栈中，然后循环直到栈为空。在每次循环中，它弹出栈顶节点，访问它，然后将右子节点和左子节点依次压入栈中，所以遍历下来的结果就是：非递归遍历结果：1, 2, 4, 5, 3</strong></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>定义：先遍历左子树，然后访问根节点，最后遍历右子树</strong><br><strong>递归算法：对左子树递归执行中序遍历，访问根节点，然后对右子树递归执行中序遍历</strong><br><strong>非递归算法：使用栈来模拟递归过程。从根节点开始，将节点依次入栈直到到达最左节点，然后访问它并转向右子节点，重复此过程</strong></p><p><strong>还是上述的二叉树为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对与中序遍历便是指按照“左子树 -&gt; 根节点 -&gt; 右子树”的顺序访问二叉树的每个节点，以下是递归算法得的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    inOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树，打印根节点的值，然后递归地遍历右子树,所以遍历的结果便是：4, 2, 5, 1, 3</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它弹出栈顶节点，访问它，并转向其右子节点,所以遍历出来的结果便是：4, 2, 5, 1, 3</strong></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>定义：先遍历左子树，然后遍历右子树，最后访问根节点</strong><br><strong>递归算法：对左子树和右子树递归执行后序遍历，然后访问根节点</strong><br><strong>非递归算法：使用两个栈来模拟递归过程。第一个栈用于遍历，第二个栈用于反转遍历顺序。将根节点入第一个栈，然后循环执行以下步骤：从第一个栈中弹出节点并将其入第二个栈，然后将其子节点依次入第一个栈（注意顺序，先右后左）。当第一个栈为空时，从第二个栈中弹出节点并访问它们</strong></p><p><strong>二叉树例子同上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历便是指按照“左子树 -&gt; 右子树 -&gt; 根节点”的顺序访问二叉树的每个节点，接下来是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    postOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树和右子树，然后打印根节点的值，所以遍历出来的结果是：4, 5, 2, 6, 7, 3, 1</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right == <span class="literal">NULL</span> || current-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            prev = current;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它检查栈顶节点的右子节点是否为空或者是否已经访问过。如果是，它弹出栈顶节点，访问它，并更新prev节点。否则，它转向栈顶节点的右子节点,所以运行出来的结果便是：4, 5, 2, 6, 7, 3, 1</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>递归方法：直观，易于实现，但可能遇到栈溢出的问题</strong><br><strong>非递归方法：使用栈或队列来模拟递归过程，可以避免栈溢出的问题，但实现相对复杂</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，学习编程可能会在一开始感到有些挑战，但请记住，每个编程高手都是从基础开始，一步一个脚印走过来的。递归是编程中一个非常强大的工具，一旦你掌握了它，很多复杂的问题都会变得简单起来。记住，每个人的学习速度都是不同的，不要和别人比较，而是和昨天的自己比较。只要你们保持耐心和热情，不断练习，很快就能掌握递归的。加油，你们可以做到的！😉</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF算法与KMP算法</title>
      <link href="/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊数据结构中两种在字符串中寻找子串的方法：暴力匹配（BF算法）和KMP算法。<strong>这两种方法都像是在玩一个“找茬”游戏</strong>，目的是在一个大字符串（我们称之为主串）中找到一个小字符串（我们称之为模式串）出现的位置。</p><p>我们先举一个例子：<br><strong>假设主串为 “ababcabcacbab”，模式串为 “abcac”</strong></p><h2 id="暴力匹配（BF算法）"><a href="#暴力匹配（BF算法）" class="headerlink" title="暴力匹配（BF算法）"></a>暴力匹配（BF算法）</h2><p><strong>BF算法，也称为暴力匹配算法，是一种简单的字符串匹配方法。它的基本思想是从主串的每一个字符开始，逐个与模式串的字符进行比较，直到找到匹配的字符或比较完整个模式串。如果模式串中有某个字符不匹配，BF算法会回溯到主串的下一个字符重新开始匹配。想象一下，你手上有一张小图片（模式串），你想在一个巨大的画布（主串）上找到这张图片。使用暴力匹配的方法，你会从画布的最左边开始，试着把小图片的每个角对准画布上的每个点，看看是否能完全匹配。如果不匹配，你就向右移动一点，再试一次。这个过程会一直重复，直到你找到匹配的地方，或者把整个画布都试一遍。</strong></p><p><strong>原理</strong><br><strong>1.从主串的第一个字符开始，与模式串的第一个字符进行比较。</strong><br><strong>2.如果相等，则继续比较主串和模式串的下一个字符。</strong><br><strong>3.如果不相等，则主串指针回溯到上次匹配的首位的下一位，模式串指针回到开头，重新开始匹配。</strong><br><strong>4.重复上述过程，直到找到匹配的子串或主串遍历完毕。</strong></p><p>以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; S[i + j] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = BF(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h2><p><strong>KMP算法是一种改进的字符串匹配算法。它通过预处理模式串，构建部分匹配表（next数组），在匹配过程中利用已经匹配的信息，避免重复比较，从而提高匹配效率。KMP算法更聪明一些。它在开始全面搜索之前，会先研究一下小图片（模式串），找出一些特征，这样在大画布（主串）上搜索时，就能跳过一些明显不需要检查的地方。这就像是你记住了小图片的一些特征，然后在大画布上快速地找到可能匹配的地方。</strong></p><p><strong>KMP算法的核心是预处理模式串，创建一个“部分匹配表”，这个表告诉我们，当某个位置不匹配时，我们应该跳到模式串的哪个位置继续比较.</strong></p><p><strong>原理</strong><br><strong>1.预处理模式串，构建next数组。next数组记录了模式串中每个位置的最长相等前后缀的长度。</strong><br><strong>2.在匹配过程中，当遇到不匹配时，利用next数组跳过已经匹配的部分，避免回溯。</strong></p><p>还是刚才的例子，以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    computeNext(T, next);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = KMP(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p><strong>BF算法：简单易懂，但效率较低，时间复杂度为 O(n⋅m)</strong><br><strong>KMP算法：通过预处理模式串，利用next数组避免重复比较，提高匹配效率，时间复杂度为O(n+m)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
