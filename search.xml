<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++变量类型</title>
      <link href="/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-变量类型"><a href="#C-变量类型" class="headerlink" title="C++变量类型"></a>C++变量类型</h1><p>在程序中，<strong>变量</strong>就是存储数据的容器。它们是程序可以操作的存储位置，每个变量都有一个名字和特定的数据类型。</p><hr><h3 id="变量类型的作用"><a href="#变量类型的作用" class="headerlink" title="变量类型的作用"></a>变量类型的作用</h3><ul><li><strong>变量类型</strong>定义了：<ol><li><strong>占用的内存大小和布局</strong>：不同类型的数据需要不同大小的内存空间。</li><li><strong>可以存储的值范围</strong>：例如，整数型不能存储小数，布尔型只能存储 <code>true</code> 或 <code>false</code>。</li><li><strong>适用的运算</strong>：变量类型决定了哪些运算符可以对它们进行操作。</li></ol></li></ul><hr><h3 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h3><ol><li><strong>可以使用的字符</strong>：变量名可以由<strong>字母</strong>、<strong>数字</strong>和<strong>下划线（_）</strong>组成。</li><li><strong>开头限制</strong>：变量名必须以<strong>字母</strong>或<strong>下划线</strong>开头，不能以数字开头。</li><li><strong>区分大小写</strong>：C++ 是<strong>区分大小写</strong>的语言，所以 <code>Var</code> 和 <code>var</code> 是两个不同的变量名。</li><li><strong>建议使用有意义的名称</strong>：例如，用 <code>age</code> 表示年龄，比用 <code>a</code> 更直观。</li></ol><hr><h3 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h3><p>C++ 中有多种变量类型，每种类型适用于不同种类的数据，例如：</p><ul><li><strong>整数型</strong>存储整数。</li><li><strong>浮点型</strong>存储小数。</li><li><strong>字符型</strong>存储单个字符。</li><li><strong>布尔型</strong>存储逻辑值（<code>true</code> 或 <code>false</code>）。</li></ul><p>在后续章节中，我们将具体介绍这些变量类型的使用和特点！</p><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>Data Types Description</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>Data Types Description</h2><table>    <tr>        <th>类型</th>        <th>描述</th>    </tr>    <tr>        <td>bool</td>        <td>布尔类型，存储值 true 或 false，占用 1 个字节。</td>    </tr>    <tr>        <td>char</td>        <td>字符类型，用于存储 ASCII 字符，通常占用 1 个字节。</td>    </tr>    <tr>        <td>int</td>        <td>整数类型，通常用于存储普通整数，通常占用 4 个字节。</td>    </tr>    <tr>        <td>float</td>        <td>单精度浮点值，用于存储单精度浮点数。单精度是这样的格式，1 位符号，8 位指数，23 位小数，通常占用4个字节。</td>    </tr>    <tr>        <td>double</td>        <td>双精度浮点值，用于存储双精度浮点数。双精度是 1 位符号，11 位指数，52 位小数，通常占用 8 个字节。</td>    </tr>    <tr>        <td>void</td>        <td>表示类型的缺失。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>宽字符类型，用于存储更大范围的字符，通常占用 2 个或 4 个字节。</td>    </tr></table></body></html><h2 id="C-中的变量类型"><a href="#C-中的变量类型" class="headerlink" title="C++中的变量类型"></a>C++中的变量类型</h2><p>在 C++ 中，你可以定义各种类型的变量来存储不同种类的数据，以下是常见的几种类型：</p><h3 id="整数类型-Integer-Types"><a href="#整数类型-Integer-Types" class="headerlink" title="整数类型 (Integer Types)"></a>整数类型 (Integer Types)</h3><ul><li><strong>int</strong>：存储整数，通常占用 4 个字节。</li><li><strong>short</strong>：存储较小的整数，通常占用 2 个字节。</li><li><strong>long</strong>：存储较大的整数，通常占用 4 个字节。</li><li><strong>long long</strong>：存储更大的整数，通常占用 8 个字节。</li></ul><h3 id="浮点类型-Floating-Point-Types"><a href="#浮点类型-Floating-Point-Types" class="headerlink" title="浮点类型 (Floating-Point Types)"></a>浮点类型 (Floating-Point Types)</h3><ul><li><strong>float</strong>：存储单精度浮点数（带小数的数），通常占用 4 个字节。</li><li><strong>double</strong>：存储双精度浮点数，精度比 <code>float</code> 高，通常占用 8 个字节。</li><li><strong>long double</strong>：存储更高精度的浮点数，字节数依编译器和系统而不同。</li></ul><h3 id="字符类型-Character-Types"><a href="#字符类型-Character-Types" class="headerlink" title="字符类型 (Character Types)"></a>字符类型 (Character Types)</h3><ul><li><strong>char</strong>：存储一个字符，通常占用 1 个字节。</li><li><strong>wchar_t</strong>：存储宽字符（用于表示更复杂的字符），占用 2 或 4 个字节。</li><li><strong>char16_t</strong>：存储 16 位 Unicode 字符，占用 2 个字节。</li><li><strong>char32_t</strong>：存储 32 位 Unicode 字符，占用 4 个字节。</li></ul><h3 id="布尔类型-Boolean-Type"><a href="#布尔类型-Boolean-Type" class="headerlink" title="布尔类型 (Boolean Type)"></a>布尔类型 (Boolean Type)</h3><ul><li><strong>bool</strong>：存储布尔值，只能是 <code>true</code> 或 <code>false</code>。</li></ul><h3 id="枚举类型-Enumeration-Types"><a href="#枚举类型-Enumeration-Types" class="headerlink" title="枚举类型 (Enumeration Types)"></a>枚举类型 (Enumeration Types)</h3><ul><li><strong>enum</strong>：定义一组命名的整数常量，通常用来表示具有多个固定值的变量。</li></ul><h3 id="指针类型-Pointer-Types"><a href="#指针类型-Pointer-Types" class="headerlink" title="指针类型 (Pointer Types)"></a>指针类型 (Pointer Types)</h3><ul><li><strong>type</strong>*：存储指向某个类型变量的地址。</li></ul><h3 id="数组类型-Array-Types"><a href="#数组类型-Array-Types" class="headerlink" title="数组类型 (Array Types)"></a>数组类型 (Array Types)</h3><ul><li>**type[] 或 type[size]**：存储多个相同类型的元素。</li></ul><h3 id="结构体类型-Structure-Types"><a href="#结构体类型-Structure-Types" class="headerlink" title="结构体类型 (Structure Types)"></a>结构体类型 (Structure Types)</h3><ul><li><strong>struct</strong>：存储多个不同类型的数据（可以是整数、字符等的组合）。</li></ul><h3 id="类类型-Class-Types"><a href="#类类型-Class-Types" class="headerlink" title="类类型 (Class Types)"></a>类类型 (Class Types)</h3><ul><li><strong>class</strong>：存储具有属性和方法的自定义数据类型。</li></ul><h3 id="共用体类型-Union-Types"><a href="#共用体类型-Union-Types" class="headerlink" title="共用体类型 (Union Types)"></a>共用体类型 (Union Types)</h3><ul><li><strong>union</strong>：存储多种类型的数据，但它们共享同一块内存空间，这意味着同一时刻只能存储其中一种类型。</li></ul><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>C++ 标准规定了这些类型的最小大小，但实际占用的字节数可能会因为编译器或计算机架构的不同而有所差异。例如，<code>int</code> 在许多现代计算机上占用 4 字节，<code>long</code> 有时占用 8 字节。</li><li>了解这些变量类型及其占用内存的特点有助于更好地管理程序中的数据和内存。</li></ul><h2 id="C-中的变量定义"><a href="#C-中的变量定义" class="headerlink" title="C++中的变量定义"></a>C++中的变量定义</h2><p>在 C++ 中，<strong>变量定义</strong>是指告诉编译器在内存中为变量分配空间，并指定变量的数据类型。</p><h3 id="变量定义的基本形式："><a href="#变量定义的基本形式：" class="headerlink" title="变量定义的基本形式："></a>变量定义的基本形式：</h3><p>定义一个变量时，需要指定它的数据类型和变量的名称，格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_list;</span><br></pre></td></tr></table></figure><p>这里，<code>type</code> 是你要定义的变量的数据类型，例如 <code>int</code>（整数）、<code>char</code>（字符）等，<code>variable_list</code> 是你要定义的变量名，多个变量名用逗号分隔。</p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i, j, k;   <span class="comment">// 定义了三个整数变量 i, j, k</span></span><br><span class="line"><span class="type">char</span> c, ch;     <span class="comment">// 定义了两个字符变量 c 和 ch</span></span><br><span class="line"><span class="type">float</span> f, salary; <span class="comment">// 定义了两个浮点数变量 f 和 salary</span></span><br><span class="line"><span class="type">double</span> d;       <span class="comment">// 定义了一个双精度浮点数变量 d</span></span><br></pre></td></tr></table></figure><p>这行代码表示在内存中为 <code>i</code>、<code>j</code>、<code>k</code>、<code>c</code>、<code>ch</code>、<code>f</code>、<code>salary</code> 和 <code>d</code> 这些变量分配空间，并且每个变量的类型已经被明确指定。</p><h3 id="变量初始化："><a href="#变量初始化：" class="headerlink" title="变量初始化："></a>变量初始化：</h3><p>你可以在定义变量时，给它们一个初始值，这叫做<strong>初始化</strong>。格式如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type variable_name = value;</span><br></pre></td></tr></table></figure><h3 id="示例：-1"><a href="#示例：-1" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d = <span class="number">3</span>, f = <span class="number">5</span>;    <span class="comment">// 定义并初始化了两个整数变量 d 和 f</span></span><br><span class="line">byte z = <span class="number">22</span>;         <span class="comment">// 定义并初始化了一个名为 z 的变量</span></span><br><span class="line"><span class="type">char</span> x = <span class="string">&#x27;x&#x27;</span>;        <span class="comment">// 定义了一个字符变量 x，其值为 &#x27;x&#x27;</span></span><br></pre></td></tr></table></figure><p>这里，<code>d</code> 被初始化为 3，<code>f</code> 被初始化为 5，<code>z</code> 被初始化为 22，而 <code>x</code> 被初始化为字符 <code>&#39;x&#39;</code>。</p><h3 id="未初始化的变量："><a href="#未初始化的变量：" class="headerlink" title="未初始化的变量："></a>未初始化的变量：</h3><p>如果你定义变量时没有给它们初始值，那么对于<strong>静态存储持续时间的变量</strong>，它们会被自动初始化为 0（空值）；而对于<strong>局部变量</strong>，它们没有初始值，可能包含不确定的值，这样的变量会被称为“未定义值”。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><ul><li>变量定义时，你要指定数据类型和变量名。</li><li>可以在定义时给变量初始化一个值。</li><li>如果没有初始化，静态变量会被自动初始化为 0，而其他变量没有初始值。</li></ul><h2 id="C-中的变量声明"><a href="#C-中的变量声明" class="headerlink" title="C++中的变量声明"></a>C++中的变量声明</h2><p>在 C++ 中，<strong>变量声明</strong>告诉编译器你将在某个地方使用某个变量，但不需要在此时提供变量的具体内容。简单来说，声明只是告诉编译器“这个变量存在”。而<strong>变量定义</strong>则是真正分配内存空间并给变量赋值的过程。</p><h3 id="变量声明："><a href="#变量声明：" class="headerlink" title="变量声明："></a>变量声明：</h3><p>声明一个变量时，使用<code>extern</code>关键字告诉编译器该变量在其他地方定义，不需要在当前代码中重复定义。声明的目的是为了让编译器知道该变量的类型和名称，以便在编译时不会出错。</p><h3 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> type variable_name;</span><br></pre></td></tr></table></figure><h3 id="示例：-2"><a href="#示例：-2" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 变量声明</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> a, b;   <span class="comment">// 声明了 a 和 b，表示它们将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> c;      <span class="comment">// 声明了 c，表示它将在其他地方定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">float</span> f;    <span class="comment">// 声明了 f，表示它将在其他地方定义</span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 变量定义和初始化</span></span><br><span class="line">  <span class="type">int</span> a, b;         <span class="comment">// 定义变量 a 和 b</span></span><br><span class="line">  <span class="type">int</span> c;            <span class="comment">// 定义变量 c</span></span><br><span class="line">  <span class="type">float</span> f;          <span class="comment">// 定义变量 f</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 初始化变量</span></span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  b = <span class="number">20</span>;</span><br><span class="line">  c = a + b;</span><br><span class="line">  </span><br><span class="line">  cout &lt;&lt; c &lt;&lt; endl;   <span class="comment">// 输出 c 的值</span></span><br><span class="line"></span><br><span class="line">  f = <span class="number">70.0</span> / <span class="number">3.0</span>;</span><br><span class="line">  cout &lt;&lt; f &lt;&lt; endl;   <span class="comment">// 输出 f 的值</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li>我们在代码的开头声明了<code>a</code>、<code>b</code>、<code>c</code>和<code>f</code>这几个变量，告诉编译器它们将在其他地方定义。</li><li>然后，在<code>main</code>函数中，我们实际上定义了这些变量并初始化了它们。</li></ul><h3 id="重要注意点："><a href="#重要注意点：" class="headerlink" title="重要注意点："></a>重要注意点：</h3><ol><li><strong>声明</strong>：只是告诉编译器变量存在，不会分配内存。例如，<code>extern int a;</code> 声明了变量<code>a</code>，但它没有给<code>a</code>分配内存。</li><li><strong>定义</strong>：才会为变量分配内存，并且可以给它一个初始值。例如，<code>int a = 10;</code> 会定义变量<code>a</code>，并给它分配内存和初始值。</li><li><strong>多个声明，单次定义</strong>：你可以在多个地方声明同一个变量，但只应该在一个地方定义它。定义时会分配内存并赋值。</li></ol><h3 id="类似函数声明："><a href="#类似函数声明：" class="headerlink" title="类似函数声明："></a>类似函数声明：</h3><p>就像变量声明一样，函数也可以先声明再定义。你可以在程序的其他地方声明一个函数，而函数的定义可以放在程序的任何位置。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 函数调用</span></span><br><span class="line">  <span class="type">int</span> i = <span class="built_in">func</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数定义</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，函数<code>func</code>先声明，在<code>main</code>函数中调用它，实际的定义可以放在程序的任何地方。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><ul><li><strong>变量声明</strong>只是告诉编译器变量存在，并不分配内存。</li><li><strong>变量定义</strong>才会分配内存，并可以赋初值。</li><li><strong>函数声明</strong>告诉编译器函数存在，函数的实际实现可以在其他地方。</li></ul><h2 id="C-中的左值（Lvalues）和右值（Rvalues）"><a href="#C-中的左值（Lvalues）和右值（Rvalues）" class="headerlink" title="C++ 中的左值（Lvalues）和右值（Rvalues）"></a>C++ 中的左值（Lvalues）和右值（Rvalues）</h2><p>在 C++ 中，<strong>左值</strong>（Lvalue）和 <strong>右值</strong>（Rvalue）是两种不同类型的表达式，它们的区别在于是否可以被赋值，以及它们代表的内存位置。</p><h3 id="左值（Lvalue）："><a href="#左值（Lvalue）：" class="headerlink" title="左值（Lvalue）："></a>左值（Lvalue）：</h3><ul><li><strong>定义</strong>：左值表示一个可以出现在赋值符号（&#x3D;）左边的表达式，通常是一个可以定位到内存地址的对象。</li><li><strong>特点</strong>：左值表示一个存储位置，可以对其进行赋值，因为它表示内存中的一个具体位置。</li><li><strong>例子</strong>：变量、数组元素、解引用的指针等都是左值。例如，<code>g = 20;</code> 中的 <code>g</code> 是左值，因为它可以接受赋值。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> g = <span class="number">20</span>;  <span class="comment">// g 是左值</span></span><br><span class="line">g = <span class="number">30</span>;       <span class="comment">// 可以对左值进行赋值</span></span><br></pre></td></tr></table></figure><h3 id="右值（Rvalue）："><a href="#右值（Rvalue）：" class="headerlink" title="右值（Rvalue）："></a>右值（Rvalue）：</h3><ul><li><strong>定义</strong>：右值通常是一个没有明确内存地址的表达式。它表示一个临时的值或常量，通常只出现在赋值符号的右边。</li><li><strong>特点</strong>：右值不能出现在赋值符号的左边，因为它没有可以存储的内存位置，不能被赋值。</li><li><strong>例子</strong>：常量、字面值、表达式的计算结果（如 <code>10 + 5</code>）等都是右值。例如，<code>10 = 20;</code> 是非法的，因为 <code>10</code> 是右值，不能作为赋值的左边。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能出现在赋值符号的左边</span></span><br></pre></td></tr></table></figure><h3 id="简单总结："><a href="#简单总结：" class="headerlink" title="简单总结："></a>简单总结：</h3><ul><li><strong>左值</strong>：可以出现在赋值符号的左边，表示一个可以被修改的内存位置（如变量）。</li><li><strong>右值</strong>：只能出现在赋值符号的右边，表示一个临时的、无法修改的值（如常量或表达式的结果）。</li></ul><p><strong>正确的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// a 是左值，10 是右值</span></span><br><span class="line">a = <span class="number">20</span>;       <span class="comment">// 可以对 a（左值）赋值</span></span><br></pre></td></tr></table></figure><p><strong>错误的示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> = <span class="number">20</span>;  <span class="comment">// 错误，10 是右值，不能作为赋值的左边</span></span><br></pre></td></tr></table></figure><p>通过这种方式，你可以理解左值是可以被赋值和修改的存储位置，而右值则是一次性的值，不能直接进行赋值。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++的关键字（保留字）完整介绍</title>
      <link href="/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/"/>
      <url>/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        body {            text-align: left; /* 使整个页面内容居中 */        }        table {            margin: 0 auto; /* 使表格在页面中居中 */            border-collapse: collapse;            font-weight: bold; /* 字体加粗 */        }        th, td {            border: 1px solid #ddd;            padding: 8px;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>保留字(关键字)</h2><p>C++系统中预定义的、在语言或编译系统的实现中具有特殊含义的单词:</p><table>    <tr>        <td>if</td>        <td>else</td>        <td>while</td>        <td>signed</td>        <td>throw</td>        <td>union</td>        <td>this</td>    </tr>    <tr>        <td>int</td>        <td>char</td>        <td>double</td>        <td>unsigned</td>        <td>const</td>        <td>goto</td>        <td>virtual</td>    </tr>    <tr>        <td>for</td>        <td>float</td>        <td>break</td>        <td>auto</td>        <td>class</td>        <td>operator</td>        <td>case</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>typedef</td>        <td>static</td>        <td>friend</td>        <td>template</td>        <td>default</td>    </tr>    <tr>        <td>new</td>        <td>void</td>        <td>register</td>        <td>extern</td>        <td>return</td>        <td>enum</td>        <td>inline</td>    </tr>    <tr>        <td>try</td>        <td>short</td>        <td>continue</td>        <td>sizeof</td>        <td>switch</td>        <td>private</td>        <td>protected</td>    </tr>    <tr>        <td>asm</td>        <td>while</td>        <td>catch</td>        <td>delete</td>        <td>public</td>        <td>volatile</td>        <td>struct</td>    </tr></table></body></html><p><strong>以下是对上述C++关键字的解释：</strong></p><hr><h3 id="1-asm（汇编指令）"><a href="#1-asm（汇编指令）" class="headerlink" title="1. asm（汇编指令）"></a>1. <strong>asm（汇编指令）</strong></h3><ul><li><code>asm</code>允许在C++程序中直接嵌入汇编代码。  </li><li>用法场景：需要执行底层硬件相关的指令时，可以使用它。</li></ul><hr><h3 id="2-auto（自动存储类型）"><a href="#2-auto（自动存储类型）" class="headerlink" title="2. auto（自动存储类型）"></a>2. <strong>auto（自动存储类型）</strong></h3><ul><li><code>auto</code>用来声明变量的存储类型是“自动的”，这意味着变量的生命周期受限于它所在的代码块（比如函数、循环等）。  </li><li>通常可以省略，因为这是默认行为。</li></ul><hr><h3 id="3-bool（布尔类型）"><a href="#3-bool（布尔类型）" class="headerlink" title="3. bool（布尔类型）"></a>3. <strong>bool（布尔类型）</strong></h3><ul><li><code>bool</code>表示“真或假”的值。  </li><li>有两个有效值：<code>true</code>（真）和<code>false</code>（假）。  </li><li>示例：<code>bool isActive = true;</code>  </li><li>在条件判断中很常用，比如<code>if</code>语句。</li></ul><hr><h3 id="4-break（跳出语句）"><a href="#4-break（跳出语句）" class="headerlink" title="4. break（跳出语句）"></a>4. <strong>break（跳出语句）</strong></h3><ul><li><code>break</code>用于终止循环或退出<code>switch</code>语句。  </li><li>当程序遇到<code>break</code>时，会直接跳到代码块的外面继续执行。  </li><li>示例：在<code>for</code>循环中提前停止迭代。</li></ul><hr><h3 id="5-case（条件分支）"><a href="#5-case（条件分支）" class="headerlink" title="5. case（条件分支）"></a>5. <strong>case（条件分支）</strong></h3><ul><li><code>case</code>用在<code>switch</code>语句中，表示不同的条件。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 1，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="comment">// 如果 x 是 2，执行这里的代码</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="6-catch（异常捕获）"><a href="#6-catch（异常捕获）" class="headerlink" title="6. catch（异常捕获）"></a>6. <strong>catch（异常捕获）</strong></h3><ul><li><code>catch</code>和<code>try</code>配合使用，用于处理程序运行时的异常。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 可能抛出异常的代码</span></span><br><span class="line">&#125; <span class="built_in">catch</span> (std::exception&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 捕获异常并处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="7-char（字符类型）"><a href="#7-char（字符类型）" class="headerlink" title="7. char（字符类型）"></a>7. <strong>char（字符类型）</strong></h3><ul><li><code>char</code>表示一个字符，比如字母或符号。  </li><li>数据范围是0到255，对应ASCII码表的值。  </li><li>示例：<code>char letter = &#39;A&#39;;</code></li></ul><hr><h3 id="8-class（类）"><a href="#8-class（类）" class="headerlink" title="8. class（类）"></a>8. <strong>class（类）</strong></h3><ul><li><code>class</code>是C++面向对象编程的核心，用来定义对象的模板或蓝图。  </li><li>类中可以包含属性和方法，用于模拟现实世界中的事物。  </li><li>示例：  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Car</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        string brand;</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">drive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 驾驶行为</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="9-const（常量）"><a href="#9-const（常量）" class="headerlink" title="9. const（常量）"></a>9. <strong><code>const</code>（常量）</strong></h3><ul><li><p><code>const</code>表示“不可更改”。  </p></li><li><p>用<code>const</code>修饰的变量或对象，其值在程序运行中不能被改变。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="number">3.14159</span>; <span class="comment">// pi 是一个常量，不能修改</span></span><br></pre></td></tr></table></figure></li><li><p><strong>修饰函数</strong>：<br>如果<code>const</code>修饰一个函数，则该函数不能修改外部变量，也不能调用非<code>const</code>函数。<br>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> value; &#125; <span class="comment">// getValue不能修改任何变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>优点</strong>：<br>相较于<code>#define</code>，<code>const</code>不仅可以定义常量，还具有类型检查功能，使用更安全。</p></li></ul><hr><h3 id="10-const-cast（类型转换运算符）"><a href="#10-const-cast（类型转换运算符）" class="headerlink" title="10. const_cast（类型转换运算符）"></a>10. <strong><code>const_cast</code>（类型转换运算符）</strong></h3><ul><li><p><code>const_cast</code>用来去除<code>const</code>属性，允许对原本不可修改的对象进行更改。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">int</span>* px = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;x); <span class="comment">// 去掉 x 的 const 性质</span></span><br><span class="line">*px = <span class="number">100</span>;                     <span class="comment">// 修改 x 的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：使用<code>const_cast</code>需要小心，错误的使用可能导致程序未定义行为。</p></li></ul><hr><h3 id="11-continue（跳过当前循环）"><a href="#11-continue（跳过当前循环）" class="headerlink" title="11. continue（跳过当前循环）"></a>11. <strong><code>continue</code>（跳过当前循环）</strong></h3><ul><li><p><code>continue</code>用在循环中，跳过本次循环剩下的代码，直接开始下一次循环。  </p></li><li><p><strong>与<code>break</code>的区别</strong>：  </p><ul><li><code>break</code>会结束整个循环。</li><li><code>continue</code>只跳过当前循环的后续部分，继续执行下一次循环。</li></ul></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">2</span>) <span class="keyword">continue</span>; <span class="comment">// 跳过 i == 2 的情况</span></span><br><span class="line">    std::cout &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：0 1 3 4</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="12-default（默认分支）"><a href="#12-default（默认分支）" class="headerlink" title="12. default（默认分支）"></a>12. <strong><code>default</code>（默认分支）</strong></h3><ul><li><p><code>default</code>是<code>switch</code>语句中的默认分支。  </p></li><li><p>当所有的<code>case</code>条件都不满足时，执行<code>default</code>部分的代码。  </p></li><li><p>示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">switch</span> (x) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 5&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is 8&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;x is something else&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出：x is something else</span></span><br></pre></td></tr></table></figure></li><li><p><strong>注意</strong>：<code>default</code>是可选的，可以没有。</p></li></ul><hr><h3 id="13-delete（释放内存）"><a href="#13-delete（释放内存）" class="headerlink" title="13. delete（释放内存）"></a>13. <strong><code>delete</code>（释放内存）</strong></h3><ul><li><code>delete</code>用于释放通过<code>new</code>关键字动态分配的内存空间。</li><li>释放的对象可以是单个变量或数组，但必须与分配时的形式匹配。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptr = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">5</span>);  <span class="comment">// 动态分配一个整数</span></span><br><span class="line"><span class="keyword">delete</span> ptr;             <span class="comment">// 释放内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span>* arr = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]; <span class="comment">// 动态分配一个数组</span></span><br><span class="line"><span class="keyword">delete</span>[] arr;           <span class="comment">// 释放数组</span></span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：释放内存后不能再次使用，否则会导致“悬空指针”。</li></ul><hr><h3 id="14-do（循环结构）"><a href="#14-do（循环结构）" class="headerlink" title="14. do（循环结构）"></a>14. <strong><code>do</code>（循环结构）</strong></h3><ul><li><code>do</code>是<code>do-while</code>循环的一部分，与<code>while</code>循环类似，但它<strong>至少执行一次循环体</strong>，因为条件是在循环体执行之后才检查的。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;i is &quot;</span> &lt;&lt; i &lt;&lt; std::endl;</span><br><span class="line">    i++;</span><br><span class="line">&#125; <span class="keyword">while</span> (i &lt; <span class="number">3</span>);</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i is 0</span><br><span class="line">i is 1</span><br><span class="line">i is 2</span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="15-double（双精度浮点数）"><a href="#15-double（双精度浮点数）" class="headerlink" title="15. double（双精度浮点数）"></a>15. <strong><code>double</code>（双精度浮点数）</strong></h3><ul><li><code>double</code>是C++中表示浮点数的一种数据类型，用于存储带小数点的数值，精度比<code>float</code>更高。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> pi = <span class="number">3.14159</span>;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Pi is &quot;</span> &lt;&lt; pi &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure></li><li>通常用于需要更高精度的数学计算。</li></ul><hr><h3 id="16-dynamic-cast（动态类型转换）"><a href="#16-dynamic-cast（动态类型转换）" class="headerlink" title="16. dynamic_cast（动态类型转换）"></a>16. <strong><code>dynamic_cast</code>（动态类型转换）</strong></h3><ul><li><code>dynamic_cast</code>用于在运行时将基类指针或引用转换为派生类指针或引用，确保类型安全。</li><li>适用于有<strong>继承关系</strong>的类之间的转换。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 必须有虚函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* basePtr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derivedPtr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(basePtr);</span><br><span class="line"><span class="keyword">if</span> (derivedPtr) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion successful!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Conversion failed!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong>：<ul><li>如果转换失败，返回<code>nullptr</code>（对于指针）或抛出异常（对于引用）。</li></ul></li></ul><hr><h3 id="17-else（条件分支）"><a href="#17-else（条件分支）" class="headerlink" title="17. else（条件分支）"></a>17. <strong><code>else</code>（条件分支）</strong></h3><ul><li><code>else</code>和<code>if</code>配合使用，用于处理<code>if</code>条件为<code>false</code>时的操作。</li><li>示例：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;x is non-positive&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>输出</strong>：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x is positive</span><br></pre></td></tr></table></figure></li></ul><hr><ol start="18"><li><strong>enum（枚举）</strong><br><code>enum</code>（枚举）类型用于定义一组固定的值，值的选择只能在这些预定义的选项中进行。例如，你可以使用枚举类型来表示一周的七天，每天对应一个固定的值：<code>Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday</code>。每个枚举值都代表一个常量，确保只能选择这些特定的值。</li></ol><hr><ol start="19"><li><strong>explicit（显式的）</strong><br><code>explicit</code>关键字的作用是“禁止单参数构造函数”在自动类型转换中被使用。简单来说，它防止编译器在进行类型转换时，自动将一个类型转换成这个构造函数的类型。例如，某些容器类型的构造函数可能接收一个数字作为初始大小，如果没有<code>explicit</code>，那么编译器可能会错误地将一个整数自动转换成容器类型。通过显式标记构造函数，可以避免这种自动转换。</li></ol><hr><ol start="20"><li><strong>export（导出）</strong><br>当你想访问其他代码文件中的变量或对象时，如果是普通类型（如基本数据类型、结构体或类），可以使用<code>extern</code>来引用。但是对于模板类型（如模板类或模板函数），你需要使用<code>export</code>来声明它们。在这种情况下，<code>export</code>告诉编译器这些模板是为了在其他文件中使用而被定义的。</li></ol><hr><ol start="21"><li><strong>extern（外部的）</strong><br><code>extern</code>关键字用于声明一个变量或函数是“外部链接”的，意思是它在其他文件中可以被访问和使用。这意味着这个变量或函数并没有在当前文件中定义，而是在程序的其他部分定义的。使用<code>extern</code>声明的变量或函数会在程序开始时分配空间，结束时释放。它们的定义应该出现在其他文件或同一文件的其他地方。如果要使用其他语言编写的代码，可以用<code>extern &quot;C&quot;</code>来声明，指明用C语言的方式进行链接。</li></ol><hr><ol start="22"><li><strong>false（假的）</strong><br><code>false</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“假”。它等价于整数类型中的0。在C++中，<code>bool</code>类型的变量可以是<code>true</code>（真）或<code>false</code>（假）。</li></ol><hr><ol start="23"><li><strong>float（浮点数）</strong><br><code>float</code>是C++中的一种数据类型，用于表示小数（浮点数）。它的精度比<code>double</code>低，适用于对精度要求不高的情况。比如，如果你只需要表示一位小数，使用<code>float</code>可以节省内存。</li></ol><hr><ol start="24"><li><strong>for（循环）</strong><br><code>for</code>是C++中的一种循环结构，用来反复执行一段代码，直到满足特定的条件为止。通常用于已知需要循环多少次的场景。例如，遍历数组或从1加到10。</li></ol><hr><ol start="25"><li><strong>friend（友元）</strong><br><code>friend</code>关键字用来声明友元关系，它允许其他函数或类访问当前类的私有（<code>private</code>）和保护（<code>protected</code>）成员。通过友元，某些函数或类可以直接操作本应隐藏的成员，从而提高效率或简化代码。友元可以是函数、类或特定的成员函数。</li></ol><hr><ol start="26"><li><strong>goto（转到）</strong><br><code>goto</code>是C++中的一种语句，用于跳转到程序中的另一个位置。虽然它可以改变程序的执行流，但通常不推荐使用，因为它会让程序的逻辑变得混乱。现代编程中，常用其他控制流结构（如<code>for</code>、<code>while</code>、<code>if</code>等）来替代<code>goto</code>。</li></ol><hr><ol start="27"><li><strong>if（如果）</strong><br><code>if</code>是C++中的条件语句，用于判断某个条件是否为真。如果条件为真，程序就会执行相应的代码块；如果为假，则跳过这个代码块。它是实现程序决策和分支逻辑的基础。</li></ol><hr><ol start="28"><li><strong>inline（内联函数）</strong><br><code>inline</code>用于定义内联函数，即编译器在调用该函数时，将函数的代码直接插入调用处，而不是进行常规的函数调用。内联函数通常很小，且频繁调用，使用<code>inline</code>可以提高程序执行效率，减少函数调用的开销。</li></ol><hr><ol start="29"><li><strong>int（整型）</strong><br><code>int</code>是C++中的基本数据类型，用来表示整数（没有小数的数）。它的范围通常较小，比<code>long</code>类型的整数范围要窄一些。</li></ol><hr><ol start="30"><li><strong>long（长整型）</strong><br><code>long</code>是C++中的另一种整型数据类型，用来表示比<code>int</code>类型范围更大的整数。它可以存储更大的数值。</li></ol><hr><ol start="31"><li><strong>mutable（易变的）</strong><br><code>mutable</code>是C++中的一个特殊关键字，通常用于类中的成员变量。它允许即使在<code>const</code>函数中，也可以修改被声明为<code>mutable</code>的成员变量。换句话说，它让类的常量成员函数能够修改某些成员变量，这通常用于需要记录某些信息但又不能改变对象状态的情况。</li></ol><hr><ol start="32"><li><strong>namespace（命名空间）</strong><br><code>namespace</code>用于组织和区分类。它是一种比类更大的组织结构，允许你将不同的类、函数等进行分组，避免命名冲突。你可以把它看作一个容器，帮助管理代码。</li></ol><hr><ol start="33"><li><strong>new（新建）</strong><br><code>new</code>是C++中的一个运算符，用于动态创建对象。它会在内存中为对象分配空间，并返回指向该对象的指针。也就是说，<code>new</code>会返回一个指向新创建对象的指针。</li></ol><hr><ol start="34"><li><strong>operator（操作符）</strong><br><code>operator</code>用于操作符重载，它让你可以为C++中的操作符（比如加号、减号等）定义自定义的行为。通过操作符重载，你可以让这些操作符在你的类对象上起作用。</li></ol><hr><ol start="35"><li><strong>private（私有的）</strong><br><code>private</code>是C++中的访问控制符之一，表示一个类的成员（如变量和函数）只能在该类的内部或者其友元类中访问。外部代码不能直接访问这些私有成员。</li></ol><hr><ol start="36"><li><strong>protected（受保护的）</strong><br><code>protected</code>也是C++中的访问控制符之一。被<code>protected</code>标记的成员只能在当前类、派生类（继承的类）以及友元类中访问。外部代码无法直接访问这些受保护的成员。</li></ol><hr><ol start="37"><li><strong>public（公有的）</strong><br><code>public</code>是C++中的访问控制符之一，表示一个类的成员可以被任何代码访问。它没有访问限制，可以在类的外部直接访问这些公有成员。</li></ol><hr><ol start="38"><li><strong>register（寄存器）</strong><br><code>register</code>是C++中的一个关键字，表示请求编译器将某个变量存放在CPU的寄存器中（而不是内存中），以提高访问速度。这个优化仅适用于局部变量，但在现代编译器中，它通常会根据实际情况自动优化，因此在32位编译器中作用较小。</li></ol><hr><ol start="39"><li><strong>reinterpret_cast（重新解释转换）</strong><br><code>reinterpret_cast</code>是C++中的一种类型转换，它可以把一个类型转换成完全不同的另一个类型。例如，它可以把指针转换成整数，或者把整数转换成指针。它的作用是直接重解释数据的二进制表示，而不考虑数据的实际类型，因此需要谨慎使用。</li></ol><hr><ol start="40"><li><strong>return（返回）</strong><br><code>return</code>关键字用于从函数中返回一个值，并结束函数的执行。一旦程序执行到<code>return</code>语句，函数会立即返回结果，之后的代码不会再执行。</li></ol><hr><ol start="41"><li><strong>short（短整型）</strong><br><code>short</code>是C++中的一种整型数据类型，用于表示比<code>int</code>类型范围小的整数。它占用的内存空间比<code>int</code>小，适用于存储较小范围的整数。</li></ol><hr><ol start="42"><li><strong>signed（有符号）</strong><br><code>signed</code>表示数字类型（如整型）是有符号的，也就是说它可以表示正数和负数。与之相对的是<code>unsigned</code>，即无符号类型，表示只有正数和零。大多数数值类型默认就是<code>signed</code>，所以通常不需要显式声明。</li></ol><hr><ol start="43"><li><strong>sizeof（大小）</strong><br><code>sizeof</code>是一个运算符，用来获取数据类型占用的内存大小（以字节为单位）。由于不同系统和编译器可能会有不同的内存分配，使用<code>sizeof</code>可以确保程序的可移植性。</li></ol><hr><ol start="44"><li><strong>static（静态的）</strong><br><code>static</code>关键字用于声明静态变量或静态函数。静态变量在程序开始时分配内存，并且在程序结束时释放。它的作用范围限于定义它的文件或类，在其他文件中不可访问。对于类的静态成员，它是由类的所有实例共享的，所有对象共享同一个静态变量。静态成员变量必须在类外部进行初始化。</li></ol><p>好的，下面是这些概念的更简洁易懂的解释：</p><hr><ol start="45"><li><strong>static_cast（静态转换）</strong><br><code>static_cast</code>是C++中的一种类型转换方式，它把表达式转换为指定的类型。它没有运行时的类型检查，所以开发者需要确保转换是安全的。常见的用法包括：</li></ol><ul><li><strong>类层次转换</strong>：在继承关系中，可以将子类指针&#x2F;引用转换为基类类型（安全），也可以把基类转换为子类（不安全，因为没有检查）。</li><li><strong>基本类型转换</strong>：在不同基本类型之间转换，比如<code>int</code>转换为<code>char</code>或枚举类型。  </li><li><strong>空指针转换</strong>：可以将空指针转换为其他类型的空指针。</li><li><strong>转换为<code>void</code>类型</strong>：可以将任何类型转换为<code>void</code>，用于不返回任何内容。</li></ul><p>需要注意的是，<code>static_cast</code>无法移除<code>const</code>、<code>volatile</code>或<code>__unaligned</code>属性。</p><hr><ol start="46"><li><strong>struct（结构体）</strong><br><code>struct</code>是C++中用于定义结构体的一种数据类型，与<code>class</code>类似，但与C语言兼容。它可以用来定义面向对象的程序，且所有成员默认是公有的（<code>public</code>），在实现上类似于<code>class</code>。</li></ol><hr><ol start="47"><li><strong>switch（选择）</strong><br><code>switch</code>是C++中的一种条件语句，用于在多个可能的分支中选择执行一条。它的用法类似于<code>if-else</code>链，但更简洁。<code>switch</code>的条件表达式必须是整型（如<code>int</code>或<code>char</code>）。<code>switch</code>语句通常包括一个可选的<code>default</code>分支，以处理没有匹配的情况。</li></ol><hr><ol start="48"><li><strong>template（模板）</strong><br><code>template</code>是C++中实现泛型编程的关键字。通过模板，可以定义适用于多种数据类型的通用函数或类，使代码更灵活、可重用。</li></ol><hr><ol start="49"><li><strong>this</strong><br><code>this</code>是C++中的一个指针，用于指向当前对象，也就是正在调用该成员函数的对象本身。通过<code>this</code>，对象可以访问它自己的数据成员和其他成员函数。</li></ol><hr><ol start="50"><li><strong>throw（抛出）</strong><br><code>throw</code>关键字用于C++中的异常处理。当程序遇到错误情况时，可以使用<code>throw</code>来抛出一个异常，通知调用者出错。<code>throw</code>的值可以是任意类型的异常对象。</li></ol><hr><ol start="51"><li><strong>true（真的）</strong><br><code>true</code>是C++中布尔类型（<code>bool</code>）的一个值，表示“真”，等价于整数的非零值。布尔类型<code>bool</code>的值可以是<code>true</code>或<code>false</code>。</li></ol><hr><ol start="52"><li><strong>try（尝试）</strong><br><code>try</code>是C++异常处理机制的一部分。它用于包围可能会抛出异常的代码块，并与<code>catch</code>语句搭配使用，以捕获并处理异常。</li></ol><hr><ol start="53"><li><strong>typedef（类型定义）</strong><br><code>typedef</code>用于为已有数据类型创建一个新的别名。例如，可以用<code>typedef</code>给<code>int</code>类型取一个新的名字。这样可以使代码更易读，但并不会创建新的数据类型。</li></ol><hr><ol start="54"><li><strong>typeid</strong><br><code>typeid</code>用于在运行时获得某个对象或指针的实际类型（比如某个指针或引用指向的派生类型），常用于了解继承关系中的具体类型信息。</li></ol><hr><ol start="55"><li><strong>typename（类型名）</strong><br><code>typename</code>关键字告诉编译器，某个名称代表的是一种类型。主要用于模板代码中，以便让编译器正确地理解该名称的含义，尤其当该名称嵌套在其他类型中或依赖于模板参数时。</li></ol><hr><ol start="56"><li><strong>union（联合体）</strong><br><code>union</code>是一种数据结构，允许存储不同类型的数据，但同一时刻只存储一种。所有成员共享同一段内存，大小取决于最大的数据成员。这与<code>enum</code>不同，<code>enum</code>只能用于整数类型。</li></ol><hr><ol start="57"><li><strong>unsigned（无符号）</strong><br><code>unsigned</code>表示无符号类型，只能存储非负数。与<code>signed</code>（有符号）相对，<code>unsigned</code>省去了负数部分，使得同样的空间可以存储更大的正数。</li></ol><hr><ol start="58"><li><strong>using</strong><br><code>using</code>用于简化命名空间的引用。通过<code>using</code>声明，可以直接使用某命名空间的内容，而不必每次都写命名空间前缀。</li></ol><hr><ol start="59"><li><strong>virtual（虚函数）</strong><br><code>virtual</code>用于实现多态性，允许在基类中声明虚函数，从而可以在派生类中实现不同的行为。这样，通过基类指针或引用调用函数时，会执行派生类中的实际实现。</li></ol><hr><ol start="60"><li><strong>void（空）</strong><br><code>void</code>是一种特殊类型，表示“没有类型”或“空”。它可以用于：</li></ol><ul><li><strong>函数返回类型</strong>：表示函数不返回值。</li><li><strong>函数参数</strong>：表示没有参数传入。</li><li><strong>指针类型</strong>：<code>void*</code>表示一个通用指针，可以指向任意类型的数据。</li></ul><hr><ol start="61"><li><strong>volatile（易变的）</strong><br><code>volatile</code>用于标记变量的值可能会随时被系统或其他进程修改，防止编译器对它进行优化。常用于异步处理，如中断程序中涉及的变量。</li></ol><hr><ol start="62"><li><strong>wchar_t（宽字符）</strong><br><code>wchar_t</code>是一种数据类型，用于表示宽字符（即多字节字符）。每个<code>wchar_t</code>占用两个字节，适合表示Unicode字符，例如汉字。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++数据类型</title>
      <link href="/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2024/11/15/C-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-数据类型"><a href="#C-数据类型" class="headerlink" title="C++数据类型"></a>C++数据类型</h1><p><strong>在编写程序时，我们经常需要用到变量来保存各种信息。变量其实是内存中的一块空间，用来存储特定的数据。创建变量时，计算机会根据变量的类型，分配合适大小的内存，并决定存储的数据格式。</strong></p><p>不同的数据类型可以用来保存不同种类的信息，比如：  </p><ul><li><strong>字符类型</strong>：用来存储单个字符，比如<code>&#39;A&#39;</code>。  </li><li><strong>宽字符类型</strong>：用于存储多字节字符，比如Unicode字符。  </li><li><strong>整数类型</strong>：用来存储整数，比如<code>10</code>或<code>-5</code>。  </li><li><strong>浮点数类型</strong>：用来存储小数，比如<code>3.14</code>。  </li><li><strong>双精度浮点数类型</strong>：精度更高的小数，比如<code>3.1415926</code>。  </li><li><strong>布尔类型</strong>：用来存储<code>true</code>（真）或<code>false</code>（假）。</li></ul><p>操作系统会根据变量的类型，确定分配多少内存以及如何处理存储的数据。这样，可以更高效地利用系统资源并保证数据正确存储。</p><h2 id="基本的内置类型"><a href="#基本的内置类型" class="headerlink" title="基本的内置类型"></a>基本的内置类型</h2><p>C++ 为程序员提供了种类丰富的内置数据类型和用户自定义的数据类型。下表列出了七种基本的 C++ 数据类型：<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>数据类型和关键字</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>数据类型和关键字</h2><table>    <tr>        <th>类型</th>        <th>关键字</th>    </tr>    <tr>        <td>布尔型</td>        <td>bool</td>    </tr>    <tr>        <td>字符型</td>        <td>char</td>    </tr>    <tr>        <td>整型</td>        <td>int</td>    </tr>    <tr>        <td>浮点型</td>        <td>float</td>    </tr>    <tr>        <td>双浮点型</td>        <td>double</td>    </tr>    <tr>        <td>无类型</td>        <td>void</td>    </tr>    <tr>        <td>宽字符型</td>        <td>wchar_t</td>    </tr></table></body></html><p><code>wchar_t</code> 其实是通过定义类型别名实现的，具体是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">short</span> <span class="type">int</span> <span class="type">wchar_t</span>;</span><br></pre></td></tr></table></figure><p>这意味着，<code>wchar_t</code> 实际上占用的空间和 <code>short int</code> 一样，通常是 2 个字节。</p><p>C++ 中的一些基本数据类型可以通过修饰符来修改它们的属性，包括：</p><ul><li><strong>signed</strong>：表示带符号（可以是正数或负数，默认情况下大多数整数类型是带符号的）。</li><li><strong>unsigned</strong>：表示无符号，只能是正数。</li><li><strong>short</strong>：表示短整型，通常占用比 <code>int</code> 更少的内存（通常是 2 个字节）。</li><li><strong>long</strong>：表示长整型，通常占用比 <code>int</code> 更多的内存（通常是 8 个字节）。</li></ul><p>不同的数据类型在内存中占用的空间（字节数）会有所不同，而且它们能存储的最大值和最小值也会根据系统有所不同。通常情况下，1 字节等于 8 位。</p><h3 id="默认情况下："><a href="#默认情况下：" class="headerlink" title="默认情况下："></a>默认情况下：</h3><ul><li><code>int</code>、<code>short</code>、<code>long</code> 类型都是带符号的（<code>signed</code>），可以表示负数和正数。</li></ul><h3 id="关于-long-int-和-int-的大小："><a href="#关于-long-int-和-int-的大小：" class="headerlink" title="关于 long int 和 int 的大小："></a>关于 <code>long int</code> 和 <code>int</code> 的大小：</h3><ul><li>在一些早期的编译器中，<code>long int</code> 占 4 个字节，<code>int</code> 占 2 个字节。但是现代的 C&#x2F;C++ 标准已经兼容这种设定，通常在较新的系统中，<code>long int</code> 占 8 个字节，<code>int</code> 占 4 个字节。<!DOCTYPE html><html lang="en"><head>  <meta charset="UTF-8">  <meta name="viewport" content="width=device-width, initial-scale=1.0">  <title>Data Types and Ranges</title>  <style>      table {          width: 100%;          border-collapse: collapse;      }      th, td {          border: 1px solid #ddd;          padding: 8px;          text-align: left;      }      th {          background-color: #add8e6; /* 浅蓝色背景 */          color: #000; /* 文本颜色，可以根据需要调整 */      }  </style></head><body></li></ul><h2>Data Types and Ranges</h2><table>    <tr>        <th>类型</th>        <th>位</th>        <th>范围</th>    </tr>    <tr>        <td>char</td>        <td>1个字节</td>        <td>-128到127或者0到255</td>    </tr>    <tr>        <td>unsigned char</td>        <td>1个字节</td>        <td>0到255</td>    </tr>    <tr>        <td>signed char</td>        <td>1个字节</td>        <td>-128到127</td>    </tr>    <tr>        <td>int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>unsigned int</td>        <td>4个字节</td>        <td>0到4294967295</td>    </tr>    <tr>        <td>signed int</td>        <td>4个字节</td>        <td>-2147483648到2147483647</td>    </tr>    <tr>        <td>short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>unsigned short int</td>        <td>2个字节</td>        <td>0到65,535</td>    </tr>    <tr>        <td>signed short int</td>        <td>2个字节</td>        <td>-32768到32767</td>    </tr>    <tr>        <td>long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>signed long int</td>        <td>8个字节</td>        <td>-9,223,372,036,854,775,808到9,223,372,036,854,775,807</td>    </tr>    <tr>        <td>unsigned long int</td>        <td>8个字节</td>        <td>0到18,446,744,073,709,551,615</td>    </tr>    <tr>        <td>float</td>        <td>4个字节</td>        <td>精度型占4个字节(32位)内存空间,+/-3.4e+/-38(~7个数字)</td>    </tr>    <tr>        <td>double</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,+/-1.7e+/-308(~15个数字)</td>    </tr>    <tr>        <td>long long</td>        <td>8个字节</td>        <td>双精度型占8个字节(64位)内存空间,表示-9,223,372,036,854,775,807到9,223,372,036,854,775,807的范围</td>    </tr>    <tr>        <td>long double</td>        <td>16个字节</td>        <td>长双精度型16个字节(128位)内存空间,可提供18-19位有效数字。</td>    </tr>    <tr>        <td>wchar_t</td>        <td>2或4个字节</td>        <td>1个宽字符</td>    </tr></table></body></html><h2 id="typedef-声明"><a href="#typedef-声明" class="headerlink" title="typedef 声明"></a>typedef 声明</h2><p>在 C++ 中，<code>typedef</code> 关键字可以用来给已有的类型起一个新的名字。这相当于创建一个类型的别名，让代码更清晰或者更方便。</p><h3 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> 原类型 新名字;</span><br></pre></td></tr></table></figure><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><p>如果想给 <code>int</code> 类型起一个新名字 <code>feet</code>，可以这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> feet;</span><br></pre></td></tr></table></figure><p>从现在起，<code>feet</code> 就和 <code>int</code> 完全等价，表示同一种类型。比如下面的代码是合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">feet distance; <span class="comment">// 等同于 int distance;</span></span><br></pre></td></tr></table></figure><p>这里的 <code>distance</code> 是一个整型变量，但通过 <code>feet</code> 这个名字，它更直观地表示变量的意义，比如“表示距离”。这让代码更容易阅读和理解。</p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p><strong>枚举类型（<code>enumeration</code>）是 C++ 中一种用户自定义的数据类型，用来定义一组固定的值。它非常适合表示只有有限可能取值的变量。通过枚举，可以为变量列举出所有合法值，变量的取值范围就被限制在这些列举的值中。</strong></p><h3 id="枚举的定义"><a href="#枚举的定义" class="headerlink" title="枚举的定义"></a>枚举的定义</h3><p>枚举用关键字 <code>enum</code> 定义，基本语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举名 &#123; </span><br><span class="line">    标识符<span class="number">1</span>[=整型常数], </span><br><span class="line">    标识符<span class="number">2</span>[=整型常数], </span><br><span class="line">    ...</span><br><span class="line">    标识符n[=整型常数]</span><br><span class="line">&#125; 枚举变量;</span><br></pre></td></tr></table></figure><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ul><li>如果没有为标识符赋值（即省略 <code>=整型常数</code>），枚举会默认从 0 开始，后续值依次加 1。</li><li>也可以为部分或全部标识符指定具体的值。未指定的标识符会自动比前一个值大 1。</li></ul><h3 id="示例-1：默认值"><a href="#示例-1：默认值" class="headerlink" title="示例 1：默认值"></a>示例 1：默认值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green, blue &#125;; <span class="comment">// red=0, green=1, blue=2</span></span><br><span class="line">color c;  <span class="comment">// 定义变量 c，类型为 color</span></span><br><span class="line">c = blue; <span class="comment">// c 的值为 blue（等价于 2）</span></span><br></pre></td></tr></table></figure><h3 id="示例-2：自定义值"><a href="#示例-2：自定义值" class="headerlink" title="示例 2：自定义值"></a>示例 2：自定义值</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">color</span> &#123; red, green=<span class="number">5</span>, blue &#125;; <span class="comment">// red=0, green=5, blue=6</span></span><br><span class="line">color c = green;  <span class="comment">// c 的值为 5</span></span><br></pre></td></tr></table></figure><p>在这个例子中：</p><ul><li><code>red</code> 的值为 0。</li><li><code>green</code> 的值被设置为 5。</li><li><code>blue</code> 自动被赋值为 6，因为它比前一个值大 1。</li></ul><h3 id="枚举的好处"><a href="#枚举的好处" class="headerlink" title="枚举的好处"></a>枚举的好处</h3><ol><li><strong>代码更易读</strong>：通过枚举名称表达变量的意义（如 <code>red</code> 和 <code>green</code>）。</li><li><strong>更安全</strong>：变量的取值被限制在定义的枚举值范围内，避免了非法值的出现。</li></ol><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>类型转换是指将一种数据类型的值转换成另一种数据类型的值。在 C++ 中，主要有四种类型转换方式：<strong>静态转换、动态转换、常量转换</strong>和<strong>重新解释转换</strong>。下面我们用更简单的语言解释这些转换方式。</p><hr><h3 id="1-静态转换（Static-Cast）"><a href="#1-静态转换（Static-Cast）" class="headerlink" title="1. 静态转换（Static Cast）"></a>1. <strong>静态转换（Static Cast）</strong></h3><ul><li><strong>作用</strong>：在编译时，将一种类型强制转换成另一种类型。</li><li><strong>特点</strong>：没有运行时检查，所以如果转换不合理，可能会导致程序运行时出错。</li><li><strong>用途</strong>：通常用在类型之间有一定相似性的场景，比如 <code>int</code> 和 <code>float</code> 的转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(i); <span class="comment">// 把 int 类型的值转换为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="2-动态转换（Dynamic-Cast）"><a href="#2-动态转换（Dynamic-Cast）" class="headerlink" title="2. 动态转换（Dynamic Cast）"></a>2. <strong>动态转换（Dynamic Cast）</strong></h3><ul><li><strong>作用</strong>：在运行时将基类的指针或引用转换为派生类的指针或引用。</li><li><strong>特点</strong>：会进行运行时类型检查，如果转换不合法，会返回空指针或抛出异常。</li><li><strong>用途</strong>：主要用于带有<strong>继承关系的类</strong>之间的指针或引用转换。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Base* ptr_base = <span class="keyword">new</span> Derived;  <span class="comment">// 基类指针指向派生类对象</span></span><br><span class="line">Derived* ptr_derived = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(ptr_base); <span class="comment">// 转换成派生类指针</span></span><br></pre></td></tr></table></figure><hr><h3 id="3-常量转换（Const-Cast）"><a href="#3-常量转换（Const-Cast）" class="headerlink" title="3. 常量转换（Const Cast）"></a>3. <strong>常量转换（Const Cast）</strong></h3><ul><li><strong>作用</strong>：用于移除变量的 <code>const</code> 属性，允许对其进行修改。</li><li><strong>特点</strong>：只能去掉 <code>const</code>，不会改变数据类型。</li><li><strong>用途</strong>：在特定场景下需要修改 <code>const</code> 修饰的变量时使用。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> i = <span class="number">10</span>;  <span class="comment">// 一个常量</span></span><br><span class="line"><span class="type">int</span>&amp; r = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>&amp;&gt;(i); <span class="comment">// 将 const int 转换为普通 int</span></span><br></pre></td></tr></table></figure><hr><h3 id="4-重新解释转换（Reinterpret-Cast）"><a href="#4-重新解释转换（Reinterpret-Cast）" class="headerlink" title="4. 重新解释转换（Reinterpret Cast）"></a>4. <strong>重新解释转换（Reinterpret Cast）</strong></h3><ul><li><strong>作用</strong>：直接将一种类型的值按二进制格式解释为另一种类型。</li><li><strong>特点</strong>：不做任何检查，可能会导致未定义行为。</li><li><strong>用途</strong>：通常用于需要对内存内容重新解释的场景（如底层编程）。</li></ul><p><strong>例子：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">float</span>&amp;&gt;(i); <span class="comment">// 强行把 int 的内存解释为 float</span></span><br></pre></td></tr></table></figure><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th><strong>转换方式</strong></th><th><strong>特点</strong></th><th><strong>主要用途</strong></th></tr></thead><tbody><tr><td><strong>静态转换</strong></td><td>编译时转换，无运行时检查</td><td>类型相似的普通数据类型转换（如 <code>int</code> 转 <code>float</code>）</td></tr><tr><td><strong>动态转换</strong></td><td>运行时检查，安全但速度稍慢</td><td>基类与派生类之间的指针或引用转换</td></tr><tr><td><strong>常量转换</strong></td><td>去掉 <code>const</code> 属性，只修改可变性</td><td>修改 <code>const</code> 变量的值</td></tr><tr><td><strong>重新解释转换</strong></td><td>直接按内存内容重新解释类型，不安全</td><td>内存地址、类型的低级转换（如底层硬件编程）</td></tr></tbody></table><p>需要注意的是，<strong>尽量避免不必要的类型转换</strong>，特别是动态转换和重新解释转换，因为它们可能引发潜在的问题或性能损耗。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++基本语法</title>
      <link href="/2024/11/15/%E5%88%9D%E5%A7%8BC/"/>
      <url>/2024/11/15/%E5%88%9D%E5%A7%8BC/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>相信你已经看完前面一节的内容了，如果还有不熟悉的地方，可以再去温故一下<a href="https://blog.tomatou.xyz/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">面向对象与面向过程</a>，本节我将正式开始讲解关于C++的内容，废话不多说，我们正式开始吧！</strong></p><h1 id="C-基本语法"><a href="#C-基本语法" class="headerlink" title="C++基本语法"></a>C++基本语法</h1><p>C++ 程序可以看作是由一组对象组成的，每个对象都有自己的特性和行为。这些对象通过互相调用方法来交流。现在让我们用简单的方式理解一下<strong>类</strong>、<strong>对象</strong>、<strong>方法</strong>和<strong>实例变量</strong>。</p><ol><li><p><strong>对象</strong>  </p><ul><li>对象就像是生活中的实物，它既有特性，也有行为。  <ul><li>比如：一只狗。  <ul><li><strong>特性</strong>：颜色（白色）、名字（小白）、品种（牧羊犬）。  </li><li><strong>行为</strong>：摇尾巴、叫、吃东西。</li></ul></li><li><strong>在程序中，对象是根据类创建出来的“实例”。</strong></li></ul></li></ul></li><li><p><strong>类</strong>  </p><ul><li>类可以看作是创建对象的“设计图”或者“模板”。  <ul><li>比如，“狗”这个类就描述了所有狗的共性（颜色、名字、品种）和它们可以做的事（摇尾巴、叫、吃东西）。  </li><li><strong>具体的狗（如小白、小黑）就是从这个类生成的对象。</strong></li></ul></li></ul></li><li><p><strong>方法</strong>  </p><ul><li>方法就是对象可以执行的“动作”或者“功能”。  <ul><li>对狗来说，方法可以是“叫”（bark()）、“吃”（eat()）。  </li><li><strong>方法中包含程序逻辑，定义了对象可以做的事情。</strong></li></ul></li></ul></li><li><p><strong>实例变量</strong>  </p><ul><li>实例变量是对象的“特性值”，每个对象都有自己的值。  <ul><li>比如，狗类中可能有变量“颜色”、“名字”。小白的颜色是白色，名字是“小白”；而小黑的颜色是黑色，名字是“小黑”。这些特性值存储在实例变量中，决定了对象的状态。</li></ul></li></ul></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>把类比作“模板”，对象是根据模板创建的“具体实例”，方法定义了对象的“行为”，而实例变量存储了对象的“特性值”。通过这种方式，我们可以用编程模拟真实世界中的事物和它们之间的交互。</p><h1 id="C-程序结构"><a href="#C-程序结构" class="headerlink" title="C++ 程序结构"></a>C++ 程序结构</h1><p>让我们看一段简单的代码，可以输出单词 Hello World</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>接下来我们讲解一下这个程序:</strong></p><ol><li><p><strong>头文件 <code>&lt;iostream&gt;</code></strong>  </p><ul><li><code>&lt;iostream&gt;</code> 是一个标准库，提供输入输出功能。  </li><li>在这个程序中，它允许我们使用 <code>cout</code> 输出信息到屏幕上。</li></ul></li><li><p><strong><code>using namespace std;</code></strong>  </p><ul><li>告诉编译器我们要使用标准命名空间 <code>std</code>。  </li><li>这样，我们可以直接写 <code>cout</code> 而不用每次都写成 <code>std::cout</code>。</li></ul></li><li><p><strong>单行注释 <code>//</code></strong>  </p><ul><li>以 <code>//</code> 开头的部分是注释，它的作用是让程序员记录说明，编译器会忽略这些内容。  </li><li>比如 <code>// main() 是程序的开始</code>，是为了帮助人类理解程序的结构。</li></ul></li><li><p><strong>主函数 <code>int main()</code></strong>  </p><ul><li><code>main()</code> 是程序的入口点，每个 C++ 程序都需要这个函数。  </li><li>程序从这里开始运行。</li></ul></li><li><p><strong>输出语句 <code>cout &lt;&lt; &quot;Hello World&quot;;</code></strong>  </p><ul><li><code>cout</code> 是 C++ 用来输出信息到屏幕的工具。  </li><li>这句代码会在屏幕上打印 <code>Hello World</code>。</li></ul></li><li><p><strong><code>return 0;</code></strong>  </p><ul><li>这句话的意思是：程序运行结束，并返回一个值 <code>0</code> 给系统。  </li><li>在 C++ 中，返回 <code>0</code> 通常表示程序正常结束。</li></ul></li></ol><h2 id="编译-执行-C-程序"><a href="#编译-执行-C-程序" class="headerlink" title="编译 &amp; 执行 C++ 程序"></a>编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤:</p><ol><li><p><strong>编写代码</strong>  </p><ul><li>打开一个文本编辑器，比如记事本或代码编辑器（如 VS Code、Sublime Text）。  </li><li>将前面写好的代码粘贴进去。</li></ul></li><li><p><strong>保存文件</strong>  </p><ul><li>将文件保存为 <code>hello.cpp</code>（扩展名必须是 <code>.cpp</code>，表示这是一个 C++ 程序）。</li></ul></li><li><p><strong>打开命令提示符</strong>  </p><ul><li>在 Windows 系统中，可以通过按下 <code>Win + R</code>，输入 <code>cmd</code> 打开命令提示符。  </li><li>使用 <code>cd</code> 命令进入保存 <code>hello.cpp</code> 文件的文件夹。<br>例如，如果文件在桌面上：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> Desktop</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>编译代码</strong>  </p><ul><li>输入以下命令，按下回车：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ hello.cpp</span><br></pre></td></tr></table></figure></li><li>如果代码没有错误，编译器会生成一个可执行文件，默认命名为 <code>a.exe</code>（在 Windows 中）或 <code>a.out</code>（在 Linux&#x2F;macOS 中）。</li></ul></li><li><p><strong>运行程序</strong>  </p><ul><li>在命令提示符中输入以下命令，运行生成的可执行文件：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.exe    <span class="comment"># Windows 系统</span></span><br><span class="line">./a.out  <span class="comment"># Linux/macOS 系统</span></span><br></pre></td></tr></table></figure></li><li>你将看到屏幕上显示 <code>Hello World</code>。</li></ul></li></ol><h3 id="补充说明："><a href="#补充说明：" class="headerlink" title="补充说明："></a>补充说明：</h3><ul><li><strong>什么是编译？</strong><br>编译是将我们写的 C++ 代码转换成机器能理解的二进制文件（可执行文件）的过程。  </li><li><strong>为什么需要编译？</strong><br>计算机只能理解二进制代码，因此必须先将源代码“翻译”成计算机语言，才能运行。<br>通过以上步骤，你的第一个 C++ 程序就成功运行了！</li></ul><h2 id="C-中的分号-语句块"><a href="#C-中的分号-语句块" class="headerlink" title="C++ 中的分号 &amp; 语句块"></a>C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束</p><h3 id="分号的作用"><a href="#分号的作用" class="headerlink" title="分号的作用"></a>分号的作用</h3><ol><li><p><strong>分号是语句结束的标志</strong>：  </p><ul><li>每条C++语句都需要以分号结尾，用来告诉编译器“这句话结束了”。</li><li>你可以把分号看成是句号，表示一个完整的逻辑结束。</li></ul></li><li><p><strong>示例</strong>：<br>下面是三条独立的语句，每条语句都以分号结束：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;         <span class="comment">// 把 y 的值赋给 x</span></span><br><span class="line">y = y + <span class="number">1</span>;     <span class="comment">// y 加 1 后赋值给 y</span></span><br><span class="line"><span class="built_in">add</span>(x, y);     <span class="comment">// 调用函数 add，把 x 和 y 作为参数</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="语句块的作用"><a href="#语句块的作用" class="headerlink" title="语句块的作用"></a>语句块的作用</h3><ol><li><p><strong>语句块是逻辑上的一组代码</strong>：  </p><ul><li>使用大括号 <code>&#123;&#125;</code> 将多条语句包裹在一起，这些语句作为一个整体，通常用于函数、条件语句、循环等结构中。</li></ul></li><li><p><strong>示例</strong>：<br>下面是一个语句块，它包含两条语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;             <span class="comment">// 返回值 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同一行的多个语句"><a href="#同一行的多个语句" class="headerlink" title="同一行的多个语句"></a>同一行的多个语句</h3><ol><li><p><strong>C++ 不限制每行只能写一条语句</strong>：  </p><ul><li>你可以在同一行放置多条语句，只要每条语句以分号结束即可。</li></ul></li><li><p><strong>示例</strong>：<br>以下两种写法是等价的：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y;</span><br><span class="line">y = y + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = y; y = y + <span class="number">1</span>; <span class="built_in">add</span>(x, y);</span><br></pre></td></tr></table></figure></li></ol><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>分号</strong>：是C++的语句结束符，必须添加。</li><li><strong>语句块</strong>：是一组用大括号 <code>&#123;&#125;</code> 包裹的语句，用于逻辑上的分组。</li><li><strong>多语句</strong>：C++允许多条语句写在一行，只需确保用分号分隔即可。<br>通过这些规则，你可以更灵活地组织代码。</li></ul><h2 id="C-标识符"><a href="#C-标识符" class="headerlink" title="C++ 标识符"></a>C++ 标识符</h2><p>C++ 标识符是用于命名变量、函数、类等的符号，用来帮助程序员在代码中识别不同的内容。下面是一些详细解释：</p><ol><li><p><strong>命名规则</strong>：</p><ul><li>标识符必须以字母（A-Z或a-z）或下划线（_）开头。</li><li>后面可以跟字母、数字（0-9）或下划线的组合。</li></ul></li><li><p><strong>限制</strong>：</p><ul><li>不能包含特殊字符，如 <code>@</code>、<code>&amp;</code>、<code>%</code> 等。</li><li>C++ 区分大小写，也就是说 <code>apple</code> 和 <code>Apple</code> 是两个不同的标识符。</li></ul></li><li><p><strong>有效的标识符示例</strong>：</p><ul><li><code>mohd</code>, <code>zara</code>, <code>move_name</code>, <code>a_123</code>, <code>_temp</code> 等，符合规则。<br>通过这些规则，C++ 程序员可以创建各种命名来组织代码，使代码更有条理。</li></ul></li></ol><h2 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h2><p>下面出了一些在 C++ 中的保留字，这些保留字不能作为常量名、变量名或其他标识符名称。<br><!DOCTYPE html></p><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>C++ Keywords</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #f2f2f2;        }    </style></head><body><h2>C++ Keywords</h2><table>    <tr>        <td>asm</td>        <td>else</td>        <td>new</td>        <td>this</td>    </tr>    <tr>        <td>auto</td>        <td>enum</td>        <td>operator</td>        <td>throw</td>    </tr>    <tr>        <td>bool</td>        <td>explicit</td>        <td>private</td>        <td>true</td>    </tr>    <tr>        <td>break</td>        <td>export</td>        <td>protected</td>        <td>try</td>    </tr>    <tr>        <td>case</td>        <td>extern</td>        <td>public</td>        <td>typedef</td>    </tr>    <tr>        <td>catch</td>        <td>false</td>        <td>register</td>        <td>typeid</td>    </tr>    <tr>        <td>char</td>        <td>float</td>        <td>reinterpret_cast</td>        <td>typename</td>    </tr>    <tr>        <td>class</td>        <td>for</td>        <td>return</td>        <td>union</td>    </tr>    <tr>        <td>const</td>        <td>friend</td>        <td>short</td>        <td>unsigned</td>    </tr>    <tr>        <td>const_cast</td>        <td>goto</td>        <td>signed</td>        <td>using</td>    </tr>    <tr>        <td>continue</td>        <td>if</td>        <td>sizeof</td>        <td>virtual</td>    </tr>    <tr>        <td>default</td>        <td>inline</td>        <td>static</td>        <td>void</td>    </tr>    <tr>        <td>delete</td>        <td>int</td>        <td>static_cast</td>        <td>volatile</td>    </tr>    <tr>        <td>do</td>        <td>long</td>        <td>struct</td>        <td>wchar_t</td>    </tr>    <tr>        <td>double</td>        <td>mutable</td>        <td>switch</td>        <td>while</td>    </tr>    <tr>        <td>dynamic_cast</td>        <td>namespace</td>        <td>template</td>        <td></td>    </tr></table></body></html><p>若要查看完整关键字介绍可查阅：<a href="https://blog.tomatou.xyz/2024/11/15/C-%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88%E4%BF%9D%E7%95%99%E5%AD%97%EF%BC%89%E5%AE%8C%E6%95%B4%E4%BB%8B%E7%BB%8D/">C++ 的关键字（保留字）完整介绍</a></p><h2 id="三字符组"><a href="#三字符组" class="headerlink" title="三字符组"></a>三字符组</h2><h3 id="什么是三字符组？"><a href="#什么是三字符组？" class="headerlink" title="什么是三字符组？"></a>什么是三字符组？</h3><p>三字符组是用三个特定字符组合来表示其他字符的一种方法，通常以??开头。这是早期为了解决一些键盘上缺少特定字符的问题而设计的。虽然现代编译器和键盘已经不需要这个功能，但它仍然是C++标准的一部分。</p><h3 id="三字符组的常用替换规则"><a href="#三字符组的常用替换规则" class="headerlink" title="三字符组的常用替换规则"></a>三字符组的常用替换规则</h3><!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <meta name="viewport" content="width=device-width, initial-scale=1.0">    <title>字符替换表</title>    <style>        table {            width: 100%;            border-collapse: collapse;        }        th, td {            border: 1px solid #ddd;            padding: 8px;            text-align: left;        }        th {            background-color: #add8e6; /* 浅蓝色背景 */            color: #000; /* 文本颜色，可以根据需要调整 */        }    </style></head><body><h2>字符替换表</h2><table>    <tr>        <th>三字符组</th>        <th>替换</th>    </tr>    <tr>        <td>??=</td>        <td>#</td>    </tr>    <tr>        <td>??/</td>        <td>\</td>    </tr>    <tr>        <td>??'</td>        <td>^</td>    </tr>    <tr>        <td>??(</td>        <td>[</td>    </tr>    <tr>        <td>??)</td>        <td>]</td>    </tr>    <tr>        <td>??!</td>        <td>|</td>    </tr>    <tr>        <td>??&lt;</td>        <td>{</td>    </tr>    <tr>        <td>??&gt;</td>        <td>}</td>    </tr>    <tr>        <td>??-</td>        <td>~</td>    </tr></table></body></html><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用三字符组代替常规符号</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Hello, World!&quot;</span> ??! std::endl;  <span class="comment">// ??! 替换成 |</span></span><br><span class="line">    <span class="type">int</span> arr??(<span class="number">3</span>??) = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;                 <span class="comment">// ??( 和 ??) 替换成 [ 和 ]</span></span><br><span class="line">    std::cout &lt;&lt; arr??(<span class="number">0</span>??) &lt;&lt; std::endl;       <span class="comment">// 输出数组第一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>输出结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hello, World!</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h3 id="三字符组的注意事项"><a href="#三字符组的注意事项" class="headerlink" title="三字符组的注意事项"></a>三字符组的注意事项</h3><p><strong>特殊情况避免替换</strong>：</p><p>如果你需要在字符串、字符常量或者注释中保留两个连续的问号，而不被自动替换，可以用以下方式：<br>转义序列：”???“。<br>字符串拼接：”??””?”。</p><p><strong>现代编译器支持：</strong></p><p>Microsoft Visual C++：从2010版开始，默认不再支持三字符组。如果需要启用，可以使用命令行选项&#x2F;Zc:trigraphs。<br>GCC编译器：仍支持三字符组，但会提示编译警告，表明这种用法已经过时。</p><h3 id="为什么了解三字符组？"><a href="#为什么了解三字符组？" class="headerlink" title="为什么了解三字符组？"></a>为什么了解三字符组？</h3><p>虽然三字符组在现代开发中极少使用，但在维护一些古老的代码时可能会遇到。这是一个有趣的历史遗留特性，了解它有助于更全面地理解C++语言的设计。</p><h2 id="C-中的空格"><a href="#C-中的空格" class="headerlink" title="C++中的空格"></a>C++中的空格</h2><p>以下是对“C++ 中的空格”更通俗易懂的解释：</p><h3 id="空白行和空格"><a href="#空白行和空格" class="headerlink" title="空白行和空格"></a>空白行和空格</h3><ol><li><p><strong>空白行</strong>：只有空格或注释的行称为“空白行”。C++ 编译器会自动忽略这些行，它们不会影响代码运行。</p></li><li><p><strong>空格的作用</strong>：</p><ul><li>空格不仅指空白符，还包括制表符（Tab）、换行符和注释，它们都属于“空白符号”。</li><li>空格帮助编译器区分不同部分，比如在<code>int age;</code>这行代码中，<code>int</code>和<code>age</code>之间需要空格，这样编译器才能知道<code>int</code>是数据类型，<code>age</code>是变量名。</li></ul></li><li><p><strong>代码的可读性</strong>：</p><ul><li>在一些地方，空格不是必需的，比如在 <code>fruit = apples + oranges;</code> 中，<code>fruit</code> 和 <code>=</code> 之间不强制要求空格，但适当添加空格可以让代码更清晰，便于阅读。</li></ul></li></ol><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>空格让代码更易读，帮助编译器识别代码中的不同部分。虽然有些地方空格不是必须的，但为了让代码更美观，推荐合理使用空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> C++程序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象与面向过程</title>
      <link href="/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>/2024/11/11/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%8E%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>从现在开始我将正式开始分享一些C++程序的讲解，相信大家对于C语言并不陌生，我们接下来需要去学习的C++这个编程语言也跟C语言有关系，但是它与C语言有很大的区别，本节内容不会有代码的讲解，作为一个引文的作用，目的在于让大家认识到C++与C语言的区别，或者说面向对象程序设计语言与面向过程程序设计语言的区别，以便于之后更好的去理解代码、语法等等</strong></p><h1 id="面向对象与面向过程"><a href="#面向对象与面向过程" class="headerlink" title="面向对象与面向过程"></a>面向对象与面向过程</h1><h2 id="一-面向过程-OOP"><a href="#一-面向过程-OOP" class="headerlink" title="一.面向过程(OOP)"></a>一.面向过程(OOP)</h2><h3 id="什么是面向过程？"><a href="#什么是面向过程？" class="headerlink" title="什么是面向过程？"></a>什么是面向过程？</h3><p><strong>面向过程是一种以步骤为核心的编程方式，逻辑比较线性。可以理解为<u>以完成任务为目标</u>，通过一系列有序的指令来操作数据，逐步完成任务。我们来具体谈谈：</strong></p><h4 id="游戏中的面向过程"><a href="#游戏中的面向过程" class="headerlink" title="游戏中的面向过程"></a>游戏中的面向过程</h4><p><strong>设想我们要设计一个战斗游戏，有以下角色和功能：</strong></p><p><strong>角色：玩家、怪物</strong><br><strong>功能：攻击、逃跑、升级</strong></p><p><strong>在面向过程的思维中，我们可以按照以下步骤实现：</strong></p><p><strong>1.定义玩家的属性：生命值、攻击力、防御力</strong><br><strong>2.定义怪物的属性：生命值、攻击力、防御力</strong><br><strong>3.编写函数：</strong><br><strong>玩家攻击函数——playerAttackMonster()：玩家攻击怪物，怪物的生命值减少</strong><br><strong>怪物攻击函数——monsterAttackPlayer()：怪物攻击玩家，玩家的生命值减少</strong><br><strong>升级函数——upgradePlayer()：玩家升级时提升攻击力和防御力</strong><br><strong>4.游戏逻辑：通过调用这些函数来实现游戏流程，如玩家攻击、怪物攻击、玩家升级等</strong>。<br><strong>我们可以看到，<u>游戏的主要逻辑由一系列的函数组成，这些函数一个接一个地执行</u></strong></p><p><strong>所以可以得到面向过程的特点：</strong><br><strong>1.步骤清晰：逐步执行代码，如先定义角色，再实现攻击功能</strong><br><strong>2.数据分散：每个角色的数据和行为都是分开的，玩家和怪物的属性、函数不相关</strong><br><strong>3.适合小型项目：如果游戏简单，面向过程的逻辑非常直观</strong></p><p><strong>但这也带来了面向过程的劣势：</strong><br><strong>1.代码重复：不同的角色可能要定义相似的属性（如生命值、攻击力等）</strong><br><strong>2.维护困难：如果要新增一个角色，如“弓箭手”，需要增加很多函数和属性，工作量增加</strong></p><h2 id="二-面向对象-POP"><a href="#二-面向对象-POP" class="headerlink" title="二.面向对象(POP)"></a>二.面向对象(POP)</h2><h3 id="什么是面向对象？"><a href="#什么是面向对象？" class="headerlink" title="什么是面向对象？"></a>什么是面向对象？</h3><p><strong>面向对象是一种以数据和行为组合为核心的编程方式，结构较为模块化。它强调将数据和操作结合在一起，通过“类”和“对象”将复杂的任务组织为独立的模块，还是以游戏为例：</strong></p><h4 id="游戏中的面向对象"><a href="#游戏中的面向对象" class="headerlink" title="游戏中的面向对象"></a>游戏中的面向对象</h4><p><strong>在面向对象的思维中，我们可以通过创建类来封装角色和行为：</strong></p><p><strong>1.定义一个“玩家”类（Player）：</strong><br><strong>属性：生命值、攻击力、防御力等</strong><br><strong>方法：攻击怪物（attack()）、升级（levelUp()）</strong></p><p><strong>2.继承和扩展：</strong><br><strong>如果有不同类型的玩家角色，比如战士（Warrior）、法师（Mage），我们可以让Warrior和Mage继承Player类，这样它们就自动拥有了生命值、攻击力等属性和攻击、升级等方法</strong><br><strong>我们可以为Warrior增加“近战攻击”方法（meleeAttack()），为Mage增加“施法”方法（castSpell()），这样每种角色都有独特的行为，而不需要重复编写基础属性</strong></p><p><strong>3.怪物类（Monster）：</strong><br><strong>我们也可以定义一个Monster类，包含怪物的生命值和攻击力</strong><br><strong>通过定义方法如attackPlayer()，实现怪物对玩家的攻击</strong></p><p><strong>4.道具类（Item）：</strong><br><strong>还可以定义道具类，包含道具名称、效果等属性</strong><br><strong>比如药水类可以恢复玩家的生命值，而武器类可以提升玩家的攻击力</strong></p><p><strong>从上面的例子我们不难看出面向过程的特点：</strong><br><strong>1.模块化：每个类都包含属性和行为，Player类中的方法直接操作Player的数据，怪物则自成一体</strong><br><strong>2.继承性：Warrior、Mage继承自Player，只需扩展各自的特性，而无需重复代码</strong><br><strong>3.封装性：属性和行为封装在类内，外部代码无需关心具体实现，只需调用方法</strong><br><strong>4.扩展性：可以轻松添加新角色或功能，如增加“弓箭手”类，继承Player类，扩展新技能，不影响已有代码</strong></p><h2 id="三-面向对象-vs-面向过程：对比分析"><a href="#三-面向对象-vs-面向过程：对比分析" class="headerlink" title="三.面向对象 vs. 面向过程：对比分析"></a>三.面向对象 vs. 面向过程：对比分析</h2><h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><p><strong>1.面向对象是对面向过程的进一步抽象，结构上更清晰，适合管理复杂系统</strong><br><strong>2.二者的基本逻辑相同，但面向对象在逻辑结构和扩展性上更优</strong></p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p><strong>1.核心思维：面向过程以步骤和流程为主，逐步实现目标。面向对象通过类和对象组织代码，模块化更高</strong><br><strong>2.代码结构：面向过程的代码较分散，面向对象将数据和操作结合，封装在类中，结构更紧密</strong><br><strong>3.适用场景：面向过程适合简单、线性逻辑；面向对象适合复杂系统，方便维护和扩展</strong></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>通过面向对象编程，我们可以更轻松地在游戏中管理不同角色、怪物、道具的行为和状态。这种模块化的设计方式不仅让代码更易读，还使得后续扩展和维护更加简单。在C++中，面向对象为我们提供了丰富的表达能力，从而使游戏设计更具灵活性和扩展性</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> C++教程 </category>
          
          <category> C++基础教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 程序设计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>好用的网站 www.______.com😏</title>
      <link href="/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/"/>
      <url>/2024/11/11/%E5%A5%BD%E7%94%A8%E7%9A%84%E7%BD%91%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>先问大家一个问题：大家的浏览器收藏夹里面有多少好东西呢？😋</strong></p><p><strong>我收藏夹里藏着不少“古董级”的宝贝网站，就像那些被遗忘在阁楼角落里的旧玩具，虽然不常拿出来玩，但偶尔翻出来，总能发现一些意想不到的乐趣。这些网站可能平时默默无闻，但说不定在某个无聊的下午，它们就能给你带来惊喜，让你的浏览器收藏夹不再是“尘封的记忆”，而是“宝藏的宝库”。那么，这次我为大家带来了哪些新奇有趣的网站呢？让我们一起来看看，说不定能发现一些被我们忽略的“隐藏版”乐趣哦！</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="网站介绍"><a href="#网站介绍" class="headerlink" title="网站介绍"></a>网站介绍</h2><p><strong>使用设备：电脑</strong><br><strong>获取方式：文章底部(每一个推荐网站的底部)</strong></p><h3 id="1-懒盘搜索——聚合搜索神器"><a href="#1-懒盘搜索——聚合搜索神器" class="headerlink" title="1. 懒盘搜索——聚合搜索神器"></a>1. 懒盘搜索——聚合搜索神器</h3><p><strong>这是一个非常好用的网盘搜索工具，包括音乐、电影、动漫、小说等等内容都能搜索到</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120117.png" alt="主页面" >  <img src="/img_2/QQ截图20241111120126.png" alt="聚合搜索界面" ></div><p><strong>电影搜索</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120237.png" alt="电影搜素" ></div><p><strong>学习资源</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111120246.png" alt="学习资源" >  <img src="/img_2/QQ截图20241111121051.png" alt="学习资源" ></div><h4 id="懒盘搜索官网链接：https-www-lzpan-com"><a href="#懒盘搜索官网链接：https-www-lzpan-com" class="headerlink" title="懒盘搜索官网链接：https://www.lzpan.com/"></a>懒盘搜索官网链接：<a href="https://www.lzpan.com/">https://www.lzpan.com/</a></h4><h3 id="2-虫部落"><a href="#2-虫部落" class="headerlink" title="2.虫部落"></a>2.虫部落</h3><p><strong>虫部落是一个集结了海量资源的搜索平台。在这里，你能找到的资源大多是通过网盘链接分享的。只要你拥有相应的网盘账户，轻轻一点，就能迅速将资源保存到你的网盘中，然后直接下载，方便快捷</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111121454.png" alt="主页面" >  <img src="/img_2/QQ截图20241111121853.png" alt="部分内容" >  <img src="/img_2/QQ截图20241111121916.png" alt="部分内容" ></div><p><strong>这个平台就像是一个资源宝库，让寻找各类资料变得轻而易举。它极大地简化了我的日常搜索任务，让我能够快速获取所需资源，真是一个值得向大家推荐的实用工具</strong></p><h4 id="虫部落官网链接：http-www-chongbuluo-com"><a href="#虫部落官网链接：http-www-chongbuluo-com" class="headerlink" title="虫部落官网链接：http://www.chongbuluo.com/"></a>虫部落官网链接：<a href="http://www.chongbuluo.com/">http://www.chongbuluo.com/</a></h4><h3 id="3-考研百科网"><a href="#3-考研百科网" class="headerlink" title="3.考研百科网"></a>3.考研百科网</h3><p><strong>这个平台致力于为准备考研的学生提供全方位的支持，让他们能够提前掌握所需的学习资源和准备工作。该平台划分为四个核心板块，分别是考研入门知识、考研流程指导、考研目标规划和备考技巧建议</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111122642.png" alt="主页面" >  <img src="/img_2/QQ截图20241111122656.png" alt="部分内容" ></div><p><strong>这个网站提供了非常全面的资源，我就不在这里一一列举了。正在准备考研或者有意向考研的朋友们，可以查看下面的图表，或者直接访问这个网站来获取更多信息</strong></p><h4 id="考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk"><a href="#考研百科官网链接：https-yz-chsi-com-cn-yzzt-kybk" class="headerlink" title="考研百科官网链接：https://yz.chsi.com.cn/yzzt/kybk"></a>考研百科官网链接：<a href="https://yz.chsi.com.cn/yzzt/kybk">https://yz.chsi.com.cn/yzzt/kybk</a></h4><h3 id="一键抠图——在线图片处理神器"><a href="#一键抠图——在线图片处理神器" class="headerlink" title="一键抠图——在线图片处理神器"></a>一键抠图——在线图片处理神器</h3><p><strong>一键抠图是一个卓越的网络图像编辑工具，它提供了众多的图片处理功能，包括但不限于图像抠图、证件照制作、照片修复、文件格式转换、全面编辑以及图片裁剪等，这些功能全面覆盖了日常工作中可能遇到的图像编辑需求</strong></p><div style="text-align:center">  <img src="/img_2/QQ截图20241111123156.png" alt="主页面" ></div><p><strong>抠图功能使用起来非常简单便捷，即使是初学者也能快速掌握。用户只需选择相应的功能，上传图片，系统便会自动进行识别并提取图片中的核心元素，整个过程轻松无压力</strong><br><video controls><br>  <source src="/img_2/bandicam 2024-11-11 12-34-06-243.mp4" type="video/mp4"><br></video></p><h4 id="一键抠图官网链接：https-www-yijiankoutu-com"><a href="#一键抠图官网链接：https-www-yijiankoutu-com" class="headerlink" title="一键抠图官网链接：https://www.yijiankoutu.com/"></a>一键抠图官网链接：<a href="https://www.yijiankoutu.com/">https://www.yijiankoutu.com/</a></h4><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，我们每个人的周围其实都有着不少宝贵的资源，无论是知识、技能、人脉还是物质条件。这些资源就像是我们生活中的宝藏，等待着我们去发掘和利用。不要害怕去探索和尝试，因为每一次的尝试都可能开启新的可能性。让我们勇敢地迈出步伐，用开放的心态去学习，用智慧的眼光去发现，用创新的思维去整合。记住，善于利用身边的资源，不仅能帮助我们解决问题，还能让我们在成长的道路上走得更远。所以，请用好每一份资源，让它们成为我们成功的助力！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 网站 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
            <tag> 宝藏网站 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对不住了，Steam！Steam 游戏发烧友必备😏</title>
      <link href="/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/"/>
      <url>/2024/11/09/%E5%AF%B9%E4%B8%8D%E4%BD%8F%E4%BA%86-Steam/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>说到 Steam，那可是游戏爱好者心中的圣地，就像图书馆之于书虫，糖果店之于小朋友，那是一个应有尽有，让人眼花缭乱的地方。你想要最新的 3A 大作？没问题！在线游戏？小菜一碟！但问题是，这些游戏可不是免费派发的糖果，你得先掏腰包才能把它们领回家</strong><br><strong>如果你偶尔心血来潮，买一两个游戏，那钱包还能勉强保持微笑。但如果你是个游戏收藏家，那可就得小心了，你的钱包可能会因为过度兴奋而 “心脏病发作”</strong><br><strong>当然，如果游戏能让你爱不释手，那花点钱也值了。但最怕的就是，你花了钱，结果发现这游戏跟你八字不合，那可真是让人哭笑不得</strong><br><strong>所以，今天给大家介绍一个神奇的游戏下载盒子，它能让你在 Steam 的海洋里畅游，而不用掏空你的口袋。这可不是普通的盒子，它能让你免费享受那些让人垂涎三尺的游戏大餐。这就好比你走进了一家自助餐厅，却发现老板说：“今天免费，随便吃！” 这等好事，你怎能错过呢？</strong></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：游戏盒子 (game box)</strong><br><strong>使用设备：电脑</strong><br><strong>软件大小：130.04MB</strong><br><strong>获取方式：文章底部</strong></p><h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="游戏资源"><a href="#游戏资源" class="headerlink" title="游戏资源"></a>游戏资源</h3><p><strong>软件已经出了新版本，但是大家不需要进行更新，我觉得这个版本也是没啥问题，并且也是可以正常使用的，大家想更新的也可以选择更新试试看！然后大家也是能看到内置了超多的游戏资源～</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-41-37-709.mp4" type="video/mp4"><br></video></p><h3 id="游戏搜索"><a href="#游戏搜索" class="headerlink" title="游戏搜索"></a>游戏搜索</h3><p><strong>软件支持直接搜索，你可以通过搜索游戏并下载，下方也是有内置各种分类可供选择，可以在不同类别里发掘自己喜欢的游戏</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 15-43-08-343.mp4" type="video/mp4"><br></video></p><h3 id="安装路径与下载"><a href="#安装路径与下载" class="headerlink" title="安装路径与下载"></a>安装路径与下载</h3><p><strong>软件提供了一系列精彩的游戏资源，包括许多高品质的 3A 级作品。在开始下载之前，需要先登录天翼云网盘 (免费注册的)，再通过设置选项来指定下载和安装的位置，这样可以确保一切顺利进行。只需点击界面右上角的 “设置” 图标，就可以轻松地自定义您的下载和安装路径了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-04-45-737.mp4" type="video/mp4"><br></video></p><h2 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h2><p><strong>安装的方式也简单，找到自己喜欢的游戏后，点击安装按钮，然后选择游戏的版本号即可一键下载安装该游戏了</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-12-23-001.mp4" type="video/mp4"><br></video></p><h2 id="下载速度"><a href="#下载速度" class="headerlink" title="下载速度"></a>下载速度</h2><p><strong>测试了一下游戏的下载速度，非常不错，开发大佬优化了下载速度，可以让大家快速的下载完成</strong><br><video controls><br>  <source src="/img_1/bandicam 2024-11-09 16-15-17-955.mp4" type="video/mp4"><br></video></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>通过网盘分享的文件：gamebox.exe</strong><br><strong>链接: <a href="https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg">https://pan.baidu.com/s/1gXagyGZ8lqwxoDCq_rdBMg</a></strong><br><strong>提取码: e5sa</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>对于这些无私地提供免费软件的开发者们，我们应当怀有敬意和感激之情，向他们致敬🫡</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新的歌曲</title>
      <link href="/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/"/>
      <url>/2024/11/08/%E6%96%B0%E7%9A%84%E6%AD%8C%E6%9B%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>这是我最近这段时间做的曲子，偏励志的歌曲，希望大家能够喜欢</strong></p><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><h3 id="以下是歌词"><a href="#以下是歌词" class="headerlink" title="以下是歌词"></a>以下是歌词</h3><p><strong>歌名：Step By step</strong></p><p><strong>In the race of life, we take our place,</strong><br><strong>With hopes aflame, in this timeless chase.</strong><br><strong>Through storms we walk, lessons deep and wise,</strong><br><strong>With each dawn’s light, a new dream arises.</strong></p><p><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we claim the prize,</strong><br><strong>Eyes set forward, on dreams that rise.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step</strong><br><strong>Step by step</strong><br><strong>Step by step, we’re climbing high,</strong><br><strong>Through every storm and every sky.</strong><br><strong>Step by step, we’ll mark our way.</strong></p><p><strong>The road is winding, misty, unclear,</strong><br><strong>Yet each stride brings our visions near.</strong><br><strong>To heights unknown, where dreams aspire,</strong><br><strong>With a heart that beats, forever on fire.</strong></p><p><strong>For each mile walked, a tale we hold,</strong><br><strong>Of battles fought, and stories told.</strong><br><strong>We march on strong, fueled by belief,</strong><br><strong>Our destiny waits beyond disbelief.</strong></p><p><strong>Step by step, beyond the fear,</strong><br><strong>Through shadows cast, our way is clear.is clear</strong><br><strong>Step by step, we’re redefined,</strong><br><strong>Into a strength of heart and mind.</strong></p><p><strong>Lift your gaze, the world awaits,</strong><br><strong>The dawn of dreams, through future gates.</strong><br><strong>Step by step, we’ll mark our way,</strong><br><strong>Leaving echoes in history’s sway.</strong></p><h3 id="工程文件"><a href="#工程文件" class="headerlink" title="工程文件"></a>工程文件</h3><video controls>  <source src="/img_1/bandicam 2024-11-09 21-43-51-757.mp4" type="video/mp4"></video><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>进化是万物的自然法则 ，不问因由、不辨方向，只因适应便是生存的唯一。【成长】却是内心深处的觉醒，为更坚定的信念，心向未来，带着无悔的初心启程。 在探索中我们成长，不再因未知而迷茫，在风雨中我们成长，所有的挑战都将迎刃而解，跌倒的站起 ，彷徨的找到归途，仰望那片无际的星空，成长的力量化为无形的支柱，筑起我们心中坚不可摧的信念，成为那份无论何时都不曾动摇的守望！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 个人创作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 音乐 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>你可以使用到下架的音乐软件</title>
      <link href="/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2024/11/05/%E4%BD%A0%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E4%B8%8B%E6%9E%B6%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在这个快节奏的世界里，音乐无疑是我们心灵的慰藉，它如同一股清泉，滋润着我们的灵魂。今天想与大家分享的，不仅仅是一款音乐软件，而是一段音乐旅程的开始。这是一款简约而不简单的音乐应用。🙂</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：酷狗概念版</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：124.33MB</strong><br><strong>获取方式：文章底部</strong></p><div style="text-align:center">  <img src="/img_1/55CF549DC97727664019811146FF1E35.jpg" alt="主页面" ></div><h2 id="其他信息"><a href="#其他信息" class="headerlink" title="其他信息"></a>其他信息</h2><p><strong>想象一下，当你在繁忙的日常中寻找一丝宁静，这款软件就像是一位老朋友，静静地等待你的召唤。它的界面相对于其它几个平台的软件较为简洁，操作直观，只需轻轻一点，就能带你进入音乐的海洋。</strong></p><div style="text-align:center">  <img src="/img_1/5D3400BE1891D4531BD075F73B1F69E2.jpg" alt="播放界面" style="width:50%;">  <img src="/img_1/8BC982518DF64AE8D876DA37D4E8F6D1.jpg" alt="播放界面" style="width:50%;"></div><p><strong>与其他音乐平台相比，这款软件的独特之处在于它的“音乐故事”功能。在这里，每一首歌曲都不仅仅是旋律的堆砌，它们背后的故事，如同珍珠般串联起来，让你在聆听的同时，也能感受到音乐的深度与温度。</strong></p><p><strong>官方还更新了开屏画面，各位可以按照下面的方式去根据自己喜欢的风格壁纸设置</strong></p><div style="text-align:center">  <img src="/img_1/83885ACB3D60D33140B471BD706C4A9A.jpg" alt="" >  <img src="/img_1/1100F28525ACE1DC8B3B740DFFEF4C3A.jpg" alt="效果展示" style="width:50%;"></div><p><strong>值得一提的是这个软件的好处在于，每日都可以领取一日的VIP，只需要看五秒的广告，理论上可以一直不收费的听下去，这绝对是白嫖党的福利😀!</strong></p><div style="text-align:center">  <img src="/img_1/0C8331419A6D582631E22F5406EA3CF6.jpg" alt="" style="width:50%;">  <img src="/img_1/C92DEA934D74627728C5CF99FFA655FC.jpg" alt="" style="width:50%;"></div><p><strong>各位音乐爱好者们，如果你渴望在音乐的世界里寻找一份纯粹，那么这款软件定会是你的不二之选。让我们一起，随着音符跳跃，随着旋律起舞，不要错过这场音乐的盛宴。😆</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA">https://pan.baidu.com/s/1RBaXZmaRjczbi9mn6HtMTA</a></strong> <br><strong>提取码:iay2</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>星际之舞：宇宙的诗篇</title>
      <link href="/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2024/11/03/%E7%B2%BE%E7%BE%8E%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p><img src="/img_1/9E0BE8E969CAC462282B28BDB3DF1AFE.jpg" alt="马头星云"></p><h3 id="星河璀璨"><a href="#星河璀璨" class="headerlink" title="星河璀璨"></a>星河璀璨</h3><p>  <strong>在浩瀚无垠的宇宙中，每一个星系都是一个独特的存在，它们以自己的方式讲述着宇宙的故事。 这张图片捕捉到了一个遥远星系的壮丽景象，它的中心散发出耀眼的光芒，仿佛是宇宙的灯塔，指引着迷失在星际间的旅者</strong></p><div style="text-align:center">  <img src="/img_1/7318400BB81BE3610CB7C214222D802A.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="旋舞银河"><a href="#旋舞银河" class="headerlink" title="旋舞银河"></a>旋舞银河</h3><p><strong>星系的旋臂如同宇宙的舞者，优雅地旋转着，上面点缀着无数的恒星，每一颗都在以自己的生命节奏闪烁。这些恒星的诞生、演化和死亡，构成了宇宙生命的交响曲。而那些暗淡的尘埃和气体，则是新恒星的摇篮，孕育着未来的光明</strong></p><div style="text-align:center">  <img src="/img_1/F872DED84FC80417240DFAA73466AD77.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/C880F01E01FF0D0849D9AFBB44BA7CA6.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="微光感悟"><a href="#微光感悟" class="headerlink" title="微光感悟"></a>微光感悟</h3><p> <strong>在这片星海中，我们不仅看到了宇宙的壮丽，也感受到了自己的渺小。然而，正是这种渺小，让我们对宇宙的探索充满了无限的好奇和渴望。每一次对星空的凝视，都是对未知的一次致敬，也是对人类探索精神的一次肯定。</strong></p><div style="text-align:center">  <img src="/img_1/34E6F253E9EB266011351DBB9C2F2082.jpg" alt="拍摄＆后期 By 码头">  <img src="/img_1/39DC3EE370E1BC8F31E5739ED3707C34.jpg" alt="拍摄＆后期 By 码头"></div><h3 id="远征"><a href="#远征" class="headerlink" title="远征"></a>远征</h3><p> <strong>每一颗星星都可能是一个新世界的开始。在这个无尽的宇宙之旅中，我们都是勇敢的探险者，追寻着知识的光，照亮前行的路。</strong></p><div style="text-align:center">  <img src="/img_1/CAA771D7E2B3AE60CE7475CD17304335.jpg" alt="拍摄＆后期 By 码头"></div><p><strong>自己拍摄的图，分享给大家，希望每个人都可以在自己的追寻的道路上走的足够远，成为有所建树的人😃</strong></p>]]></content>
      
      
      <categories>
          
          <category> 图片 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 摄影 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一款好用的音乐软件</title>
      <link href="/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/11/05/%E4%B8%80%E6%AC%BE%E5%A5%BD%E7%94%A8%E7%9A%84%E9%9F%B3%E4%B9%90%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p><strong>在数字时代的浪潮中，音乐软件如同璀璨的星辰，点缀着我们的生活。今天我要向大家介绍的，是一款与众不同的音乐应用，它以其独特的魅力，悄然走进了我们的世界</strong></p><h2 id="软件介绍"><a href="#软件介绍" class="headerlink" title="软件介绍"></a>软件介绍</h2><p><strong>软件名称：速悦音乐</strong><br><strong>适用设备：Android(安卓)</strong><br><strong>软件大小：31.01MB</strong><br><strong>获取方式：文章底部</strong></p><p><strong>这款音乐软件如同一股清新的风，吹散了繁琐的注册登录流程(你可以不需要注册或登录就可以直接使用)，让你无需任何门槛，甚至可以下载音乐，即可直接沉浸在音乐的海洋中。它的首界面，简洁至极，如同一张白纸，等待着你用指尖的魔法，绘制出属于自己的音乐天地</strong></p><div style="text-align:center">  <img src="/img_1/488C7C60ED9CA57D5F062D06E558EBC5.jpg" alt="主页面" >  <img src="/img_1/42F2AA03FF2EF5FB741F2B8A6BADF78D.jpg" alt="播放界面" style="width:50%;" ></div><p><strong>顺带一提，下载音乐只需要分享就可以下载了(你可以不直接分享，点击分享按钮，再退出就好了，不过为了支持原作者，建议还是分享一下吧😁)，具体操作如下图</strong></p><div style="text-align:center">  <img src="/img_1/CA1AA8F8B40A78F3E4CD9932426B3C99.gif" alt="播放界面" ></div><h2 id="自定义主题"><a href="#自定义主题" class="headerlink" title="自定义主题"></a>自定义主题</h2><p><strong>不仅如此，这款软件还赋予了你无限的创造力。你可以根据自己的喜好，自定义界面，让每一次打开应用，都成为一场视觉与听觉的双重盛宴。无论是色彩的搭配，还是布局的调整，都能随心所欲，打造出一个完全属于你的音乐空间</strong><br><strong>你也可以设置界面是否为深色模式，以及背景的模糊度和透明度等，具体参照下图，这里就不再演示，可自行探索</strong></p><div style="text-align:center">  <img src="/img_1/7F3CFD25EB3A4E1502F4330A748F859C.jpg" alt="主题切换演示" >  <img src="/img_1/11259F93D8B82874CE5AE29E1C52F5D5.jpg" alt="这是我的主题" style="width:50%;" ></div><p><strong>朋友们，如果你厌倦了复杂的操作，渴望一份简单而纯粹的音乐体验，那么这款软件无疑是你的最佳选择。让我们一起，在这个小小的屏幕上，探索无限的音乐世界，享受那份只属于你的宁静与自由</strong></p><h2 id="获取链接"><a href="#获取链接" class="headerlink" title="获取链接"></a>获取链接</h2><p><strong>链接:<a href="https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg">https://pan.baidu.com/s/1SCf64uKBMf5CTUd6UtsOfg</a></strong><br><strong>提取码:nt24</strong><br><strong>复制这段内容打开「百度网盘APP 即可获取」</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>在我们国内不缺乏一些好用的音乐软甲，但很可惜的是，由于动了别人的蛋糕，难免会遭受排挤，诸如歌词适配，洛雪等老牌软件也未能幸免，想要找到一款好用的软件实属不易，但仍然有许多为爱发电的大佬开发的软件依旧在坚挺，向他们致敬🫡！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 黑科技 </category>
          
          <category> 软件 </category>
          
          <category> 音乐软件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 每日搜罗 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/"/>
      <url>/2022/01/19/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h1 id="递归思想"><a href="#递归思想" class="headerlink" title="递归思想"></a>递归思想</h1><p><strong>在此之前，我们先来聊聊递归的思想</strong><br><strong>递归是计算的基本思想之一，想象一下，你是一个老师，要解释什么是“递归”，你可能会说：“递归就是我给你们举的例子，这个例子就是递归的一个实例。” 这就是递归的本质：用递归自身来解释递归</strong></p><h2 id="递归的工作原理"><a href="#递归的工作原理" class="headerlink" title="递归的工作原理"></a>递归的工作原理</h2><p><strong>递归的工作原理可以想象成俄罗斯套娃，每个娃娃里面都有一个更小的娃娃，直到最小的那个。在编程中，这就像是函数A调用自己A，函数A又调用自己A，如此继续，直到达到最小的娃娃（也就是递归的基本情况），然后开始一层层解开，直到回到最初的那个函数A</strong><br><strong>再换一个例子，想象一下，你正在爬楼梯，每爬一阶，你就离顶层更近一步。递归也是这样，每次函数调用自己时，都会更接近基本情况（base case），也就是递归结束的条件</strong></p><h2 id="递归的两个关键部分"><a href="#递归的两个关键部分" class="headerlink" title="递归的两个关键部分"></a>递归的两个关键部分</h2><p><strong>1.基本情况（Base Case）：这是递归停止的条件，就像最小的俄罗斯套娃，没有更小的娃娃了。或则说，类似于你爬到顶层，就不再爬了在编程中，这通常是最简单的问题，可以直接解决，不需要进一步递归</strong><br><strong>递推关系（Recursive Case）：这是函数如何调用自己的部分，每次调用都应该让问题更接近基本情况</strong></p><h2 id="具体实例"><a href="#具体实例" class="headerlink" title="具体实例"></a>具体实例</h2><h3 id="1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120"><a href="#1-阶乘是一个数所有正整数的乘积。例如，5的阶乘（5-）是5×4×3×2×1-120" class="headerlink" title="1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120"></a>1.阶乘是一个数所有正整数的乘积。例如，5的阶乘（5!）是5×4×3×2×1&#x3D;120</h3><p>以下是C语言的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 阶乘函数</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> <span class="title function_">factorial</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为0或1，直接返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回n乘以(n-1)的阶乘</span></span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%u 的阶乘是 %llu\n&quot;</span>, num, factorial(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-斐波那契数列"><a href="#2-斐波那契数列" class="headerlink" title="2.斐波那契数列"></a>2.斐波那契数列</h3><p><strong>斐波那契数列是这样的数列：0, 1, 1, 2, 3, 5, 8, 13, …，其中每个数是前两个数的和。</strong></p><p>以下是C语言代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 斐波那契函数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">fibonacci</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;  <span class="comment">// 基本情况：如果n为0，返回0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;  <span class="comment">// 基本情况：如果n为1，返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  <span class="comment">// 递推关系：否则返回前两个斐波那契数的和</span></span><br><span class="line">        <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">6</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;斐波那契数列的第 %d 项是 %d\n&quot;</span>, num, fibonacci(num));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>递归在编程中是一种强大的编程技术，它通过函数自我调用来解决问题。在使用递归时，确保有明确的基本情况和递推关系，这样可以避免无限递归和栈溢出的问题。希望这些例子能帮助你理解递归的概念和应用</strong></p><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><p><strong>通过上面的例子你应该大致理解了递归的思想了，那么接下来我们回到本次要讲的正题————二叉树的遍历。相信学数据结构的同学对它一定不陌生！二叉树的遍历是按照某种规则，依次访问二叉树中的每个节点，每个节点只访问一次。主要有三种遍历方式：先序遍历（Preorder Traversal）、中序遍历（Inorder Traversal）和后序遍历（Postorder Traversal）</strong></p><h2 id="先序遍历（Preorder-Traversal）"><a href="#先序遍历（Preorder-Traversal）" class="headerlink" title="先序遍历（Preorder Traversal）"></a>先序遍历（Preorder Traversal）</h2><p><strong>定义：先访问根节点，然后遍历左子树，最后遍历右子树</strong>。<br><strong>递归算法：访问根节点，然后对左子树和右子树递归执行先序遍历。</strong><br><strong>非递归算法：使用栈来模拟递归过程。首先将根节点入栈，然后循环执行以下步骤：弹出栈顶节点，访问它，然后将它的右子节点和左子节点依次入栈（注意顺序，先右后左）</strong></p><p><strong>假设我们有如下的二叉树：</strong>  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于先序遍历，简单来说就是指按照“根节点 -&gt; 左子树 -&gt; 右子树”的顺序访问二叉树的每个节点,以下是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    preOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    preOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它打印根节点的值，然后递归地遍历左子树和右子树</strong><br><strong>遍历下来的结果就是：1, 2, 4, 5, 3</strong></p><p><strong>接下来是非递归的遍历算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">preOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    s.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">        TreeNode* node = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, node-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.push(node-&gt;right); <span class="comment">// 先右后左，保持顺序</span></span><br><span class="line">            s.push(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将根节点压入栈中，然后循环直到栈为空。在每次循环中，它弹出栈顶节点，访问它，然后将右子节点和左子节点依次压入栈中，所以遍历下来的结果就是：非递归遍历结果：1, 2, 4, 5, 3</strong></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p><strong>定义：先遍历左子树，然后访问根节点，最后遍历右子树</strong><br><strong>递归算法：对左子树递归执行中序遍历，访问根节点，然后对右子树递归执行中序遍历</strong><br><strong>非递归算法：使用栈来模拟递归过程。从根节点开始，将节点依次入栈直到到达最左节点，然后访问它并转向右子节点，重复此过程</strong></p><p><strong>还是上述的二叉树为例子</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对与中序遍历便是指按照“左子树 -&gt; 根节点 -&gt; 右子树”的顺序访问二叉树的每个节点，以下是递归算法得的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    inOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">    inOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树，打印根节点的值，然后递归地遍历右子树,所以遍历的结果便是：4, 2, 5, 1, 3</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">        current = current-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它弹出栈顶节点，访问它，并转向其右子节点,所以遍历出来的结果便是：4, 2, 5, 1, 3</strong></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p><strong>定义：先遍历左子树，然后遍历右子树，最后访问根节点</strong><br><strong>递归算法：对左子树和右子树递归执行后序遍历，然后访问根节点</strong><br><strong>非递归算法：使用两个栈来模拟递归过程。第一个栈用于遍历，第二个栈用于反转遍历顺序。将根节点入第一个栈，然后循环执行以下步骤：从第一个栈中弹出节点并将其入第二个栈，然后将其子节点依次入第一个栈（注意顺序，先右后左）。当第一个栈为空时，从第二个栈中弹出节点并访问它们</strong></p><p><strong>二叉树例子同上</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br></pre></td></tr></table></figure><p><strong>对于后序遍历便是指按照“左子树 -&gt; 右子树 -&gt; 根节点”的顺序访问二叉树的每个节点，接下来是递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversal</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) <span class="keyword">return</span>; <span class="comment">// 基本情况：如果节点为空，返回</span></span><br><span class="line">    postOrderTraversal(root-&gt;left); <span class="comment">// 递归遍历左子树</span></span><br><span class="line">    postOrderTraversal(root-&gt;right); <span class="comment">// 递归遍历右子树</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, root-&gt;val); <span class="comment">// 访问根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码首先检查根节点是否为空，如果为空则返回。如果不为空，它递归地遍历左子树和右子树，然后打印根节点的值，所以遍历出来的结果是：4, 5, 2, 6, 7, 3, 1</strong></p><p><strong>接下来是非递归算法的实现</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">postOrderTraversalIterative</span><span class="params">(TreeNode* root)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;TreeNode*&gt; s;</span><br><span class="line">    TreeNode* prev = <span class="literal">NULL</span>;</span><br><span class="line">    TreeNode* current = root;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span> || !s.empty()) &#123;</span><br><span class="line">        <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            s.push(current);</span><br><span class="line">            current = current-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        current = s.top();</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;right == <span class="literal">NULL</span> || current-&gt;right == prev) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, current-&gt;val); <span class="comment">// 访问节点</span></span><br><span class="line">            s.pop();</span><br><span class="line">            prev = current;</span><br><span class="line">            current = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current = current-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这段代码使用一个栈来模拟递归过程。它首先将当前节点及其所有左子节点压入栈中，直到当前节点为空。然后，它检查栈顶节点的右子节点是否为空或者是否已经访问过。如果是，它弹出栈顶节点，访问它，并更新prev节点。否则，它转向栈顶节点的右子节点,所以运行出来的结果便是：4, 5, 2, 6, 7, 3, 1</strong></p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p><strong>递归方法：直观，易于实现，但可能遇到栈溢出的问题</strong><br><strong>非递归方法：使用栈或队列来模拟递归过程，可以避免栈溢出的问题，但实现相对复杂</strong></p><h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p><strong>朋友们，学习编程可能会在一开始感到有些挑战，但请记住，每个编程高手都是从基础开始，一步一个脚印走过来的。递归是编程中一个非常强大的工具，一旦你掌握了它，很多复杂的问题都会变得简单起来。记住，每个人的学习速度都是不同的，不要和别人比较，而是和昨天的自己比较。只要你们保持耐心和热情，不断练习，很快就能掌握递归的。加油，你们可以做到的！😉</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BF算法与KMP算法</title>
      <link href="/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/"/>
      <url>/2022/01/17/BF%E7%AE%97%E6%B3%95%E4%B8%8EKMP%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>我们来聊聊数据结构中两种在字符串中寻找子串的方法：暴力匹配（BF算法）和KMP算法。<strong>这两种方法都像是在玩一个“找茬”游戏</strong>，目的是在一个大字符串（我们称之为主串）中找到一个小字符串（我们称之为模式串）出现的位置。</p><p>我们先举一个例子：<br><strong>假设主串为 “ababcabcacbab”，模式串为 “abcac”</strong></p><h2 id="暴力匹配（BF算法）"><a href="#暴力匹配（BF算法）" class="headerlink" title="暴力匹配（BF算法）"></a>暴力匹配（BF算法）</h2><p><strong>BF算法，也称为暴力匹配算法，是一种简单的字符串匹配方法。它的基本思想是从主串的每一个字符开始，逐个与模式串的字符进行比较，直到找到匹配的字符或比较完整个模式串。如果模式串中有某个字符不匹配，BF算法会回溯到主串的下一个字符重新开始匹配。想象一下，你手上有一张小图片（模式串），你想在一个巨大的画布（主串）上找到这张图片。使用暴力匹配的方法，你会从画布的最左边开始，试着把小图片的每个角对准画布上的每个点，看看是否能完全匹配。如果不匹配，你就向右移动一点，再试一次。这个过程会一直重复，直到你找到匹配的地方，或者把整个画布都试一遍。</strong></p><p><strong>原理</strong><br><strong>1.从主串的第一个字符开始，与模式串的第一个字符进行比较。</strong><br><strong>2.如果相等，则继续比较主串和模式串的下一个字符。</strong><br><strong>3.如果不相等，则主串指针回溯到上次匹配的首位的下一位，模式串指针回到开头，重新开始匹配。</strong><br><strong>4.重复上述过程，直到找到匹配的子串或主串遍历完毕。</strong></p><p>以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 暴力匹配算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">BF</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> i, j;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= n - m; i++) &#123;</span><br><span class="line">        j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; m &amp;&amp; S[i + j] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = BF(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP算法（Knuth-Morris-Pratt算法）"><a href="#KMP算法（Knuth-Morris-Pratt算法）" class="headerlink" title="KMP算法（Knuth-Morris-Pratt算法）"></a>KMP算法（Knuth-Morris-Pratt算法）</h2><p><strong>KMP算法是一种改进的字符串匹配算法。它通过预处理模式串，构建部分匹配表（next数组），在匹配过程中利用已经匹配的信息，避免重复比较，从而提高匹配效率。KMP算法更聪明一些。它在开始全面搜索之前，会先研究一下小图片（模式串），找出一些特征，这样在大画布（主串）上搜索时，就能跳过一些明显不需要检查的地方。这就像是你记住了小图片的一些特征，然后在大画布上快速地找到可能匹配的地方。</strong></p><p><strong>KMP算法的核心是预处理模式串，创建一个“部分匹配表”，这个表告诉我们，当某个位置不匹配时，我们应该跳到模式串的哪个位置继续比较.</strong></p><p><strong>原理</strong><br><strong>1.预处理模式串，构建next数组。next数组记录了模式串中每个位置的最长相等前后缀的长度。</strong><br><strong>2.在匹配过程中，当遇到不匹配时，利用next数组跳过已经匹配的部分，避免回溯。</strong></p><p>还是刚才的例子，以下是代码演示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算部分匹配表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">computeNext</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *T, <span class="type">int</span> *next)</span> &#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; T[i] != T[j]) &#123;</span><br><span class="line">            j = next[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == T[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KMP算法</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">KMP</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *S, <span class="type">const</span> <span class="type">char</span> *T)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(S);</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">strlen</span>(T);</span><br><span class="line">    <span class="type">int</span> *next = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">    computeNext(T, next);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == T[j]) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="built_in">free</span>(next);</span><br><span class="line">            <span class="keyword">return</span> i - j; <span class="comment">// 找到匹配的位置</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; n &amp;&amp; S[i] != T[j]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(next);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 没有找到匹配</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> S[] = <span class="string">&quot;ababcabcacbab&quot;</span>;</span><br><span class="line">    <span class="type">char</span> T[] = <span class="string">&quot;abcac&quot;</span>;</span><br><span class="line">    <span class="type">int</span> pos = KMP(S, T);</span><br><span class="line">    <span class="keyword">if</span> (pos != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;找到匹配，位置：%d\n&quot;</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;没有找到匹配\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结一下："><a href="#总结一下：" class="headerlink" title="总结一下："></a>总结一下：</h2><p><strong>BF算法：简单易懂，但效率较低，时间复杂度为 O(n⋅m)</strong><br><strong>KMP算法：通过预处理模式串，利用next数组避免重复比较，提高匹配效率，时间复杂度为O(n+m)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
          <category> 数据结构 </category>
          
          <category> C语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
